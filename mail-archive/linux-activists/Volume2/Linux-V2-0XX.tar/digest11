From:     Digestifier <Linux-Activists-Request@news-digests.mit.edu>
To:       Linux-Activists@news-digests.mit.edu
Reply-To: Linux-Activists@news-digests.mit.edu
Date:     Thu, 2 Apr 92 23:45:16 EST
Subject:  Linux-Activists Digest #11

Linux-Activists Digest #11, Volume #2             Thu, 2 Apr 92 23:45:16 EST

Contents:
  Beginner's Guide: Installation (I Reid)

----------------------------------------------------------------------------

From: eonu24@castle.ed.ac.uk (I Reid)
Subject: Beginner's Guide: Installation
Date: 2 Apr 92 22:18:33 GMT

==============================================================
This is an updated release of my guide to installing Linux. It mostly corrects
one or two errata but there are one or two new bits. It is being reposted
because the original is disappearing from many news feeds and I think there is
still a demand for it.

A plea for errors
=================

I've been fortunate.... for the most part installation of Linux has been easy
and completely trouble free for me. If you have had problems with installation
then please tell me what they were, where they were, what was on the screen,
how you fixed them etc etc.

The other thing to be said is.... 

I will be trying to keep this document up to date as new developments occur
(e.g. the new fdisk command) but there is probably not too much to be done
here. Is there any aspect of Linux which you feel isn't well covered in the
documentation available? Please let me know and I'll see if I want to work on
it (well, I have to enjoy myself doing it!).

Iain [Iain_Reid@ed.ac.uk]

p.s. Mail on any subject is always welcome and I'll try to help with specific
     problems if I can. Please check the FAQ and the other documentation if
     possible 'cos many of the common problems are covered there.

p.p.s A rough contents list is

Section 1: First tests with floppies, rawrite etc
Section 2: Installing to hard disk (including non destructive partitioning)
==============================================================

                   A Beginner's Guide to Linux
                   ---------------------------
Purpose
=======

        This document is intended to be a complete beginner's guide to the
installation and running of Linux (a free Unix clone) and, as such,
tries to make as few assumptions as possible. However, some familiarity
with Unix at an "ordinary user" level (i.e. no sysadmin experience) is
assumed/required but I'll try to keep to a "hand-holding" level for anything
out of the ordinary. I don't intend this as a technical reference
guide, merely something to get you started and keep you clear of trouble!

        I hope to cover everything you need to get "up and running"
but if not please let me know so that I can change things. Similarly,
if there is anything you think is a "must know", a useful tip, or a
waste of space please let me know so I can do something about it.
Email is best 'cos I can't guarantee to see all the stuff posted to
alt/comp.os.linux. 

          Hope this helps and happy hacking,

                        Iain Reid [Iain_Reid@ed.ac.uk]

This document is quite big (and growing all the time). Despite this you might
find it helpful to print it out. I appreciate that this is damaging to
rainforests, aardvarks etc but then again, do you really want to be stuck in
the middle of something tricky with nothing to refer to if everything starts
to go wrong?


Errors: Where possible I have included details of potential errors and
        troublespots (with solutions where known). These are marked as

[Error n]

            where n is a number. A description of the error and solution etc can
        be found at the end of each section. I badly need feedback on these
                (list of other problems etc 'cos this bit is a bit sparse at the moment)

==============================================================
Required abilities
==================

        To get Linux and keep up to date with new releases you will need
to be able to get files from your nearest Linux archive site,
uncompress some of them and transfer them to a DOS filesystem. If you
don't know how to do this you should ask someone at your local site to
show you because the exact method used is highly dependant on your
local hardware and software.

        All the files and utilities mentioned should be available from the
Linux archive sites.
==============================================================

Ok, ready to start.... First and foremost....

BACKUP EVERYTHING!!!!!! 

I don't expect you to have problems but if you do then why risk losing
everything? You'll need to do this before installing to hard disk
anyway so why not do it now?

Section 1. Preliminary testing (otherwise known as 10 steps to happiness)
=========================================================================

Q. Will Linux run on my hardware?
A. If you have a 386Sx or above with 2 or more megabytes of memory
   then the chances are that Linux will run but the easiest way to
   check is to try running from floppy.

You will need - the current bootimage (bootimage-0.95a.Z)
              - the current rootimage (rootimage-0.95a.Z)
              - rawrite.exe (a utility to write the boot & root images
                to floppy from within DOS)
              - Two formatted floppies (2 x 1.2 Mb or 2 x 1.44 Mb but
                both must be the same capacity)

        It's up to you whether you use 1.2 Mb or 1.44 Mb disks but you
should use whichever type you can boot your machine from. For example,
my disk drives (under DOS) are

   A: 3.5" 1.44 Mb floppy drive [ bootable ]
   B: 5.25" 1.2 Mb floppy drive [ NOT bootable]
   C: 110 Mb IDE Hard Disk [ bootable ]

In my BIOS setup program I can choose to boot from drive A or C so I
would choose 1.44 Mb floppy disks.

What to do:

   1. Get the three files listed above from your nearest archive site.
   2. Uncompress the boot and root images and transfer them plus
      rawrite.exe to DOS
   3. Run rawrite.exe and you should see something like the following
      (type bootimage or rootimage where prompted and use whichever
      drive you can boot from)

c:\> rawrite
Rawrite 1.2 - Write disk file to raw floppy diskette

Enter source file name: bootimage <RETURN>
Enter destination drive: a <RETURN>
Please insert a formatted diskette into drive A: and press -ENTER-:
Number of sectors per track for this disk is 18
Writing Image to drive A:. Press ^C to abort.
Track: nn  Head: n  Sectors: nn

    4. Save bootimage (about 200 Kbytes) and rootimage (about 1100
       Kbytes) to separate disks using rawrite as above. You should
       see some information about tracks and sectors and the numbers
       should keep changing until it is finished and the command
       prompt comes back. Bootimage is fairly quick to transfer but
       rootimage is sloooooow so leave it running and have a quick (3 minute) 
       cup of tea or something.

    5. Reboot your machine with the boot floppy (i.e. the one with
       bootimage on it) in your floppy drive. If all goes well your
       floppy should whir a bit and the message "Loading...." should
       appear. The floppy will whir and click a bit more and some more
       dots should appear. On my machine this takes about 6 or 7
       seconds in total... it should be fairly quick. The following
       message should appear

Press <RETURN> to see SVGA-modes available or any other key to continue.

       and you may see something like EGAc in the top right corner of
       your screen. Things get slightly hazy for me here because Linux
       and my video card disagree about things but you can have a
       quick explore here if you wish. I have no idea what is supposed
       to happen, I just know that it doesn't happen for me :-(. Press
       return or any other key as instructed and you should see all the text
       on your screen shrink to half size (VGA 50 row mode) and something like
       this 

8 virtual consoles
4 pty's
Partition table ok.
Insert root floppy and press ENTER

[Error 1]

    6. Put the root floppy (i.e. the one with the rootimage on it) in
       the drive and press enter. You should see something like the
       following although the numbers may be different)

44/1200 free blocks.
265/400 free inodes.
721 buffers = 738304 bytes buffer space
Free mem: 2621440 bytes
All systems functioning.


        There will be a slight pause (2-3 seconds here) and then at the bottom the
        screen you should see


Welcome to Linux 0.95a.

Login as 'root' to install.  No password.

(none) login: 

        7. login as root and you should see

==============================================
        Welcome to Linux version 0.95a
==============================================

        See the files in the directory
        /INSTALL for installation info
        and scripts.    - Jim Winstead
        ------------------------------
        Questions?  You should talk to
        jwinstea@jarthur.Claremont.EDU

==============================================

#

    8. Congratulations! Linux is now running (from floppy admittedly)
       on your system. The '#' is your command prompt so you can have
       a play now although there isn't very much on the root floppy.
       It is worthwhile trying a few ls's (list files) and cd's (change
       directory) and you should definitely read some of the documents in
           INSTALL

[Error 2]

# cd /INSTALL
# ls

CHANGES-0.95a           INSTALL-0.95a           LDS-Standard            LDSS.Tree
WARNING                         install                         mkdev                           mktree

# more INSTALL-0.95a

           (q get you out of more.... make sure it's lower case)
                 
       Don't worry about your floppy drive bursting into life at odd
       times (usually at least once every 30 seconds or so (see "sync"
       later on)).... this is normal.
 
[ You can run entirely from floppy but as you can see it really isn't
much fun so, if you like what you see, onwards ever onwards, otherwise
please think again... Linux really is gorgeous to use once you get it
set up. Still not convinced? Oh well, bye then ] 

    9. You now know that Linux will run on your processor so the next
       question is "Will it run on my hard disk?". To test this use
       the fdisk command

# fdisk

Disk 0:
    /dev/hda1:  61516 blocks active 16-bit DOS (>=32M)
    /dev/hda2:  48090 blocks unknown partition type 0x80

        The messages you get will vary according to what you have set
        up on your hard disk but, if it tells you about any partitions
        (I have 2 as shown), then Linux can read at least part of your
        hard drive. This is good. If it barfs then things don't look
        so good and, if you think Linux should run on your hardware
        (see the info sheet at the archive sites), you should tell
        Linus Torvalds (the creator of Linux) 'cos he needs to know
        such things. Please be very sure that it is supposed to run on
        your hardware before sending off that mailer tho' :-)

    10. Sync. This is an initially mysterious command which you must
        ALWAYS, ALWAYS, ALWAYS run before you log out. What does it
        do? Well, in common with many unix systems, Linux stores some
        information in buffers in memory (remember those 721 buffers
        at bootup?). Some of it is to do with what's where on the disk
        so rebooting the machine without syncing (writing those
        buffers to disk) could leave you in a BIG mess. That's why you
        must ALWAYS sync. 'Nuff said?

# sync <RETURN>

Well, you've got this far so that means that 1. you can run Linux, 2.
your hard disk and Linux are on talking terms and 3. You're ready to
install to hard disk :-)

p.s. type "exit" to leave ash.
==============================================================

Errors and solutions (for section 1)
====================================

1. Just after the "4 pty's" message appears and before the "Partition table
   ok." your hard disk may make a descending tone 2-3 seconds long and the
   message HD timeout appears. This is a recognised problem caused by failure
   to reset the hard disk controller. It is not damaging and you can deal with
   it once you are up and running. You have to tolerate it until you have
   recompiled the kernel. Unfortunately you need the "damaged" kernel to build
   a linux filesystem which is why this bug still exists.

2. There is a bug in ash (the shell supplied on rootimage 0.95a) in that it
   doesn't seem to recognise delete when used on the first virtual console.
   This is being worked on and will hopefully be fixed by the next release. A
   solution is to run on the second virtual console. Press Alt-F2 to get it.
   You should see a login prompt. Login as root again and check that you can
   delete.

==============================================================

Section II: Installation to Hard Disk
=====================================

        You've tried the basic tests in section I; you liked what you saw
and you want to install to hard disk. Well, there are a few things you
should know before you start...


        Linux uses a Minix file system which is comaptible with Minix but not
with anything else (e.g. Dos). You will, therefore, have to give it its own
area on your hard disk and keep that area separate from everything else.
This is done by creating a separate PARTITION (area of disk) for
Linux. This is quite straightforward but is a fairly major thing so
I'll start with a little theory so that you know what you're doing and
why...

... There are two types of partition that Linux can use- primary and
extended. At the moment, however, the extended partition code is still
being written and tested so, in the interests of simplicity, I will
only cover primary partitions.


Q. What is a primary partition?
A. The first sector (512 bytes) of a hard disk contains the primary
   boot record. This is a record of various pieces of information
   about the physical characteristics of the hard disk, code for use
   during bootup and information about partitions. There is a fixed
   amount of space allocated for the partition information (enough for 4
   entries) and so there is a limit to the number of divisions that a
   hard disk may have (4). A primary partition is one of these 4 major
   divisions of a hard disk.    

   This limit of 4 partitions on a disk was rather restrictive and so
   secondary or extended partitions were introduced to bypass it. As
   with most add ons, however, they are not as "clean" from a
   programming point of view and special care is needed when dealing
   with them.


Q. How do you create a primary partition?
A. Simple. You just edit the partition table in the primary boot
   record to reflect your needs. Reformat any areas of the disk
   affected by the partitioning and that's about it (in theory
   anyway!)


Armed with that extensive tour of the intricacies of hard disk
partitions you are now ready for the main event. To make things
clearer I will use the example of a machine with one hard drive, a 107
Mb IDE drive which at the start has one partition (all disks must have
at least one) but which I want to divide into a 47 Mb Linux partition and
a 60 Mb Dos partition. The actual figures involved are irrelevant and
are meant as an example, not a guide.

Q. How much disk space should I give to Linux?
A. How high is the sky? This is very much a personal decision based on
your computing interests, whether you intend to run in single or
multi-user mode, whether you are planning to have Usenet stuff on your
disk etc etc. I can't give you a figure that is guaranteed to be what
you'll need. I doubt I could even come close but, even with a couple
of versions of the kernel compiled up, lots of source sitting around,
lots of big text files, lots of Usenet stuff, lots of utilities etc etc I
haven't gone beyond about 18 Mb (+ 8 Mb for swapping). At the moment I'm using
about 18 Mb and that's only because I've just de-archived my entire Linux
partition and there are lots of duplicate files to throw out.

Note: For serious kernel hacking, you will need an additional ~3Mb to
      maintain  the kernel source tree under RCS + source files and object
      code created by the build.


Structure of the rest of this section
=====================================

There are a number of topics which you may want/need to read about
before partitioning. To keep the main bit reasonably brief I have put these
at the end of the SECTION as appendices. These are:

  Appendix A: The DOS bootable floppy

  Appendix B: Rootset.c

  Appendix C: Non destructive partitioning (courtesy of Drew Eckhardt)


The rest is straightforward - Disk partitioning using pfdisk
                            - Installing Linux to hard drive
                            - Booting entirely from hard disk (not yet)
                            - Common problems and solutions (some)


Installing Linux to HD
======================

You will need: - the current bootimage (0.95a)
               - the current rootimage (0.95a)
               - tools to reinstall DOS, OS/2 etc after partitioning
               - Hard drive specifics (number of cylinders, heads and
                 sectors- look at your BIOS setup for these)


===========================================================================:
: There is a diving (sub-aqua) rule which applies to doing this kind of    :  
: thing to your setup.... make sure you have at least 2 ways out of any    :
: serious situation. What I mean by this is that you are about to kill     :
: off your HD... you will not be able to boot up into DOS (or whatever)    :
: on it so make sure that you have the tools to rebuild DOS on a write     :
: protected floppy somewhere handy. You should also have the tools to do   :
: this for Linux handy as well. What I used was                            :
:                                                                          :
: 1. a bootable DOS floppy with:                                           :
:                                                                          :
:     1.1: pkunzip.exe to restore my DOS backups                           :
:     1.2: DOS fdisk and format                                            :
:     1.3: rawrite.exe                                                     :
:     1.4: zipzap (a good binary file editor)                              :
:     1.5: Rootset.exe (see appendix B for src)                            :
:                                                                          :
:                                                                          :
: 2. Linux v0.95a rootimage rawritten to floppy (NOT WRITE-PROTECTED)      :
:                                                                          :
: 3. Linux v0.95a bootimage rawritten to a WRITE-PROTECTED floppy          :
:                                                                          :
: 4. Safe copies of the root and boot images stored as dos files (for      :
:    use with rawrite)                                                     :
:                                                                          :
:                                                                          :
: Escape plan 1: If all goes badly wrong you can use fdisk and format to   :
:                rebuild a dos disk partition.                             :
:                                                                          :
: Escape plan 2: If you can perform a floppy only boot into Linux you      :
:                can use pfdisk to try to recover your partitions.         :
:                                                                          :
: Escape plan 3: You can't salvage dos but you can install linux to HD.    :
:                Use rootset.exe to complete the Linux installation then   :
:                fix things from Linux.                                    :
:                                                                          :
============================================================================


What to do:
===========

1. Backup everything. You have no choice in this.... you either backup
   or say bye bye to DOS (or whatever else you have on your hard disk) (see
   Appendix C if you don't like the sound of this restore and you are happy
   guddling about with low-ish level Dos)

2. Boot up into Linux from floppy... login as root (see part 1 of this
   guide for details)

[ Remember, one HD, 107 Mb -> 47 Mb Linux + 60 Mb DOS ]

3. Once logged in run pfdisk as follows

# pfdisk /dev/hda

  This command means run pfdisk (a disk partitioner that comes on the
  0.95a root disk) on /dev/hda (my entire primary hard disk). Some text
  like this

============================================================================== 
# pfdisk version 1.2.1 by Gordon W. Ross  Aug. 1990
Modified by S. Lubkin  Oct. 1991
 
        Warning:  The device "/dev/hda" is assumed to have:
        cyls=306, heads=4, sectors=17 (an arbitrary guess).
 
        This program was compiled for generic UNIX and therefore
        does not know how to determine the disk parameters.  You must
        describe the disk geometry manually, using the 'G' command.
For help, enter: '?'
pfdisk>
============================================================================== 

  will appear if all goes well. The first thing to do is to tell pfdisk some
  things about your hard disk using the 'g' command ('g' for geometry).
  The format for this is g <cylinders> <heads> <sectors> so for a disk
  with 523 cylinders, 15 heads and 28 sectors (such as mine), the
  command would be 

pfdisk> g 523 15 28

  Next you use the 'l' command ('l' for list) to see what is currently
  set. You should see 4 entries (remember 4 primary partitions per hard
  disk) but only one of them should have any numbers in it (one 107 Mb
  partition) . For a partitioned disk this looks something like this

============================================================================== 
# Partition table on device: /dev/hda
geometry 523 15 28 (cyls heads sectors)
#  ID  First(cyl)  Last(cyl)  Name  # start, length (sectors)
1   6      0        292       DOSbi # 28, 123032
2 128    293        521       Minix # 123060, 96180
3   0      0          0       empty # 0, 0
4   0      0          0       empty # 0, 0
active: 1
pfdisk> 
============================================================================== 

Warning: Do not used edpart.exe (a Dos disk partitioner) on your disk 'cos it
         completely wrecked my partition table (re-ordered everything and
                 wrote rubbish into some bits of the partition table). It is a good
         disk partition editor for partitions smaller than 32 Mb but there are
         better, friendlier ones around. 

  Make a note of the number in the ID field (labelled) for the single
  partition. If you are partitioning a dos disk (as in the example
  then this value will probably be 6. For other systems other values
  apply.

  Make a note of the maximum cylinder (521 on mine despite the fact
  that the tech support people reckon 523 and the bios is set to 523)

  Now for the clever bit..... I decided I wanted 2 partitions (47Mb
  and 60 Mb) so I divide up my 523 cylinders in that ratio i.e.

  (60/107) x 523 = 293 clusters for DOS (what a waste)
  (47/107) x 523 = 228 clusters for Linux (near enough)
                   ---
                   521 <-- make sure everything adds up!
                   ---

  then you use the "unnameable" command to partition your hard disk.
  The format of this command is

  n sys_id first_cluster last_cluster sys_name

  where n ............ is the partition number
        sys_id ....... is a magic number (ID in example above)
    and sys_name ..... is optional and should not be used ('cos it
                       makes things fail (strange but true)


  For DOS sys_id is 6 (and you should have seen that in the ID field
  above), some other systems have their own code. Linux uses a Minix file
  system so we use 128 (code for Minix) for the Linux sys_id and use whatever
  the original ID was for the other partition (e.g. 6 for DOS).

  For the example disk I would type the following

pfdisk> 2 6 0 292
pfdisk> 1 128 293 521

  Explanation time..... partition 1 is now a Dos partition with 293
  clusters (0 to 292 inclusive). Partition 2 is a Linux partition with
  228 clusters.

  Last bit... last but not least is the 'a' command ('a' for active)
  which marks a partition as the one to boot from. I chose partiton 1
  (DOS) 'cos Linux cannot boot entirely from hard disk without some
  assistance (more later (eventually)). So ....

pfdisk> a 2

  Finally, the 'wq' command ('wq' = write partition table and quit) so...

pfdisk> wq


 4. That wasn't too bad was it? Now all you need to do is make a Linux
    filesystem, install Linux and rebuild DOS. Filesystem first I think...

    ... at the command prompt use the fdisk command and you should see
    something like this

# fdisk

Disk 0:
    /dev/hda1:  61516 blocks active 16-bit DOS (>=32M)
    /dev/hda2:  48090 blocks unknown partition type 0x80

        What this tells you is that you have 2 partitions which, as far as
    Linux is concerned, are known as /dev/hda1 and /dev/hda2.
    /dev/hda2 is 48090 blocks long (1 block = 1 Kbyte thus this 
    partition is 48090/1024 or 46.9Mb) and is of type 0x80 (hex 80 =
    decimal 128 (sound familiar yet?)). The other one is a 60 Mb Dos
    partition.

        Next you use the mkfs command (make filesystem) with the following
    format
 
    mkfs -c device blocks

    the -c option specifies that it should perform some checking as it
    works and the blocks figure is the one from fdisk (above). To make
    a file system on this partition I would type

# mkfs -c /dev/hda1 48090

    Your hard disk will be busy for a few minutes and you should get
    some numbers popping up and changing on your screen. Don't worry
    about these... you don't need to know anything about them (nor
    could I tell you much about them :-))

[Error 1]

    Ah, finally.... you are ready to install to HD! Thanks to Jim
    Winstead's excellent installation scripts this is easy as pie so
    without further ado type the following

# mount /dev/hda1 /mnt

    to "attach" your newly created/formatted partition to the file
    system (currently on the floppy) at the mnt directory in the root
    directory. Remember to use whichever device you have formatted.

    Now type

# cd /INSTALL
# ./install /mnt

    to run the installation script and install the file system bits
    and pieces in whatever is attached to the file system at /mnt.
    This is of course part of your hard disk so you are now installing
    properly to hard disk from the original file system on the floppy
    disk. Clever huh?

        When that finishes (you'll know when) you unmmount your partition
    by using the umount command (e.g. umount /dev/hda1) and you should
    sync (see part 1 of this guide) and logout (with the exit command).

WARNING: ALWAYS SYNC IF POSSIBLE AND LOG OUT PROPERLY. THIS IS UNIX
         NOT MESSY-DOS AND THE 'OLD 3 FINGER SALUTE (CTRL-ALT-DEL) WAY
         OF EXITING IS LIKELY TO LAND YOU IN TROUBLE SO DON'T DO IT!

  5. Go back to DOS and edit the bootimage to reflect the partition
     upon which you have installed Linux. How? Well, there are 2 main
     methods:

        1. Edit a fresh copy of the bootimage and rawrite it to a
           FRESH floppy (i.e. not you existing bootimage 'cos you
           never know when you might need that (pure floppy boot +
           mount /dev/hd?? is a very useful way to sort out problems)).

        2. Edit the bootimage disk (while keeping a copy- same idea as
           at 1). I haven't come across any binary editors that can read
           in rawritten disks but the Turbo C absread and abswrite
           function seem to manage it (see Appendix C) so you could
                   write a small utility to make your life easier/safer (as I did)

Note: there is some debate as to which binary editor should be recommended. I
      use Zipzap 7.15 and I'm very happy with it (it's shareware and available
      on most major archives). Others like Norton Disk Editor. It's up to you
      what you use.

        The important bit, regardless of the method used, is to change the
        bytes at offset 508 and 509 in the bootimage to store the minor and
        major numbers for your new Linux partition.

        For a hard disk the major number (offset 509) is always 3, and the
    minor number (offset 508) is a combination of primary or secondary HD
        drive and partition details (see FAQ for details). Here are the details

    Device      Major    Minor       Device      Major    Minor
    ------      -----    -----       ------      -----    -----
    /dev/hda1     3        1         /dev/hdb1     3        65
    /dev/hda2     3        2         /dev/hdb2     3        66
    /dev/hda3     3        3         /dev/hdb3     3        67
    /dev/hda4     3        4         /dev/hdb4     3        68
    /dev/hda5     3        5         /dev/hdb5     3        69
    /dev/hda6     3        6         /dev/hdb6     3        70
    /dev/hda7     3        7         /dev/hdb7     3        71
    /dev/hda8     3        8         /dev/hdb8     3        72


  6. Boot up linux with your new boot floppy. It should give the
     loading messages and then switch to booting and running from hard
     disk.

         Taaaaaa-Daaaaaa!


  7. When you're happy with it logout and rebuild dos. I don't intend
         to cover this in any detail 'cos most dos manuals already do
     that. What you need to fo is to format your new dos partition using
     format (on the dos bootable floppy you made). Something like

A:\ format /u /s /v:"Dos_5_0" c:

         should do the trick. After that finishes you should have a
     bootable Dos partition on your hard disk and you can reinstall
     from your backups.
==============================================================================

Errors and solutions (for section 2)
====================================

1. If you have bad blocks on the first bit of your disk then mkfs will barf
   and refuse to build a file system (happened to me!). The solution is to
   make Linux your first partition. Those of you who are still awake will
   notice that in the example above (my disk), my Dos partition is first on
   the disk. Am I lying about this bad blocks thing? Nope! The reason is that
   the mkfs suplied with 0.95a doesn't like bad blocks but the one with 0.95
   (and I believe 0.12) doesn't care. I partitioned my disk with 0.95a,
   sync'ed, exited, rebooted with 0.95 (an otherwise bug ridden release) and
   ran mkfs. That done I rebooted with 0.95a. Cunning huh?
==============================================================================


Appendix A: The DOS bootable floppy
===========

Q. What is a "DOS bootable floppy"?
A. A DOS bootable floppy is a floppy disk containing just enough of DOS to be
   able to be "boot up" and produce a command prompt. It consists of 4 things:

      1. A DOS boot sector (first 512 bytes on the disk)
      2. MSDOS.SYS (a hidden dos system file)
      3. IO.SYS (another hidden dos system file)
      4. COMMAND.COM (the DOS command interpreter)

Q. Do I need one?
A. If you run DOS at the moment and want to keep DOS somewhere on your hard
   disk then you will need to create a DOS partition. Once created you will
   need to reinstall DOS to this partition and a bootable floppy makes this
   much, much easier.

Q. How do I make one?
A. You can create one in either of two ways using DOS commands.

1. Use the SYS command with a blank, DOS formatted floppy disk e.g.

# sys a:

   will copy the "system" (the 4 things above) to a disk in drive A.

2. Use the FORMAT command with the /s and /u switches e.g.

# format /s /u /f:1.44 /v:"Dos_Boot" a:

   will perform an unconditional format (checks for bad sectors etc) on the
   1.44 Mb floppy disk in drive A, labels it Dos_Boot (11 characters maximum
   allowed length) and copies the "system" on to it.

Now test it by resetting your machine with the boot disk in the floppy drive.
Your machine should start up (floppy is much slower than hard disk though)
and you should get a command prompt. Try some simple commands like DIR to
satisfy yourself that you are running from floppy only.

[ If your machine boots from hard disk and ignores the floppy you will need
  to check your BIOS setup and enable "Floppy Seek at Boot" (AMI BIOS) or
  equivalent option and try again. ]

Next you need to copy some things to your bootable floppy. What you copy is
entirely up to you but the following is the sort of thing I have on mine

4DOS  - 4dos.com            [ an excellent command.com replacement ]
      - aliases.txt         [ my command aliases/macros for 4dos ]

DOS   - ansi.sys
      - attrib.exe
      - emm386.exe
      - fdisk.exe
      - format.com          [ Absolutely essential! Do NOT forget ]
      - himem.sys
      - keyb.com

UTILS - pkunzip.exe         [ for restoring backups ]

autoexec.bat
command.com                 [ Just in case ]
config.sys
filelist                    [ dir /skf c: > filelist before I backed up ]

Once you've got everything you think you want onto the floppy write protect
it (in case of foolishness) and THOROUGHLY TEST IT (i.e. make sure it boots,
formats, restores backups etc 'cos you're going to have to rely on it!)
=========================================================================

Appendix B
==========
/********************************************************/
/* Rootset.c - modify Linux bootdisk root device entry  */
/*           - quick Turbo C hack by Iain_Reid@ed.ac.uk */
/********************************************************/


#include <stdio.h
#include <conio.h>
#include <process.h>
#include <dos.h>

void main(int ac, char **av)
{
        char buf[512];


        if (ac != 3) {
                fprintf (stderr, "%s: update Linux bootimage root device details.\n",
                        av[0]);
                fprintf (stderr, "Usage: %s <Major> <Minor>\n", av[0]);
                exit (-1);
        }

        /**************************************************************/
        /* Don't remove this keypress bit 'cos it gives you a chance  */
        /* to run this program from your dos boot floppy, remove that */
        /* disk, put your linux boot disk into the same drive, patch  */
        /* in the new root device details and save them. No HD or     */
        /* rawrite required! (v. handy if DOS is dead)                            */
        /**************************************************************/

        printf ("Insert Linux boot disk into drive A and press any key\n");
        getch();

        if (absread (0, 1, 0, &buf) != 0) {
                 perror ("Disk reading problem");
                 exit (-1);
        }

        printf ("Current rootdevice: Major %d Minor: %d\n", buf[509], buf[508]);

        buf[508] = atoi (av[2]);
        buf[509] = atoi (av[1]);

        if (abswrite (0, 1, 0, &buf) != 0)
        {
                 perror ("Disk writing problem");
                 exit (-1);
        }
        printf ("New rootdevice: Major %d Minor: %d\n", buf[509], buf[508]);

        exit(0);
}
=========================================================================

Appendix C: Non destructive partitioning by Drew Eckhardt
==========

Reformatting your hard disk, and reinstalling all your DOS programs from
scratch can be a real nuissance, and is unecessary.

Breathe a sigh of relief : it is possible to non-destructively repartition
        hard disks.

Notes : Before continuing, make sure you have a RECENT BACKUP.

        I assume that you understand hex arithmatic, and are not
        afraid of a little assembler or DEBUG.

        Actually, a decent partition and disk editor will get you around
        this - NU works gret.

        Of course,  the modern programmer doesn't use anything but a
        source level debugger - so I've included some helpful hints
        and the command syntaxes.  However, there is no room for
        handholding here : if you screw up, you might have to use
        that backup.  Don't do it unless you are confident in your
        abilities.

        Also, this procedure only works with NON-EXTENDED DOS partitions,
        < 64K logical sectors,  (DOS 4 large partitions add additional BPB
        fields that I am unsure of - roughly the same procedure applies there
        though.  According to Townsend' Advanced MS DOS : Expert Techniques
        for programmers

        offset 26h will have the signature byte 29h if this is
        the case, 20h a dword containing the number of sectors if
        volume size > 64K sectors

        I still use MS-Loss 3.3, with an ~82M partition under disk mangler
        and fall into the tested category)

        Large partitions, handled by a third party partition manager
        and handled so that there are < 64K logical sectors
        work - this was the case with my SCSI disk.

        I will lay down what general procedures you need to know (
        required to read / write the raw disk), as well as the
        data structures we are dealing with.  Then I will proceed
        with the entire procedure, which applies the general procedures
        in reading and modifying the data structures.  If it looks like
        a tech manual - it is.  If you don't grok non-destructive
        repartitioning, you shouldn't be doing it.

        DEBUG has a Hexaritmatic command, h which will add and
        subtract the two operands.  You may find this useful.

        IE : I have loaded sector 0 into memory at 0200, and wish to know
        the address of the partition table at 1be.

        -h 200 1be
        03BE  0042

        Where 03BE is the sum, and 042 the difference.

        DEBUG prints a segment before the offset : note that your segments
        will probably not match.  The offset is what's important.

        The 80x86 family is LITTLE ENDIAN.  This means least significant
        byte first - ie the internal representation of 0x12345678 would be
        78 56 34 12.  When dealing with multi-byte quantities, keep this
        in mind.

        When I say word, I mean word as in the Intel documentation :
        16 bits.  dword is 32 bits.

        DISK BIOS addresses cylinder, head as zero based, sector
        as 1 based.  Same thing for the partition table.

        DOS addresses sectors as 0 based, from the start of the
        logical partition, and as logical sectors which may
        consist of multiple physical sectors.

        Unless otherwise noted, all numbers are hex.

        You're better off using Norton Utilities - but Debug works fine
        too.

        This document is sort of a quick hack 8^)

Tools :

Required : DEBUG, and a disk defragmenter

Optional : partition editors (NOTE!!!! Make sure these DO NOT perform
           any formatting, and allow you to edit partitions in the
           REAL order they appear on the disk.), the Linux FDISK program,
           utilities that save an image of the boot sector FATs, and
           directory (IE Norton's Format Recover), a raw disk editor
           (Norton Utilities NU)..

Procedures :
Editing memory with debug :

d ADDRESS l LENGTH

will dump memory

f ADDRESS l LENGTH values

will fill memory.


Reading and writing DOS logical sectors (using debug):

Reading is accomplished using the debug l command.

l ADDRESS DRIVE SECTOR COUNT

Where ADDRESS is the hex address of where to put the data,

DRIVE is a 0 based drive number (IE A:=0, B:=1, C:=2, etc.  If there
is only one floppy drive, it is considered both A: and B: as it is
in DOS)

SECTOR is a zero based sector number.  Of interest to us are
sector 0, the boot sector, and the sectors immediately following it -
the FAT's.


COUNT is the number of sectors to read.


So, to read in the first 10 sectors of the FAT on my E: partition (the
FAT starts at sector 1), storing them at 0200, I would enter

l 0200 4 0 A

Writing is done with the W command, which takes the same
parameters.  Assuming I had edited the boot sector of E: at 0200 in memory,
and wanted to write it back to disk, I would type in

w 0200 4 0 1


Using Norton Utilities NU:

<E>xplore disk, <C>hoose Item, <S>ector, <E>dit/display

Unfortunately, absolute sector 0 falls outside of all partitions (this
is where the partition table is), and we need to use a different
procedure for it.

Reading / Writing absolute sector 0:
The following debug / assembler interaction shows how to read absolute disk
sector 0 , replace xx with 80 for hard disk 0, 81 for hard disk 1:

-a 0100
1984:0100 mov ax, 0201
1984:0103 mov bx, 0200
1984:0106 mov cx, 0001
1984:0109 mov dx, 00xx
1984:010C int 13
1984:010E int 20
1984:0110 ^C

-


-g = 0100

This will read sector 0 into DS:0200.  To write it back,

-a 0100
1984:0100 mov ax, 0301 <RETURN>
1984:0103 ^C


-g = 0100.


Using Norton Utilities NU :
Under <E>xplore disk, choose <C>hoose item, <A>bsolute sector, <E>dit / display



Structures :

1.  The Partition table

The partition table resides at absolute sector 0 (ie
cylinder 0, head 0, sector 1) on all  harddisks.  It is accessed
by a short bootstrap loader on that sector,  which reads the partition
table and then picks a partition from which to load the boot sector for
the operating system.


The partition table itself resides at offset 1be.  It is 64 bytes (decimal)
in length, plus the two byte signature 55 AA.  When dealing with the
partition table, make sure byte 40 (offset 1fe of the sector) is 55 and
byte 41 (offset 1ff of the sector) is
of the sector




The partition table is subdivided into FOUR 16 byte entries, fielded
as follows :
offset  length  field
0       byte    bootable 80h = bootable, 0 = not
1       byte    starting head number
2       word    starting cylinder (and sector - sector is 1 based
                high byte is low byte of cylinder, low byte low 6 bits is
                sector, high 2 bits of low byte high 2 bits of cylinder)


                typically, sector = 0.

4       byte    system  1 = primary DOS, 12 bit, 4 = primary DOS 16 bit,
                        5 = extended DOS, 8 = NON-DOS (might be usable)
5       byte    ending head number


6       word    ending cylinder / sector

8       dword   starting sector (relative to begining of disk - THIS IS ZERO
                based)

C       dword   number of sectors



My partition table on drive 0 looks like :

-d 3be
1984:03BE  80 01                                             ..
1984:03C0  01 00 01 05 22 08 22 00-00 00 0A 07 00 00 00 00   ....".".........
1984:03D0  01 09 51 05 E2 2B 2C 07-00 00 E4 7F 02 00 00 00   ..Q.b+,...d.....
1984:03E0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
1984:03F0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 55 AA   ..............U*

Interpreting this, we can see that I have two partitions in use -
partition 1 and 2, the rest being blank.


My first partition is bootable (80)
        FAT size is 12 bits (type = 01)
        It starts at head 1, cylinder 0, sector 1, which is sector 22
        (34 decimal) relative to the start of the disk.
        It is 0000070a sectors in length (1802 decimal), and ends on
        head 5, cylinder 8, sector 22 (34 decimal).


My second partition is non-bootable (00).
        It is type 51 (Disk Mangler) meaning I need to
        find out fat size some other way.

        It starts at Head 0, cylinder 9, sector 1, which is sector 72c
        (1836 decimal) relative to the start of the disk.
        It is 27FE4 (163812 decimal) sectors in length, and ends on
        head 5, cylinder 32b (811 decimal), sector 22 (34 decimal)..

See how I got ending cylinder?  In Hex, each digit is a nibble.  You can
easily convert to binary a nibble at a time.  IE E2 becomes 1110 0010


The low 6 bits (sector) are 10 0010 = 22
The high 2 bits are 11 = 3

So high byte cylinder is 03, low byte is 2B so cylinder = 032b

Got it?



2.  The Boot sector

The second important piece of data is the bootsector.  There are a number
of fields we are interested in.  I have ommitted the DOS 5 extended fields
(Can't give you an answer I'm 100% sure on), as well as fields unecessary
to our procedure.

Fields we are interested in :
Offset  Size    Field
b       word    bytes per LOGICAL sector - divide by 512 to get physical
                to logical mapping

d       byte    sectors per cluster.  Multiply by logical sector size and
                divide by 1024 (decimal) to get K / cluster

13      word    total number of LOGICAL sectors.  This is one field
                extended by DOS5.

18      word    sectors per track

1a      word    heads

Clusters = sectors / sectors per cluster.

Since my first partition on drive 1 is fairly boring, we'll look at
partition 2 - E:

-l 0200 4 0 1
-d 0200
1984:0200  EB FE 90 4E 4F 53 59 53-54 45 4D 00 08 04 01 00   k~.NOSYSTEM.....
1984:0210  02 00 02 F9 9F F8 0A 00-22 00 06 00 2C 07 80 00   ...y.x.."...,...

The first three bytes are either a near jump over the actual BPB or
a short jump and a NOP.  There follows an eight byte system ID, and then
the Good Stuff.

I have 800 (2048 decimal) bytes per logical sector, meaning 4 physical
        sectors = 1 logical sector.
        .
There are 4 logical sectors per cluster, meaning there is 8K in
        each cluster, 16 logical sectors per cluster.

There are 9ff9 (40953 decimal) logical sectors in my partition, meaning
        163812 decimal physical sectors (Notice how this number matches the
        number in the partition table.)

There are 22 (34 decimal) sectors per track, and 6 heads.

3.  The FAT

The final interesting data structure is the FAT.  If you have some other
reliable means of insuring all data is at the begining of the partition
you can ignore this.

If there are > 4096 clusters, you definately have a 16 bit FAT.

The FAT will begin with an FFF8 signature - 16 bit or (FF8) 12 bit.
What follows
is one entry for each cluster of the disk - with FFFF (FFF) marking
end of file, FFF7 (FF7) marking a bad sector, 0000 (000) empty, basically
anything else a next cluster pointer.

Basically, all that were interested in is that there are roughly enough
0 entries all together, with only BAD marks and no end of file or next
cluster pointers.

12 bit entries are packed two per three bytes - low byte = low byte
first cluster, middle byte low nibble is high nibble for the first cluster,
middle byte high nibble is low nibble for the second cluster, high byte
is high byte for the second cluster.


Step 1:
        Make a FULL backup.

1a:
        If you have a program to save off an image of the boot sector,
        do it now.  Dumping the boot sector / partition sectors to
        floppy disk (do an rcx:200 in debug, then a w FILENAME to
        save to a file) would also accomplish the same thing.

        This will save you the trouble of having to restore an entire
        backup if you screw up either of these sectors.

Step 2:

Defragment.  All data must be contiguous.


Step 3:
        Decide where the partition goes, and how big it is.

        The new partition must fullfil these requirements :

1.  It resides at the end of the original partition.
2.  It is situated such that the original partition has a boundary
    that ends on a FULL logical sector (In my example, this is four
    physical sectors).

In my case, I am simply starting testing on my already packed SCSI
disk, and want a ~1 megabyte partition, or 2048 sectors.

This partition ends at :

cylinder 32b (812 decimal), head 5, sector 22 (34 decimal)

If I divide by 34 sectors per track (available in the boot record),
I get 60 tracks.  If I divide by 6 heads, I get 10 cylinders.

So, I will start my partition at

cylinder 802 decimal (322 hex)
sector     0
head       0
relative sector 802 * 34 * 6 decimal= 163608


I will adjust the size of my E: drive down by 510 logical (2040) (decimal)
physical sectors, and make this my new partition.

Note that this falls on the required logical sector boundary.

Likewise, I will reduce the size of my second partition by 2040 (decimal)
sectors, to 161772 (decimal) sectors and reduce the ending cylinder to
801 (decimal).

Step 4:

Verify that all data is contiguous, and we have enough free space
for the partition we are about to create.

Use a reliable disk space map utility, if none is available you will
have to do so manually.  Again, NU can fill this role.


To do this manually, first determine FAT size

check - partition table
      - number of clusters (roughly - (sectors - 1) / sectors per cluster)
        if > 4096, definately 16 bit

After you've decided on 12 bits or 16 bits,

Find the first 0 cluster (The disk has been defragmented?)

Count consecutive 0 or BAD FAT entries (1 per 2 bytes on 16 bits,
3 per 2 bytes on 12 bits), multiply by K per cluster (as determined
from the boot sector - see data structures above), and be happy.

If there are intervening NEXT CLUSTER pointers, or END OF FILE (FFFF),
try a different defragmenter.

Also, not that some defragmenters will not move hidden files.  You will
have to unhide these, defragment,  and rehide these.



5.  Adjust boot record of old DOS partition.  Change # sectors field,
        offset 13 hex (word), be sure to adjust in number of
        LOGICAL SECTORS, not physical sectors (as determined from the
        word size field at offset b divided by a 200 hex (512 decimal) byte
        sector size)

After image for my example :
-l 0200 4 0 1
-d 0200
1563:0200  EB FE 90 4E 4F 53 59 53-54 45 4D 00 08 04 01 00   k~.NOSYSTEM.....
1563:0210  02 00 02 FB 9D F8 0A 00-22 00 06 00 2C 07 80 00   ...{.x.."...,...

6.  Adjust partition table.  Change ending head, cylinder, sector
        field of old partition, total sectors of old partition,
        add new partition.

        Avoid overlap.  Note that new partition table becomes active
        on reboot.

After image for our example:
-d 03be
1563:03BE  80 01                                             ..
1563:03C0  01 00 01 05 22 08 22 00-00 00 0A 07 00 00 00 00   ....".".........
1563:03D0  01 09 51 05 E2 21 2C 07-00 00 EC 77 02 00 00 00   ..Q.b!,...lw....
1563:03E0  C1 22 FF 05 E2 2B 18 7F-02 00 F8 07 00 00 00 00   A"..b+....x.....
1563:03F0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 55 AA   ..............U*

Yes, I know 0xff is a bizarre identifier for the linux partition.  That's
how I did my first one, that's how I did this one.

References :
        Norton, Peter Norton's Programmer's Guide to the IBM PC
        Townsend, Advanced MS-DOS Expert Techniques for Programmers

Hopefully this has been enlightening, and possibly even useful to some.

Mail comments to drew@colorado.edu.
=========================================================================

Section III: What now?
======================

I was going to write about the maintainance and running of Linux, installation
of new software etc but I've been beaten to it. For details of all this sort
of thing please see Chuck Boyer's excellent "Beginner's Guide" which was
appeared in the alt.os.linux yesterday.
=========================================================================

------------------------------


** FOR YOUR REFERENCE **

The service address, to which questions about the list itself and requests
to be added to or deleted from it should be directed, is:

    Internet: Linux-Activists-Request@NEWS-DIGESTS.MIT.EDU

You can send mail to the entire list (and comp.os.linux) via:

    Internet: Linux-Activists@NEWS-DIGESTS.MIT.EDU

Linux may be obtained via one of these FTP sites:
    nic.funet.fi				pub/OS/Linux
    tsx-11.mit.edu				pub/linux
    tupac-amaru.informatik.rwth-aachen.de	pub/msdos/replace

The current version of Linux is 0.95a released on March 17, 1992

End of Linux-Activists Digest
******************************

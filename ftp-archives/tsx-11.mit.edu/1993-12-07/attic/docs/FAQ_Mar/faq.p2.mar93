Newsgroups: comp.os.linux,comp.os.linux.announce,news.answers,comp.answers
Distribution: world
Followup-To: poster
From: corsini@labri.greco-prog.fr
Reply-To: linux@numero6.greco-prog.fr
Organization: Greco Prog. CNRS & LaBRI, Bordeaux France
Subject: Linux Frequently Asked Questions 2/4 [monthly posted]
Summary: Linux, a small and free unix-like for 386-AT computers.

Archive-name: linux-faq/part2

Last-Modified: 93/03/28
Version: 1.16.1

*********************************************************
*							*
*   Answers to Frequently asked questions about Linux   *
*							*
*********************************************************

This post contains Part 2 of the Linux FAQ (4 parts).
It must be read *after* the first part. 

================================8<=====8<==============================
CONTENTS (of this part)

	III. 	INSTALLATION, and COMMON PROBLEMS	(part2)
	IV.	SOME CLASSICAL PROBLEMS			(part2)
	V.	LINUX and DOS				(part2)

===================================8<====>8============================




III. INSTALLATION, SETUP, and COMMON PROBLEMS
=============================================
*** Note: this FAQ section should be kept up-to-date, and should
*** be the most 'reliable' source for installation info. Please mail
*** any corrections or changes to this section's coordinator, 
*** Matt Welsh (mdw@tc.cornell.edu). Last update March 93.


III.A. WHERE TO START: What are the reliable sources of information
III.B. LINUX PACKAGES: Where and how install a complete Linux package

III.C. SOME COMMON PROBLEMS: Simple problems and simple solutions


III.A. WHERE TO START
~~~~~~~~~~~~~~~~~~~~~

 III.01)  I want to install Linux on my machine. Where do I start?

ANSWER: The first thing you should do is read through the various
introductory files, and ESPECIALLY the FAQ (this file). Especially
this section :). A lot of effort has been done on these intro files,
but note that some of them conflict with each other and cover older
versions of Linux. When in doubt consult this file.

These files are all found on tsx-11.mit.edu:/pub/linux/docs...

  FAQ
  The Linux Frequently Asked Questions list
    It's sitting in your hands now. This section is probably the best
    place to start to get the most up-to-date Linux installation
    information.

  INFO-SHEET 
  Linux Information Sheet, by J. Winstead/L. Wizenius
    This is a collection of general info about Linux. It's
    a good place to start if you've never heard of the package
    before.
  
  README.kernel
  Kernel compilation README file, by L. Wirzenius
    This is the README notes for recompiling the Linux kernel from the
    sources. You don't need it unless you're planning to upgrade
    your kernel by compiling it yourself.

  Others
    Every "release" of Linux (such as SLS, boot/root, HLU's disks, etc.,
    see below) has its own up-to-date README files and docs that explain
    how to install that release. This FAQ section summarizes, but for more
    info on how to install Linux, read the READMEs and docs for the release 
    that you choose.

  Old docs
    There are a number of obsolete, old docs lying around. Most of these
    tell how to install Linux from the old boot/root disk combo. I DO NOT
    SUGGEST that you use these docs unless you know what you're doing--
    the best thing for beginners to do is read this FAQ and install the SLS
    release (using the docs and READMEs for the SLS release). 
    These old docs are things like "install.txt", "guide.txt", "RELNOTES",
    "CHANGES", and so on, and are all geared towards old versions of the
    boot/rootdisk. They are *NOT* relevant to current versions of Linux.


 III.02)  Is there some kind of limit on how large my Linux partitions
and/or filesystems can be?

ANSWER: There's no limit on partition size (just the size of your drive),
but Linux mainly uses the minix filesystem which limits filesystems to
64 megs each. You can also use the extended filesystem (which is still
in testing, but has been included with recent kernel versions) which has
a limit of 4 terabytes. Probably enough unless you have a disk array. :) 

See section III.C below on creating partitions and filesystems for more info.



III.B. LINUX PACKAGES
~~~~~~~~~~~~~~~~~~~~~
This section contains information about *SOME* of the current Linux
packages  available. 

 III.03)  Does there exist a way to get all (or nearly all) of the Linux
stuff?

ANSWER: Yes. To install Linux, you're going to want to choose one of the
"releases" of Linux, all of which have a different method of installation
and set up. Each release also has its own README and installation docs,
which you'll want to read first. But I'll summarize here. The major
releases are:
   
   * The "Softlanding Linux System Release"
     Also known as the "SLS" release, consists of 14 disks for Linux
     and 8 for X11. The nice thing about this release is that you can
     pick and choose which disks and packages you want to install. The
     first 2 disks must be "rawritten" (using rawrite.exe) on floppies,
     and the rest of the images are put onto DOS format floppies. 
     Contains all of the softs you'll ever need, and is easy to install
     for newcomers.

     This is the release that I suggest everyone new to Linux should
     install. It's the most complete and up-to-date package. HLU's
     disks, below, are good for upgrading, and (unfortunately),
     the MCC-interim is quite dated at this point. If you install
     SLS you'll save yourself a lot of trouble.

   * The "TAMU" (Texas A&M University) Linux Release
     This release is supposedly like the SLS release, but has some
     different softs and a different installation procedure. From Dave
     Safford, "The installation procedure is the main difference from
     SLS. A single boot diskette is used, and it boots directly into
     an automated installation program." This installation program
     asks a few questions about the desired configuration, and sets up
     everything, including your filesystems, booting from the hard
     drive with LILO (see section III.C below), and a simplified
     X-Windows configuration. 

     This humble author has never installed the TAMU release but I've
     heard good things about it. 

   * H.J. Lu's "bootable rootdisk"
     This is a release of the Linux kernel and basic binaries on
     a single floppy. It, along with HLU's 'gccdisk', 'libdisk',
     and so on, are good for upgrading or installing basic
     Linux system by hand. It's not reccommended for newcomers,
     because there's no real install script, it's mostly meant
     as an upgrade of the basic system software. Beginners should
     install SLS or MCC-interim (see below) instead.
     The images and docs are found at tsx-11.mit.edu:/pub/linux.

   * Others but OUTDATED
     There are other releases and distributions of the Linux software,
     such as the "MCC-Interim" and "MJ" releases. There is also an older
     "boot/root" disk combo (0.98.1) which is like HLU's bootable
     rootdisk, above, but it's no longer supported (as far as I know).

     The MCC-Interim release (the previous de facto Linux standard)
     isn't going to be updated anymore, according to Owen LeBlanc. So
     if you install it, be warned that you'll have to upgrade it all
     in some other way (the last version of MCC-Interim was 0.97.2,
     quite dated). 

     The "MJ" release, according to Martin Junius, is no longer
     maintained. The last version was 0.97.1.

 III.04)  Where can I get these versions of Linux?

ANSWER: 

The SLS release is at tsx-11.mit.edu:/pub/linux/packages/SLS and
sunsite.unc.edu:/pub/Linux/SLS.

H.J. Lu's "bootable rootdisk" release is found at tsx-11.mit.edu:
/pub/linux/packages/GCC, as well as the mirror sites.

TAMU.99p4 is available from sc.tamu.edu in pub/free_unix/TAMU.99p4.


 III.05)  What should I do to install the SLS release?

ANSWER: Basically all of the releases are alike. You need to get the
DOS program 'rawrite.exe' (or 'rawrite2.exe'). This program takes a
binary file and writes it, block by block, to a blank formatted
floppy. This is the way to take a Linux floppy image and put it onto a
disk from DOS.

For the SLS release, you need to get the files in the a1, a2, a3, and
a4 directories at least. You also need the README's there. Basically,
you use rawrite to copy the a1 and a2 images onto floppies.  Or, you
can use 'dd' on your UNIX system to transfer the files directly to
floppies (assuming you have a floppy drive on your UNIX system) in
place of rawrite.

The rest of the files all go onto DOS-formatted floppies, just using
DOS copy. The SLS release is nice because it reads the DOS floppies
during installation, so you don't have to rawrite all of those disks.

Once you have these 4 disks, you're ready to go. You can also get all
of the files in the b1-b7 directories (for extras, like man pages and
emacs), c1-c4 directories (for the GCC compiler and libraries), the
x1-x8 directories (for Xwindows), and so on, but they're all optional.
I suggest at least getting the files in the a, b, and c directories.
Remember that only the a1 and a2 images need to be rawritten, ALL of
the other files just do onto the floppies in DOS format.

First you boot the a1 disk. It will load up Linux, and will ask you to
put in the a2 disk at some point. You'll be left with a prompt... from
here you want to look at the SLS README file on-line (it tells you
how).  Then you'll run 'fdisk' to create your Linux partition(s), (see 
section III.C, below, for info on making partitions), and 
then reboot the a1 disk again (putting in the a2 disk, again, when
asked). Then you'll run 'mkfs' and 'mkswap' to make your filesystems
and swap space. Then you're ready to install the software-- type
	doinstall /dev/PART 
where PART is the main Linux partition you created with fdisk, above.
>From here on it's pretty automatic-- you simply flip disks while it
installs the software. First it will ask you how much software you
plan to install-- just choose the correct option depending on which
sets of disks you got.

You will need to have a blank DOS-formatted floppy on hand. The
installation procedure makes a Linux kernel boot disk out of it.

 III.06)  What's about SLS ?

ANSWER: (this is part of the FAQ written for SLS 0.98p5 by Peter
MacDonald).
SLS (Softlanding Linux System) Copyright 1992, Softlanding Software.

which is NOT just an image dump of someones Unix system.

Also note that in the interest of preventing ftp storms, the version
of SLS that appears on the internet, is not quite the same as the
version distributed by Softlanding.   Softlanding regularly gets a
whole new version which has the changes integrated.   But the updates
to the Internet version are tailored to minimize the amount that has
to be downloaded to become current.  That is why bugs manage to creep
in on me.  I am not installing and testing the Internet version, 
although, functionally, it should be quite close to the Softlanding
one.  

So, why am I telling you this?  After the next period of stability
(few changes to SLS), I will be uploading the Softlanding version of
SLS to tsx-11.mit.edu.

This distribution is freely available if you have internet 
access, or an obliging friend with access to it.

The purposes of the SLS are the following:
0) provide an initial installation program (for the queasy).
1) utilities compiled to use minimal disk space.
2) provide a reasonably complete/integrated U*ix system.
3) provide a means to install and uninstall packages.
4) permit partial installations for small disk configs.
5) add a menu driven, extensible system administration.
6) take the hassle out of collecting and setting up a system.
7) give non internet users access to Linux.
8) provide a distribution that can be easily updated.

SLS is a binary mostly distribution (except for the kernel), and is
broken into multiple parts, or series, each of which is denoted by a
letter followed by the disk number as follows:

        a1-aN: The minimal base system
        b1-bN: Base system extras, like man pages, emacs etc.
        c1-cN: The compiler(s), gcc/g++/p2c/f2c
        x1-xN: The X-windows distribution
        i1-iN: Interviews (doc and idraw)
        t1-tN: TeX (document processing)

This scheme allows new disks to be added to the distribution without
changing the disk numbering.  Also, the sysinstall program doesn't
have to be changed when new disks are added as the last disk is marked
by the presence of the file "install.end".  And when interviews is
added, say as a new series "i", it can be installed with: 

        sysinstall -series i

Highlights of the base are:  gcc/g++, emacs, kermit, elm/mail/uucp,
gdb, sc (spreadsheet), man pages, groff, elvis, zip/zoo/lh and menu.
Highlights of X are: X, programmers libs, 75 dpi fonts, games (spider,
tetris, xvier, chess, othello, xeyes, etc) and utilities like xmag,
xmenu, xcolormap and ghostscript.  Approximate usage is as follows: 

Tiny base system:        9 Meg  (Series 'a')
Main base system:       25 Meg  (Series 'a', 'b' and 'c')
Main base system + X11: 45 Meg  (Series 'a', 'b', 'c' and 'x')

Please read the file COPYING which outlines the GNU copying 
restrictions.  The linux kernel is copywrite Linux B. Torvalds.
Various other copywrites apply, but the upshot is that you
may do whatever you like with SLS, except restrict others
in any way from doing likewise, and you must leave all copywrites
intact, and you can not misrepresent or take credit for others work.

                AVAILABILITY

SLS is available from the address: 

        Softlanding Software               
        910 Lodge Ave. 
        Victoria, B.C., Canada             
        V8X-3A8            
        (604) 360-0188

More details about SLS can be asked to pmacdona@sanjuan.uvic.ca


 III.07)  What should I get to install the bootdisk/rootdisk combo
release? 

ANSWER: Essentially it's a lot like the SLS installation, above. You
get the boot disk and root disk, and use rawrite to transfer them to
floppies.  Then you boot the boot disk, and put in the root disk when
asked. At this point you login as 'install' to install the software.


 III.08)  How do I get and install H.J. Lu's "bootable rootdisk" release?

ANSWER: It's just like the boot/root disk and the SLS release. Just
get the bootroot disk image and use rawrite to transfer it to a
floppy, and then boot it. You'll probably want to get the 'gccdisk'
and 'libdisk', etc.  images and rawrite them to floppies as well. Note
that this release doesn't have a user-friendly installation script,
it's meant mostly to upgrade or install the system by hand. Unless
you're familiar with Linux this may prove difficult. :)


 III.09)  What is the MCC interim version of Linux?

ANSWER: The MCC-Interim release of Linux was put together by Owen
LeBlanc of the Manchester Computing Centre. Unfortunately, it's quite
dated, and isn't going to be updated anymore. :(




III.C. SOME COMMON PROBLEMS
~~~~~~~~~~~~~~~~~~~~~~~~~~~
 III.10)  What filetype is the extension ".z"? What about ".taz", 
".tpz", and ".tgz"? I see these files on the archives but I don't
know how to unpack them.

ANSWER: Here's a list of common filename extensions on the archives.
  
   Extension      Used by
   ---------      ----------------------------------------------------------
    .Z              compress/uncompress. Use "uncompress foo.Z" to 
		    uncompress the file.
    .z              gzip. Gzip is now used by many archive sites instead
		    of compress; if you don't have gzip on your system,
		    get it! To uncompress one of these files use 
		    "gzip -d foo.z".
    .tar            Tar file. Use "tar xvf foo.tar" to unpack it. Or, you
		    can fo "tar tvf foo.tar" to get an index listing of 
		    the tarfile.
    .taz            Compressed tar file. You can do something like
		    "zcat foo.taz | tar xvf -" or "tar xvfz foo.taz" to 
		    unpack it (some versions of tar don't have the z 
		    option).
    .tpz, .tgz      Gzipped tar file. If you have gzip, zcat is linked to 
		    it, so you can do "zcat foo.tpz | tar xvf -" to unpack
		    it. .tpz is the old extension; all gzipped tar files 
		    should now end in .tgz instead.

The SLS distribution uses gzipped tar files (.tgz). 


 III.11)  How do I make partitions and/or filesystems for Linux?

ANSWER: For most Linux installations (such as SLS) you'll need at
least two partitions: one for swap space (used as virtual memory) and
another for your "root filesystem" (that is, the actual Linux software
itself).  You can also make seperate partitions for your /usr
filesystem, etc. (however, the SLS doinstall program, at this point,
mounts your root filesystem for you before installing, thus, you can't
have a seperate /usr filesystem to start out with).

But that's beside the point. First thing you need to do is resize the
existing partitions on your drive (if any) to make space for Linux;
for example, if you have a DOS partition taking up all of your drive,
you need to use FDISK under MS-DOS to delete it and recreate it with a
smaller size.  Of course, in so doing you'll lose everything on that
DOS partition-- just back it up first and reinstall after you've
recreated and reformatted the partition. That's life! :)

Now you can boot up Linux (say, from SLS, or from the boot/root disks). 
>From there you run 'fdisk' to create your partitions: it's very self-
explanatory. If you make a swap partition you need to change it's type
to "Linux swap" with the fdisk 't' command. 

And, if you want a Linux partition larger than 64 megabytes, you'll
need to use the extended filesystem[*] (as opposed to the default, the
Minix filesystem).  The extended filesystem ("extfs" for short) has a
4 terabyte size limit (and lets you have filenames longer than 14
characters). If you want to use it just set the type of the partition
to "Linux extfs" with the fdisk 't' command.

[*] You can also use the Xia filesystem (xiafs) or ext2fs (better version of
the extended filesystem). These two filesystems are proving to be more
widely used as both the extfs and the Minix filesystem are being phased out.
Both of them are now included in SLS. Use "mkxfs" to create Xia filesystems,
and "mke2fs" to make Extdended 2 Filesystems. As most installations are
phasing out the Minix and Extended filesystems I suggest using xiafs or ext2fs.

NOTE: "Extended filesystem" does NOT equal "extended partition". An
extended partition acts as a "container" for logical partitions, which
is nice because you can have many logical partitions inside the
extended partition, and only use up one of your four available primary
partitions on the drive.  (You can have only one extended partition
per drive). Extended partition can't hold data on their own: you need
to create logical partitions on top of it first. They are numbered
/dev/hda5, /dev/hda6, and so on. 

The extended FILESYSTEM on the other hand has nothing to do with
extended partitions. It's just the name of another filesystem used by
Linux which lets you have larger filesystem sizes and other features.

Once you've got your partitions created, you need to reboot the system
so that changes to your partition table are picked up. Then you need
to 'format' the partitions (i.e. create filesystems on them). For your
swap partition, use the command 'mkswap <partition> <size>'. For
example, if you have a swap partition on /dev/hda2 with a size of 8208
blocks (about 8 megs), use the command
	mkswap /dev/hda2 8208

If you have a partition set up for a Minix filesystem (the default
type) use the command 'mkfs <partition> <size>'. If however you're
going to use the extended filesystem (a must for partitions over 64
megs) use the command 'mkefs <partition> <size>'. (Note: If you use the 
ext2fs, you'll have to use mke2fs, and if you use Xia filesystem, you'll 
have to use mkxfs when creating the filesystems).

 III.12)  Why does fdisk say "Linux cannot currently use XXXX sectors of
this partition"? 

ANSWER: Fdisk is an older program which expected all filesystems to be
Minix fs, which limited filesystems to 64 megs. You can ignore this warning
because the extfs, xiafs, and ext2fs don't have this limit.


 III.13)  What does the message "MINIX-fs: Magic match failed" on bootup mean?

ANSWER: Basically, this means that you're trying to mount a non-Minix
filesystem as a Minix filesystem, and mount is croaking on it because the
type is wrong. If you use a root filesystem type other than Minix fs (i.e.
if you use the extfs, ext2fs, or xiafs) you'll probably see this message:
the kernel tries to mount root as Minix, then extfs, then ext2fs, and so on...
every time it fails for one type it tries the next type. 

In most situations, this can be ignored, if the kernel is able to mount
your root partition as any one of its known types. However, if you have the 
root device set to the wrong partition, for example, then the kernel should
hang at this point and you'll have to use "rdev" to set it correctly.

 III.14)  Linux mkfs doesn't accept the size I give the device,
although I double-checked with fdisk, and it's correct.

ANSWER: Be sure you give the size in Linux BLOCKS (1024 bytes), not
sectors. Also make sure that you have the right partition: partitions
are numbered "/dev/hda1", "/dev/hda2", and so on (and "/dev/hdb1",
"/dev/hdb2" for the second hard drive)... DON'T use "/dev/hda" or
"/dev/hdb" as they correspond to the entire disk, not just single
partitions.

Also remember that SCSI drives use /dev/sda1, /dev/sda2... and
/dev/sdb1, /dev/sdb2, and so on for their partitions.


 III.15)  How can I get mkfs/mkefs to check for bad blocks?

ANSWER: Unfortunately the -c option on mk(e)fs does not work; it
cannot detect bad blocks on the drive, and thus if you create a
filesystem over a part of your hard drive with bad blocks, things will
eventually go wrong. So you need to generate a bad block list (in a
file) and use the -l option on mk(e)fs so it will flag those blocks
when making a filesystem.

NOTE: This is only needed for older RLL and MFM drives. SCSI and IDE 
drives have bad block logic on-board.

Generating a bad block list for mk(e)fs
=======================================
Nov 11, 1992  Gerhard Kircher   (kircher@neuro.tuwien.ac.at)

Introduction
 ------------ 
First of all: the -c option (check bad
blocks) of mk(e)fs does not work (the code used cannot detect any bad
blocks).  Fortunately there is another option -l <file> to tell
mk(e)fs where the bad blocks are.  SCSI and IDE drive users do not
need any bad block management - the drive logic does it for them.
However, users of old MFM or RLL drives do need it.

1 Where are my bad blocks ?  
--------------------------- 
Every MFM or RLL drive is tested by the manufacturer and the locations
of bad blocks are usually printed directly on the drive case.  If you
cannot find any bad block information on your drive, you can use the
common disk test software (Norton,...) to check your drive and obtain
a defect list.

Locations of bad blocks are given in terms of cylinder and head
coordinates.  Cylinder and head together specify a certain track. Some
manufacturers are more specific about the location of the bad spot
within the track but if you know how to use this information you
probably do not need to read this guide.  So if we know the track
where the bad spot sits, we declare the entire track as bad (even
experts do this).

What we have now is a table of the form

  CYLINDER  HEAD
  ...       ...
  ...       ...
  ...       ...


2 calculating all bad sectors
-----------------------------
Each sector on the drive can be addressed by three cordinates:
  Cylinder = [0..CYLINDERS-1]
  Head     = [0..HEADS-1]
  Sector   = [0..SECTORS-1]
where
  CYLINDERS ... total number of cylinders
  HEADS     ... total number of heads
  SECTORS   ... number of sectors per track

The absolute address of a sector on the disk is then calculated
according to the formula

  Abssector = HEADS*SECTORS*Cylinder + SECTORS*Head + Sector.

We can now calculate the absolute addresses of all sectors
of every bad track on our disk according to

  for each bad track given by Cylinder and Head do
  begin
    for Sector=0 to SECTORS-1 do
    begin
      Abssector = HEADS*SECTORS*Cylinder + SECTORS*Head + Sector
    end
  end

obtaining a list of all bad sectors.


3 Converting absolute sectors to partition relative sectors
-----------------------------------------------------------
Partitions are like separate disks, that means that sector counting
starts with 0 for each partition. So what we have to do next is to
generate a bad sector list for each partition we want to use for
linux. To do that, we must know where each partition starts and ends.
We can get this information from fdisk. When we start fdisk and type
'p' to view the partition table, the begin, start and end information
will be given in terms of cylinders.  When we type 'u' to toggle the
units, an then again 'p' we get what we need: Start and End of each
partition in terms of absolute sectors.  Here is what I see on my
system (I use my second disk for linux):

	# fdisk /dev/hdb

	Command (m for help): p

	Disk /dev/hdb: 8 heads, 17 sectors, 1024 cylinders
	Units = cylinders of 136 * 512 bytes

	   Device Boot  Begin   Start     End  Blocks   Id  System
	/dev/hdb1           1       1     963   65483+  81  Linux/MINIX
	/dev/hdb2         964     964    1024    4148   82  Linux swap

	Command (m for help): u
	Changing display/entry units to sectors

	Command (m for help): p

	Disk /dev/hdb: 8 heads, 17 sectors, 1024 cylinders
	Units = sectors of 1 * 512 bytes

	   Device Boot  Begin   Start     End  Blocks   Id  System
	/dev/hdb1           1       1  130967   65483+  81  Linux/MINIX
	/dev/hdb2      130968  130968  139263    4148   82  Linux swap

Sector counting (as counting always should do :-) starts with 0.
The first partition begins with sector one, as sector 0 is
always the boot sector.

This is how we calculate the addresses for one partition:

  a) From the list obtained in section 2, cancel all addresses
     that are not in the range [Start..End] (including limits)
     shown by fdisk.
  b) Subtract Start from each remaining entry.


4 Converting to blocks
----------------------
A disk sector has a length of 512 bytes (this is the usual size
BIOS/DOS can handle). Linux groups two sectors to an entity called
block. A block therefore consists of two physical sectors and has a
size of 1024 bytes (I read somewhere that larger blocks will be
supported in the future). The mk(e)fs program wants to know the
addresses of bad blocks, not sectors. So we convert our partition
relatve sector addresses to partition relative block addresses by
dividing by two and taking the integer part. Doing that we certainly
get a lot of duplicate addresses which we have to get rid of, so we
simply delete redundant entries.

What we have now is a list of bad blocks for each partition.  Mk(e)fs
likes to get this information from a file, one address per line, one
file for each partition.


5 Automating the process
------------------------
Doing all the calculations by hand is tedious and error prone.
So we may decide to automate the whole thing.
We can do everything in dos when we use the proper utilities
(see later)

5.1 The Input File

We need a single file containing the coordinates of all bad tracks of
one entire disk. Each line of the file consists of two fields, the
first of which is the cylinder number and the second is the head
number. These are the first few lines of the file for my second disk:

    48 0
   105 4
   150 2
   224 1
   380 2
   427 6
   435 1


5.2 An AWK script for doing all the calculations

In the following we present an awk script that does all the work for
us. We just have to plug in the correct values of the partition and
drive parameters and off we go.  I use gawk211.zip and sort03.arc
which I downloaded from a simtel20 mirror.  Sort is used to remove the
duplicates.

#---the awk script starts here
# generates linux bad blocks file (starting count with 0)
# for partition ONE
# for micropolis drive 8 heads, 17 sectors
# input file: cyl[0.. ] head[0.. ]\n
# stdout: abs blocks of corresponding partition\n
BEGIN { start   = 1;
        end     = 130967;
        sectors = 17;
        heads   = 8;
      }
{ sec=$1*sectors*heads+$2*sectors;
  if (sec>=start && sec<=end)
    for (i=0; i<sectors; i++) print int((sec-start+i)/2) | "sort -mu"
}
#---the awk script ends here

Suppose that our input file is named 'badtrack.lst' and that the awk
file is 'part1.awk', then we can generate a bad block list for mk(e)fs
by typing the command

  gawk -f part1.awk badtrack.lst > badblk1.lst

This is the file we need. 

5.3 Making the file system

What we must do now is to have this file accessible for linux during
installation. There are several ways to do this. You can either mount
your DOS partition and copy the file over to Linux, or use mtools (as
in 'mcopy c:badblk1.lst /user/badblocks').

Now we can make the file system. In this case the bad blocks file is
in /user/badblocks, and the partition we're making a filesystem on is
/dev/hdb1.  We're making an extended filesystem with a size of 65483
blocks:

  mkefs -l /user/badblocks /dev/hdb1 65483

Thats it!


Bugs
----
I only tried mkfs but I'm rather convinced that it works with
mkefs as well.


 III.16)  How can I boot Linux off of my hard drive? 

ANSWER: You need to install the "LILO" program which changes the boot
sector of your hard drive to allow you to choose between a DOS or a
Linux partition to boot from. These programs are provided with most
major releases, or you can get them seperately from one of the FTP
sites.

As of LILO version 8 there is a "quick install" script available which
should make LILO installation quick and easy. See Section VII for LILO
information.


 III.17)  Cripes! I tried to install LILO, but screwed up somehow, and
now can't boot anything from the hard drive. How can I fix this?

ANSWER: Simple. First you need an MS-DOS 5.0 (or OS/2) bootable floppy
with FDISK.EXE on it. Boot it and run the command
	FDISK /MBR 
which will (hopefully) restore your hard drive's master boot record to
a standard MS-DOS (resp. OS/2) boot record. Now you can go back and
reinstall LILO. :)


 III.18)  When installing SLS, I get the error "You may have inserted
the wrong disk" when putting in the next disk in a series. What's
going on?

ANSWER: Each disk has a small file on it which contains the name of
the disk. For example, the SLS a3 disk has a file on it called
"diska3". If it doesn't exist, or is named something else (like
"diska3.z"), then just create it/rename it.

Also, the last disk in a series (i.e. the a4 disk, b5 disk, etc.) has
a file on it called "install.end". You need this file as well. These
files are used by the SLS doinstall program to keep track of where it
is.


 III.19)  When installing SLS, the installation script creates a "boot
floppy" for me to boot Linux with. How can I make these myself (or fix
problems with them?)

ANSWER: The SLS install scripts just copy the kernel image to a blank
floppy for you to boot Linux with. When SLS is installed, a copy of
the kernel is stored in the file /Image on your hard drive: since you
use the kernel on your boot floppy to boot, this file isn't used
during the bootup process (unless you install LILO).

To make a boot floppy yourself, you must do two things:
  1) Run 'rdev' (a.k.a. 'rootdev') on the kernel in the file /Image to set
     the root partition it uses. For example, if your root partition is
     /dev/hda3, run the command
	   rdev /Image /dev/hda3
  2) Copy the kernel to a new floppy. You may need to DOS format the floppy
     first(*). Then run the command
          cp /Image /dev/fd0
     if the floppy is in /dev/fd0 (the first floppy drive). You can use a
     command like
          dd if=/Image of=/dev/fd0 bs=16k
     as well; they should accomplish the same thing.

(*) (From: "Michael L. Kaufman" kaufman@delta.eecs.nwu.edu)
Formating the floppy lays down the track/sector information. If
you have a completely unformated floppy, dd can fail in interesting
ways.  

Many folks have problems with their SLS boot disks made in this manner
because they forgot to run 'rdev' on the kernel image before copying
it to the floppy.

 III.20)  How can I set the default video mode used by Linux? Do I have
to recompile the kernel to do this? 

ANSWER: No, you don't have to recompile the kernel. Just use "rdev" with
the "-v" switch to set the video mode in the kernel (either on your 
hard drive (if booting from LILO) or on your boot floppy). For example,
to change the kernel in /Image to prompt for the videomode on bootup, do
	rdev -v /Image -3
to change the kernel on your boot floppy do,
	rdev -v /dev/fd0 {video-mode}

 III.21)  How else can I use rdev?

ANSWER: rdev is very handy and also is used to set the root and swap 
partitions, ramdisk size, and more, in a compiled kernel. It means you 
don't have to recompile the kernel to make these changes. Use "rdev -?" 
for a list of options.


 III.22)  When I login as non-root, I get tons of errors about
"shell-init: permission denied". Also, some things work as root but
not as a normal user. What's the deal?

ANSWER: This is a really common problem which comes from not having
permissions set right and a misunderstanding of some UNIX terms. Some
installations won' t have the file permissions set correctly on the
various directories that normal users (i.e. non-root) will use. For
example, if your user directories are in /home, then /home must be of
mode rwxr-xr-x, or 'chmod 755 /home'.  Also, a home directory must be
owned by the user who it belongs to (i.e.  /home/mdw must be owned by
'mdw'...  just 'chown mdw /home/mdw', for example).  Also, the
permissions must be set correctly for / (the root directory). Here's a
list of permissions that should work (although you can use other
permissions, these are just suggestions that shouldn't cause trouble):

 permissions (chmod)   owner   file
 ----------- -------   -----   ---------------------------------------------
 rwxr-xr-x   (755)     root    /
 rwxr-xr-x   (755)     root    /home
 rwxr-xr-x   (755)     mdw     /home/mdw
 rwxr--r--   (744)     mdw     /home/mdw/.profile (or other startup files)
 rwxr--r--   (744)     mdw     /home/mdw/foo (normal files)

In most cases the group of the file doesn't matter, but in general
most files are set to group 'root' (except for binaries which are
group bin, and so on) and user files are set to group 'user' (or
whatever group users are in).

In general you want directories that everyone can access to be
rwxr-xr-x (chmod 755). Files that everyone can read are rwxr--r--
(chmod 744), and programs that everyone can run are rwxr-xr-x (chmod
755).

Thus /bin, /usr, /usr/bin, /etc, and so on, should all be rwxr-xr-x.
All binaries should be rwxr-xr-x (unless, of course, they're setuid
programs).  For UNIX newbies, setuid programs run under the user id of
the owner, thus programs owned by root which have a permission of
rwsr-xr-x (note the 's') run as root, with root's priveleges. So
before changing permissions on a program check to see if it's setuid
first. To make a program setuid prepend a '4' to the permissions you
give to chmod, i.e. rwsr-xr-x is 'chmod 4755'.

Here's a list of common uses for permissions:

permission    effect on files           effect on directories
----------    -----------------------   ---------------------------------
read          lets you look             lets you see what's in the directory
	      at a file, lets you       with ls
	      run a shell script

write         lets you edit a file or   lets you create or delete a file from
	      copy over it              the directory (*)

execute       lets you run a binary or  lets you cd into the directory
	      shell script

(*) Note that you can delete a file from a directory even if you DON'T
have write access to the file itself! Write access to the DIRECTORY
that the file is in will let you delete any file in that directory.
The permissions of the file itself have nothing to do with being able
to delete a file.  This is standard across all UNIX systems, nothing
new with Linux.


 III.23)  I have the previous version of the Linux kernel, how can 
I upgrade it?

ANSWER: If you've never done this before, get the kernel sources from
your nearest FTP site (in a file named something like linux-*.tar.Z)
and unpack them into /usr/src/linux. As of Linux-0.99 there is a
script to autoconfigure your kernel, and you need at least GCC version
2.3.3. You unpack these sources in /usr/src/linux. Make sure you have
the logical links for /usr/include/linux and /usr/include/asm as 
described below.

First run 'make config' and answer the various questions. Then
edit /usr/src/linux/Makefile to set the root partition, keyboard, etc.
Finally, do a 'make dep' (to set dependencies: VERY important!) and
finally 'make'.  Assuming you have GCC installed correctly, the kernel
should compile and you'll be left with a new "Image" which is your new
kernel: if you boot from harddrive, copy the Image to wherever you
told LILO to look for it, or if you boot from floppy dd the Image to a
new floppy. Make sure that you run "rdev" on the Image to make it look
for the correct partition for your root filesystem (if you specified
this correctly in the Makefile you don't need to do this).

** Make sure you read /usr/src/linux/README, which explains in detail
** what to do when recompiling the kernel.

If you HAVE done this before, you can just apply the source patches to
your old sources and then recompile (i.e. you don't have to get the
entire kernel sources all over again). Use the "patch" program to do
this.  Before you recompile the kernel do a 'make dep' to set
dependencies and a 'make clean'.


 III.24)  Where is /usr/include/linux and /usr/include/asm, or,
Why won't the kernel compile correctly?

ANSWER: The files /usr/include/linux and /usr/include/asm are symbolic
links to /usr/src/linux/include/linux and /usr/src/linux/include/asm,
respectively. In other words, all of the Linux include files are
actually under /usr/src/linux/include, but to access them you need two
symbolic links in /usr/include:
	/usr/include/linux -> /usr/src/linux/include/linux
	/usr/include/asm -> /usr/src/linux/include/asm
To make these, run the commands
	ln -sf /usr/src/linux/include/linux /usr/include/linux
	ln -sf /usr/src/linux/include/asm /usr/include/asm
NOT the other way around. :) If you dont have these links then many 
compilations will surely fail.


 III.25)  How can I upgrade to the newest version of GCC and/or
libraries? 

ANSWER: See section IX on GCC for more information, but essentially
all you need to do is FTP to sunsite.unc.edu (or one of the other
Linux FTP sites) and look in /pub/Linux/GCC. You'll see a number of
.tar.Z files there (often abbreviated .TZ). The names change from time
to time: you need to get the compiler (often in a file such as
'gcc233.TZ'), header files, and library files. At this point, the
compiler lives in /usr/bin, the compiler's setup files are under
/usr/lib/gcc-lib/i386-linux, and the libraries (shared, jump table,
and static) are all in /usr/lib. It's all very straightforward once
you actually unpack the tar files and everything falls into place.


 III.26)  What's the deal with these things called "jump tables"? 

ANSWER: There's more information in section IX and VII, but to be
brief: There are three kinds of libraries for Linux. As of gcc v2.3.3
they all live in /usr/lib. The files are...
	/usr/lib/*.a   static (non-shared) libraries  (use gcc -static ...)
	/usr/lib/*.sa jump table shared lib stubs (use gcc -jump ...)

There is an older form of the shared libraries which is no longer widely used.
Nonetheless, you may run across it from time to time.
	/usr/lib/*.ca  classic shared lib stubs

When you compile a program, depending on the options you give gcc
(-jump is the default) it will link it against one set of these
libraries. The static libs contain all of the code and thus make your
executable very big; no shared code is used. The classic shared libs
were actually 'stubs' which reference the shared code in
/lib/libc.so.VERSION (where VERSION is a number like '4.2').
/lib/libc.so.VERSION is a file which contains the actual code of the
library, which is accessed at runtime by your executable. The
jump-table library stubs are also shared libs, but they are built in
such a way that you can upgrade the /lib/libc.so.VERSION file without
having to recompile the programs that use it.

So when we say "uses Jump Tables version 4.2" we mean it uses the
actual library itself, /lib/libc.so.4.2. To compile programs that use
jump tables version 4.2 you need the right version of /usr/lib/*.sa
installed, but you don't need them to RUN programs that use jump
tables.

However programs that are compiled to use, for example, jump table
version 4.2 (in the file /lib/libc.so.4.2) won't work if you only have
libc.so.4.1 installed. They're only backwards-compatible. If you get
errors about 'can't find /lib/libc.so.4.1' then the executable you're
using is looking at runtime for a jump table version that you don't
have. Basically you're safe if you have the most recent version of the
/lib/libc.so.VERSION file installed (which is found on
sunsite.unc.edu:/pub/Linux/GCC and comes with the GCC stuff).

You should always have a symbolic link with the major version number
of the library in /lib, because that's what's actually read. For
instance, if you have /lib/libc.so.4.2 installed, then you need the
symbolic link
	/lib/libc.so.4 -> /lib/libc.so.4.2
Make this with the command
	ln -s /lib/libc.so.4.2 /lib/libc.so.4

 III.27)  How to upgrade jump tables? (Without hanging my system)

ANSWER: Be careful! If you upgrade your /lib/libc.so.VERSION file and
either remove the symlink or delete the old libc.so.VERSION file
before the new one is in place (and the link points to it), then more
than likely all of your binaries like "cp", "mv", "ls" and "ln" use
the library, so they'll all stop working once you kill the link or the
library file. So to upgrade the file, copy the new version to /lib and
switch the link in one step with a command such as
	ln -sf /lib/libc.so.NEW_VERSION /lib/libc.so.4 
where NEW_VERSION is the new version of the library you're installing.
This will switch the link in one step and everything should work. You
just can't copy over the old file because the old version is in use by
'cp', 'mv', and so on.

BTW you get new versions of GCC, jump tables, libraries, include files, etc.
from tsx-11.mit.edu:/pub/linux/GCC.

  
 III.28)  How can I be sure I won't be writing over anything important
when installing Linux?  I have to use DOS on my machine, and I don't
want to lose any files.

ANSWER: Back up everything. Just in case. As long as your DOS and
Linux partitions don't overlap you should be okay.


 III.29)  I just rebooted my machine, and now Linux dies with a
"panic: trying to free unused inode". What's going on?

ANSWER: You probably forgot to "sync" before rebooting, which stores
on the disk physically the contents of the kernel buffers. You can
either run "fsck" on the partition to TRY to correct the problem (it
might fail), or re-mkfs and re-install the software on that partition.
For the extended filesystem use "efsck" instead.

The best way to shutdown your system is the "shutdown" command. To
shutdown and reboot the system, use
	shutdown -r now 
or substitute a number of minutes in place of "now". Leave off the
"-r" switch if you just want to shutdown and not reboot.


 III.30)  Can I use both OS/2 and Linux on my machine??

ANSWER: Yes! See the following two Q/A's about getting your OS/2 Boot
Manager to work. But, be warned: IF YOU USE OS/2, DO NOT USE LINUX's
FDISK TO CREATE LINUX PARTITIONS!! The problem is with a bug/feature
in OS/2's fdisk that tries to correct 'errors' in partitions that it
doesn't like... Linux partitions included. The solution: make your
Linux partitions with OS/2's fdisk, then use Linux's fdisk to change
the partition ID's to the right values (this is self-explanatory with
Linux's fdisk).

If you made your Linux partitions with Linux's fdisk, and OS/2 sees
them, it will think they have errors and end up trashing them.


 III.31)  I use OS/2's Boot Manager on my hard drive. How can I get it
to recognize Linux?

ANSWER: To do this, install LILO on your Linux root partition, NOT on
your hard drive's master boot record. The lilo command for this would
be (if /dev/hda3 is your Linux root partition, and your Linux kernel
is in /Image):

	/etc/lilo/lilo -c -b /dev/hda3 -v -v /Image

Then use OS/2's fdisk to add it to the Boot Manager.


 III.32)  When I run Linux's fdisk it says "OPUS" for OS/2's Boot
Manager partition. Is this right? What's OPUS?

ANSWER: It's correct. OPUS is BBS software that used partition type
0x0A long before OS/2.




IV. SOME CLASSICAL PROBLEMS 
===========================

  IV.01)  While running du I get "Kernel panic: free_inode: bit
already cleared".  Also, du produces a ENOENT error for all the files
in certain of my directories.  What's going on?

ANSWER: These are both consistent with a bad file-system.  That's
relatively easy to produce by not syncing before rebooting, as linux
usually has 1.5MB of buffer space held in memory (unless you have <=4M
RAM, in which case the buffers are only about 0.5MB). Also linux
doesn't do anything special about the bit-map blocks, and as they are
used often, those are the thing most likely to be in memory. If you
reboot, and they haven't been written to disk ...

Just do an fsck on the device, the -a flag might repair it otherwise,
the only thing to do is to reinstall the filesystem from the Images.

A sync is done only every 30 seconds normally (standard unix
practice), so do one by hand (some people think you should do 3 syncs
after each other, but that's superstition, you just have to give time
to the first sync to finish), or by logging out from the
startup-shell, which automatically syncs the system. Unmounting a
filesystem also syncs it (but of course you can never unmount root).

Another (sad) possibility is that you have bad blocks on your disk.
Not very probable, as they would have to be in the inode-tables, just
a couple of blocks in size. Again there aren't programs available to
read a disk for bad sectors and put them in some kind of
"bad-sector-file".  On IDE drives this is no problem (bad sectors are
automatically mapped away).


  IV.02)  How can I partition my hard-drive to use Linux?

ANSWER: See section III of the FAQ on installation.

  IV.03)  I heard something about repartition a hard disk without
deleting everything on it, any clue?

ANSWER: It's not a program but a partition procedure which requires
a) a partitionning program
b) a sector editor
The procedure itself can be found (at least) in digest#132 Vol2.


  IV.04)  What must I do to mkfs a floppy?

ANSWER: blocks are of size 1K so 1.44 floppy is 1440 blocks. The
floppy has to be formatted before this will work (e.g., fdformat can
do this from within Linux).


  IV.05)  I have some trouble with tar/untar; any clue ?

ANSWER: The tar provided on .96 and later is Pax (don't know for
CURRENT_VERSION) which does not accept the z flag. You can download
the GNU tar at tsx-11 in /pub/linux/binaries/usr.bin 


  IV.06)  I can do this as root but not as non-root, is it a bug?

ANSWER: Except for an early make utility, the problem is caused by an
incorrect permission flag. The most common problems are about /tmp
which should be 1777 and /dev/ttys? which might be 766. So as root do

	chmod 1777 /tmp ; chmod 766 /dev/ttys?


  IV.07)  "du" reports twice the size showed with "ls -l", is it a
bug?

ANSWER: No it is not, the report is 512 bytes multiple (due to POSIX
requirement), for KB you just add the -k flag. You can add a du
function in your .profile which does this automatically, something
like du(){ /usr/bin/du -k $* }
	

  IV.08)  Sometimes, I get "mount can't open lock file"; what does this
means? 

ANSWER: This can happened for two reasons: 
A) You try to mount something as non-root. In that case you can either
retry as root, or set the setuid bit to mount as follows:
- be sure that mount belongs to root, if not do 'chown root /bin/mount'
- set the setuid bit with 'chmod u+s /bin/mount'
BTW you have to do the same with umount (in order to be able to unmount) 
Remark that it is NOT safe to allow anyone to perform mount/umount.

B) You are root. mount wants to open /etc/mtab and /etc/mtab~ - the
first one for reading, the second as lock file. If there is already a
mtab~ remove it. This can happen if you used once gnuemacs on mtab.

To forbid that case, just add the following entry in your /etc/rc file:
rm -f /etc/mtab~


  IV.09)  When I try "mount /dev/hd?? /user", I get error 2.

ANSWER: Be sure, that your mount point /user does exist; if not perform 
a "mkdir /user". 
BTW the error numbering is explained in /usr/include/errno.h


  IV.10)  Since I have upgrade my Linux kernel, ps won't work anymore,
why? 

ANSWER: Each time you upgrade (or re-compile the kernel), you should
perform a 'ps -U' (-U is for update the /etc/psdatabase). 

Every time you boot a new kernel you have to do a 'ps -U' to update
the psdatabase, after doing this you can remove the system file or
even have to patch the ps-suite.

BTW: sometimes a patch makes recompiling ps necessary. Sometimes you
do a make clean.

NOTE: As of 0.99 there is now a ps package which uses the "/proc
filesystem".  This is a meta-filesystem which has an entry for each
process that's running... create the directory /proc and do a 
'mount -t proc /proc /proc' to see it, or else add the following
entry in your /etc/fstab:

	none 	/proc 	proc

You can get the "procps" package from tsx-11.mit.edu in
/pub/linux/BETA/procps. The nice thing about this is: you don't have
to upgrade it for every kernel version (and thus ps -U is meaningless
if you use procps).

MKJ wrote in c.o.l.a:

tsx-11.mit.edu:/pub/linux/BETA/procps/procps.tar.Z is the latest
version of procps.  Most of the reported bugs (i.e. all I can remember
at the moment ;-) have been fixed, a man page for ps has been added,
and several new programs have been added and/or fixed.  A list of the
stuff provided:
	ps
	free (a real one, from Linus)
	uptime (this needs work to be good, mine is a hack)
	tload (a hack, but who cares?)
	xload (from drew)
	fuser (perl script prototype, hopefully the real thing in a
               later release)

  IV.11)  Since Linux 0.96b I have a lot of core file all over
my disk. How can I sweep them away ?

ANSWER: Use the following command
		find / -name core -exec rm {} \;

BTW: think twice before using this command, there might be a John Core
user on your system; this command will erase his mail :)

If you never want to see another core file, put this line into
your /etc/rc file:
	for a bash user
 				ulimit -c 0
	for a csh or tcsh user
				limit coredumpsize 0

 

  IV.12)  I can only log-in as "root", is it normal ?

ANSWER: No, add "rm -f /etc/nologin" in your /etc/rc.local file

  IV.13)  Sometimes my Linux virtual console get messed up when I cat
a binary file. The characters shown are above ascii 127, any clue ?

ANSWER: (J. Stuckey stuckey@mrcnext.cso.uiuc.edu)

It's a vt-100 thing I think.
echo "^V^O"
should fix it.  Control-V is the literal-next character that stty
reports for me, and Control-O is the "magic" character that returns
you to livability. 


V. LINUX and DOS 
=================
*** This section is co-written by Mark Komarinski, A. V. Le Blanc and
*** MM. Corsini. The official maintainer is Mark, if you have *any*
*** questions, mail him at komarimf@craft.camp.clarkson.edu 
*** Last Update 03.08.93


   V.01)  Is is possible to access DOS from Linux?

ANSWER: Yes.  
(1) The mtools package allows you to access DOS files;
it emulates the DOS commands CD, COPY, DEL, DIR, TYPE, and others.
(2)  Since approximately version 0.97 of the kernel, you can mount
DOS file systems as part of your Linux directory tree, providing you
have an appropriate mount command.  
(3)  A DOS emulator is in alpha test, which will allow some DOS programs
and utilities to run under Linux. 


   V.02)  Why use mtools if you can just mount a drive?

ANSWER: Mtools is good if you want to do something quickly.  For
example, if you want to get directories on a bunch of floppies.  The
mount procedure requires you to mount the drive, get a directory, then
umount it. Mtools lets you get the directory with one command.

(Dirk Hohndel:) Mtools is really fast when copying disks. I mount the
SLS directory of my SUN to my linux box and use mcopy to get the files
on the disks. 3 times faster than using xcopy under DOS
 

   V.03)  How do I get the mtools package set up correctly?

ANSWER: The mtools package is available in source form on most Linux
ftp sites.  The most recent version (As of Sept 1992) is mtools.n2,
and there are linked binaries and library (.a) files available as
well (for example, as part of MCC interim releases of Linux).
In the n2 release of mtools, there is only one executable binary
which works differently depending on its name: you can create hard
or symbolic links to it named mcopy, mdel, mdir, mtype, etc; this
is how the Makefile in version n2 of mtools does it, and it saves
several hundred kilobytes of disk space.  Finally, you need the
correct information in the file /etc/mtools, which is described below.
Mtools also comes with the SLS release of linux.


   V.04)  What is the format of the file /etc/mtools?

ANSWER: A complete entry in the file /etc/mtools contains the following
fields: drive, device, fat, cylinders, heads, sectors, offset.  Two
examples of entries from /etc/mtools are
 
     A /dev/fd0 12 80 2 15
     C /dev/hda1 16 0 0 0
 
which defines the DOS disk A: as accessible through the device /dev/fd0,
having a 12-bit FAT, 80 cylinders, 2 heads, and 15 sectors per track;
DOS disk C: is accessible through the device /dev/hda1, has a 16-bit
FAT, and its geometry is simply that of the hard disk where it lives.
The last three numbers can be 0 if you wish; this allows mtools to
try to figure out the disk's geometry itself, and perhaps to fail.
A 12-bit FAT is common for floppies, but may occur in small hard
disk partitions.  A 16-bit FAT is common for hard disks.
This is an extract of my /etc/mtools file:
A /dev/fd0 12 0 0 0     # 3.5  1.4 Meg (autodetect)
B /dev/fd1 12 0 0 0 	# 5.25 1.2 Meg (autodetect)
C /dev/hda1 16 0 0 0	# 1st partition of my Disk


   V.05)  Where can I find out more about mtools?

ANSWER: There are two detailed README files in the mtools.n2 distribu-
tion.  These files treat compiling and using mtools.  There is a file
README.mtools which treats only using mtools, which is a part of the
MCC interim version of Linux.
 

   V.06)  How do I use the DOS file system?

ANSWER: The DOS file system is part of the kernel.  If you have a
kernel of level .97.1 or above, and an appropriate mount command, type
 
     mount -t msdos [-o conv=text] /dev/hda1 /dos
 
to mount the partition /dev/hda1 as an MS/DOS file system on the
directory /dos.  You'll need a recent mount command, from at least
release 97 or later of the root disk.  Recent mount commands also
accept the options conv=binary|text|auto (default is binary) to
specify that text end-of-lines in DOS files are to be converted to
UNIX end-of-lines (by omitting carriage return characters) in no cases
(binary) or in all cases (text) or in cases that don't have 'well-
known binary extensions' (e.g., .EXE or .COM) (auto).
 

   V.07)   When I mount an MS-DOS disk, I get two lines of what seem to
be error messages and the message: No bmap support.  Is my disk bad?

ANSWER: No.  Since the dosfs is still in ALPHA mode, the two lines are
used for displaying information about the disk that was mounted, just in
case you have problems.  The 'No bmap support' message means that you
cannot run linux programs from that partition.  This has been fixed in the 
latest release (alpha.9)


   V.08)  I want to use the DOS file system with either conv=binary or
conv=auto, but I want to convert text files from DOS to UNIX format,
or from UNIX to DOS format.

ANSWER: Use the utility todos/fromdos which comes as part of the
dosfs package, currently (Sept 92) in released in version 8, or
use the flip utility by Rahul Dhesi.
 

   V.09)  Where can I find out more about the DOS file system?

ANSWER: There is a README file included in dosfs.XX.tar.Z (the current
value of XX is 10)


   V.10)  This sounds me like a chicken and eggs problem, how can I
install the mtools package at the very beginning.

ANSWER: You have to use rawrite or the mount procedure.


   V.11)  Could someone explain how to use rawrite?

ANSWER: Rawrite is a DOS util which write sequential sectors of
a formatted disk/floppy. When a floppy has been rawritten, you can
(under Linux) untar it (use x, v, z and f flags). As an example:
a) under Dos use rawrite
rawrite
	source: kermit.z
	destination: a
b) boot under Linux, and perform a tar
tar zxvf /dev/fd0
tar zxvp < /dev/fd0

You DO NOT NEED TO MOUNT a rawritten disk


   V.12)  What is as86.tar.Z ?

ANSWER: It's the port of Bruce Evans' minix assembler, you need it to 
be able to recompile Linux at your convenience. In fact this is ONLY
used for boot/setup.S and boot/bootsect.S they create 80x86 REAL mode
code. 


   V.13)  Turbo (Microsoft) Assembler won't compile the Linux boot
code.  In fact, some of the opcodes in these files look completely
unfamiliar.  Why?

ANSWER: The Linux boot codes are written in Bruce Evans' minix
assembler, which has the same opcodes as the original minix assembler
ported to linux get as86.tar.Z There are a few differences
between these and normal DOS assemblers.


   V.14)  What about the dos emulator (dosemu)?

ANSWER: Dosemu is in alpha testing now, so it is very unstable and crashes
easily.  Some programs (such as earlier versions of Turbo Pascal; TP
5.5 too) seem to work fine, but other programs such as dir /p will
crash the emulator. 
Look in your favorite FTP site for the dosemu kit.  For a semi-complete
list of programs that do and do not work under the emulator, get the file
/pub/Linux/docs/emusucc.txt at sunsite.unc.edu or tsx-11.mit.edu.


   V.15)   I have a Stacker volume on my hard drive.  Can I access that?

ANSWER:  Yes, but you will have to do that through the dosemu program. 
For more information on it, check out the file /pub/Linux/docs/stacker.doc
at sunsite.unc.edu


   V.16)   How about OS/2 HPFS partitions, or MacIntosh/Amiga floppies?
Can I mount any of them?

ANSWER:  There is no support for any of those filesystems yet.


	   ===================8<==========>8================



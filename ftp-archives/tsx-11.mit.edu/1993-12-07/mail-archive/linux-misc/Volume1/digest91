From:     Digestifier <Linux-Misc-Request@senator-bedfellow.mit.edu>
To:       Linux-Misc@senator-bedfellow.mit.edu
Reply-To: Linux-Misc@senator-bedfellow.mit.edu
Date:     Fri, 3 Sep 93 19:13:13 EDT
Subject:  Linux-Misc Digest #91

Linux-Misc Digest #91, Volume #1                  Fri, 3 Sep 93 19:13:13 EDT

Contents:
  [Patch] term 1.0.7 improvements (Olaf Titz)

----------------------------------------------------------------------------

From: uknf@rzstud1.rz.uni-karlsruhe.de (Olaf Titz)
Crossposted-To: alt.sources,de.comp.os.linux,uka.linux
Subject: [Patch] term 1.0.7 improvements
Date: 3 Sep 1993 23:01:23 GMT

Archive-name: term107-p-ot1
Submitted-by: Olaf Titz <s_titz@ira.uka.de>

This is a set of enhancements to term 1.0.7. I consider it to be in
beta stage and would appreciate any bug reports, especially if
something that works with 1.0.7 gets broken by this patch (which
really shouldn't happen). Probably this stuff could get into the
official distribution but that depends on Michael.  :-)

The following features are added:
- tredir may now redirect several ports at once
- Support for HP-UX 8.07 
- Enhanced security: trsh requests can be blocked, term can run under
  chroot.
- termftp works more like standard FTP than before.
- Some bug corrections.

Read the file "Blurb" for more info. "termdiff.all" contains diffs
against term 1.0.7. "noproxy.d" contains diffs against ncftp.

Olaf

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#               "End of shell archive."
# Contents:  Blurb Changed noproxy.d termdiff.all
# Wrapped by olaf@bigred on Sat Sep  4 00:21:55 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Blurb' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Blurb'\"
else
echo shar: Extracting \"'Blurb'\" \(6946 characters\)
sed "s/^X//" >'Blurb' <<'END_OF_FILE'
XThis is a set of enhancements to term 1.0.7. I consider it to be in
Xbeta stage and would appreciate any bug reports, especially if
Xsomething that works with 1.0.7 gets broken by this patch (which
Xreally shouldn't happen). Probably this stuff could get into the
Xofficial distribution but that depends on Michael.  :-)
X
XI'm distributing this as one large collection of unified diffs against
Xstock term 1.0.7 (termdiff.all - just feed it to patch, there should
Xbe absolutely no problems with backward compatibility) and one
Xseparate file for patching into ftp.c (of either stock BSD or ncftp
Xflavor - the diff is noproxy.d against the ncftp version of ftp.c, for
Xthe BSD version apply the patch manually - it's very easy).
X
XSee the file 'Changed' for a table of additional features vs. changed
Xfiles.
X
XThe following features are added:
X- tredir may now redirect several ports at once
X       Affects clients only
X- Support for HP-UX 8.07 
X       Affects server and clients under HP-UX only
X- Enhanced security: trsh requests can be blocked, term can run under
X  chroot.
X       Affects server only
X
XBug corrections:
X- typo in pty handling: alphabetical sequence was incorrect
X       Affects server only
X- C_BIND works now: correct update of # of active clients
X       Affects server only but makes certain clients usable
X- Redundancy taken out: don't request own address and delete it just 
X  afterwards
X       In the server, affects nothing (as far as I can tell now)
X- Finally, non-existing "linecheck.1" taken out of Makefile
X       Affects installation process only
X
XAnd one major feature was added, which unfortunately required a
Xprotocol change.  The termftp clients as known use proxy (passive)
Xserver mode. This will break with ancient ftp servers and with certain
Xfirewalls (the latter situation provided the incentive for me to write
Xthis, s.b.)).  To use the PORT command like the genuine ftp client,
Xterm needs the C_BIND command which does not work. I've corrected this
X(making possible some other new clients as well... see tclient.c for
Xan example. Anyone dares to hack up ircII to do DCC file transfer over
Xterm in both directions?)  Also, to properly implement this mode, the
Xftp client needs to get a listening socket from the system (usual
Xtechnique: bind to 0.0.0.0:0 and get port # with getsockname()). For
Xthis I have inserted a new command, C_BINDN, which will return the
Xport number used. I've not seen any possibility to transfer this
Xcritical information - the port # - from the remote server to the
Xclient other than a new protocol element.
X       Affects server and termftp clients only, but *could* cause
X       problems with future clients *if* protocol is changed again
X       (very unlikely)
X
XTo get termftp working with this, you need to completely replace the
Xfunctions initconn() and dataconn() in ftp.c, inside the #ifdef TERM
Xor TERM_FTP, with the ones provided in ftpconn.c. (I've done this in a
Xseparate branch with #ifdef TERMPROXY.) This applies to both termftp
X(patched original BSD ftp client) and ncftp+term (patched ncftp);
Xncftp is derived from BSD anyway.
X
X*** Explanations - only of interest if you really need to know ***
X
X  Multiple redirections 
XHave you ever worried about the long list of tredir's in the ps
Xlisting? One process can manage as many ports as file descriptors are
Xavailable, only the standard tredir doesn't use this capability. (as
Xfrom the release note of 0.99.something) The changes are rather
Xtrivial (get tredir to process a set of arguments in the first place,
Xand add an argument to the redirector function in the client lib - the
Xlatter means that every client compiled with the new lib has to be
Xadapted (trivially), but old ones will run unchanged. Refer to the
Xdiff for xconn.c to see what has to be changed.)
X
X  HPUX support 
XThis is the result of my (eventually successful) attempts to get term
X1.0.7 to run on a HP with a rather screwy OS (some sort of a mixture
Xof HPUX 8.05 and 8.07). Some definitions in the Makefile are changed,
Xetc. The most prominent feature is the use of SIGWINCH (which is
Xcalled SIGWINDOW and not used properly in HPUX, but required anyway).
XI'm using the c89 compiler (cc refuses to run), there is no install
Xcommand, and other minor annoyances.
X
X  Security considerations 
XEver run term as root on one end? Don't.  Everyone who has access to
Xthe other end's term socket (at least root on that machine) can become
Xroot on your box - all he has to do is trsh. Also, if term runs as
Xroot, it can clobber every file on your system with an appropriate
Xtupload. The solution: two more options in the termrc file, one to
Xdeny trsh's from the other end and one to run term in a chroot
Xenvironment (much like anonymous ftp does). The changes are only a few
Xlines of addition.
X
X  Why not use proxy mode with FTP? Why does termftp fail on some sites?
XThere are two ways how the data port of FTP can be opened: the client
Xconnects to a port of the server, or the server connects to a port of
Xthe client. Proxy FTP mode (the client sends PASV command and connects
Xto the socket returned by the server for data connections) works well
Xin an open network with modern ftp servers (the PASV command is now
Xrequired). However, there is a subtle difference to the usual scheme
X(where the client sends PORT <port> command and the server connects to
X<port>). If you bother to look at netstat, you will see the
Xdifference:
X(Example: A.B.C.D be the host with term and Internet connection, and
XM.N.O.P the ftp server; 9999 denotes an arbitrary port number, the *
Xside is the active end)
Xeither   *A.B.C.D:9999   M.N.O.P:9999  (termftp, proxy mode)
Xor        A.B.C.D:9999  *M.N.O.P:20    (the usual scheme)
X
XIn the latter case (which is set up by the PORT command), the
Xconnection is from a standard port (20 - ftp data). In the former
Xcase, you can get two nonstandard ports, which will be blocked by
X"packet filtering gateways" (the most modest and least annoying form
Xof firewalls). To avoid this problem, one side of the connection must
Xbe port 20, and for this in the first case (proxy mode) the client had
Xto run setuid root. This is impractical just in the situation where it
Xwould be needed, so proxy mode can't be used. If you have termftp or
Xncftp-term, and it "hangs" on the first "ls", "get" or "put" command,
Xthen you're perhaps in this situation. If you can use standard
XInternet ftp, you can likely use my enhanced termftp as well - it uses
Xthe same ports and makes the term server behave exactly like an
Xordinary ftp client.
X  More FTP chicanery
XAssume you have an ftp client on your Internet box that is setuid
Xroot, and any other ftp client (compiled by yourself) won't run. Then
Xyou're out of luck with term anyway and should ask your network
Xadministration a few polite questions. The same holds for a genuine
Xfirewall - a network gateway which doesnt't let anything "through" at
Xall. In this case you can't do anything but FTPing the files to the
Xfirewall and tupload'ing them afterwards (or vice versa).
X
END_OF_FILE
if test 6946 -ne `wc -c <'Blurb'`; then
    echo shar: \"'Blurb'\" unpacked with wrong size!
fi
# end of 'Blurb'
fi
if test -f 'Changed' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Changed'\"
else
echo shar: Extracting \"'Changed'\" \(387 characters\)
sed "s/^X//" >'Changed' <<'END_OF_FILE'
XFollowing table lists changed files vs. features:
X
XMakefile.HP            HP BU
XPROTOCOL.unix          BN
XTERMRC                 SE
Xclient.h               MU BN
Xconfig.h               HP
Xconnect.c              MU
Xincludes.h             HP
Xlink.c                 SE BN BU
Xmain.c                 SE
Xpty.c                  HP BU
Xredir.c                        MU
Xsocket.c               BU
Xterm.1                 SE
Xterm.h                 SE
Xterm_clients.1         MU
Xxconn.c                        MU
X
XBU = bugfix
XHP = HPUX support
XBN = termftp, C_BINDN
XSE = enhanced security
XMU = multiple redirections
END_OF_FILE
if test 387 -ne `wc -c <'Changed'`; then
    echo shar: \"'Changed'\" unpacked with wrong size!
fi
# end of 'Changed'
fi
if test -f 'noproxy.d' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'noproxy.d'\"
else
echo shar: Extracting \"'noproxy.d'\" \(2138 characters\)
sed "s/^X//" >'noproxy.d' <<'END_OF_FILE'
X--- oldftp.c   Fri Jan 29 21:50:13 1993
X+++ newftp.c   Fri Sep  3 20:16:50 1993
X@@ -1316,8 +1316,9 @@
X 
X 
X #ifdef TERM
X 
X+#ifdef TERMPROXY
X 
X /*
X  * Need to start a listen on the data channel
X  * before we send the command, otherwise the
X@@ -1366,8 +1367,98 @@
X {
X         return (fdopen(data, lmode));
X }
X 
X+#else /* TERMPROXY */
X+
X+/* Need to open a new listening port. This requires C_BINDN. 
X+ * No provision for *not* giving each new connection a new PORT. -ot 
X+ */
X+
X+int pending = -1;
X+
X+initconn()
X+{
X+      int s, p;
X+      char port[64] = "PORT ";
X+      
X+      if (data != -1)
X+              (void) close(data);
X+      data = -1;
X+      if (pending != -1)
X+              (void) close(pending);
X+      
X+      lcompression = rcompression = compress_toggle;
X+      if (debug)
X+              printf("initconn...-");
X+
X+      if ((s = connect_server(0)) < 0) {
X+              perror("initconn: connect to term server");
X+              return 1;
X+      }
X+      if (debug)
X+              printf("\b/");
X+      if (send_command(s, C_BINDN, 0, 0, 0) < 0) {
X+              printf("initconn:C_BINDN: %s\n", command_result);
X+              return 1; 
X+      }
X+      if (debug)
X+              printf("\b \n");
X+      if (read(s, port+5, 58)<0) {
X+              perror("initconn:read port");
X+              return 1;
X+      }
X+      if ((p=command(port)) != COMPLETE) {
X+              fprintf(stderr, "initconn:PORT command failed: %u\n", p);
X+              return 1;
X+      }
X+      if (debug)
X+              printf(" ...done\n");
X+
X+      pending = s;
X+      return 0;
X+}
X+
X+FILE *
X+dataconn(lmode)
X+      char *lmode;
X+{
X+      int s, p;
X+      char port[10];
X+      if (pending == -1) {
X+              fprintf(stderr,"dataconn: bogus pending\n");
X+              return NULL;
X+      }
X+      if (debug)
X+              printf("Server connecting...-");
X+      if (read(pending, port, 10)<0) {
X+              perror("dataconn:read-accept");
X+              return NULL;
X+      }
X+      p = atoi(port);
X+      if (debug)
X+              printf("\b/");
X+      if ((s = connect_server(0)) < 0) {
X+              perror("dataconn: connect to term server");
X+              return NULL;
X+      }
X+      if (debug)
X+              printf("\b|");
X+      if (send_command(s, C_ACCEPT, 0, "%d", p) < 0) {
X+              fprintf(stderr, "dataconn:C_ACCEPT: %s\n", command_result);
X+              return NULL;
X+      }
X+
X+      (void) close(pending);
X+      pending = -1;
X+      data = s;
X+      if (debug)
X+              printf("\b done\n");
X+      return (fdopen(data, lmode));
X+}
X+
X+#endif /* TERMPROXY */
X+
X #else /* TERM */
X 
X initconn(void)
X {
END_OF_FILE
if test 2138 -ne `wc -c <'noproxy.d'`; then
    echo shar: \"'noproxy.d'\" unpacked with wrong size!
fi
# end of 'noproxy.d'
fi
if test -f 'termdiff.all' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'termdiff.all'\"
else
echo shar: Extracting \"'termdiff.all'\" \(14644 characters\)
sed "s/^X//" >'termdiff.all' <<'END_OF_FILE'
X--- term107/Makefile   Sat Apr 17 01:12:55 1993
X+++ term.new/Makefile.HP       Fri Sep  3 15:33:59 1993
X@@ -1,3 +1,3 @@
X #
X-# Term program makefile.
X+# Term program makefile. for HP-UX 8.07  -ot
X # valids targets are:
X@@ -6,3 +6,4 @@
X SHELL=/bin/sh
X-CC=gcc
X+CC=c89
X+# Hpux. c89 instead of cc
X # AIX: replace CC with this line...
X@@ -15,5 +16,5 @@
X DEBUGFLAGS= $(DEBUG) -O
X-CFLAGS= $(DEBUGFLAGS) -Wall -funsigned-char
X-LINKFLAGS=-O
X-# Hpux. -Aa for lib.c
X+CFLAGS= $(DEBUGFLAGS) -D_HPUX_SOURCE
X+LINKFLAGS=-O -Aa -s
X+# Hpux. -Aa for lib.c -s for stripping
X   
X@@ -27,7 +28,8 @@
X RANLIB= ranlib
X-INSTALL= install
X-INSTPGMFLAGS = -s
X+# HPUX has no install
X+INSTALL= cp
X+INSTPGMFLAGS =
X MKDIR= mkdir
X-BINDIR=/usr/bin
X-MANDIR=/usr/man/man1
X+BINDIR=$(HOME)/bin
X+MANDIR=$(HOME)/man/man1
X #
X@@ -52,3 +54,3 @@
X MANPAGES=term.1 term_clients.1 term_setup.1 tupload.1 tredir.1 \
X-      trsh.1 linecheck.1 tmon.1
X+      trsh.1 tmon.1
X 
X@@ -61,3 +63,3 @@
X       do \
X-      $(INSTALL) -c $(INSTPGMFLAGS)  $$i $(DESTDIR)$(BINDIR);\
X+      $(INSTALL)  $(INSTPGMFLAGS)  $$i $(DESTDIR)$(BINDIR);\
X       done
X@@ -88,5 +90,8 @@
X 
X-test: test.o
X-      $(CC) $(LINKFLAGS) -o test test.o
X+test: test.o client.a
X+      $(CC) $(LINKFLAGS) -o test test.o client.a $(LIBS)
X 
X+tclient: tclient.o client.a
X+      $(CC) $(LINKFLAGS) -o tclient tclient.o client.a $(LIBS)
X+
X tupload: $(UPLOADOBJS) 
X@@ -113,6 +118,6 @@
X clean:
X-      $(RM) *.o *.a core compress.debug out *~
X+      $(RM) a.out *.o *.a core compress.debug out *~ *.log
X 
X realclean: clean
X-      $(RM) $(PROGS) test 1 linerem check trcmd linecheck TAGS
X+      $(RM) $(PROGS) test 1 linerem check trcmd linecheck tclient TAGS
X 
X--- term107/PROTOCOL.unix      Thu Jan  7 03:55:30 1993
X+++ term.new/PROTOCOL.unix     Fri Sep  3 15:25:18 1993
X@@ -94 +94,6 @@
X 
X+C_BINDN binds a remote port selected by the system. It immediately writes
X+      back to the stream the remote getsockname() info in the format
X+      a,b,c,d,e,f (cf. RFC 959). Then it proceeds like C_BIND. 
X+      (I've added this to support a non-passive termftp client for 
X+      the benefit of firewalled people. -ot)
X--- term107/TERMRC     Mon Jan 18 09:25:01 1993
X+++ term.new/TERMRC    Wed Sep  1 12:46:12 1993
X@@ -88 +88,5 @@
X # 
X+
X+# denyrsh on
X+# Disallow execution of shell on this end.
X+#
X--- term107/client.h   Fri Feb 12 02:16:21 1993
X+++ term.new/client.h  Thu Sep  2 17:23:14 1993
X@@ -54,2 +54,3 @@
X #define C_QUIT          'N'   /* Shutdown term. */
X+#define C_BINDN         'U'     /* Bind a remote unspecified socket. -ot */
X 
X@@ -87,3 +88,3 @@
X 
X-void do_connect(int num, int *svs, int (*get_server)(void));
X+void do_connect(int num, int *svs, int (*get_server)(int n)); /* -ot */
X #endif
X--- term107/config.h   Tue Mar  9 06:12:19 1993
X+++ term.new/config.h  Mon Aug  9 21:39:19 1993
X@@ -82,2 +82,6 @@
X #if defined(__hpux) 
X+#ifndef SIGWINCH
X+#define SIGWINCH SIGWINDOW 
X+#endif
X+#define USE_SIGWINCH
X #define USE_TERMIOS
X--- term107/connect.c  Fri Feb 12 02:13:47 1993
X+++ term.new/connect.c Sun Aug  8 16:59:47 1993
X@@ -20,3 +20,3 @@
X 
X-void do_connect(int num, int *svs, int (*get_server)(void)) {
X+void do_connect(int num, int *svs, int (*get_server)(int n)) {
X   int max, num_cons = 0;
X@@ -126,3 +126,3 @@
X       
X-      if ((c->server = get_server()) <0) {
X+      if ((c->server = get_server(loop)) <0) {
X         perror("Couldn't open term");
X--- term107/includes.h Mon Mar  1 04:22:37 1993
X+++ term.new/includes.h        Mon Aug  9 20:48:41 1993
X@@ -55,3 +55,3 @@
X #elif defined(__hpux) || defined(__386BSD__) || defined(___386BSD___) || defined(SVR4)
X-#ifdef __hpux__
X+#if defined(__hpux__) || defined(__hpux)  
X #include <unistd.h>
X--- term107/link.c     Tue Mar  9 06:12:19 1993
X+++ term.new/link.c    Fri Sep  3 18:45:28 1993
X@@ -173,3 +173,3 @@
X   ((clt)->out_buff.data[(clt)->out_buff.start++] = (c), \
X-   (((clt)->out_buff.start == 2048) ? ((clt)->out_buff.start = 0) : 0), \
X+   (((clt)->out_buff.start == BUFFER_SIZE) ? ((clt)->out_buff.start = 0) : 0), \
X    (++(clt)->out_buff.size))
X@@ -180,3 +180,3 @@
X   ((clt)->out_buff.data[(clt)->out_buff.start++] = (c), \
X-   (((clt)->out_buff.start == 2048) ? ((clt)->out_buff.start = 0) : 0), \
X+   (((clt)->out_buff.start == BUFFER_SIZE) ? ((clt)->out_buff.start = 0) : 0), \
X    (++(clt)->out_buff.size)) ;
X@@ -189,3 +189,3 @@
X   ((clt)->in_buff.data[(clt)->in_buff.start++] = (c), \
X-   (((clt)->in_buff.start == 2048) ? ((clt)->in_buff.start = 0) : 0), \
X+   (((clt)->in_buff.start == BUFFER_SIZE) ? ((clt)->in_buff.start = 0) : 0), \
X    (((clt)->in_buff.size++ ? 0 : ++clients_waiting)))
X@@ -324,4 +324,7 @@
X            c[0]==C_PTYEXEC?"C_PTYEXEC":"C_EXEC", cl->number, c+1); 
X-    if (c[0] == C_PTYEXEC)   cl->fd = open_pty((char *)(c + 1));
X-    else cl->fd = open_socket((char *)(c + 1));
X+    if (denyrsh) cl->fd = -5;
X+    else {
X+      if (c[0] == C_PTYEXEC)   cl->fd = open_pty((char *)(c + 1));
X+      else cl->fd = open_socket((char *)(c + 1));
X+    }
X     if (cl->fd < 0) {
X@@ -336,2 +339,3 @@
X       case -4: p = "socketpair() failed"; break;
X+      case -5: p = "Permission denied"; break;
X       default: p = "Unknown failure"; break;
X@@ -610,2 +614,63 @@
X #endif        /* USE_SIGWINCH */
X+
X+  case C_BINDN: /* ftp special -ot */
X+    DEBUG_FP(stderr, "%s: C_BINDN\n", term_server);
X+    {
X+      int s, k;
X+      struct hostent *hp, *gethostbyname();
X+      struct sockaddr_in addr;
X+      char hostname[258];
X+      char *a, *p;
X+      
X+#ifdef SYSV
X+      uname(&unam);
X+      strcpy(hostname, unam.nodename);
X+#else
X+      gethostname(hostname, sizeof(hostname));
X+#endif /* SYSV */
X+      
X+      hp=gethostbyname(hostname);
X+      if (!hp) {
X+      ret_fail(cl, local, 1, "gethostbyname() failed");
X+      perror ("gethostbyname");
X+      break;
X+      }
X+      
X+      s = bind_tcp(0);
X+      if (s < 0) {
X+      ret_fail(cl, local , 1, "bind_tcp() failed");
X+      DEBUG_FP(stderr, "%s:Bind_tcp failed\n", term_server);
X+      break;
X+      }
X+      k=sizeof(addr);
X+      if (getsockname(s, &addr, &k) < 0) {
X+      ret_fail(cl, local, 1, "getsockname() failed");
X+      DEBUG_FP(stderr, "%s:getsockname failed\n", term_server);
X+      break;
X+      }
X+      
X+      DEBUG_FP(stderr, "%s:sockname returned %u,%u\n", term_server,
X+             addr.sin_addr.s_addr, addr.sin_port);
X+      ret_ok(cl, local);
X+      a = (char *)hp->h_addr;
X+      p = (char *)&addr.sin_port;
X+
X+      #define UC(x) (int) (((int) x) & 0xff)
X+      (void) sprintf(hostname, "%d,%d,%d,%d,%d,%d",
X+                   UC(a[0]), UC(a[1]), UC(a[2]), UC(a[3]), UC(p[0]), UC(p[1]));
X+      for (k =0 ;hostname[k];++k)
X+      add_to_buffer(&cl->in_buff, hostname[k]);
X+      add_to_buffer(&cl->in_buff, 0);
X+      if (cl->in_buff.size)
X+      ++clients_waiting;
X+      
X+      set_nonblock(s);
X+      if (cl->fd>=0) close(cl->fd);
X+      cl->fd = s;
X+      cl->cl_type = CL_BOUND;
X+      cl->type = T_RDFILE | T_WRFILE;
X+      cl->state = 1;
X+    }
X+    break;
X+
X   default:
X@@ -668,6 +733,6 @@
X     return -1;
X-  SANITY(cl->in_buff.end < 2048);
X+  SANITY(cl->in_buff.end < BUFFER_SIZE);
X   SANITY(cl->in_buff.end >= 0);
X   SANITY(cl->in_buff.size >=0);
X-  SANITY(cl->in_buff.size < 2048);
X+  SANITY(cl->in_buff.size < BUFFER_SIZE);
X 
X@@ -675,3 +740,3 @@
X   i = cl->in_buff.data[cl->in_buff.end++];
X-  if (cl->in_buff.end == 2048)        /* Wrap the buffer round if we have */
X+  if (cl->in_buff.end == BUFFER_SIZE) /* Wrap the buffer round if we have */
X                               /* hit the end. */
X--- term107/main.c     Tue Mar  9 06:12:19 1993
X+++ term.new/main.c    Thu Sep  2 14:32:01 1993
X@@ -63,2 +63,5 @@
X 
X+int denyrsh = 0;  /* Used in link.c. -ot */
X+char ownroot[128] = "";
X+
X char escapes[256];
X@@ -296,2 +299,8 @@
X     } 
X+    else if (!strncmp(file, "denyrsh on", 10)) {
X+      denyrsh = 1;
X+    }
X+    else if (!strncmp(file, "chroot ", 7)) {
X+      strncpy(ownroot, file+7, 128);
X+    }
X     else {
X@@ -481,2 +490,7 @@
X   terminal_raw(modem_out);
X+
X+  if (ownroot[0]) {
X+    if (!chroot(ownroot))
X+      perror("chroot");
X+  }
X   
X@@ -726,2 +740,4 @@
X         add_to_buffer(&clients[i].in_buff, 0);
X+        if (clients[i].in_buff.size)
X+          ++clients_waiting;
X       }
X--- term107/pty.c      Tue Mar  9 06:12:20 1993
X+++ term.new/pty.c     Thu Aug 12 18:20:55 1993
X@@ -35,6 +35,8 @@
X static  char *first ="pqrstuv";
X+#define NBANK 15
X #else                         /*  not hpux, and not sgi. */
X static  char masterline[]="/dev/ptyXY";
X-static  char *first ="pqrstuvwzyz";
X+static  char *first ="pqrstuvwxyz";
X static  char slaveline[]="/dev/ttyXY";
X+#define NBANK 16
X #endif
X@@ -81,3 +83,3 @@
X 
X-    for (i = 0; i < 16; ++i) {
X+    for (i=0; i<NBANK; ++i) {
X       masterline[MSECOND] = "0123456789abcdef"[i];
X@@ -86,3 +88,3 @@
X     }
X-    if (i != 16) {
X+    if (i != NBANK) {
X                               /* Ok. now check to make sure we can */
X@@ -104,2 +106,4 @@
X   
X+  DEBUG_FP(stderr, "%s: opened pty master=%s(%u) slave=%s(%u)\n",
X+              term_server, masterline, masterfd, slaveline, slavefd);
X #ifdef SUIDROOT
X@@ -147,3 +151,4 @@
X   fflush (stdout);
X-  pipe(pip);
X+  if (pipe(pip) <0)
X+    return -3; /* unable to pipe */
X   if ((pid = fork ()) < 0)
X@@ -201,3 +206,3 @@
X 
X-#if !defined(SVR4)
X+#if !(defined(SVR4)) && !(defined(__hpux))
X     terminal_restore(0); 
X--- term107/redir.c    Tue Mar  9 06:12:20 1993
X+++ term.new/redir.c   Tue Aug 10 18:21:40 1993
X@@ -8,2 +8,5 @@
X 
X+#define MAXREDIR 32
X+/* improved version - does multiple redirs  -ot */
X+
X int display_num = 9;
X@@ -11,5 +14,5 @@
X 
X-char *remote_port;
X+char *remote_port[MAXREDIR];
X 
X-int rd_connect_server(void) {
X+int rd_connect_server(int n) {
X   int s;
X@@ -22,3 +25,3 @@
X 
X-  if (send_command(s, C_PORT, 0, "%s", remote_port)< 0) {
X+  if (send_command(s, C_PORT, 0, "%s", remote_port[n])< 0) {
X     return -1;
X@@ -30,2 +33,9 @@
X 
X+void check_usage(int n) {
X+  if ( n < 2 )
X+    {
X+      fprintf ( stderr, "Usage: redir [options] {<localport> <[host:]remoteport>}\n" );
X+      exit(1);
X+    }
X+}
X 
X@@ -33,26 +43,25 @@
X   int s;
X-  int first;
X-  int svs[1];
X+  int first, i;
X+  int svs[MAXREDIR];
X   signal(SIGPIPE, SIG_IGN);
X   first = client_options(argc, argv,"",NULL);
X-  if ( (argc-first) < 1 )
X-  {
X-      fprintf ( stderr, "Usage: redir [options] <localport> <[host:]remoteport>\n" );
X-      exit(1);
X-  }
X-  fprintf ( stderr, "Redirecting %s to %s\n", argv[first], argv[first+1] );
X-  remote_port = argv[first+1];
X-
X   setbuf(stderr, 0);
X-
X-                              /* Bind the local socket we are going */
X-                              /* to listen on.  */
X-  s = bind_tcp(atoi(argv[first]));
X-  if (s < 0) {
X-    fprintf(stderr, "Port is already bound or some such error.\n");
X-    fprintf(stderr, "  s was %d.  Exiting\n", s);
X-    exit(1);
X+  check_usage(argc-first);
X+ 
X+  for (i=0; i<MAXREDIR && first<argc; first+=2 ) {
X+    check_usage(argc-first);
X+    fprintf ( stderr, "Redirecting %s to %s\n", argv[first], argv[first+1] );
X+    remote_port[i] = argv[first+1];
X+    
X+    /* Bind the local socket we are going */
X+    /* to listen on.  */
X+    s = bind_tcp(atoi(argv[first]));
X+    if (s < 0) {
X+      fprintf(stderr, "Port is already bound or some such error. s = %d\n", s);
X+    }
X+    else {
X+      svs[i++] = s;
X+    }
X   }
X-  svs[0] = s;
X-  do_connect(1, svs, rd_connect_server);
X+  do_connect(i, svs, rd_connect_server);
X }
X--- term107/socket.c   Mon Feb 15 06:30:08 1993
X+++ term.new/socket.c  Fri Sep  3 15:28:41 1993
X@@ -9,6 +9,10 @@
X {
X-  struct hostent *hp;
X-  char host_name[100];
X   struct sockaddr_in sin;
X   int s;
X+
X+#if 0 
X+/* This is not necessary here! - ot */
X+  struct hostent *hp;
X+  char host_name[100];
X+
X #ifdef SYSV
X@@ -37,6 +41,9 @@
X   memcpy(&sin.sin_addr, hp->h_addr, hp->h_length);
X-  sin.sin_port = htons( port );
X   sin.sin_family = hp->h_addrtype;
X-  sin.sin_addr.s_addr = INADDR_ANY;
X-  s = socket(hp->h_addrtype, SOCK_STREAM, 0);
X+#endif 
X+  sin.sin_port = htons( port );
X+  sin.sin_addr.s_addr = INADDR_ANY; 
X+/*  s = socket(hp->h_addrtype, SOCK_STREAM, 0); */
X+  s = socket(AF_INET, SOCK_STREAM, 0);
X+
X   if (s == -1) {
X--- term107/term.1     Tue Mar  9 06:12:20 1993
X+++ term.new/term.1    Wed Sep  1 17:09:48 1993
X@@ -234,3 +234,3 @@
X .TP
X-.I remote
X+.IR remote
X Sets this to the remote side.  It should always be specified on one, and only one
X@@ -256,2 +256,29 @@
X when relative paths are used.
X+.TP
X+.IR denyrsh \ on
X+If this is set, any
X+.IR trsh
X+request from the other end will be rejected. 
X+This is to provide better security, especially when run as root.
X+You can set this on both ends separately, allowing access on one end
X+and denying on the other.
X+.TP
X+.IR chroot \ <directory>
X+Runs term in a 
X+.IR chroot 
X+environment (see
X+.IR chroot (2),
X+.IR ftpd (8)).
X+If term is run as root, a 
X+.IR tupload 
X+from the other side could clobber every file on the system. 
X+To avoid this, a 
X+.IR chroot 
X+environment can be set up to give access only to specific directories. 
X+It accordingly restricts the commands that can be used by
X+.IR trsh.
X+The 
X+.IR chroot 
X+takes place after every file access in the initialisation process,
X+in particular after the server socket is opened.
X .SH ENVIRONMENT VARIABLES
X--- term107/term.h     Tue Mar  9 06:12:35 1993
X+++ term.new/term.h    Wed Sep  1 12:46:29 1993
X@@ -30,2 +30,3 @@
X         debug, 
X+        denyrsh,
X         window_size,
X--- term107/term_clients.1     Tue Mar  9 06:12:20 1993
X+++ term.new/term_clients.1    Tue Aug 10 02:38:39 1993
X@@ -11,3 +11,3 @@
X .IR tredir 
X-[options] local_port remote_port
X+[options] {local_port remote_port} ...
X .PP
X@@ -28,3 +28,3 @@
X .IR tredir 
X-redirects connections from a port on the local system to a port on the
X+redirects connections from ports on the local system to ports on the
X remote system, 
X@@ -117,11 +117,10 @@
X .IR Tredir
X-accepts two port numbers, the first is the local port number to redirect, and the second
X-is the remote port to redirect into.  
X+accepts pairs of port numbers, the first of each being the local port
X+number to redirect, and the second the remote port to redirect into.  
X .IR Tredir 
X will also accept
X-a hostname with the second port number.  For example, 
X+a hostname with each of the second port numbers.  For example, 
X .TP
X .IR
X-.IR
X-\ \ \ tredir 119 my.nntp.host:119
X+\ \ \ tredir\ 119\ my.nntp.host:119
X .TP
X@@ -268,7 +267,10 @@
X .IR
X-\ \ \ tredir 6667 munagin.ee.mu.oz.au:6500
X+\ \ \ tredir 6667 munagin.ee.mu.oz.au:6500 9017 17
X .PP
X This will map any connections to port 6667 on your local host to port
X-6500 on munagin.ee.mu.oz.au. So if you do 'telnet 0 6667' locally, you will be
X-connected to port 6500 on munagin.
X+6500 on munagin.ee.mu.oz.au and any connections on your local host to port
X+9017 to port 17 on the remote machine.
X+So if you do 'telnet 0 6667' locally, you will be
X+connected to port 6500 on munagin, and if you do 'telnet 0 9017', you will
X+be connected to port 17 on the remote machine.
X .PP 
X--- term107/xconn.c    Mon Feb 15 06:29:48 1993
X+++ term.new/xconn.c   Sun Aug  8 16:59:48 1993
X@@ -14,3 +14,3 @@
X 
X-int xc_connect_server(void) {
X+int xc_connect_server(int dummy) {
X   int s;
END_OF_FILE
if test 14644 -ne `wc -c <'termdiff.all'`; then
    echo shar: \"'termdiff.all'\" unpacked with wrong size!
fi
# end of 'termdiff.all'
fi
echo shar: End of shell archive.
exit 0
-- 
        olaf titz     o       olaf@bigred.ka.sub.org          praetorius@irc
  comp.sc.student    _>\ _         s_titz@ira.uka.de      LINUX - the choice
karlsruhe germany   (_)<(_)      uknf@dkauni2.bitnet     of a GNU generation
what good is a photograph of you? everytime i look at it it makes me feel blue

------------------------------


** FOR YOUR REFERENCE **

The service address, to which questions about the list itself and requests
to be added to or deleted from it should be directed, is:

    Internet: Linux-Misc-Request@NEWS-DIGESTS.MIT.EDU

You can send mail to the entire list (and comp.os.linux.misc) via:

    Internet: Linux-Misc@NEWS-DIGESTS.MIT.EDU

Linux may be obtained via one of these FTP sites:
    nic.funet.fi				pub/OS/Linux
    tsx-11.mit.edu				pub/linux
    sunsite.unc.edu				pub/Linux

End of Linux-Misc Digest
******************************

From:     Digestifier <Linux-Development-Request@senator-bedfellow.mit.edu>
To:       Linux-Development@senator-bedfellow.mit.edu
Reply-To: Linux-Development@senator-bedfellow.mit.edu
Date:     Fri, 24 Sep 93 08:13:09 EDT
Subject:  Linux-Development Digest #123

Linux-Development Digest #123, Volume #1         Fri, 24 Sep 93 08:13:09 EDT

Contents:
  Re: Linux Slowly Dying Off? + Lets make a game for Linux (Johnnie Walker)
  Bug in Kernel.99pl12? (Quota) (Joerg Stenger)
  Re: Linux Slowly Dying Off? (jcburt@gats486.larc.nasa.gov)
  Re: Net-2 Patches are GREAT (Alan Cox)
  Re: Linux Slowly Dying Off? (Brandon S. Allbery)
  CORRECTED NEW multiple sector transfer for IDE drives (Jan Richert)

----------------------------------------------------------------------------

From: koellner@galaxy.fernuni-hagen.de (Johnnie Walker)
Crossposted-To: comp.os.linux.help,comp.os.linux.misc
Subject: Re: Linux Slowly Dying Off? + Lets make a game for Linux
Date: 24 Sep 1993 11:04:31 GMT

Jeff Epler (jepler@nyx.cs.du.edu) wrote:
: What's a computer for besides games?
Buy a monitor with box-shaped case
and you will always have a place
to drop the papers, cups and cans
so undisturbed you may commence
with coffee-breaks until work ends.

--
Peter Koellner 
Student of Idiocy at the university of Dortmund
EMAIL:koellner@fernuni-hagen.de 

------------------------------

From: stenger@zeus.uni-duisburg.de (Joerg Stenger)
Subject: Bug in Kernel.99pl12? (Quota)
Date: 24 Sep 1993 11:14:55 GMT
Reply-To: stenger@zeus.uni-duisburg.de


Hi,
I use the latest SLS1.03 distribution. Apart from many "bugs" caused from that
distribution (i.e. wrong permissions, wrong net-setup, a SCSI-setup that didn't
work for my configuration, lp-set, that doesn't work, etc) - I'll never use
SLS again!!!- there seems to be a serious bug in the kernel.
While making zImage (*with quota support enabled*) I get the following:

--- begin make-zImage-log ---
[...]
quota
gcc -D__KERNEL__ -Wall -Wstrict-prototypes -O6 -fomit-frame-pointer -x c++ -m486 -c dquot.c
dquot.c: In function `int  sync_device (struct device_list*, int)':
dquot.c:330: warning: `fs' may be used uninitialized in this function
dquot.c: In function `int  quota_transfer (short unsigned int, short unsigned int, short unsigned int, short unsigned int, short unsigned int, long unsigned int, long unsigned int)':
dquot.c:549: warning: `usr_device' may be used uninitialized in this function
dquot.c:549: warning: `grp_device' may be used uninitialized in this function
gcc -D__KERNEL__ -Wall -Wstrict-prototypes -O6 -fomit-frame-pointer -x c++ -m486 -c sys.c
ld -r -o quota.o dquot.o sys.o
[...]
--- end make-zImage-log ---

When I try to do a make quotacheck in /usr/src/quota I get a:

gcc -I. -O6       -c quotacheck.c -o quotacheck.o
In file included from /usr/include/linux/quota.h:117, from quotacheck.c:36:
/usr/include/linux/fs.h:331: parse error before string constant
/usr/include/linux/fs.h:342: parse error before string constant
make: *** [quotacheck.o] Error 1

However make quotaon works.
I have created a qouta.user with the quotacheck that came with SLS and when I 
tried to do a quotaon /dev/sda2 I got a:

quotaon: using /home/helena/quota.user on /dev/sda2: Function not implemented

when I did the same with the new-compiled quotaon from the source directory,
my machine hang completely up. I got no "kernel panic", just a bunch of 
numbers:

gerneral protection: 4930
EIP:        0010:00167C68
EFLAGS:     00010202
eax: 00186a60  ebx:  00ff0c00  ecx: 00004930   edx: 00186a60
esi: 00000000  ebi:  00000000  ebp: 001a4930
ds: 0018   es: 0018  fs: 002b  gs: 002b
PID: 1, process nr: 1
66 8e e1 bf 18 00 00 00 66 8e

Has anybody any ideas?
Should I use a different quota-package (would be typical for SLS, where almost 
nothing fits together)? If so, where?

Thank You in advance for Your answers, and
sorry for for the flames to SLS 
(not because of their content but they don't fit in this Newsgroup 
  - I'm really upset!)
Joerg Stenger
=======================================================
E-Mail:    stenger@zeus.uni-duisburg.de   [134.91.4.79] 
        or
           hj902st@unidui.uni-duisburg.de  [134.91.4.3]
=======================================================




------------------------------

From: jcburt@gats486.larc.nasa.gov
Crossposted-To: comp.os.linux.help,comp.os.linux.misc
Subject: Re: Linux Slowly Dying Off?
Date: 24 Sep 1993 11:25:06 GMT

In article <sxjcb.8.0011F26F@alaska.edu> sxjcb@alaska.edu (Jay Beavers) writes:

   In article <27t2au$3v1@samba.oit.unc.edu> mdw@sunSITE.unc.edu (Matt Welsh) writes:

   >It's not dying off... not at all. It's simply stabilizing. Things aren't
   >changing as rapidly, which is a sign of maturity. 

   So, like, CP/M is really really mature now?

Yep! kinda like a corpse...'bout as mature as its gonna get...:-)
--
John Burton                      G & A Technical Software, Inc.
jcburt@gatsibm.larc.nasa.gov     28 Research Dr. Hampton, Va. 23666
jcburt@gats486.larc.nasa.gov     (804) 865-7491

------------------------------

Crossposted-To: comp.os.linux.misc
From: iiitac@swan.pyr (Alan Cox)
Subject: Re: Net-2 Patches are GREAT
Date: Fri, 24 Sep 1993 09:50:34 GMT

In article <27stla$87f@iskut.ucs.ubc.ca> jmorriso@rflab.ee.ubc.ca (John Paul Morrison) writes:
>In article <27qj40$cli@bigbird.csd.scarolina.edu>,
>Billy L. Williams Jr. <williams@vierzk.bates.scarolina.edu> wrote:
>:Hello Fellow net-users,
>:
>:I would just like to remark that the net-2 patches found on sunsite under
>:/pub/Linux/system/Network/net2-debugged-tcp.tar.z really work wonders for
>:me.  My system (pl 12, 13 alpha, and 13) really wasn't stable at all under
>:any kind of net load, but the new patches really help my system stay up
>:under normal usage.  Take a look:
>
>OK, what's the secret? I can get pl13 with net-2e4 running, although
>it isnt very stable. I'm about to give up on net-2e, so I downloaded
>the newest pl13 source and followed the net2-debugged instructions. The
>instructions tell you to move your inet directory, then unpack the new
>code. No Makefile or CONFIG is included with net2-debugged, so I
>assume you are supposed to copy the old ones (from inet.old!).

Ok so everyone knows I messed up slightly on the instructions. Keep the old
CONFIG and Makefile. Net2Debugged is really a short term thing. All the
magic goodies from it should percolate into the real NET-2E as it comes along
(I've been emailing things to FvK as I go). Net2Debugged still isn't a 100% 
reliable trip to paradise however. I've got two fixes I've found since the 
release.

>After compiled and booting, the new net2 stuff won't even detect my ethercard.
Sounds like a configuration error. The new net2 doesn't alter the ethernet
detection at all. Please email me if you have any problems. If it is a bug in
net-2debugged I want to track it down, if not then I don't mind helping anyway.
>:
>:[1] % uptime
>:  6:14pm  up 17:47,  2 users,  load average: 0.01, 0.06, 0.02
>:
>:and I've been hitting the net fairly hard trying to crash the machine
>:(it didn't crash 17:47 ago either, just rebooted after applying patches).
>:This would have been unthinkable without these patches--a simple repition
>:of "tcpspray" commands would eventually bring it down (after approx.
>:100 or so such commands in a row).
>:
>:Oh, my hardware: 386-40, 20 meg ram (but with kernel 16 meg limit due to
>:the ethernet card drivers), Boca AT1500 compatible card, nothing else
>:special.
I'm glad to hear a report that it works with an AT1500 type card. That is
one I haven't got access to test it on.
>:
>:Thank you, Swansea University, for making my net stable!
>:
>:By the way, can anybody direct me to the newest telnetd and rlogind?  I
>:realize that I should get them for pl 13, but I have been unable to find
>:any kind of new sources for them....
They are on athos.rutgers.edu in /pub/linux. The've improved things here 
but not 100%. I know Fred van Kempen has improved the NET-2 code in NET-2E
to remove some complicated problems with ACK packets not being sent in
certain cases (causing odd lockups of links) so I deduce these are still
in NET-2D

Alan Cox
(internet) iiitac@pyr.swan.ac.uk // GW4PTS@GB7SWN (packet)

------------------------------

Crossposted-To: comp.os.linux.help,comp.os.linux.misc
From: bsa@kf8nh.wariat.org (Brandon S. Allbery)
Subject: Re: Linux Slowly Dying Off?
Date: Fri, 24 Sep 1993 11:47:51 GMT

In article <sxjcb.8.0011F26F@alaska.edu> sxjcb@alaska.edu (Jay Beavers) writes:
>In article <27t2au$3v1@samba.oit.unc.edu> mdw@sunSITE.unc.edu (Matt Welsh) writes:
>
>>It's not dying off... not at all. It's simply stabilizing. Things aren't
>>changing as rapidly, which is a sign of maturity. 
>
>So, like, CP/M is really really mature now?

In the software publishing industry, "stable" is a euphemism for "outdated".
:-)

++Brandon
-- 
Brandon S. Allbery         kf8nh@kf8nh.ampr.org          bsa@kf8nh.wariat.org
"MSDOS didn't get as bad as it is overnight -- it took over ten years
of careful development."  ---dmeggins@aix1.uottawa.ca

------------------------------

From: jrichert@krefcom.GUN.de (Jan Richert)
Subject: CORRECTED NEW multiple sector transfer for IDE drives
Date: Thu, 23 Sep 1993 17:22:41 GMT
Reply-To: fsommer@fh-krefeld.de

This is another multiple sector transfer patch for hd.c for IDE drives.

THIS IS TO REPLACE THE PATCH I POSTED SOME HOURS AGO (CANCELED) WHICH
HAD TWO TYPOS!

--- hd.c        Wed Jul 28 02:19:32 1993
+++ hd2290.c    Tue Sep 21 17:41:40 1993
@@ -4,6 +4,23 @@
  *  Copyright (C) 1991, 1992  Linus Torvalds
  */
 
+
+/* Multiple Sector Transfer and 32 Bit IO by Frank Sommer      
+                                               fsommer@krefcom.gun.de
+                                               fsommer@fh-krefeld.de
+This Driver supports 32-Bit IO for faster data transfer.
+But I know only about 1 controller who supports this:  DTC2290 EISA-IDE.  
+Maybe VL IDE cards works with 32 bit io, too. To enable this feature add
+-DCONFIG_BLK_DEV_HD_DTC2290 to your Makefile.
+If you don't want multi sector io, but your drive supports it, you should
+add -DCONFIG_BLK_DEV_HD_NOMULTI to your Makefile to override drive information.
+There is no support for the 2nd ide port of the DTC2290, because i don't know
+how to handle the second int in one device driver....
+Currently there is sometimes a problem when the kernel wants to read the
+ partition  table and the drive does not support multiple sector io:
+a timeout errors may occure. I think this is not  dangerous !
+*/
+
 /*
  * This is the low-level hd interrupt support. It traverses the
  * request-list, using interrupts to jump between functions. As
@@ -53,6 +70,24 @@
 #define RECAL_FREQ      4      /* Recalibrate every 4th retry */
 #define MAX_HD         2
 
+#define WIN_MULTIPLE_READ      0xc4
+#define WIN_MULTIPLE_WRITE     0xc5
+#define WIN_SET_MULTIPLE       0xc6
+#define WIN_IDENTIFY_DRIVE     0xec
+
+static struct {
+       int     secspint;
+       char    name[80];
+       int     dwordio;
+       int     readcmd;
+       int     writecmd;
+} new_hd_info[2] = {{0,"\0",0,WIN_READ,WIN_WRITE},{0,"\0",0,WIN_READ,WIN_WRITE}};
+
+static volatile int new_hd_intack = 1;
+
+
+
+static int exec_multiple_write;
 static void recal_intr(void);
 static void bad_rw_intr(void);
 
@@ -86,11 +121,22 @@
 static int hd_sizes[MAX_HD<<6] = {0, };
 static int hd_blocksizes[MAX_HD<<6] = {0, };
 
+#ifdef CONFIG_BLK_DEV_HD_DTC2290
+/* 32 Bit-IO on data transfer */
+
 #define port_read(port,buf,nr) \
+__asm__("cld;rep;insl": :"d" (port),"D" (buf),"c" (nr>>1):"cx","di")
+
+#define port_write(port,buf,nr) \
+__asm__("cld;rep;outsl": :"d" (port),"S" (buf),"c" (nr>>1):"cx","si")
+#else
+
+#define port_read(port,buf,nr) \
 __asm__("cld;rep;insw": :"d" (port),"D" (buf),"c" (nr):"cx","di")
 
 #define port_write(port,buf,nr) \
 __asm__("cld;rep;outsw": :"d" (port),"S" (buf),"c" (nr):"cx","si")
+#endif
 
 #if (HD_DELAY > 0)
 unsigned long read_timer(void)
@@ -228,6 +274,7 @@
        printk("HD controller times out, status = 0x%02x\n",c);
        return 1;
 }
+static void init_multiplesector_transfer(int);
 
 static void reset_controller(void)
 {
@@ -241,6 +288,8 @@
                printk("HD-controller still busy\n");
        if ((hd_error = inb(HD_ERROR)) != 1)
                printk("HD-controller reset failed: %02x\n",hd_error);
+       for (i=0;i<2;i++)
+               init_multiplesector_transfer(i);
 }
 
 static void reset_hd(void)
@@ -275,7 +324,9 @@
 void unexpected_hd_interrupt(void)
 {
        sti();
-       printk("Unexpected HD interrupt\n");
+       if (!new_hd_intack)
+               printk("Unexpected HD interrupt\n");
+       new_hd_intack = 0;
        SET_TIMER;
 }
 
@@ -315,10 +366,18 @@
 #define STAT_OK (READY_STAT | SEEK_STAT)
 
 static void read_intr(void)
+/* Supports multiple block io; i think multi io is not selected, the driver
+must be compatible to the original read_intr. Tell me if not (and why ?).
+Frank Sommer (fsommer@fh-krefeld.de)                           */
+
 {
        int i;
        int retries = 100000;
 
+register int multiple_sectrs = 0;
+register int max_multi_secs;
+
+       max_multi_secs = new_hd_info[MINOR(CURRENT->dev)>>6].secspint;
        do {
                i = (unsigned) inb_p(HD_STATUS);
                if (i & BUSY_STAT)
@@ -345,6 +404,7 @@
        CURRENT->sector++;
        i = --CURRENT->nr_sectors;
        --CURRENT->current_nr_sectors;
+       multiple_sectrs++;
 #ifdef DEBUG
        printk("hd%d : sector = %d, %d remaining to buffer = %08x\n",
                MINOR(CURRENT->dev), CURRENT->sector, i, CURRENT-> 
@@ -352,7 +412,11 @@
 #endif
        if (!i || (CURRENT->bh && !SUBSECTOR(i)))
                end_request(1);
-       if (i > 0) {
+       if (i > 0)
+               if (multiple_sectrs < max_multi_secs) {
+                       goto ok_to_read;
+                       }
+               else {
                SET_INTR(&read_intr);
                sti();
                return;
@@ -365,11 +429,21 @@
        return;
 }
 
+static void dummy_write_intr(void);
+
 static void write_intr(void)
 {
        int i;
        int retries = 100000;
 
+register       int multiple_sectrs = 0;
+register       int max_multi_secs ;
+       
+       if (exec_multiple_write){
+               multiple_sectrs++;
+               exec_multiple_write--;
+       }
+       max_multi_secs = new_hd_info[MINOR(CURRENT->dev)>>6].secspint;
        do {
                i = (unsigned) inb_p(HD_STATUS);
                if (i & BUSY_STAT)
@@ -394,18 +468,54 @@
        i = --CURRENT->nr_sectors;
        --CURRENT->current_nr_sectors;
        CURRENT->buffer += 512;
-       if (!i || (CURRENT->bh && !SUBSECTOR(i)))
+       multiple_sectrs++;
+       if (CURRENT->bh && !SUBSECTOR(i))
                end_request(1);
-       if (i > 0) {
-               SET_INTR(&write_intr);
+       if (i > 1) { 
+               if (multiple_sectrs < max_multi_secs) { 
+                       port_write(HD_DATA,CURRENT->buffer,256);
+                       goto ok_to_write;
+               } else  {
+                       SET_INTR(&write_intr);
+                       port_write(HD_DATA,CURRENT->buffer,256);
+                       sti();
+                       return;
+               }
+       }       
+       
+       else { if (i) { /* only possible if multiple io */
+               SET_INTR(&dummy_write_intr);
                port_write(HD_DATA,CURRENT->buffer,256);
                sti();
-       } else {
+               return;
+              } else { 
+                  if (!(CURRENT->bh && !SUBSECTOR(i))) 
+                     end_request(1);
+                  cli(); 
+                  do_hd_request();
+               }
+       }
+       
+       
 #if (HD_DELAY > 0)
                last_req = read_timer();
 #endif
-               do_hd_request();
-       }
+               return;
+}
+
+static void dummy_write_intr(void)
+{
+       int i;
+       CURRENT->sector++;
+       i = --CURRENT->nr_sectors;
+       --CURRENT->current_nr_sectors;
+       CURRENT->buffer += 512;
+       end_request(1);
+       cli();
+       do_hd_request();
+#if (HD_DELAY > 0)
+               last_req = read_timer();
+#endif
        return;
 }
 
@@ -439,6 +549,11 @@
        do_hd_request();
 }
 
+
+
+
+
+
 /*
  * The driver has been modified to enable interrupts a bit more: in order to
  * do this we first (a) disable the timeout-interrupt and (b) clear the
@@ -500,7 +615,7 @@
                return;
        }       
        if (CURRENT->cmd == WRITE) {
-               hd_out(dev,nsect,sec,head,cyl,WIN_WRITE,&write_intr);
+               hd_out(dev,nsect,sec,head,cyl,new_hd_info[dev].writecmd,&write_intr);
                if (reset)
                        goto repeat;
                if (wait_DRQ()) {
@@ -509,11 +624,16 @@
                        goto repeat;
                }
                port_write(HD_DATA,CURRENT->buffer,256);
-               sti();
+               exec_multiple_write =1;
+/* I think this is compatible to the original do_hd_request */
+               if (new_hd_info[dev].secspint>1) 
+                       write_intr();   /* multi sector io */
+               else 
+                       sti();
                return;
        }
        if (CURRENT->cmd == READ) {
-               hd_out(dev,nsect,sec,head,cyl,WIN_READ,&read_intr);
+               hd_out(dev,nsect,sec,head,cyl,new_hd_info[dev].readcmd,&read_intr);
                if (reset)
                        goto repeat;
                sti();
@@ -624,6 +744,62 @@
        sti();
 }
 
+static void init_multiplesector_transfer(int drive)
+
+{
+       if (new_hd_info[drive].secspint>1) {
+/* if secspint is < 2 multi sector io is not possible */
+               sti();
+               new_hd_intack = 1;
+               SET_INTR(unexpected_hd_interrupt);
+               outb(new_hd_info[drive].secspint,0x1f2);
+               outb(0xA0|(drive<<4),0x1f6);
+               outb(WIN_SET_MULTIPLE,0x1f7);
+               new_hd_info[drive].writecmd = WIN_MULTIPLE_WRITE;
+               new_hd_info[drive].readcmd = WIN_MULTIPLE_READ;
+       } else {
+/* no multi sector io */
+               new_hd_info[drive].writecmd = WIN_WRITE;
+               new_hd_info[drive].readcmd = WIN_READ;  
+       }
+}      
+
+
+static void get_drive_info(void)
+{
+static unsigned char   infobuffer[512];
+       unsigned int    i;
+       for(i=0;i<2;i++) { 
+                       new_hd_intack = 1;
+                       sti();
+                       SET_INTR(unexpected_hd_interrupt);
+                       outb(0xA0|(i<<4),0x1f6);
+                       outb(WIN_IDENTIFY_DRIVE,0x1f7);
+                       if (wait_DRQ()==0) {
+                               cli();
+                               port_read(HD_DATA,&infobuffer,256);
+                               sti();
+                               int x;
+                               for (x=0;x<40;x+=2) {
+                                       new_hd_info[i].name[x] = infobuffer[55+x];
+                                       new_hd_info[i].name[x+1] = infobuffer[54+x];
+                               }
+                               new_hd_info[i].name[42] = '\0';
+                               new_hd_info[i].secspint = infobuffer[94]; 
+
+#ifdef CONFIG_BLK_DEV_HD_NOMULTI
+new_hd_info[i].secspint = 0;
+#endif
+
+                               new_hd_info[i].dwordio =  infobuffer[96];
+                       } else {
+                               new_hd_info[i].secspint = 0;
+                       }
+       }
+
+
+}
+
 /*
  * This is the harddisk IRQ description. The SA_INTERRUPT in sa_flags
  * means we run the IRQ-handler with interrupts disabled: this is bad for
@@ -736,11 +912,18 @@
                printk("Unable to get major %d for harddisk\n",MAJOR_NR);
                return mem_start;
        }
+       int i;
+       get_drive_info();
+       reset_controller(); 
        blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
        read_ahead[MAJOR_NR] = 8;               /* 8 sector (4kB) read-ahead */
        hd_gendisk.next = gendisk_head;
        gendisk_head = &hd_gendisk;
        timer_table[HD_TIMER].fn = hd_times_out;
+       printk("Device:  Description:                             MEM   INT DMA  IO          \n");
+       for (i=0;i<2;i++)
+/* TODO: try to print only the hd-info of the first drive, if only one hd is installed */ 
+               printk("hd%-6d %-40s ---    %2d  --  %3x SPI: %1d\n",i,new_hd_info[i].name,HD_IRQ,HD_DATA,new_hd_info[i].secspint);
        return mem_start;
 }
 


-- 
Jan Richert (NIC-ID: JR482)   | Internet:   jrichert@krefcom.GUN.de
Krefeld, FRG                  | Datex-J:    02151399843-0001
Voice: +49 2151 313124        | IRC-Nick:   jrichert
FAX:   +49 2151 396479        | Data:       +49 2151 396479 (12-20h MEDT)

------------------------------


** FOR YOUR REFERENCE **

The service address, to which questions about the list itself and requests
to be added to or deleted from it should be directed, is:

    Internet: Linux-Development-Request@NEWS-DIGESTS.MIT.EDU

You can send mail to the entire list (and comp.os.linux.development) via:

    Internet: Linux-Development@NEWS-DIGESTS.MIT.EDU

Linux may be obtained via one of these FTP sites:
    nic.funet.fi				pub/OS/Linux
    tsx-11.mit.edu				pub/linux
    sunsite.unc.edu				pub/Linux

End of Linux-Development Digest
******************************

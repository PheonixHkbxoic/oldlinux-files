# MAN1
	MAN1 (1)

Section 1 of the Manual describes user commands.

The sections of the manual are:
	
  -->Section 1: User commands
     Section 2: System calls
     Section 3: C library
     Section 4: File formats
     Section 5: Miscellaneous
     Section 6: Games
     Section 7: Special files (devices)
     Section 8: Maintenance procedures

# ar
	 ar (1)
COMMAND		 ar - archiver
SYNTAX		 ar [dmpqrtx][abciluv] [posname] archive file ...
FLAGS		 (none)
EXAMPLES	 ar r libc.a sort.s Replace sort.s in libc.a
        	 ar rb a.s libc.a b.s Insert b.s before a.s in libc.a

Ar allows groups of files to be put together into a single archive. It
is normally used for libraries of compiled procedures.  The following
keys are allowed:
	d:	Delete. Ar will delete the named members.
	m:	Move named files. Ar expects a, b, or i to be specified.
	p:	Print the named files (list them on stdout)
	q:	Quickly append to the end of the archive file.
	r:	Replace (append when not in archive).
	t:	Print the archive's table of contents.
	x:	Extract
The keys may optionally concatencated with one or more of the following:
	a:	After posname
	b:	Before posname
	c:	Create  (suppresses creation message)
	i:	Before posname
	l:	Local temporary file for work instead of /tmp/ar.$$$$$
	u:	Replace only if dated later than member in archive
	v:	Verbose

(ast)

# ascii
	 ascii (1)
COMMAND		 ascii - strip all the pure ASCII lines from a file
SYNTAX		 ascii [-n] [file]
FLAGS		 -n Extract the lines containing non-ASCII characters
EXAMPLES	 ascii file >outf Write all the ASCII lines on outf
        	 ascii -n <file >outf Write all the non-ASCII lines on outf

Sometimes a file contains some non-ASCII characters that are in the way.
This program allows the lines containing only ASCII characters to be 
grepped from the file.   With the -n flag, the non-ASCII lines are 
grepped.   No matter whether the flag is used or not, the program
returns an exit status of true if the file is pure ASCII, and false
otherwise.

(ast)

# asld
	 asld (1)
COMMAND		 asld - assembler-loader [IBM]
SYNTAX		 asld [-Lis] [-T dir] [-o name] file ...
FLAGS		 -L A listing is produced on stdout
     		 -T Used to specify a directory for the temporary file
     		 -i Use separate I & D space (64K + 64K)
     		 -o Output goes to file named by next argument
     		 -s A symbol table is produced on stdout
EXAMPLES	 asld -s file.s Assemble file.s and  list symbols
        	 asld -o output file.s Assemble file.s, put binary on output
        	 asld -T. file1.s file2.s Use current directory for temporary 
		      file

	 Asld is the MINIX assembler and loader combined. It accepts a
language similar to that accepted by the PC-IX assembler (see Chap. 9).
Symbols are made up of letters, digits and underscores. The machine
instructions and addressing modes are the same as those used by PC-IX,
except that modes using multiple registers are written like this
example: 
	 mov ax,(bx_si). 
Constant operands are denoted by a sharp sign. Local labels are
permitted in the usual  UNIX style: the instruction 
	 jmp 1f
jumps forward to the closest label 
	 1:

The pseudoinstructions accepted by the assembler are listed below:
	.align n	Align to a multiple of n bytes
	.ascii str	Assemble a string
	.asciz str	Assemble a zero-terminated string
	.bss		What follows goes in the bss segment
	.byte n		Assemble one or more bytes
	.data		What follows goes in the data segment
	.define sym	Export sym from the file
	.errnz n	Force error if n is nonzero
	.even		Align to an even address
	.extern sym	Declare sym external
	.globl sym	Same as extern
	.long n		Assemble n as a long
	.org adr	Set address within current segment
	.short n	Assemble n as a short
	.space n	Skip n bytes
	.text		What follows goes in the text segment
	.word n		Assemble n as a word
	.zerow n	Assemble n words of zeros

In the above pseudoinstructions, adr is an expression yielding a
machine address, n is a numeric expression, str is a quoted string, and
sym is a symbol.

The library /usr/lib/libc.a is a packed archive of assembly code.  To
see some examples of it, extract some files from the archive with ar
and then use the filter libupack to convert them to readable ASCII.

IBM PC MINIX does not use .o files.  Compiler output is packed assembly
language, as are the modules in an archive.  This scheme requires
reassembling archive modules all the time, but it saves space.  The
68000 versions use .o files.  See also Chap. 9.

(ast)

# ast
	 ast (1)
COMMAND		 ast - add symbol table to executable file [IBM]
SYNTAX		 ast [-Xx] [file] [symbol_file]
FLAGS		 -X Preserve local symbols (except compiler generated ones)
     		 -x Do not preserve local symbols
EXAMPLES	 ast -X a.out Add symbols from symbol.out to a.out

Ast adds the symbol table produced by the -s  option of asld to the
executable file.   If no symbol table file is listed, the default name
symbol.out is used.   The symbol table can also be directly added to an
executed file by the commands cc -s prog.c.

(ast)

# at
	 at (1)
COMMAND		 at - execute commands at a later time
SYNTAX		 at time [month day] [file]
FLAGS		 (none)
EXAMPLES	 at 2315 Jan 31 myfile Myfile executed Jan 31 at 11:15 pm
        	 at 0900 Job input read from stdin
        	 at 0711 4 29  Read from stdin, exec on April 29

At prepares a file to be executed later at the specified time by 
creating a special entry in /usr/spool/at.   The program atrun should
be started  periodically, for example, every minute by cron.  Atrun 
checks to see if any files in /usr/spool/at should now be run, and if
so, it runs them  and then puts them in /usr/spool/at/past. The name of
the file created in /usr/spool/at by  at is YY.DDD.HHMM.UU (where YY,
DDD, HH, and MM give the time to execute
 and 
UU is a unique number).  Note that when the command runs, it will not
be able  to use stdin or stdout unless specifically redirected.  In 
the first example above, it might be necessary to put >/dev/tty0 on
some lines in the shell script myfile.   The same holds for the
commands typed directly to at.

(ast)

# backup
	 backup (1)
COMMAND		 backup - backup files
SYNTAX		 backup [-djmnorstvz] dir1 dir2
FLAGS		 -d At top level, only directories are backed up
     		 -j Do not copy junk:  *.Z, *.bak, a.out, core, etc
     		 -m If device full, prompt for new diskette
     		 -n Do not backup top-level directories
     		 -o Do not copy *.o files
     		 -r Restore files
     		 -s Do not copy *.s files
     		 -t Preserve creation times
     		 -v Verbose; list files being backed up
     		 -z Compress the files on the backup medium
EXAMPLES	 backup -mz . /f0 Backup current directory compressed
        	 backup /bin /usr/bin Backup bin from RAM disk to hard disk

Backup (recursively) backs up the contents of a given directory and its
subdirectories to another part of the file system. It has two typical
uses. First, some portion of the file system can be backed up onto 1 or
more diskettes. When a diskette fills up, the user is prompted for a
new one. The backups are in the form of mountable file systems. Second,
a directory on RAM disk can be backed up onto hard disk. If the target
directory is empty, the entire source directory is copied there,
optionally compressed to save space. If the target directory is an old
backup, only those files in the target directory that are older than
similar names in the source directory are replaced. Backup uses times
for this purpose, like make. Calling Backup as Restore is equivalent to
using the -r option;  this replaces newer files in the target directory
with older files from the source directory, uncompressing them if
necessary.  The target directory contents are thus returned to some
previous state. 

(ast)

# badblocks
	 badblocks (1)
COMMAND		 badblocks - put a list of bad blocks in a file
SYNTAX		 badblocks block_special [block] ...
FLAGS		 (none)
EXAMPLES	 badblocks /dev/hd1 Handle bad blocks on /dev/hd1
        	 badblocks /dev/hd3 310 570 1680  Three bad blocks on /dev/hd3

If a device contains bad sectors, it is important to not have them
allocated to important files.  This program makes it possible to
collect up to 7 bad blocks into a dummy file, so they will not be
allocated for a  real file.   When the program starts up, it asks for a
list of bad blocks, unless they are provided as arguments. Then it
creates a file whose name is of the form .Bad_xxxxx, where xxxxx is a
pid.

(ast)

# basename
	 basename (1)
COMMAND		 basename - strip off file prefixes and suffixes
SYNTAX		 basename file [suffix]
FLAGS		 (none)
EXAMPLES	 basename /user/ast/file.c Strips path to yield file.c
        	 basename /user/file.c .c Strips path and .c to yield file

The initial directory names (if any) are removed yielding the name of
the file itself. If a second argument is present, it is interpreted as
a suffix and is also stripped, if present. This program is primarily
used in shell scripts.

(ast)

# bawk
	 bawk (1)
COMMAND		 bawk - pattern matching language
SYNTAX		 bawk rules [file] ...
FLAGS		 (none)
EXAMPLES	 bawk rules input Process input according to rules
        	 bawk rules -  >out Input from terminal, output to out

Awk is a pattern matching language. Bawk is Basic Awk, a subset of the
original. The file name - can be used to designate stdin. The manual is
given in Chap. 9.

(ast)

# btoa
	 btoa (1)
COMMAND		 btoa - binary to ascii conversion
SYNTAX		 btoa [-adhor] [infile] [outfile]
FLAGS		 -a Decode, rather than encode, the file
     		 -d Extracts repair file from diagnosis file
     		 -h Help menu is displayed giving the options
     		 -o The obsolete algorithm is used for backward compatibility
     		 -r Repair a damaged file
EXAMPLES	 btoa <a.out >a.btoa Convert a.out to ASCII
        	 btoa -a <a.btoa >a.out Reverse the above

Btoa is a filter that converts a binary file to ascii for transmission
over a telephone line.  If two file names are provided, the first in
used for input and the second for output.  If only one is provided, it
is used as the input file.  The program is a functionally similar
alternative  to uue/uud, but the encoding is completely different.
Since both of these are widely used, both have been provided with 
MINIX . The file is expanded about 25 percent in the process.

(ast)

# cal
	 cal (1)
COMMAND		 cal - print a calendar
SYNTAX		 cal [month] year
FLAGS		 (none)
EXAMPLES	 cal 3 1992 Print March 1992

Cal prints a calendar for a month or year.  The year can be  between 1
and 9999.   Note that the year 91 is not a synonym for 1991, but is
itself a valid year about 19 centuries ago.  The calendar produced is
the one used by England and her colonies.  Try Sept. 1752, Feb 1900,
and Feb 2000.  If you do not understand what is going on, look up
Calendar, Gregorian in a good encyclopedia.

(ast)

# calendar
	 calendar (1)
COMMAND		 calendar - reminder service
SYNTAX		 calendar [-] [-r]
FLAGS		 - Work for every user and send mail to him
     		 -r Restrict multiple execution on the same day
EXAMPLES	 calendar Check calendar file in current directory
        	 calendar Normary used under the control of cron(8)
        	 calendar -r  Normary used in /etc/rc file

Basically the calendar program consults the file calendar in the 
current directory and display lines which contain today's or tomorrow's
date. Month-day formats such as '12/25', 'Dec. 25',  'december 25',
'*/25', '12/*', '*/*' are recognized.  The asterisk means 'all' days or
'all' months.  On weekends 'tomorrow' extends through  next Monday
without any consideration about holidays. To prevent ambiguity, the
formats '25 Dec.' and '25/12' are not recognized.

When an argument - is present, calendar works for all users with a file
calendar in their login directories and sends them mail. Normally this
is done daily under the control of cron.

The -r option does its the same job as - option, but touches the
calendar to prevents further access on the same day. Normally this is
done in the /etc/rc file on a machine  which may be booted several
times in one day. 

(ast)

# cat
	 cat (1)
COMMAND		 cat - concatenate files and write them to stdout
SYNTAX		 cat [-u] [file] ...
FLAGS		 -u Unbuffered output
EXAMPLES	 cat file Display file on the terminal
        	 cat file1 file2 | lpr Concatenate 2 files and print result

	 Cat concatenates its input files and copies the result to
stdout. If no input file is named, or - is encountered as a file name,
standard input is used. Output is buffered in 512 byte blocks unless
the  flag is given. If you just want to copy a file, cp should be used
since it is faster.

(ast)

# cc
	 cc (1)
COMMAND		 cc - C compiler
SYNTAX		 cc [-FLRSTUciosvw] [-Dname] ... [-Idir] ... [-LIB] file ...
FLAGS		 -D The flag -Dx=y defines a macro x with (optional) value y
     		 -F Use a file instead of a pipe for preprocessor output [IBM]
     		 -I -Idir searches dir for include files
     		 -L List the assembly code on stdout [IBM]
     		 -LIB~Produce a library module [IBM] 
     		 -R Complain about all non Kernighan & Ritchie code
     		 -S Produce an assembly code file, then stop
     		 -T The flag -Tdir tells cem to use dir for temporary files
     		 -U Undefine a macro
     		 -c Compile only. Do not link.
     		 -i Use separate I & D space (64K + 64K) [IBM]
     		 -o Put output on file named by next arg
     		 -s For IBM, add symbol table; for 68000 strip symbol table
     		 -v Verbose; print pass names
     		 -w Suppress warning messages
EXAMPLES	 cc -c file.c Compile file.c
        	 cc -D_MINIX file.c Treat the symbol _MINIX as defined
        	 cc -c -LIB file.c Make a module for the library

This is the C compiler. It has multiple passes. The names of the
programs executed for each pass, their inputs and their outputs are
given in the table below.

   Program	Input	Output	Operation performed
   /lib/cpp	prog.c	prog.i	C preprocessor [IBM]
   /lib/cem	prog.i	prog.k	Parsing and semantic analysis
   /usr/lib/opt	prog.k	prog.m	Optimization of the intermediate code
   /usr/lib/cg	prog.m	prog.s	Code generation
   /usr/bin/asld	prog.s	a.out	Assembly and linking [IBM]
   /usr/bin/as	prog.s	prog.o	Assembly [68000]
   /usr/lib/ld	prog.o	.out	Linking [68000]
   /usr/lib/cv	.out	a.out	Conversion to MINIX\s0 format [68000]

The main program, cc , forks appropriately to call the passes,
transmitting flags and arguments. The -v flag causes the passes to be
listed as they are called.

The IBM C compiler uses a combined assembler-linker that takes in
assembly code files in packed format and produces an a.out file. The
68000 C compiler uses normal .o files. Assembly language files on the
IBM can be packed and unpacked using the filters libpack and libupack.
The IBM libraries are  archives of packed assembly code files, except
that defined symbols must be declared by .define statements at the
beginning. To make modules for inclusion in the library, use the -c and
-LIB options. If you compile library modules by accident without using
the -LIB flag, they will not be recognized, leading to undefined
reference error messages from the linker.

If memory is tight, use the -F flag to force the compiler to run the
passes one at a time, without pipes.  When available memory is very
limited, it may be necessary to run chmem to reduce the sizes of some
compiler passes.  On the other hand, if the compiler (or, in fact,
almost any program) begins acting strange, it is almost always due to
its running out of stack or disk space.  The relevant pass can be given
more stack space using chmem .  For large programs, it make take a
little experimenting to get the sizes right.  The cem is usually the
guilty party.  Be careful about /tmp filling up too.  More space for
scratch files can be obtained by removing other files of using -T.

The compiler is derived from the ACK system (Tanenbaum et  al.,
Communications of the ACM, Sept. 1983), not from the AT&T portable C
compiler. The sources are available from the companies listed after the
Table of Contents.

(ast)

# cdiff
	 cdiff (1)
COMMAND		 cdiff - context diff
SYNTAX		 cdiff [-cn] oldfile newfile
FLAGS		 -c Provide n lines of context
EXAMPLES	 cdiff old new >f Write context diff on f
        	 cdiff -c1 old new >f Use only 1 line of context

Cdiff produces a context diff by first running diff and then  adding
context.   Some update programs, like patch, can use context diffs to
update files, even in the presence of other, independent changes.

(ast)

# cgrep
	 cgrep (1)
COMMAND		 cgrep - grep and display context
SYNTAX		 cgrep [-a n] [-b n] [-f] [-l n]  [-n] [-w n] pattern [file] ...
FLAGS		 -a How many lines to display after the matching line
     		 -b How many lines to display before the matching line
     		 -f Suppress file name in the output
     		 -l Lines are truncated to this length before comparison
     		 -n Suppress line numbers in the output
     		 -w Sets window size (same as -a n -b n)
EXAMPLES	 cgrep -w 3 hello file1 Print 3 lines of context each way

Cgrep is a program like grep, except that it also can print a few lines
above and/or below the matching lines. It also prints the line numbers
of the output.

(ast)

# chgrp
	############ NEXT ENTRY HAS NOT BEEN CHECKED #############
	 chgrp (1)
COMMAND		 chgrp - change group
SYNTAX		 chgrp [-R] [user.]group file ...
FLAGS		 -R Change directory hierarchies
EXAMPLES	 chgrp system file1 file2 Make system the group of the files
        	 chrgp -R other dir1 Make other\R the group of all files below
                          dir1

The group field (and optionally user field) of the named files is
changed to group and user .  Alternatively, a decimal gid (uid) may be
specified instead of a group name.  If the -R flag is used, the changes
will be applied recursively to all files in named directories.  Only
the superuser may execute this command.

(ast)

# chmem
	 chmem (1)
COMMAND		 chmem - change memory allocation
SYNTAX		 chmem [+] [-] [=] amount file
FLAGS		 (none)
EXAMPLES	 chmem =50000 a.out Give a.out 50K of stack space
        	 chmem -4000 a.out Reduce the stack space by 4000 bytes
        	 chmem +1000 file1 Increase each stack by 1000 bytes

When a program is loaded into memory, it is allocated enough memory for
the text and data+bss segments, plus an area for the stack.  Data
segment growth using malloc, brk, or sbrk eats up stack space from the
low end.  The amount of stack space to allocate is derived from a field
in the executable program's file header.  If the combined stack and
data segment growth exceeds the stack space allocated, the program will
be terminated.

It is therefore important to set the amount of stack space carefully.
If too little is provided, the program may crash.  If too much is
provided, memory will be wasted, and fewer programs will be able to fit
in memory and run simultaneously.  MINIX does not swap, so that when
memory is full, subsequent attempts to fork will fail.  The compiler
sets the stack space to the largest possible value (for the Intel CPUs,
64K - text - data).  For many programs, this value is far too large.
Nonrecursive programs that do not call brk, sbrk, or malloc, and do not
have any local arrays usually do not need more than 8K of stack space.

The chmem command changes the value of the header field that determines
the stack allocation, and thus indirectly the total memory required to
run the program.  The = option sets the stack size to a specific value;
the + and - options increment and decrement the current value by the
indicated amount.  The old and new stack sizes are printed.

(ast)

# chmod
	############ NEXT ENTRY HAS NOT BEEN CHECKED #############
	 chmod (1)
COMMAND		 chmod - change access mode for files
SYNTAX		 chmod [-R] mode file ...
FLAGS		 -R Change hierarchies recursively
EXAMPLES	 chmod 755 file Owner: rwx Group: r-x Others: r-x
        	 chmod +x file1 file2 Make file1 and file2 executable
        	 chmod a-w file Make file read only
        	 chmod u+s file Turn on SETUID for file
        	 chmod -R o+w dir Allow writing for all files in dir

The given mode is applied to each file in the file list. If the -R flag
is present, the files in a directory will be changed as well. The mode
can be either absolute or symbolic. Absolute modes are given as an
octal number that represents the new file mode. The mode bits are
defined as follows: 
	4000    Set effective user id on execution to file's owner id
	2000    Set effective group id on execution to file's group id
	0400    file is readable by the owner of the file
	0200    writeable by owner
	0100    executable by owner
	0070    same as above, for other users in the same group
	0007    same as above, for all other users

Symbolic modes modify the current file mode in a specified way. The form is:
	[who] op permissions { op permissions ...} {, [who] op ... }
The possibilities for who are u, g, o, and a, standing for user, group,
other and all, respectively.   If who is omitted, a is assumed, but the
current umask is used.   The op can be +, -, or =;  + turns on the 
given permissions, - turns them off; = sets the permissions 
exclusively for the given who.   For example g=x sets the group
permissions to --x. 

The possible permissions are r, w, x; which stand for read,  write, and
execute;  s turns on the set effective user/group id bits.   s only
makes sense with u and g; o+s is  harmless.

(ast)

# chown
	############ NEXT ENTRY HAS NOT BEEN CHECKED #############
	 chown (1)
COMMAND		 chown - change owner
SYNTAX		 chown [-R] user[.group] file ...
FLAGS		 -R Change directory hierarchies
EXAMPLES	 chown ast file1 file2 Make ast the owner of the files
        	 chown -R ast.other dir Change the owner and group of all 
                          files in dir

The owner field (and optionally group field) of the named files is
changed to user (i.e., login name specified) and group.  Alternatively,
a decimal uid(gid) may be specified instead of a user name.  Only the
superuser may execute this command.

(ast)

# cksum
	############ NEXT ENTRY HAS NOT BEEN CHECKED #############
	 cksum (1)
COMMAND		 cksum - display file checksum and size
SYNTAX		 cksum [file ...]
FLAGS		 (none)
EXAMPLES	 cksum Display CRC and size of stdin
        	 cksum *.c Display CRC and size of .c files

	 Cksum calculates and writes to standard output the 32-bits CRC
of the input files , or of stdin if no files were specified. The size
in bytes of each file will be displayed after a space. The name of each
file will be displayed after another space.

(ast)

# clr
	 clr (1)
COMMAND		 clr - clear the screen
SYNTAX		 clr
FLAGS		 (none)
EXAMPLES	 clr	 Clear the screen

All text is removed from the screen, resulting in an empty screen with the
cursor positioned in the upper left-hand corner.

(ast)

# cmp
	 cmp (1)
COMMAND		 cmp - compare two files
SYNTAX		 cmp [-ls] file1 file2
FLAGS 		 -l Loud mode. Print bytes that differ (in octal)
     		 -s Silent mode.  Print nothing, just return exit status
EXAMPLES	 cmp file1 file2 Tell whether the files are the same
        	 cmp -l file1 file2 Print all corresponding bytes that differ

Two files are compared. If they are identical, exit status 0 is
returned. If they differ, exit status 1 is returned. If the files
cannot be opened, exit status 2 is returned. If file1 is - , stdin is
compared to  file2 .

(ast)

# comm
	 comm (1)
COMMAND		 comm - print lines common to two sorted files
SYNTAX		 comm [-123] file1 file2
FLAGS		 -1 Suppress column 1 (lines present only in file1) 
     		 -2 Suppress column 2 (lines present only in file2) 
     		 -3 Suppress column 3 (lines present in both files)
EXAMPLES	 comm file1 file2 Print all three columns
        	 comm -12 file1 file2 Print only lines common to both files

Two sorted files are read and compared. A three column listing is
produced. Files only in  file1 are in column 1; files only in file2 are
in column 2; files common to both files are in column 3. The file name
- means stdin. 

(ast)

# compress
	 compress (1)
COMMAND		 compress - compress a file using modified Lempel-Ziv coding
SYNTAX		 compress [-cdfv] [file] ...
FLAGS		 -c Put output on stdout instead of on file.Z
     		 -d Decompress instead of compress
     		 -f Force output even if there is no saving
     		 -v Verbose mode
EXAMPLES	 compress <infile >outfile Compress 1 file
        	 compress x y z Compress 3 files to x.Z, y.Z, and z.Z

        	 compress -d file.Z Decompress file.Z to file

The listed files (or stdin, if none are given) are compressed using the
Ziv-Lempel algorithm.  If the output is smaller than the input, the
output is put on file.Z or stdout if no files are listed.   If compress
is linked to uncompress, the latter is the same  as giving the -d flag.
Similarly, a link to zcat decompresses to stdout. The MINIX version of
compress uses 13-bit compression. This means that when compressing
files on other systems for transmission to MINIX , be sure that only
13-bit compression is used. On many systems, the default is 16-bit (too
big).

(ast)

# cp
	############ NEXT ENTRY HAS NOT BEEN CHECKED #############
	 cp (1)
COMMAND		 cp - file copy
SYNTAX		 cp [-Rfiprv] file1 file2
		 cp [-fRiprv] file ... directory
FLAGS		 -f Forced remove existing file
     		 -i Ask before removing existing file
     		 -p Preserver full mode, uid, gid and times
     		 -r Copy directories and treat special files as ordinary
     		 -v Display what cp is doing
     		 -R Copy directories
EXAMPLES	 cp oldfile newfile Copy oldfile to newfile
        	 cp -R special newspecial Copy the special file

	 Cp copies one file to another, or copies one or more files to
a directory. Unless the -r flag is specified, special files will be
copied as special files. Copying a directory requires either the -r or
the -R flags.

(ast)

# cpdir
	 cpdir (1)
COMMAND		 cpdir - copy a directory and its subdirectories
SYNTAX		 cpdir [-msv] srcdir dstdir
FLAGS		 -m merge into existing directory
		 -s save attributes (owner, mode, time)
     		 -v verbose
EXAMPLES	 cpdir dir1 dir2 create dir2 and copy dir1's files in it

	Cpdir copies directories recursively. By default (without -m 
flag) it creates a new directory within the specified dstdir. It will copy
device files and recreate links, unlike backup, which does neither.

(ast, rev. by asw 14.02.95)

# crc
	 crc (1)
COMMAND		 crc - print the checksum of the file data
SYNTAX		 crc file ...
FLAGS		 (none)
EXAMPLES	 crc *.c Print checksums of all the C programs

The checksum of each argument is computed and printed, along with the
file length and its name, one file per line. This program is useful for
seeing if a file transmitted to another machine has arrived correctly.
It is conceptually similar to sum, except that it uses a stronger 
checksum algorithm and also prints the length.

(ast)

# cron
	 cron (1)
COMMAND		 cron - clock daemon
SYNTAX		 cron
FLAGS		 (none)
EXAMPLES	 /usr/bin/cron Use absolute path in /etc/rc

Cron is clock daemon.  It is typically started up by including the
command /usr/bin/cron in the /etc/rc file.   Once started, cron puts
itself in the background, so no & is needed.  It runs forever, sleeping
most of the time.  Once a minute it wakes up and examines
/usr/lib/crontab to se e if there is any work to do.  If there is, the
work is done.  

The entries of /usr/lib/crontab contain 6 elements each. Some examples
follow:
	Min	Hr	Dat	Mo	Day	Command
	\0*	\0*	\0*	\0*	\0*	/usr/bin/date >/dev/tty0   
						    #print date every minute
	\00	\0*	\0*	\0*	\0*	/usr/bin/date >/dev/tty0  
						    #print date on the hour
	30	\04	\0*	\0*	1-5	/bin/backup /dev/fd1       
						    #do backup Mon-Fri at 0430
	30	19	\0*	\0*	1,3,5	/etc/backup /dev/fd1       
						    #Mon, Wed, Fri at 1930
	\00	\09	25	12	\0*	/usr/bin/sing >/dev/tty0   
						    #Xmas morning at 0900 only

(ast)

# ctags
	 ctags (1)
COMMAND		 ctags - build a tags file
SYNTAX		 ctags [-r] file ...
FLAGS		 -r Generate refs as well as tags
EXAMPLES	 ctags -r *.h *.c Generate the tags file

Ctags generates a tags file from a collection of C source files.  It
can also generate a refs file. The tags file is used by elvis'  :tag
command, and its -t option.  Each C source file is scanned for #define
statements and global function definitions.  The name of the macro or
function becomes the name of a tag.  For each tag, a line is added to
the tags file which contains: the name of the tag, a tab character, the
name of the file containing the tag, a tab character, and a way to find
the particular line within the file.

The refs file is used by the ref program, which can be invoked  via
elvis K command.  When ctags finds a global function definition, it 
copies the function header into the refs file.   The first line is
flush against the right margin, but the argument definitions are
indented.the C source files.

(ast)

# cut
	 cut (1)
COMMAND		 cut - select out columns of a file
SYNTAX		 cut [  -b | -c] list [file...]
		 cut -f list [-d delim] [ -s] [file...] 
FLAGS		 -b Cut specified bytes
     		 -c Select out specific characters
     		 -d Change the column delimiter to delim
     		 -f Select out specific fields that are separated by the
		    delimiter character ( see delim)
     		 -i Runs of delimiters count as one
     		 -s Suppres lines with no delimiter characters, when used
		    with the -f option. Lines with no delimiters are passwd 
		    through untouched
EXAMPLES	 cut -f 2 file Extract field 2
        	 cut -c 1-2,5 file Extract character columns 1, 2, and 5
        	 cut -c 1-5,7- file Extract all columns except 6

Cut extracts one or more fields or columns from a file and writes them
o n standard output. If the -f flag is used, the fields are separated
by a delimiter  character, normally a tab, but can be changed using the
-d flag. If the -c flag is used, specific columns can be specified. The
list can be comma or BLANK separated. The -f and -c flags  are mutually
exclusive. Note: The POSIX1003.2 standard requires the option -b to cut
out specific bytes in a file. It is intended for systems with multi
byte characters (e.g. kanji), since MINIX uses only one byte
characters, this option is equivalent to -c. For the same reason, the
option -n has no effect and is not listed in this manual page.

(ast)

# date
	############ NEXT ENTRY HAS NOT BEEN CHECKED #############
	 date (1)
COMMAND		 date - print or set the date and time
SYNTAX		 date [-q] [[MMDDYY]hhmm[ss]]
		 date [-u] [+format]
     		 -q Read the date from stdin
     		 -u Print the date as GMT
EXAMPLES	 date Print the date and time
        	 date 0221921610 Set date to Feb 21, 1992 at 4:10 p.m.

With the -q flag or a numeric argument,
	 date
sets the GMT time and date.
	 MMDDYY
refers to the month, day, and year;
	 hhmmss
refers to the hour, minute and second. Each of the six fields must be
exactly two digits, no more and no less.
	Date always display the date and time, with the default format
for the system. The -u flag request GMT time instead of local time. A
format may be specified with a + followed by a printf-like string with
the following options:
	%%  % character
	%A  Name of the day
	%B  Name of the month
	%D  mm/dd/yy
	%H  Decimal hour on 2 digits
	%I  Decimal hour modulo 12 on 2 digits
	%M  Decimal minute on 2 digits
	%S  Decimal seconds on 2 digits
	%T  HH:MM:SS
	%U  Decimal week number, Sunday being first day of week
	%W  Decimal week number, Monday being first day of week
	%X  Same as %T
	%Y  Decimal year on 4 digits
	%Z  Time Zone (if any)
	%a  Abbreviated name of the day
	%b  Abbreviated name of the month
	%c  Appropriate date & time (default format)
	%d  Decimal day of the month on 2 digits
	%e  Same as %d, but a space replaces leading 0
	%h  Same as %b
	%j  Decimal dey of the year on 3 digits
	%m  Decimal month on 2 digits
	%n  Newline character
	%p  AM or PM
	%r  12-hour clock time with AM/PM
	%t  Tab character
	%w  Decimal day of the week (0=Sunday)
	%x  Same as %D
	%y  Decimal year on 2 digits

(ast)

# dd
	 dd (1)
COMMAND		 dd - disk dumper
SYNTAX		 dd [option = value] ...
FLAGS		 (none)
EXAMPLES	 dd if=/dev/fd0 of=/dev/fd1 Copy disk 0 to disk 1
        	 dd if=x of=y bs=1w skip=4 Copy x to y, skipping 4 words
        	 dd if=x of=y count=3 Copy three 512-byte blocks

This command is intended for copying partial files. The block size,
skip count, and number of blocks to copy can be specified. The options
are:
	if = file	- Input file (default is stdin)
	of = file	- Output file (default is standard output)
	ibs = n	- Input block size (default 512 bytes)
	obs = n	- Output block size (default is 512 bytes)
	bs = n	- Block size; sets ibs and obs (default is 512 bytes)
	skip = n	- Skip n input blocks before reading
	seek = n	- Skip n output blocks before writing
	count = n	- Copy only n input blocks
	conv = lcase	- Convert upper case letters to lower case
	conv = ucase	- Convert lower case letters to upper case
	conv = swab	- Swap every pair of bytes
	conv = noerror	- Ignore errors and just keep going

Where sizes are expected, they are in bytes. However, the letters w, b,
or k may be appended to the number to indicate words (2 bytes), blocks
(512 bytes), or K (1024 bytes), respectively. When dd is finished, it
reports the number of full and partial blocks read and written

(ast)

# de
	 de (1)
COMMAND		 de - disk editor
SYNTAX		 de [-w] block_device
		 de -r file
FLAGS		 -r Recover a file that has been removed
     		 -w Enable writing, so device can be modified
EXAMPLES	 de -r /usr/ast/prog.c Undo the effects of: rm /usr/ast/prog.c
        	 de -w /dev/fd0 Edit /dev/fd0 for writing

De is a program for system administrators that allows disks to be
inspected block by block. A variety of display options and commands are
available, as described in Chap. 9. For a summary, start the program
and type h for help. The program can also restore files that have just
been removed by rm, provided that the i-node and blocks are still
intact. Another feature is searching disks for ASCII strings, to help
locate things after a crash. Finally, individual disk words can be
changed, for example, the sizes of block special files.

(ast)

# df
	 df (1)
COMMAND		 df - report on free disk space and i-nodes
SYNTAX		 df special ...
FLAGS		 (none)
EXAMPLES	 df /dev/ram Report on free RAM disk space
        	 df /dev/fd0 /dev/fd1 Report on diskette space
        	 df~~~ Report on all mounted devices

The amount of disk space and number of i-nodes, both free and used is
reported. If no argument is given, df reports on the root device and
all mounted file systems.

(ast)

# dhrystone
	 dhrystone (1)
COMMAND		 dhrystone - integer benchmark
SYNTAX		 dhrystone
FLAGS		 (none)
EXAMPLES	 dhrystone Run the dhrystone benchmark

Many years ago, a floating-point benchmark called whetstone was popular
for benchmarking FORTRAN programs. Nowadays, an integer benchmark
called dhrystone is widely used for benchmarking UNIX systems. This is
it. Be warned, however, that dhrystone is entirely CPU bound, and goes
blindingly fast on machines with high-speed caches. Although this is a
good measure for programs that spend most of their time in some inner
loop, it is a poor benchmark for I/O bound applications.

(ast)

# diff
	 diff (1)
COMMAND		 diff - print differences between two files
SYNTAX		 diff   [-c | -e | -C <n>] [-br] file1 file2
FLAGS		 -C <n> Produce output that contains n lines of context
     		 -b Ignore white space when comparing
     		 -c Produce output that contains three lines of context
     		 -e Produce an ed-script to convert file1 into file2
     		 -r Apply diff recursively to files and directories of
		    the same name, when file1 and file2 are both directories
EXAMPLES	 diff file1 file2 Print differences between 2 files
        	 diff -C 0 file1 file2 Same as above
        	 diff -C 3 file1 file2 Output three lines of context with every
		      difference encountered
        	 diff -c file1 file2 Same as above
        	 diff /etc /dev Compares recursively the directories /etc and 
                      /dev
        	 diff passwd /etc Compares ./passwd to /etc/passwd

Diff compares two files and generates a list of lines telling how the
two files differ.  Lines may not be longer than 128 characters. If the
two  arguments on the command line are both directories, diff
recursively steps through all subdirectories comparing files of the
same name. If a file name is found only in one directory, a diagnostic
message is written to stdout. A file that is of either block special,
character special or FIFO special type, cannot be compared to any other
file. On the other hand, if there is one directory and one file given
on the command line, diff tries to compare the file with the same name
as file in the directory directory.

(ast)

# dis88
	 dis88 (1)
COMMAND		 dis88 - disassembler [IBM]
SYNTAX		 dis88 [-o] infile [outfile]
FLAGS		 -o List the object code along with the assembly code
EXAMPLES	 dis88 a.out >listing Disassemble a.out
        	 dis88 -o a.out listing Ditto, but with object code

Dis88 is an 8088 disassembler.   It takes an executable file and prints
the symbolic assembly code that corresponds to it.  If the executable
file contain s a symbol table (added by the program ast), the symbol
table  information is used to give a more readable asembly listing.
More information is provided in Chap. 9.

(ast)

# diskcheck
	 diskcheck (1)
COMMAND		 diskcheck - check a disk for bad sectors
SYNTAX		 diskcheck device start count
FLAGS		 (none)
EXAMPLES	 diskcheck /dev/at0 0 1200 Check 1.2 MB diskette
        	 diskcheck /dev/at0 100 50 Check blocks 100 to 149

Diskcheck checks a disk for bad sectors by reading in each sector,
writing a known bit pattern onto it, reading it back in and comparing
with what was written.  This check is then done a second time.  Bad
sectors are  reported.  After each sector is tested, the original
sector is restored. Only use this program on unmounted partitions.
Killing it part way through may result in lost data.

(ast)

# dosdir dosread doswrite
	 dosdir (1) 	 dosread (1) 	 doswrite (1)
COMMAND		 dosdir - list an MS-DOS directory [IBM]
SYNTAX		 dosdir [-lr] drive
FLAGS		 -l Long listing
     		 -r Recursively descend and print subdirectories
EXAMPLES	 dosdir -l A List root directory on drive A
        	 dosdir -r C x/y Recursively list directory x/y

COMMAND		 dosread - read a file from an MS-DOS diskette [IBM]
SYNTAX		 dosread [-a] drive file
FLAGS		 -a ASCII file
EXAMPLES	 dosread C g/adv >adv Read file g/adv from hard disk
        	 dosread -a A prog.c >x Read ASCII file prog.c from drive A

COMMAND		 doswrite - write a file onto an MS-DOS diskette [IBM]
SYNTAX		 doswrite [-a] drive file
FLAGS		 -a ASCII file
EXAMPLES	 doswrite A x/y <z Write file z to disk as x/y
        	 doswrite -a B f Copy stdin to MS-DOS file f

The names dosdir, dosread, and doswrite are all links to the same
program.  The program sees which function to perform by seeing how it
was called.  A drive code of A causes the program to use /dev/dosA, for
example, a link to /dev/fd0.  Similarly, to have hard disk partition 1
be DOS drive C, /dev/dosC could be a link to /dev/hd1, and so on for
other drive codes.

	 Dosdir reads standard IBM PC diskettes or hard disk partitions
in MS-DOS format and lists their contents on standard output. Directory
names should contain slashes to separate components, even though MS-DOS
uses backslashes. 

	 Dosread reads one MS-DOS file and writes it on standard
output. The file name must use slash, not backslash as a separator.
ASCII files have the final CTRL-Z stripped, and carriage return plus
line feed are mapped to line feed only, the usual MINIX convention. 

	 Doswrite writes its stdin to an MS-DOS file. The diskette or
partition must be formatted and have an MS-DOS file  system already in
place, including all the directories leading up to the file. 

(ast, rev. by asw 13.02.95)

# du
	 du (1)
COMMAND		 du - print disk usage
SYNTAX		 du [-as] [-l n] dir ...
FLAGS		 -a Give usage for all files
     		 -l List up to n levels of subdirectories
     		 -s Summary only
EXAMPLES	 du dir List disk space used by files in dir
        	 du -s dir1 dir2 Give summaries only

Du examines one or more directories and prints the amount of space 
occupied by the files in those directories and their subdirectories.

(ast)

# echo
	 echo (1)
COMMAND		 echo - print the arguments
SYNTAX		 echo [-n] argument ...
FLAGS		 -n No line feed is output when done
EXAMPLES	 echo Start Phase 1 Start Phase 1 is printed
        	 echo -n Hello Hello is printed without a line feed

	 Echo  writes its arguments to standard output. They are
separated by blanks and terminated with a line feed unless -n is
present. This command is used mostly in shell scripts.

(ast)

# ed
	 ed (1)
COMMAND		 ed - editor
SYNTAX		 ed file
FLAGS		 (none)
EXAMPLES	 ed prog.c Edit prog.c

Ed is functionally equivalent to the standard V7 editor, ed.   It
supports the following commands:
	(.)	a: append
	(.,.)	c: change
	(.,.)	d: delete
		e: edit new file
		f: print name of edited file
	(1,$)	g: global command
	(.)	i: insert
	(.,.+1)	j: join lines together
	(.)	k: mark
	(.)	l: print with special characters in octal
	(.,.)	m: move
	(.,.)	p: print
		q: quit editor
	(.)	r: read in new file
	(.,.)	s: substitute
	(1,$)	v: like g, except select lines that do not match
	(1,$)	w: write out edited file

Many of the commands can take one or two addresses, as indicated above.
 The defaults are shown in parentheses.  Thus a appends to the current 
line, and g works on the whole file as default.   The dot refers to the
current line. Below is a sample editing session with comments given
following the # symbol.
	ed prog.c	# Edit prog.c
	3,20p	  	# Print lines 3 through 20
	/whole/		# Find next occurence of whole
	s/whole/while/	# Replace whole by while
	g/Buf/s//BUF/g	# Replace Buf by BUF everywhere
	w		# Write the file back
	q		# Exit the editor

Ed is provided for its sentimental value. If you want a line-oriented
editor, try ex. If you want a good editor, use elle, elvis, or mined.

(ast)

# elle
	 elle (1)
COMMAND		 elle - ELLE Looks Like Emacs
SYNTAX		 elle file [file2]
FLAGS		 (none)
EXAMPLES	 elle file.c Start the editor

Elle is a screen-oriented editor that is patterned after Emacs. It can
edit multiple files, regardless of their length,  can support 1 or 2
windows, and has many other powerful features. An elle manual is given
in Chap. 9.

(ast)

# elvis
	 elvis (1)
COMMAND		 elvis - clone of the Berkeley vi editor
SYNTAX		 elvis [-Rerv] [-t tag] [file] ...
FLAGS		 -R Set the read-only option
     		 -e Start up emulating ex
     		 -r Tell the user to use virecover instead
     		 -t Start editing at the given tag
     		 -v Start up emulating vi
EXAMPLES	 elvis Call the editor
        	 elvis prog.c edit prog.c

Elvis is a screen editor patterned very closely after the Berkeley vi
editor. It has many commands, described in Chap. 9. See also ctags, ex,
ref, and virecover.

(ast)

# ex
	 ex (1)
COMMAND		 ex - Berkeley line editor
SYNTAX		 ex [-Rerv] [-t tag] [file] ...
FLAGS		 -R Set the readonly option
     		 -e Start up emulating ex
     		 -r Tell the user to use virecover instead
     		 -t Tagstart editing at the given tag
     		 -v Start up emulating vi
EXAMPLES	 ex Call the editor
        	 ex prog.c edit prog.c

Ex is a line editor patterned very closely after the Berkeley program
of the same name. It is essentially a much improved version of ed.
Actually, ex is really just a link to elvis, which is a vi clone. Its
commands are described in Chap. 9. See also ctags, elvis, ref, and
virecover.

(ast)

# expand
	 expand (1)
COMMAND		 expand - convert tabs to spaces 
SYNTAX		 expand [-t1,t2, ...] [file]
FLAGS		 -t Tab stop positions
EXAMPLES	 expand -16,32,48,64 Expand stdin with tabs every 16 columns

Expand replaces tabs in the named files with the equivalent numbers of
spaces.  If no files are listed, stdin is given.  If only one tab is
given, the rest are multiples of it.  The default is a tab every 8
spaces.

(ast)

# expr
	 expr (1)
COMMAND		 expr - evaluate experession
SYNTAX		 expr arg ...
FLAGS		 (none)
EXAMPLES	 x=\`expr \$x + 1\` Add 1 to shell variable x

Expr computes the value of its argument and writes the result on
standard output.  The valid operators, in order of increasing precedence,
are listed below.  Operators grouped by {...} have the same precedence.
The operators are: |, &, {<, <=, ==, !=, >=, >}, {+, -}, *, /, %, and :.
Parentheses are permitted.

(ast)

# factor
	 factor (1)
COMMAND		 factor - factor an integer less than 2**31
SYNTAX		 factor number
FLAGS		 (none)
EXAMPLES	 factor 450180 Print the prime factors of 450180

Factor prints the prime factors of its argument in increasing order.
Each factor is printed as many times as it appears in the number.

(ast)

# fdisk
	 fdisk (1)
COMMAND		 fdisk - partition a hard disk [IBM]
SYNTAX		 fdisk [-hm] [-sn] [file]
FLAGS		 -h Number of disk heads is m
     		 -s Number of sectors per track is n
EXAMPLES	 fdisk /dev/hd0 Examine disk partitions
        	 fdisk -h9 /dev/hd0 Examine disk with 9 heads

When fdisk starts up, it reads in the partition table and displays  it.
It then presents a menu to allow the user to modify partitions, store
the partition table on a file, or load it from a file.  Partitions can
be marked as  MINIX , DOS or other, as well as active or not. Using
fdisk is self-explanatory.   However, be aware that repartitioning a
disk will cause information on it to be lost.   Rebooting the system
immediately  is mandatory after changing partition sizes and
parameters. 

MINIX,  XENIX, PC-IX, and MS-DOS all have different  partition
numbering schemes. Thus when using multiple systems on the same disk,
be careful. Furthermore, MINIX expects all partitions to begin on an
even sector.  The m command, which marks a partition as  MINIX ,
automatically rounds odd partitions upward. The reason that odd
partition sizes do not cause a problem with MS-DOS is that MS-DOS
allocates disk space in units of 512-byte sectors, whereas  MINIX uses
1K blocks. Thus an odd number of sectors is no problem for  MS-DOS but
it is a problem for MINIX. That is why a command has been provided to
round  MINIX partitions to an even starting address and an even size.
If your disk has partitions for both MS-DOS\s0 and MINIX, only the
MINIX ones should be rounded off. 

Fdisk has a variety of other features that can be seen by typing h.

(ast)

# fgrep
	 fgrep (1)
COMMAND		 fgrep - fast grep
SYNTAX		 fgrep [-cfhlnsv] [string_file] [string] [file] ...
FLAGS		 -c Count matching lines and only print count, not the lines
     		 -f Take strings from file named in following argument
     		 -h Omit file headers from printout
     		 -l List file names once only
     		 -n Each line is preceded by its line number
     		 -s Status only, no output
     		 -v Print only lines not matching
EXAMPLES	 fgrep % prog.c Print lines containing % sign
        	 fgrep -f pattern prog.c Take strings from pattern

Fgrep is essentially the same as grep, except that it only searches for
lines containing literal strings (no wildcard characters), and it is
much faster.

(ast)

# file
	 file (1)
COMMAND		 file - make a guess as to a file's type based on contents
SYNTAX		 file name ...
FLAGS		 (none)
EXAMPLES	 file a.out ar.h Guess at types

File reads the first block of a file and tries to make an  intelligent
guess about what kind of file it is.   It understands about archives, C
source programs, executable binaries, shell scripts, and English text.

(ast)

# find
	 find (1)
COMMAND		 find - find files meeting a given condition
SYNTAX		 find directory expression
FLAGS		 (none)
EXAMPLES	 find /  -name a.out -print	Print all a.out paths
        	 find /usr/ast ! -newer f -ok rm {};   Ask before removing
        	 find /usr -size +20 -exec mv {} /big; move files > 20 blks
        	 find / \( -name a.out -o -name \(fm*.o\(fm \) -exec rm {};
								2 conds

Find descends the file tree starting at the given directory checking
each file in that directory and its subdirectories against a predicate.
If the predicate is true, an action is taken.  The predicates may be
connected by -a (Boolean and), -o (Boolean or) and ! (Boolean
negation). Each predicate is true under the conditions specified below.
 The integer  n may also be +n to mean any value greater than n,  -n to
mean any value less than n, or just n for exactly n.
	-name s		true if current filename is s (include shell wild 
			cards)
	-size n		true if file size is n blocks
	-inum n		true if the current file's i-node number is n
	-mtime n	true if modification time relative to today (in days)
			is n
	-links n	true if the number of links to the file is n
	-newer f	true if the file is newer than f
	-perm n		true if the file's permission bits = n (n is in octal)
	-user u		true if the uid = u (a numerical value, not a log in 
			name)
	-group g	true if the gid = g (a numerical value, not a 
			group name)
	-type x		where x is bcdfug (block, char, dir, regular file, 
			setuid, setgid)
	-xdev		do not cross devices to search mounted file systems

Following the expression can be one of the following, telling what to do
when a file is found:

	-print	print the file name on standard output
	-exec	execute a MINIX\s0 command, {} stands for the file name
	-ok	prompts before executing the command

(ast)

# fix
	 fix (1)
COMMAND		 fix - generate new file from old one and diff listing
SYNTAX		 fix oldfile difflist >newfile
FLAGS		 (none)
EXAMPLES	 fix old difflist >new Generate new from old and diffs

Fix accepts a diff listing produced by diff and reconstructs the new
file.  It is common for people to take a file, modify it, and then send
the diff listing between the old and new files to other people. Using
fix, the old file, and the diff listing, it is possible to create the
new file.  For example:

  diff oldfile newfile >difflist
  fix oldfile difflist >new2

will generate a file new2 that is identical to newfile. A more
sophisticated alternative to fix is patch, as fix only handles
old-style diffs.

(ast)

# fold
	 fold (1)
COMMAND		 fold - fold long lines
SYNTAX		 fold [-n] [file] ...
FLAGS		 -n How long should the output lines be
EXAMPLES	 fold -60 Fold stdin to 60 characters
        	 fold file Fold file to 80 characters

Fold takes copies its input from the named file (or stdin, if none is
specified) to standard output. However, lines longer than the given
maximum (default 80) are broken into multiple lines of the maximum
length by inserting new line characters.

(ast)

# format
	 format (1)
COMMAND		 format - format a diskette [IBM]
SYNTAX		 format [-a][-q][Special [kbsize]] [-v [dosvollabel]]
FLAGS		 -a Sort interactive list alphabetically not by size
     		 -q Quiet mode: skips asking if you are sure
     		 -v Volume label added along with DOS structures
EXAMPLES	 format Have format display a menu
        	 format /dev/at0 format disk in /dev/at0
        	 format /dev/at0 360 Format disk with 360 blocks
        	 format /dev/dosA Format for DOS
        	 format /dev/fd1 -v DOS_DISK Format and label DOS disk

Format allows the superuser to format diskettes. It can format all
seven non-automatic disk/media combinations that PC-Minix supports.  It
will also try to format automatics, minor devices 0 through 3, if a
device size is nozero. Format will optionally add the structures MS-DOS
needs if either  the device name is an MS-DOS device, like /dev/dosA,
or if the  -v flag is used. If no special file is specified in the
command line format will display a menu of choices. It then allows
automatic devices to be formatted even if they were made with a size of
zero. Warning:  Some disk drives are media sensitive, in which case the
diskette must match the drive (e.g., no 360K diskettes in 1.2M drives).

(ast ??)

# fortune
	 fortune (1)
COMMAND		 fortune - print a fortune
SYNTAX		 fortune
FLAGS		 (none)
EXAMPLES	 fortune Print a fortune

Fortune prints a fortune at random from the fortunes file,  
/usr/lib/fortune.dat.  This file consists of pieces of text separated
by a line containing only %%.

(ast)

# from
	 from (1)
COMMAND		 from - input half of a connection [IBM]
SYNTAX		 from port
FLAGS		 (none)
EXAMPLES	 from port | sort >x Fetch and sort an incoming file
        	 from abc | sh Primitive sherver

To and from are used together to provide connection-oriented service
over an Ethernet. On the sending machine, the last member of a pipeline
is to port.   On the receiving machine, the first member of a pipeline
is from port.   The net result is that the output of the sending
pipeline goes into the input of the receiving pipeline, making
pipelines work across the network.  See also to.

(ast)

# fsck
	 fsck (1)
COMMAND		 fsck - perform file system consistency check
SYNTAX		 fsck [-aclmrs] [device] ...
FLAGS		 -a Automatically repair inconsistencies
     		 -c Check and list only the specified i-nodes
     		 -l List the files and directories in the filesytem
     		 -r Prompt user for repairs if inconsistencies are found
     		 -s List the superblock of the file system
EXAMPLES	 fsck /dev/hd4 Check file system on /dev/hd4
        	 fsck -a /dev/at0 Automatically fix errors on /dev/at0
        	 fsck -l /dev/fd0 List the contents of /dev/fd0
        	 fsck -c 2 3 /dev/hd3 Check and list /dev/hd3 i-nodes 2 & 3

Fsck performs consistency checks on the file systems which reside  on
the specified devices.   When either the -a or -r flags are given, the
file system will be repaired if errors are found. Before running fsck
on a mounted file system, it must first be unmounted

Trying to repair a mounted file system is dangerous and should not be 
attempted.

To repair the root file system (which cannot be unmounted), first  hit
the F1 key to find the pid of the /etc/update process. Then become
superuser and send update signal 9 using kill. After doing this, hit F1
again to verify that /etc/update has vanished. Next run fsck and then
immediately reboot the computer, WITHOUT doing a sync.

This is the only situation in which you can (in fact, must) reboot
without doing a sync. Rebooting is needed because fsck repairs the disk
but does not affect the (possibly incorrect) information held in
memory. Doing a sync would force the (possibly incorrect) information
from memory back onto the disk, thus ruining the work done by fsck. By
rebooting immediately, memory is reloaded with correct information from
the disk. It is necessary to kill /etc/update before repairing the root
file system to prevent it from issuing sync calls while fsck is
running. Because /etc/update only affects mounted file systems (and the
root), when repairing a nonroot file system, unmounting it is
sufficient; it is not necessary to kill /etc/update.

(ast)

# gather
	 gather (1)
COMMAND		 gather - gather up the files in a directory for transmission
SYNTAX		 gather [-s] source_dir [-d] dest_dir [-b] bytes [-f] file 
FLAGS		 -b Desired number of bytes per output file
     		 -d Destination directory
     		 -f Base name of output files
     		 -s Source directory
EXAMPLES	 gather Collect files in current dir into 60K archives
        	 gather -d dir Put the archives in dir
        	 gather -b 90000 Try to produce 90K archives
        	 gather -s .. -d targ -b 5000 Try to produce 5K archives

It is often useful to collect all the files in a directory into one or
more archives for transmission by mail.  This program collects all the
files in the source directory (default: current directory) and puts
them into a shar archive.  The shar archive is then compressed and
uuencoded.  An attempt is made to have the final .uue file be about the
given size (default: 60K), but since gather cannot really predict how
much shar will add to the file, how much compress will reduce the file,
and how much uue will add again, the sizes can fluctuate.  If the -f
file flag is given, the archives will be given the names file_00.uue,
file_01.uue etc.  If -f is not given, the name of the source directory
is used as the base name. Since 7 characters of suffix are appended,
the base name should not exceed 7 characters.

(ast)

# getlf
	 getlf (1)
COMMAND		 getlf - wait until a line has been typed
SYNTAX		 getlf [argument]
FLAGS		 (none)
EXAMPLES	 getlf Wait for a line

In shell scripts it is sometimes necessary to pause to give the user a
chance to perform some action, such as inserting a diskette. This
command prints its argument, if any, and then waits until a carriage
return has been typed, at which time it terminates. It is used in
/etc/rc.

(ast)

# getty uugetty
	 getty (1)  uugetty(1)
COMMAND		 getty - get terminal line parameters for login
SYNTAX		 getty line [-c file] [-h] [-k] [-t] [speed]
FLAGS		 -c Use fname as gettydefs file
     		 -h Do not hang up the phone after reset
     		 -k Do not use speed selection
     		 -t Do not time out at Login: prompt
EXAMPLES	 /etc/getty /dev/tty1 1200 Connect to tty1 at 1200 baud

The getty program allows a terminal port to be used for both dialin and
dialout. It also detects the speed used, and, if enabled, it sets the
various line discipline parameters. When getty starts up, it searches
through the /etc/gettydefs file until it finds an entry that matches
the label as specified in the speed parameter.  If no parameter is
present, the first entry is used. Getty then sets up the terminal line
according to the initial parameters field found in gettydefs.

If called as uugetty this program also performs some tasks that are
needed before uucp can use the line.

SEE ALSO
	gettydefs(4), modem (1)

(ast rev by asw 950226)

# grep
	 grep (1)
COMMAND		 grep - search a file for lines containing a given pattern
SYNTAX		 grep [-elnsv] pattern [file] ...
FLAGS		 -e -e pattern is the same as pattern
     		 -l Do not print line numbers
     		 -n Print line numbers
     		 -s Status only, no printed output
     		 -v Select lines that do not match
EXAMPLES	 grep mouse file  Find lines in file containing mouse
        	 grep [0-9] file Print lines containing a digit

	 Grep searches one or more files (by default, stdin) and
selects out all the lines that match the pattern. All the regular
expressions accepted by ed and mined  are allowed. In addition, + can
be used instead of \(** to mean 1 or more occurrences, ? can be used to
mean 0 or 1 occurrences, and | can be used between two regular
expressions to mean either one of them. Parentheses can be used for
grouping. If a match is found, exit status 0 is returned. If no match
is found, exit status 1 is returned. If an error is detected, exit
status 2 is returned.

(ast)

# gres
	 gres (1)
COMMAND		 gres - grep and substitute
SYNTAX		 gres [-g] pattern string [file] ...
FLAGS		 -g Only change the first occurrence per line
EXAMPLES	 gres bug insect Replace bug with insect
        	 gres \*(SQ^[A-Z]+$\*(SQ CAPS Replace capital-only lines 
  			with CAPS

	 Gres is a poor man's sed . It looks for the same patterns as
grep , and replaces each one by the given string.

(ast)

# head
	 head (1)
COMMAND		 head - print the first few lines of a file
SYNTAX		 head [-n] [file] ...
FLAGS		 -n How many lines to print
EXAMPLES	 head -6 Print first 6 lines of stdin
        	 head -1 file1 file2 Print first line of two files

The first few lines of one or more files are printed.  The default
count is 10 lines.  The default file is stdin.

(ast)

# ic
	 ic (1)
COMMAND		 ic - integer calculator
SYNTAX		 ic [expression]
FLAGS		 (none)
EXAMPLES	 ic~~~~ Start the calculator
        	 ic 250 300+ Start calculator with 550 on the stack

Ic is a reverse Polish notation calculator that works on 32-bit
integers.  It starts out by computing the expression given as an
argument, if any, and then expects keyboard input.  As an example, to
compute 23+5 one first converts this to reverse Polish, 23 5+.  After
the calculator starts, type 23 followed by a carriage return.  Then
type 5 and another carriage return.  Finally type + to see the result,
28 displayed on the stack.  Other operations work the same way.  The
calculator can use other radices for input and output, and has
registers that can be stored and loaded.  The h\f R command gives the
help menu.  See also Chap.  9.

(ast)

# id
	 id (1)
COMMAND		 id - print the uid and gid
SYNTAX		 id
FLAGS		 (none)
EXAMPLES	 id Print the uid and gid

Id prints the current uid and gid, both numerically and symbolically.
If the effective uid and gid are different from the real ones, all of them
are printed.

(ast)

# ifdef
	 ifdef (1)
COMMAND		 ifdef - remove #ifdefs from a file
SYNTAX		 ifdef [-t] [-dsymbol] [-Dsymbol] [-Usymbol] [-Isymbol] [file]
FLAGS		 -D Define symbol permanently
     		 -I Ignore symbol
     		 -U Undefine symbol permanently
     		 -d Define symbol. It may be #undef'ed later
     		 -t Produce a table of the symbols on stdout
EXAMPLES	 ifdef -DUNIX file.c >newfile.c Define UNIX
        	 ifdef -D_MINIX -UDOS <x.c >y.c Define _MINIX, undefine DOS

Ifdef allows conditional code [ #ifdef ...  #endif ] to be selectively
removed from C files, but at the same time leaving all other C
preprocessor commands intact such as #define, #include etc.  Input to
ifdef is either the file named as the last argument, or stdin if no
file is named.  Output goes to stdout.

Symbols may be defined with the -d or -D flags just like cpp, except
that the latter option ignores subsequent #undefs.  It is not permitted
to give values to symbols.  Similarly, -U undefines a symbol and
ignores subsequent #definess[A.  Symbols defined with -I are ignored;
any #ifdef using an ignored symbol will be left intact.

(ast)

# indent
	 indent (1)
COMMAND		 indent - reformat the layout of a program
SYNTAX		 indent in_file [out_file] [options]
FLAGS		 (many)
EXAMPLES	 indent -br -c25 prog.c  Indent prog.c
        	 indent -npcs prog.c newprog.c Put output on newprog.c

Indent reformats a C program according to a set of options provided.
Most of the common choices are available.  The output file replaces the
input file, unless an explicit output file is specified (but a backup
is made of the original with suffix .BAK).  The options are given in
Chap. 9.

(ast)

# inodes
	 inodes (1)
COMMAND		 inodes - print i-node information
SYNTAX		 inodes
FLAGS		 (none)
EXAMPLES	 inodes Print information about file names typed in
        	 cd /dev; ls | inodes Print information about the special files

Inodes expects a list of file names on stdin, one file name per line.
For each file named, the file type, mode, uid, gid, checksum, length,
and name is printed.  The checksum is the same as used by crc.  This
program provides a way to see the sizes of the block special files in
/dev, as shown in the second example above.

(ast)

# kermit
	 kermit (1)
COMMAND		 kermit - transfer a file using the kermit protocol
SYNTAX		 kermit
FLAGS		 (many)
EXAMPLES	 kermit Start kermit

Kermit is a file transfer program, remote connection program, and much
more.  Even summarizing it here would be out of the question.  For a
description of it, see the 379 page book Kermit: A File Transfer
Protocol by Frank da Cruz, Digital Press, 1987, ISBN 0-932376-88-6, and
also Chap. 9.

(ast)

# kill
	 kill (1)
COMMAND		 kill - send a signal to a process
SYNTAX		 kill [-n] process
FLAGS		 -n Signal number to send
EXAMPLES	 kill 35 Send signal 15 to process 35
        	 kill -9 40 Send signal 9 to process 40
        	 kill -2 0 Send signal 2 to whole process group

A signal is sent to a given process.  By default signal 15 (SIGTERM) is
sent.  Process 0 means all the processes in the sender's process group.

(ast)

# last
	 last (1)
COMMAND		 last - display recent on-line session records
SYNTAX		 last [-f file] [-r] [-n] [name\
fR] [tty] ...
FLAGS		 -f Use file instead of /usr/adm/wtmp
     		 -r Search backwards only to last reboot
     		 -n Print a maximum of n lines
EXAMPLES	 last reboot When was the system last rebooted?
        	 last ast When was the last login for ast?
        	 last -10 tty0 tty1 Display last 10 logins on tty0 or tty1

	 Last Searches backward through the login administration file
(default is /usr/adm/wtmp), printing information about previous logins
and reboots.  During a long search, the SIGQUIT signal (CTRL-\\) causes
last to display how far back it has gone; it then continues. 

(ast)

# leave
	 leave (1)
COMMAND		 leave - warn when it is time to go home
SYNTAX		 leave [ [+] hh[:]mm]
FLAGS 		 (none)
EXAMPLES	 leave 1500 Issue a warning at 2:55 p.m.
        	 leave 10:00 Issue a warning at 9:55 a.m.
        	 leave + 30 Issue a warning in 25 minutes

Leave sets an alarm clock to a specified time and issues a warning 5
minutes before, 1 minute before, and at the time to leave.  It then
keeps issuing warnings every minute for 10 minutes, then quits.  If no
time is provided, the program prompts for one.

(ast)

# libpack
	 libpack (1)
COMMAND		 libpack - pack an ASCII assembly code file [IBM]
SYNTAX		 libpack
FLAGS		 (none)
EXAMPLES	 libpack <x.s >y.s Pack x.s

This program is a filter that reads an ASCII assembly code file from
standard input and writes the corresponding packed file on standard
output.  The compiler libraries are archives of packed assembly code
files.

(ast)

# libupack
	 libupack (1)
COMMAND		 libupack - convert a packed assembly code file to ASCII [IBM]
SYNTAX		 libupack
FLAGS		 (none)
EXAMPLES	 libupack <y.s >x.s Unpack y.s

This program is a filter that reads a packed assembly code file from
stdin and writes the corresponding ASCII file on standard output.

(ast)

# ln
	############ NEXT ENTRY HAS NOT BEEN CHECKED #############
	 ln (1)
COMMAND		 ln - create a link to a file
SYNTAX		 ln [-f] file [name]
SYNTAX		 ln [-f] file ... dir
FLAGS		 -f Remove existing links
EXAMPLES	 ln file newname Make newname a synonym for file
		 ln /usr/games/chess Create a link called chess

A directory entry is created for name.  The entry points to file.
Henceforth, name and file can be used interchangeably.  If name is not
supplied, the last component of file is used as the link name.  If more
than one file is supplied or the name refers to an existing directory,
links will be created in that directory.  An existing name will not be
removed unless the -f flag is specified.

(ast)

# login
	 login (1)
COMMAND		 login - log into the computer
SYNTAX		 login [user]
FLAGS		 (none)
EXAMPLES	 login ast Login as ast

Login allows a logged in user to login as someone else without first
logging out.  If a password is needed, login will prompt for it.

(ast)

# look
	 look (1)
COMMAND		 look - look up words in dictionary
SYNTAX		 look [-f] prefix[/suffix] [dictionary
]
FLAGS		 -f Fold upper case letters to lower case
EXAMPLES	 look ard Print words starting with ard
		 look /bing Print words ending with bing
		 look -f f/ar Print words starting with f, ending with ar


Look takes a prefix and/or suffix and searches /usr/lib/dictionary or
the specified dictionary for all words with that match.  The words are
printed.  The -f flag causes all upper case letters to be treated as
lower case.

(ast)

# lorder
	 lorder (1)
COMMAND		 lorder - compute the order for library modules [IBM]
SYNTAX		 lorder file ...
FLAGS		 (none)
EXAMPLES	 lorder proc1.s proc2.s Give lorder information

Lorder accepts a series of packed or unpacked .s files and libraries,
and produces a partial ordering suitable for processing by tsort.

(ast)

# lpr
	 lpr (1)
COMMAND		 lpr - copy a file to the line printer
SYNTAX		 lpr [file] ...
FLAGS		 (none)
EXAMPLES	 lpr file & Print file on the line printer
		 pr file | lpr & Print stdin (pr's output)

Each argument is interpreted as a file to be printed.  Lpr copies each
file to /dev/lp, without spooling.  It inserts carriage returns and
expands tabs.  Only one lpr at a time may be running.

(ast)

# ls
	 ls (1)
COMMAND		 ls - list the contents of a directory

SYNTAX		 ls [-abcdfgilmnopqrstux01ACFLRS] [name] ...

FLAGS		 -A All entries are listed, except . and ..
		 -C Multicolumn listing with entries sorted down the page
		 -F Put /, | and * after directories, fifos and executables
		 -L Print information about symbolic links
		 -R Recursively list subdirectories
		 -S Squeeze column widths in multicolumn listings
		 -a List all entries including those starting with .
 		 -b Print non-graphic characters in octal \\ddd notation
		 -c Use the status change time instead of modification time
		 -d Do not list contents of directories
		 -f List argument as unsorted directory
		 -g As for -l, but print the group only
		 -i I-node number printed in first column
		 -l Long listing: mode, links, owner, group, size and time
		 -m Stream output format
		 -n As for -l, but print numeric uid and gid
		 -o As for -l, but print the owner only
		 -p Put / after directory names
		 -q Print ? in place of non-graphic characters
		 -r Reverse the sort order
		 -s Print the size in 512 byte units
		 -t Sort by time, latest first
		 -u Use last usage time instead of modification time
		 -x Multicolumn listing with entries sorted across the page
		 -0 Reset all options
		 -1 Print one entry per line (default)

EXAMPLES	 ls -l~~ List files in working directory
		 ls -lis List with i-nodes and sizes

For each file argument, list it.  For each directory argument, list its
contents, unless -d is present.  When no argument is present, the
working directory is listed.  

(ast)

# m4
	 m4 (1)
COMMAND		 m4 - macro processor

SYNTAX		 m4 [-D name = value] [-U name] 

FLAGS		 -D Define a symbol
		 -U Undefine a symbol

EXAMPLES	 m4 <m4test Run M4

M4 is a general-purpose macro processor. It is described in Chap. 9.
It has been used to implement programming languages, such as RATFOR.

(ast)

# mail
	 mail (1)
COMMAND		 mail - send and receive electronic mail

SYNTAX		 mail [-dpqrv] [-f file] [user]

FLAGS		 -d Force use of the shell variable MAILER
		 -f Use file instead of /usr/spool/mail/user as mailbox
		 -p Print all mail and then exit
		 -q Quit program if SIGINT received
		 -r Reverse print order, i.e., print oldest first
		 -v Verbose mode

EXAMPLES	 mail ast Send a message to ast
		 mail Read your mail

Mail is an extremely simple electronic mail program.  It can be used
to send or receive email on a single MINIX system, in which case it functions
as user agent and local delivery agent.  If the flag MAILER is defined in 
mail.c, it can also call a transport agent to handle remote mail as well.
No such agent is supplied with MINIX .

When called by user with no arguments, it examines the mailbox
/usr/spool/mail/user, prints one message (depending on the -r flag), and 
waits for one of the following commands:

	<newline>	Go to the next message
	-	 	Print the previous message
	!command	Fork off a shell and execute command
	CTRL-D		Update the mailbox and quit (same as q)
	d		Delete the current message and go to the next one
	q		Update the mailbox and quit (same as CTRL-D)
	p		Print the current message again
	s [file]	Save message in the named file
	x		Exit without updating the mailbox

To send mail, the program is called with the name of the recipient as an
argument.  The mail is sent, along with a postmark line containing the date.
For local delivery, a file named after the recipient in the directory
/usr/spool/mail must be writable.

(ast)

# make
	 make (1)
COMMAND		 make - a program for maintaining large programs
SYNTAX		 make [-f file] [-iknpqrst] [option] ... 
[target]
FLAGS	   	 -f Use file as the makefile
		 -i Ignore status returned by commands
		 -k On error, skip to next command
		 -n Report, but do not execute
		 -p Print macros and targets
		 -q Question up-to-dateness of target
		 -r Rule inhibit; do not use default rules
		 -s Silent mode
		 -t Touch files instead of making them
EXAMPLES	 make kernel Make kernel up to date
		 make -n -f mfile Tell what needs to be done

	 Make is a program that is normally used for developing large
programs consisting of multiple files.  It keeps track of which object
files depend on which source and header files.  When called, it does
the minimum amount of recompilation to bring the target file up to date.
The file dependencies are expected in makefile or Makefile, unless
another file is specified with -f.
	 Make has some default rules built in, for example, it knows
how to make .s files from .c files.  

Here is a sample makefile .

	d=/user/ast	# d is a macro
	program:	head.s tail.s		# program depends on these
			cc -o program head.s tail.s	
						# tells how to make program 
			echo Program done.	# announce completion
	head.s:		$d/def.h head.c		# head.s depends on these

	tail.s: 	$d/var.h tail.c 	# tail.s depends on these


A complete description of make would require too much space here.  Many
books on UNIX discuss make.  Study the numerous Makefiles in the MINIX
source tree for examples.

(ast)

# man
	 man (1)
COMMAND		 man - display manual page
SYNTAX		 man [man_directory] [digit] [name] ...
FLAGS		 (none)
EXAMPLES	 man Display main index
		 man cdiff Display man page for cdiff program
		 man 2 fork Display man page for fork system call
		 man 3 Display the part 3 man pages

Man is a program that displays manual pages.  When called with a
program name, it displays the manual page for that program.  When the
digit k is given as an argument, the file /usr/man/mank is used instead
of the default, /usr/man/man1.  When no name is given (or just a
digit), the list of valid entries is displayed.  The arrows can be used
to select an entry, and <return> can be used to display the selected
entry.  Q or q leaves the program.  A directory name can be given to
override the use of /usr/man.  

See also: man_pages(5)

(ast revised by asw 14.02.95)

# master
	 master (1)
COMMAND		 master - control the creation of shervers [IBM]
SYNTAX		 master count uid gid command
FLAGS		 (none)
EXAMPLES	 master 2 1 1 /bin/sherver port Start 2 shervers

If a machine is intended to be used as a server, its /etc/rc file
should have a command similar to the example above.  When the system is
booted, master runs and forks off the required number of shervers
(shell servers), up to a maximum of four.  They run with the indicated
uid and gid, and listen to the indicated port.  When an rsh is done on
a client machine, the command is given to one of the shervers for
execution

When the sherver is done, it exits, master, which is always running,
sees this, and creates a new sherver.  Thus master is analogous to
init, only it makes new shervers (usually) instead of new login
programs.  Master must run as root to be able to do setuid and setgid.

(ast)

# mined
	 mined (1)
COMMAND		 mined - MINIX editor
SYNTAX		 mined [file]
FLAGS		 (none)
EXAMPLES	 mined /user/ast/book.3 Edit an existing file
		 mined Call editor to create a new file
		 ls -l | mined Use mined as a pager to inspect listing

	 Mined (pronounced min-ed) is a simple full-screen editor.
When editing a file, it holds the file in memory, thus speeding up
editing, but limiting the editor to files of up to about 35K.  Larger
files must first be cut into pieces by split.  Lines may be arbitrarily
long.  Output from a command may be piped into mined so it can be
viewed without scrolling off the screen.  See also Chap. 9.

See also: mined_commands(5), regular_expressions(5)

(ast revised by asw 14.02.95)

# mkdir
	############ NEXT ENTRY HAS NOT BEEN CHECKED #############
	 mkdir (1)
COMMAND		 mkdir - make a directory
SYNTAX		 mkdir [-p] [-m mode] directory ...
FLAGS		 -m Create directory with mod		 -p Create missing intermediate directories
EXAMPLES	 mkdir dir 	Create dir in the current directory
		 mkdir -p /user/ast/dir 
				Create the /user/ast and /user/ast/dir

The specified directory or directories are created and initialized. If any
intermediate directory is missing and (enp is specified, the missing
component will be created and no error displayed if directory already
exists. If the -m flag is used, this will be equivalent to a chmod
on the directory after its creation.

(ast)



# mkfifo
	############ NEXT ENTRY HAS NOT BEEN CHECKED #############
	 mkfifo (1)
COMMAND		 mkfifo - make a named pipe
SYNTAX		 mkfifo [-m mode] fifo ...
FLAGS		 -m Create fifo with specified mode
EXAMPLES	 mkfifo pipe Create pipe in the current directory
		 mkfifo -m a+w systatus Create the systatus writable by all

The specified fifo special files are created.  If the -m flag is used,
this will be equivalent to a chmod on the fifo special file after its
creation.

(ast)

# mkfs
	 mkfs (1)
COMMAND		 mkfs - make a file system
SYNTAX		 mkfs [-Ldot] special prototype
FLAGS		 -L Make a listing on standard output
		 -b Number of blocks in the file system
		 -d Use mod time of mkfs binary for all files
		 -i Number of i-nodes in the file system
		 -o Use a drive other than 0 or 1 (safety precaution)
		 -t Do not test if file system fits on the medium
		 -1 Make a version 1 file system (for backward compatibility)
EXAMPLES	 mkfs /dev/fd1 proto 	Make a file system on /dev/fd1
		 mkfs /dev/fd1 360 	Make empty 360 block file system
		 mkfs /dev/hd2 -b 20000 -i 4000 
					Make file system on partition 2

	 Mkfs builds a file system and copies specified files to it.
The prototype file tells which directories and files to copy to it.  If
the prototype file cannot be opened, and its name is just a string of
digits, an empty file system will be made with the specified number of
blocks.  The number of blocks can also be specified with the -b flag.
A sample prototype file follows.  The text following the # sign in the
example below is comment.  In real prototype files, comments are not allowed.

boot					# boot block file (ignored)
360 63					# blocks and i-nodes
d--755 1 1				# root directory
   bin	d--755 \|2 1			# bin dir: mode (755), uid (2), gid (1)
	sh	\|---755 2 1 /user/bin/shell	# shell has mode rwxr-xr-x
	mv	-u-755 2 1 /user/bin/mv 	# u = SETUID bit
	login	-ug755 2 1 /user/bin/login	# SETUID and SETGID
   $					# end of /bin
   dev	d--755 2 1			# special files: tty(char), fd0(block)
	tty	c--777 2 1 4 0		# uid=2, gid=1, major=4, minor=0
	fd0	b--644 2 1 2 0 360	# uid, gid, major, minor, blocks
   $					# end of /dev
   user	d--755 12 1			# user dir: mode(755), uid(12), gid(1)
	ast	d--755 12 1		# /user/ast
	$				# /user/ast is empty
   $					# end of /user
$					# end of root directory


The first entry on each line (except the first 3 and the $ lines, which
terminate directories) is the name the file or directory will get on
the new file system.  Next comes its mode, with the first character
being -dbc for regular files, directories, block special files and
character special files, respectively.  The next two characters are
used to specify the SETUID and SETGID bits, as shown above.  The last
three characters of the mode are the rwx protection bits.

Following the mode are the uid and gid.  For special files, the major
and minor devices are needed.  The size in blocks must also be
specified for block special files (the MINIX block size is 1K; this can
only be changed by changing BLOCK_SIZE and then recompiling the
operating system).

(ast)

# mknod
	 mknod (1)
COMMAND		 mknod - create a special file
SYNTAX		 mknod file [b] [c] major minor [size]
FLAGS		 (none)
EXAMPLES	 mknod /dev/plotter c 7 0 
					Create special file for a plotter
		 mknod /dev/fd3 b 2 3 360 
					Create a 360K device for disk drive 3

	 Mknod creates a special file named file, with the indicated
major and minor device numbers.  The second argument specifies a block
or character file.  Block devices have a size, which must be specified
in blocks.  Character devices do not have a size so the fifth argument
is omitted.

(ast)

# mkproto
	 mkproto (1)
COMMAND		 mkproto - create a MINIX prototype file
SYNTAX		 mkproto [-b n] [-d str] [-g n] [-i n] [-p nnn] [-s] 
			 [-t root] [-u n]
FLAGS		 -b Number of blocks in the prototype is n
		 -d Indent the prototype file using str instead of tab
		 -g Use n as the gid for all files and directories
		 -i Number of i-nodes in the prototype is n
 		 -p Use nnn (3 octal digits) as the protection mode
		 -s Use the same uid, gid and mode as the source files have
		 -t Use the string root as the path prefix for every file
		 -u Use n as the uid for all files and directories
EXAMPLES	 mkproto -b360 	Make a 360K prototype of this directory
		 mkproto -u2 -g1 -p644 	
				Give all files uid 2, gid 1 and mode 644

Mkproto creates an mkfs prototype file for the specified
source-directory.  The prototype file is either written to stdout or,
if specified, the proto-file.

(ast)

# modem ungetty
	 modem (1), ungetty(1)
COMMAND		 modem - switch the modem and getty state
SYNTAX		 modem [-d] [-g] <-o | -i num> ttyn
FLAGS		 -o Turn getty off and set modem to dialout
		 -i Set line to dialin
		 -d debug mode
		 -g plain getty mode (not dialin)
EXAMPLES	 modem -o tty1 		Set tty1 to dialout
		 modem -i2 tty1 	Set tty1 to dialin (2 rings)

The getty program allows a terminal port to be used for both dialin and
dialout.  This little program switches the getty state, and also sends
some commands to the modem attached to the specified line.  If the -o
flag is presnt, modem will put the getty process (if any) connected to
the specified line into SUSPEND state, which means that it will not pay
attention to that line until it is reset to RESTART state.  Also, modem
will send some (Hayes) commands to the attached modem to disable the
auto-answer mode.  The -i flag specifies the number of times the
telephone has to ring before the modem may answer the call (to give the
operator a chance).

(ast rev asw 950226)

# more
	 more (1)
COMMAND		 more - pager
SYNTAX		 more [-dflpsu] [-n] [+n] [+/<pattern>] [file] ...
FLAGS		 -d Display prompt message at each pause
     		 -f Do not fold lines
     		 -l Do not treat CTRL-L as form feed
     		 -p Page mode.  Do not scroll
     		 -s Suppress multiple blank lines
     		 -u Use escape sequences for underlining
EXAMPLES	 more file 		Display file on the screen
        	 more -p file1 file2 	Display two files in page mode
        	 more -10 file 		Use a 10 line window
        	 more +/begin file 	Hunt for the string begin

More is a pager that allows one to examine files.  When more starts up,
it displays a screenful of information from the first file in its list,
and then pauses for one of the following commands.  In this
description, # represents an integer telling how many of something.

	<space>		- Display next page
	<return>	- Display next line
	CTRL-B		- Go backward half a screenful
	CTRL-D		- Go forward half a screenful
	CTRL-L		- Redisplay the screen
	#<space>	- Go forward # lines
	=		- Print current line number
	.		- Repeat previous command
	'		- (single quote) Go back to start of last search
	!		- Escape to a shell
	#/<expr>	- Go to #-th occurrence of <expr>
	:f		- Display current file name and line number
	#:n		- Skip forward # files
	#:p		- Skip backward # files
	b		- Go backward half a screenful
	d		- Go forward half a screenful
	#f		- Skip # screenfuls
	h		- Display /usr/lib/more.help
	#n		- Go to #-th occurence of last <expr>
	q		- Quit more
	Q		- Quit more
	#s		- Skip # lines
	v		- Try to execute /usr/bin/vi
	#z		- Go forward # lines and set screen size to #


For the benefit of users who always want to use certain flags when calling
more, the shell variable MORE can be set,
for example, to MORE="p".

(ast)

# mount
	 mount (1)
COMMAND		 mount - mount a file system
SYNTAX		 /etc/mount special file [-r]
FLAGS		 -r File system is mounted read-only
EXAMPLES	 /etc/mount /dev/fd1 /user Mount diskette 1 on /user

The file system contained on the special file is mounted on file.  In
the example above, the root directory of the file system in drive 1 can
be accessed as /user after the mount.  When the file system is no
longer needed, it must be unmounted before being removed from the drive.

(ast)

# mref
	 mref (1)
COMMAND		 mref - make listing and cross reference map of MINIX
SYNTAX		 mref [-dlmstx] [-p n] [-n] file ..

FLAGS		 -d Do not produce definition file (global symbol table)
     		 -l Do not produce listing
     		 -m Multiple references on one line are cited only once
     		 -p Set initial page number to n
     		 -s Suppress line numbering between procedures
     		 -t Generate output for troff
     		 -x Do not produce the cross reference map
     		 -n Number of lines to print per page, default = 50
EXAMPLES	 mref *.[hc] List and cross reference files .h and .c

        	 mref -60 -t *.c Produce troff input at 60 lines/page
        	 mref -dx -p 100 *.c Listing only, first page is numbered 100

	In default mode, mref produces three output files: a numbered
listing of the input files (on standard output), a global symbol table
(on symbol.out), and a cross reference map to the global symbols (on
xref.out).  A global symbol in this context is one present in a #define, 
PUBLIC, PRIVATE, or SYMBOL statement (the latter being introduced to
allow users to explicitly declare certain symbols as global).  Any of
the three outputs can be suppressed, or alternatively, be made suitable
for input to troff for typesetting.

(ast)

# mv
	############ NEXT ENTRY HAS NOT BEEN CHECKED #############
	 mv (1)
COMMAND		 mv - move or rename a file
SYNTAX		 mv [-fi] file1 file2
		 mv [-fi] file ... directory
FLAGS		 -f Do not prompt before removing existing files
     		 -i Prompt before removing existing files
EXAMPLES	 mv oldname newname Move oldname to newname
        	 mv file1 file2 /user/ast Move two files to /user/ast

	 Mv moves one or more files from one place in the file system
to another.  If the old path and new path are on the same device, it is
done by renaming otherwise by copying.  If you're not superuser, the
copy will destroy the file's owner, group and setuid/setgid bits.  mv
will prompt before removing non-writable files if stdin is a terminal
or the -i flag was specified.

(ast)

# ncheck
	 ncheck (1)
COMMAND		 ncheck - i-node to name converter
SYNTAX		 ncheck [-i numbers] [-a] [-s] file_sy
stem
FLAGS		 -a List all files, even . and ..
     		 -i Followed by a list of i-nodes
     		 -s List only special and setuid files
EXAMPLES	 ncheck - /dev/fd0 List everything on /dev/fd0
        	 ncheck -i 10,15 /dev/fd0 List i-nodes 10 and 15 on /dev/fd0

Sometimes one knows about an i-node number and wants to find the file
name that goes with it.  This program makes that mapping.  The default
is to list everything on the device, but the -i flag restricts the list
to specified i-nodes and the -s flag restricts it to special files and
setuid files (to look for possible security violations).

(ast)

# nm
	 nm (1)
COMMAND		 nm - print name list
SYNTAX		 nm [-dgnopru] [file] ...
FLAGS		 -d Print the offsets in decimal instead of in hex
     		 -g Print only external symbols
     		 -n Sort numerically rather than alphabetically
     		 -o Prepend file name to each line rather than only once
     		 -p Do not sort, print in symbol-table order
     		 -r Sort in reverse order
     		 -u Print only undefined symbols
EXAMPLES	 nm -n a.out Print all symbols in numerical order
        	 nm -dg a.out Print globals alphabetically in decimal

Nm prints the symbol table of executable files when it is available.
If no file is given, the symbols in a.out are used.  The format of the
table is somewhat compatible with the one produced by asld when used
with the -s option.  The symbol table can be added with ast.  Assembly
language files do not have symbol tables.

(ast)

# nroff
	 nroff (1)
COMMAND		 nroff - text formatter
SYNTAX		 nroff [-bv] [-m<macros>] [-p<n>] [-<n>] [+<n>] [file] ...
FLAGS		 -b Output device can backspace
     		 -m Use /usr/lib/tmac/tmac. macros
     		 -v Print nro version number
     		 -<n> Last page to print
     		 +<n> First page to print
EXAMPLES	 nroff infile >outfile Format infile
        	 nroff +3 -5 infile >outfile Only output pages 3-5

Nroff is a text formatter like roff, but more flexible.  Unlike roff,
it accepts parametrized macros, for example.  The commands are given in
Chap. 9.

(ast)

# od
	 od (1)
COMMAND		 od - octal dump
SYNTAX		 od [-bcdhox] [file] [ [+] offset [.\f
R][b] ]
FLAGS		 -b Dump bytes in octal
     		 -c Dump bytes as ASCII characters
     		 -d Dump words in decimal
     		 -h Print addresses in hex (default is octal)
     		 -o Dump words in octal (default)
     		 -v Verbose (list duplicate lines)
     		 -x Dump words in hex
EXAMPLES	 od -ox file Dump file in octal and hex
        	 od -d file +1000 Dump file starting at byte 01000
        	 od -c file +10.b Dump file starting at block 10

	 Od dumps a file in one or more formats.  If file is missing,
stdin is dumped.  The offset argument tells od to skip a certain number
of bytes or blocks before starting.  The offset is in octal bytes,
unless it is followed by a "." for decimal or "b" for blocks, or both.

See also: xd (1)

(ast)

# passwd
	 passwd (1)
COMMAND		 passwd - change a login password
SYNTAX		 passwd [name]
FLAGS		 (none)
EXAMPLES	 passwd Change current user's password
        	 passwd ast Change ast's password (super-user only)

	 Passwd is used to change your password.  It prompts for the
old and new passwords.  It asks for the new password twice, to reduce
the effect of a typing error.  Do not forget to copy the modified
password file back to the root file system, or the changes will be lost
when the system is rebooted.

(ast)

# paste
	 paste (1)
COMMAND		 paste - paste multiple files together
SYNTAX		 paste [-s] [-d list] file...
FLAGS		 -d Set delimiter used to separate columns to list.
     		 -s Print files sequentially, file k on line k.
EXAMPLES	 paste file1 file2 Print file1 in col 1, file2 in col 2
        	 paste -s f1 f2 Print f1 on line 1 and f2 on line 2
        	 paste -d : file1 file2 Print the lines separated by a colon

Paste concatenates corresponding lines of the given input files and
writes them to standard output.  The lines of the different files are
separated by the delimiters given with the option -s.  If no list is
given, a tab is substituted for every linefeed, except the last one.

If end-of-file is hit on an input file, subsequent lines are empty.
Suppose a set of k files each has one word per line.  Then the paste
output will have k columns, with the contents of file j in column j.
If the -s flag is given, then the first file is on line 1, the second
file on line 2, etc.  In effect, -s turns the output sideways.

If a list of delimiters is given, they are used in turn.  The C escape
sequences \\n, \\t, \\\\, and \\0 are used for linefeed, tab,
backslash, and the null string, respectively.  

(ast)

# patch
	 patch (1)
COMMAND		 patch - patches up a file from the original and a diff
SYNTAX		 patch [-NRbcdeflnop] [-Fn] [-D label] [file [difflist]]
FLAGS		 -D Mark changes with   #ifdef...#endif   next arg gives label
     		 -F Sets the maximum fuzz factor to n
     		 -N Ignore patches that are reversed or already applied
     		 -R Reverse the patches
     		 -b Next argument is backup extension, instead of using a tilde
     		 -c Interpret the patch file as a context diff
     		 -d Cd to the next arg (assumed a dir) before doing anything
     		 -e Interpret the patch file as an ed script
     		 -f Forces patch to do its work without asking any questions
     		 -l Do matching loosely (e.g., all white space is equivalent)
     		 -n Interpret the patch file as a normal diff
     		 -o Next argument is the output file name
     		 -p Sets the pathname strip count
EXAMPLES	 patch file difflist Fix up file
        	 patch <difflist Patch multiple files

Patch takes an original file and a diff listing and recreates the new
file.  It is functionally similar to fix, but much more powerful.  Not
only can it handle normal diffs, but also context diffs produced by
cdiff.  In addition, it works even when the file being patched has
other changes to it.  It deduces the type of difflist itself (unless
given -c, -e, or -n).

The normal usage is given in the example above.  In this case patch
will modify file to incorporate all the patches.  

The original file will be saved to a file ending in a tilde (~).

If no input file is given, patch reads stdin which may contain the
concatenation of multiple diff listings.  In this way, all the files in
a directory may be updated at once.  See Chap.  9 for more information.

(ast)

# pathchk
	############ NEXT ENTRY HAS NOT BEEN CHECKED #############
	 pathchk (1)
COMMAND		 pathchk - check pathname
SYNTAX		 pathchk [-p] path ...
FLAGS		 -p Check against POSIX rules
EXAMPLES	 pathchk /usr/src/file.c Check the accessibility of file.c
        	 pathchk -p file Check posix compliance of file

	 Pathchk verifies path names and display error if paths are too
long, contain names that are too long, go thru a non-searchable
directory or contain an invalid character in names.  If the -p flag is
specified, the POSIX rules apply instead of the rules of the current
file system.

(ast)

# pr
	 pr (1)
COMMAND		 pr - print a file
SYNTAX		 pr [-Mfnt] [-h n]  [-l n]  [\(enw n] [-columns] [+page] 
                    [file] ...
FLAGS     	 -M Use MINIX style line number
     		 -f Do not fold long lines
     		 -h Take next argument as page header
     		 -l Sets page length in lines
     		 -n Number the output lines
     		 -t Do not print page header or trailer
     		 -w Sets line length in characters
EXAMPLES	 pr -w85 -l60 file Use 85 character line, 60 line page
        	 pr -3 file List file three columns to a page
        	 pr +4 file Start printing with page 4

	 Pr formats one or more files for printing.  If no files are
specified, stdin is printed.  Options are provided for setting the
width and height of the page, the number of columns to use (default 1),
and the page to start with, among others.

(ast)

# prep
	 prep (1)
COMMAND		 prep - prepare a text file for statistical analysis
SYNTAX		 prep [file]
FLAGS		 (none)
EXAMPLES	 prep infile >outfile Prepare infile

Prep strips off most of the troff commands from a text file and then
outputs all the words, one word per line, in the order they occur in the file.

This file can then be sorted and compared to a dictionary (as a spelling
checker), or used for statistical analyses.

(ast)

# pretty
	 pretty (1)
COMMAND		 pretty - MINIX pretty printer
SYNTAX		 pretty file ...
FLAGS		 (none)
EXAMPLES	 pretty file1 file2 Convert two files to MINIX\s0 layout

Pretty converts one or more C source files to MINIX format by changing
their layout.  Running this program does not affect the resulting
binary programs.  Actually, pretty is a postprocessor for indent, which
must be installed in /bin or /usr/bin.  Although the output is not bad,
it is not entirely consistent with the book or even with itself.

(ast)

# printenv
	 printenv (1)
COMMAND		 printenv - print out the current environment
SYNTAX		 printenv
FLAGS		 (none)
EXAMPLES	 printenv Print the environment

Printenv prints out the current environment strings, one per line.

(ast)

# printroot
	 printroot (1)
COMMAND		 printroot - print the name of the root device on standard 
			     output
SYNTAX		 printroot
FLAGS		 (none)
EXAMPLES	 printroot   Print the name of the root device

	 Printroot is useful for initializing the /etc/mtab entry when
the system is booted.  It figures out what the root device is by
searching /dev until it finds a block special file with the right
major/minor device numbers.

(ast)

# ps
	 ps (1)
COMMAND		 ps - process status
SYNTAX		 ps [-alxU] [kernel mm fs]
FLAGS		 -a Print all processes with controlling terminals
     		 -l Give long listing
     		 -x Include processes without a terminal
     		 -U Update (optional) name database
EXAMPLES	 ps -axl 	Print all processes and tasks in long format
        	 ps -U /kernel /mm /fs 
				Update database with given namelists

Ps prints the status of active processes.  Normally only the caller's
own processes are listed in short format (the PID, TTY, TIME and CMD
fields as explained below).  The long listing contains:
  F	Kernel flags:
		001: free slot
		002: no memory map
		004: sending;
		010: receiving
		020: inform on pending signals
		040: pending signals
		100: being traced.
  S	State:
		R: runnable
		W: waiting (on a message)
		S: sleeping (i.e.,suspended on MM or FS)
		Z: zombie
		T: stopped
  UID, PID, PPID, PGRP
	The user, process, parent process and process group ID's.
  ADDR, SZ
	Decimal address and size of the process in kilobytes.
  RECV
	Process/task on which a receiving process is waiting or sleeping.
  TTY	
	Controlling tty for the process.
  TIME
	Process' cumulative (user + system) execution time.
  CMD	Command line arguments of the process.

If extra arguments (the kernel, mm and fs nonstripped executables) are
given, these are used to obtain the system addresses from (instead of the
default system executables).  This applies to the -U option also.  
This option creates /etc/psdatabase that contains system addresses and 
terminal names, after which ps is faster and doesn't need the system 
executables anymore.

The default system executables are /usr/src/{kernel/kernel,mm/mm,fs/fs}.

If the database is updated, an old psdatabase exists, and no paths are
given to ps, it uses the paths that were previously stored in the
database.  A ps -U in /etc/rc thus generally ensures an up-to-date
database.

The files /dev/{mem,kmem} are used to read the system tables and
command line arguments from.  Terminal names in /dev are used to
generate the mnemonic names in the TTY column, so ps is independent of
terminal naming conventions.

Warning: ps depends heavily on up-to-date system addresses and
parameters.  It prints messages when they appear to be outdated.  

(ast)

# pwd
	 pwd (1)
COMMAND		 pwd - print working directory
SYNTAX		 pwd
FLAGS		 (none)
EXAMPLES	 pwd Print the name of the working directory

The full path name of the current working directory is printed.

(ast)

# query
	query(1)

NAME:	query

SYNTAX:	query [arg1] [arg2] ...

FLAGS:	none

EXAMPLES:
	query 		# prompt "Yes or no? (Y/n) " and wait for response
	query Do you want to mount /usr?
			# prompt "Do you want to mount /usr?" and wait
		
DISCUSSION
	Query repeats its arguments (if any) as a prompt and then waits for
input. If no arguments are supplied a built in prompt is issued. If the
response is 'n' or 'N' query returns an exit status of false, for any other
input true is returned.

(asw 11.4.93)

# rcp
	 rcp (1)
COMMAND		 rcp - remote copy [IBM]
SYNTAX		 rcp [machine1!]file1 [machine2!]file2
FLAGS		 (none)
EXAMPLES	 rcp file mach1!/usr/ast/x 	Local file to remote machine
        	 rcp mach2!/usr/ast/x file 	Fetch remote file x

Rcp is not a program.  It is a shell script that does remote copying.
It makes use of the programs to and from.

(ast)

# readall
	 readall (1)
COMMAND		 readall - read a device quickly to check for bad blocks
SYNTAX		 readall [-bt] file
FLAGS		 -b Produce shell script on stdout that calls badblocks
     		 -t Just print device size
EXAMPLES	 readall /dev/hd0 Read all of /dev/hd0
        	 readall -b /dev/hd1 >s Generate shell script on s

Readall reads all of the named device in large chunks.  It reports
about blocks that it cannot read.  Unlike diskcheck, it does not
attempt to write on the disk, making it safer to use when one is
worried about a sick system.  When the -b flag is given, the output is
a shell script that calls the badblocks program to marked all the bad
blocks.  Whenever installing MINIX, it is wise to run readall with the
-b flag first on all the hard disks.

(ast)

# readclock
	 readclock (1)
COMMAND		 readclock - read the real time clock [IBM PC/AT and AMIGA]
SYNTAX		 readclock
FLAGS		 (none)
EXAMPLES	 date \`/usr/bin/readclock\` </dev/tty Useful in /etc/rc

Readclock reads the AT's real time clock and prints the result in a
form useful to date, namely, MMDDYYhhmmss.  If the clock does not exist
(e.g., on a PC), it outputs -q to query the user for the time.  The
example given above can be put in /etc/rc to load the real time when
the system is booted.

(ast)

# readfs
	 readfs (1)
COMMAND		 readfs - read a MINIX file system
SYNTAX		 readfs [-il] block_special [dir]
FLAGS		 -i Give information about the file, but do not extract files
     		 -l List the files extracted on standard output
EXAMPLES	 readfs -l /dev/fd0 	List contents of diskette disk

Readfs reads a diskette containing a MINIX file system.  It can extract
all the files from it, give a listing of them, or both.  The files
extracted can be put in a user-specified directory (default: current
directory).  If subdirectories are needed, they will be created
automatically.

(ast)

# recover
	 recover (1)
COMMAND		 recover - recover files that have been removed.
SYNTAX		 recover file ...
FLAGS		 (none)
EXAMPLES	 rm x; recover x Unremove x
        	 recover a b c Recover three files

MINIX allows files that have been deleted (e.g., with rm) to be
restored (in /tmp).  The trick is that when a file is unlinked, its
i-node number is kept in the directory entry.  As long as the directory
entry and disk blocks are not reused, the file can be recovered.  This
program is actually just a little front end for de, which must be
installed and executable ast setuid root.

(ast)

# ref
	 ref (1)
COMMAND		 ref - look up a reference in a tags file
SYNTAX		 ref function
FLAGS		 (none)
EXAMPLES	 ref func Find func

Ref looks up a function name in the refs file in the current directory.
This file is usually made by ctags.

(ast)

# rev
	 rev (1)
COMMAND		 rev - reverse the characters on each line of a file
SYNTAX		 rev [file] ...
FLAGS		 (none)
EXAMPLES	 rev file Reverse each line

Each file is copied to standard output with all the characters of each
line reversed, last one first and first one last.

(ast)

# rm
	############ NEXT ENTRY HAS NOT BEEN CHECKED #############
	 rm (1)
COMMAND		 rm - remove a file
SYNTAX		 rm [-Rfir] name ...
FLAGS		 -f Forced remove: no questions asked
     		 -i Interactive remove: ask before removing
     		 -R Remove directories too
     		 -r Same as -R
EXAMPLES	 rm file Remove file
        	 rm -i *.c Remove .c files, asking about each

	 Rm removes one or more files.  If a file has no write
permission, rm asks for permission (type y or n) unless -f is
specified.  If the file is a directory, it will be recursively
descended and removed if and only if the -R flag is present.

(ast)

# rmdir
	 rmdir (1)
COMMAND		 rmdir - remove a directory
SYNTAX		 rmdir directory ...
FLAGS		 (none)
EXAMPLES	 rmdir /user/ast/foobar Remove directory foobar
        	 rmdir /user/ast/f* Remove 0 or more directories

The specified directories are removed.  Ordinary files are not removed.
The directories must be empty.

(ast)

# roff
	 roff (1)
COMMAND		 roff - text formatter
SYNTAX		 roff [-hs] [+n] [-n] file ...
FLAGS		 -h Expand tabs to spaces in output
     		 -s Stop before each page; continue on DEL
     		 +n Start printing with page n
     		 -n Stop after page n
EXAMPLES	 roff file Run off file
        	 roff +5 file Run off file starting at page 5

	 Roff is a text formatter.  Its input consists of the text to
be output, intermixed with formatting comman ds.  A formatting command
is a line containing the control character followed by a two character
command name, and possibly one or more arguments.  The control
character is initially .  (dot).  The formatted output is produced on
standard output.

The formatting commands are listed below, with n being a number, c
being a character, and t being a title.  A + before n means it may be
signed, indicating a positive or negative change from the current
value.  Initial values for n , where relevant, are given in parentheses.

	.ad	Adjust right margin.
	.ar	Arabic page numbers.
	.br	Line break.  Subsequent text will begin on a new line.
	.bl n	Insert n blank lines.
	.bp +n	Begin new page and number it n. No n means +1.
	.cc c	Control character is set to c.
	.ce n	Center the next n input lines.
	.de zz	Define a macro called zz. A line with ".." ends definition.
	.ds	Double space the output. Same as .ls 2.
	.ef t	Even page footer title is set to t.
	.eh t	Even page header title is set to t.
	.fi	Begin filling output lines as full as possible.
	.fo t	Footer titles (even and odd) are set to t.
	.hc c	The character c (e.g., %) tells roff where hyphens are 
		permitted.
	.he t	Header titles (even and odd) are set to t.
	.hx	Header titles are suppressed.
	.hy n	Hyphenation is done if n is 1, suppressed if it is 0. Default
		is 1.
	.ig	Ignore input lines until a line beginning with ".." is found.
	.in n	Indent n spaces from the left margin; force line break.
	.ix n	Same as .in but continue filling output on current line.
	.li n	Literal text on next n lines.  Copy to output unmodified.
	.ll +n	Line length (including indent) is set to n (65).
	.ls +n	Line spacing: n (1) is 1 for single spacing, 2 for double, etc.
	.m1 n	Insert n (2) blank lines between top of page and header.
	.m2 n	Insert n (2) blank lines between header and start of text.
	.m3 n	Insert n (1) blank lines between end of text and footer.
	.m4 n	Insert n (3) blank lines between footer and end of page.
	.na	No adjustment of the right margin.
	.ne n	Need n lines.  If fewer are left, go to next page.
	.nn +n	The next n output lines are not numbered.
	.n1	Number output lines in left margin starting at 1.
	.n2 n	Number output lines starting at n.  If 0, stop numbering.
	.ni +n	Indent line numbers by n (0) spaces.
	.nf	No more filling of lines.
	.nx f	Switch input to file f.
	.of t	Odd page footer title is set to t.
	.oh t	Odd page header title is set to t.
	.pa +n	Page adjust by n (1).  Same as .bp
	.pl +n	Paper length is n (66) lines.
	.po +n	Page offset.  Each line is started with n (0) spaces.
	.ro	Page numbers are printed in Roman numerals.
	.sk n	Skip n pages (i.e., make them blank), starting with next one.
	.sp n	Insert n blank lines, except at top of page.
	.ss	Single spacing.  Equivalent to .ls 1.
	.ta	Set tab stops, e.g., .ta 9 17 25 33 41 49 57 65 73 (default).
	.tc c	Tabs are expanded into c.  Default is space.
	.ti n	Indent next line n spaces; then go back to previous indent.
	.tr ab	Translate a into b on output.
	.ul n	Underline the letters and numbers in the next n lines.

(ast)

# rsh
	 rsh (1)
COMMAND		 rsh - remote shell for networking [IBM]
SYNTAX		 rsh [-bei] port
FLAGS		 -b Start the rsh in the background
     		 -e Keep stderr separate from stdout
     		 -i Take input from the local process
EXAMPLES	 rsh machine5 ls -l /usr/bin List remote bin directory
        	 rsh abc cat /usr/doc/f >f Fetch remote file
        	 rsh foobar Log onto remote machine

The remote shell command is the way to have a distant server carry out
a command over the Ethernet.  The port given as the first argument can
be any string of up to 6 characters, but it must match the port used by
some sherver.  The command will be executed and the results returned on
stdout\f R.  Unless the -e flag is given, the remote stderr and stdout
are merged onto the local stdout.  Giving rsh with just a port and no
argument is the standard way to log onto a remote machine.

(ast)

# rz
	 rz (1)
COMMAND		 rz - receive a file using the zmodem protocol
SYNTAX		 rz [-abepqvy] [-t timeout]
FLAGS		 -a CP/M to UNIX conventions
     		 -b Binary file
     		 -e Escape for all control characters
     		 -p Protect file if it already exists
     		 -q Quiet; opposite of verbose
     		 -t Set timeout in tenths of a second
     		 -v Verbose; opposite of quiet
     		 -y Yes, clobber existing files
EXAMPLES	 rz </dev/tty1 >/dev/tty1 Receive a file

Rz is a program that accepts a file sent from another computer using
the zmodem protocol.  It is a highly complex program.  See Chap 9 for
more details.

(ast)

# scrndump
	scrndump(1)

COMMAND:
	scrndump - read video memory and write to standard output 

SYNTAX:
	scrndump [[-]n1 [[-]n2]]

FLAGS: 
	[-]n1  Start at line n1 (0 <= n1 <= 24)
	[-]n2  Finish at line n2 (0 <= n2 <= 24, n1 <= n2)

EXAMPLES:
	scrndump > screen.txt
			# Copy the screen to file screen.txt
	scrndump -1 -10 > file
			# write lines 1..10 to file
	scrndump 5 20 > file.txt.txt
			# write lines 5..20 to file.txt

DISCUSSION:

	Scrndump captures the screen and writes it to standard output.
It uses the BIOS parameter block video mode byte to determine whether
the video buffer is at 0xb0000 (monochrome standard) or 0xb8000 (color
standard). 
	Software scrolling mode must be selected (with F3) before using 
scrndump.

BUGS:
	Handling of incorrect parameters is not correct.  Ridiculous
arguments should trigger a usage message.
	Scrndump has only been tested on a few video display adapters,
using standard 24 column x 80 row text displays.  Your mileage may vary.

AUTHOR:
	Albert S. Woodhull   awoodhull@hamp.hampshire.edu   16.02.95

# sed
	 sed (1)
COMMAND		 sed - stream editor
SYNTAX		 sed [-egn] [-f script_file] [edit_script] [file]
FLAGS		 -e Accept multiple commands commands on the commands line
     		 -f The following argument contains the edit script
     		 -g Set the global flag on all substitute commands
     		 -n Only output selected lines
EXAMPLES	 sed -f script <file 		Run a sed script on file
        	 sed '/pig/s//hog/g'<file 	Replace pig by hog in the file

Sed is a stream editor.  It takes an edit script either from its
argument or a file, and performs an edit session on a named file or
stdin, producing output on stdout.

(ast)

# sh
	 sh (1)
COMMAND		 sh - shell
SYNTAX		 sh [file]
FLAGS		 (none)
EXAMPLES	 sh < script Run a shell script

	 Sh is the shell.  It permits redirection of input and output,
pipes, magic characters, background processes, shell scripts and most
of the other features of the V7 (Bourne) shell.  A few of the more
common commands are listed below:

date			# Regular command
sort <file		# Redirect stdin
sort <file1  >file2	# Redirect stdin and stdout
cc file.c  2>error	# Redirect stderr
a.out >f  2>&1		# Combine standard output and standard error
sort <file1  >>file2	# Append output to file2
sort <file1  >file2 &	# Background job
(ls -l; a.out) &	# Run two background commands sequentially
sort <file | wc		# Two-process pipeline
sort <f | uniq | wc	# Three-process pipeline
ls -l *.c		# List all files ending in .c
ls -l [a-c]*		# List all files beginning with a, b, or c
ls -l ?			# List all one-character file names
ls \?			# List the file whose name is question mark
ls '???'		# List the file whose name is three question marks
v=/usr/ast		# Set shell variable v
ls -l $v		# Use shell variable v
PS1='Hi! '		# Change the primary prompt to Hi!
PS2='More: '		# Change the secondary prompt to More: 
ls -l $HOME		# List the home directory
echo $PATH		# Echo the search path
if ... then ... else ... fi	# If statement
for ... do ... done	# Iterate over argument list
while ... do ... done	# Repeat while condition holds
case ... in ...  esac	# Select clause based on condition
echo $?			# Echo exit status of previous command
echo $$			# Echo shell's pid
echo $#			# Echo number of parameters (shell script)
echo $2			# Echo second parameter (shell script)
echo $*			# Echo all parameters (shell script)

(ast)

# shar
	 shar (1)
COMMAND		 shar - shell archiver
SYNTAX		 shar file ...
FLAGS		 (none)
EXAMPLES	 shar *.c >s Collect C programs in shell archive
        	 sh <s Extract files from a shell archive

The named files are collected together into a shell archive written
onto standard output.  The individual files can be extracted by
redirecting the shell archive into the shell.  The advantage of shar
over ar is that shar archives can be read on almost any UNIX system,
whereas numerous, incompatible versions of ar are in widespread use.
Extracting the files from a shell archive requires that sed be
accessible.

(ast)

# sherver
	 sherver (1)
COMMAND		 sherver - shell server [IBM]
SYNTAX		 sherver port
FLAGS		 (none)
EXAMPLES	 sherver machine1 Start a sherver listening to port

The rsh command does its remote execution by doing a remote procedure
call to some sherver.  The sherver executes the command and then exits.
Usually a master will be running to make a new one.  Because shervers
get their input from a pipe, remote execution cannot handle signals and
CTRL-D, because they cannot be sent down a pipe.

(ast)

# size
	 size (1)
COMMAND		 size - print text, data, and bss size of a program
SYNTAX		 size [file] ...
FLAGS		 (none)
EXAMPLES	 size file Print the size of file

The text, data, bss, and total sizes for each argument are printed.  If
no arguments are present, a.out is assumed.  The amount of memory
available for combined stack and data segment growth is printed in the
column stack.  This is the value manipulated by the chmem command.  The
total amount of memory allocated to the program when it is loaded is
listed under memory.  This value is just the sum of the other four
columns.

(ast)

# sleep
	 sleep (1)
COMMAND		 sleep - suspend execution for a given number of seconds
SYNTAX		 sleep seconds
FLAGS		 (none)
EXAMPLES	 sleep 10 Suspend execution for 10 sec.

The caller is suspended for the indicated number of seconds.  This
command is typically used in shell scripts.

(ast)

# sort
	 sort (1)
COMMAND		 sort - sort a file of ASCII lines
SYNTAX		 sort [-bcdfimnru] [-t<c>]  [-o <name>] [+<pos1>] [-<pos2>] 
			file ...
FLAGS		 -b Skip leading blanks when making comparisons
     		 -c Check to see if a file is sorted
     		 -d Dictionary order: ignore punctuation
     		 -f Fold upper case onto lower case
     		 -i Ignore nonASCII characters
     		 -m Merge presorted files
     		 -n Numeric sort order
     		 -o Next argument is output file
     		 -r Reverse the sort order
     		 -t Following character is field separator
     		 -u Unique mode (delete duplicate lines)
EXAMPLES	 sort -nr file 		Sort keys numerically, reversed
        	 sort +2 -4 file 	Sort using fields 2 and 3 as key
        	 sort +2 -t: -o out 	Field separator is :
        	 sort +.3 -.6 		Characters 3 through 5 form the key

	 Sort sorts one or more files.  If no files are specified,
stdin is sorted.  Output is written on standard output, unless -o is
specified.  The options +pos1 -pos2 use only fields pos1 up to but not
including pos2 as the sort key, where a field is a string of characters
delimited by spaces and tabs, unless a different field delimiter is
specified with -t.  Both pos1 and pos2 have the form m.n where m tells
the number of fields and n tells the number of characters.  Either m or
n may be omitted.

(ast)

# spell
	 spell (1)
COMMAND		 spell - print all words in a file not present in the 
			dictionary
SYNTAX		 spell file
FLAGS		 (none)
EXAMPLES	 spell document Print the spelling errors on stdout

Spell is the MINIX spelling checker.  It is actually a short shell
script.  First, the program prep strips off the roff, nroff, and troff
control lines, and the punctuation, and lists each word on a separate
line.  These words are then sorted.  The resulting output is then
compared to the dictionary.  Words present in the file but not present
in the dictionary are listed.  The dictionary must be located in
/usr/lib/dictionary.

(ast)

# split
	 split (1)
COMMAND		 split - split a large file into several smaller files
SYNTAX		 split [-n] [file [prefix]]
FLAGS		 -n Number of lines per piece (default: 1000)
EXAMPLES	 split -200 file Split file into pieces of 200 lines each
        	 split file z 	 Split file into zaa, zab, etc.

	 Split reads file and writes it out in n-line pieces.  By
default, the pieces are called xaa, xab, etc.  The optional second
argument can be used to provide an alternative prefix for the output
file names.

(ast)

# strings
	 strings (1)
COMMAND		 strings - print all the strings in a binary file
SYNTAX		 strings [-] [-o] [-n] file ...
FLAGS		 - search whole file, not just data seg
     		 -o Print octal offset of each string
     		 -n n is minimum length string (default = 4)
EXAMPLES	 strings -5 a.out Print the strings > 4 chars in a.out
        	 strings - /bin/sh Search entire shell file (text and data)

Strings looks for sequences of ASCII characters followed by a zero
byte.  These are usually strings.  This program is typically used to
help identify unknown binary programs

(ast)

# strip
	 strip (1)
COMMAND		 strip - remove symbol table from executable file
SYNTAX		 strip [file] ...
FLAGS		 (none)
EXAMPLES	 strip a.out Remove symbols from a.out

For each file argument, strip removes the symbol table.  Strip makes a
copy of the file being stripped, so links are lost.

(ast)

# stty
	 stty (1)
COMMAND		 stty - set terminal parameters
SYNTAX		 stty [option ...]
FLAGS		 (none)
EXAMPLES	 stty -echo Suppress echoing of input
        	 stty erase # Set the erase character to #

When given no arguments, stty prints the current terminal parameters.
It can also be used to set the parameters, as follows:

	cbreak		- Enter cbreak mode; erase and kill disabled
	echo		- Echo input on the terminal
	nl		- Accept only line feed to end lines
	raw		- Enter raw mode; no input processing at all
	tabs		- Output tabs (do not expand to spaces)
	erase c		- Set erase character (initially backspace)
	int c		- Set interrupt (SIGINT) character (initially DEL)
	kill c		- Set kill line character (initially @)
	quit c		- Set quit (SIGQUIT) character (initially CTRL-\\)
	even		- Use even parity
	odd		- Use odd parity
	[5-8]		- Number of bits per character
	[110-9600]	- Baud rate
	default		- Set options back to original values

The first five options may be prefixed by - as in -tabs to turn the
option off.  The next four options each have a single character
parameter separated by a space from the option.  The default option
sets the mode and the four settable characters back to the values they
had when the system was booted.  It is useful when a rogue program has
messed them up.

(ast)

# su
	 su (1)
COMMAND		 su - temporarily log in as superuser or another user
SYNTAX		 su [name]
FLAGS		 (none)
EXAMPLES	 su~~~~ Become superuser
        	 su ast Become ast

	 Su can be used to temporarily login as another user.  It
prompts for the superuser password.  If the correct password is
entered, su creates a shell with the desired uid.  If no name is
specified, root is assumed.  To exit the temporary shell, type CTRL-D.
When memory is tight, it is better to become superuser by logging out
and then logging in again as root, rather than using su since the
latter creates an extra shell in memory.

(ast)

# sum
	 sum (1)
COMMAND		 sum - compute the checksum and block count of a file
SYNTAX		 sum file
FLAGS		 (none)
EXAMPLES	 sum /user/ast/xyz Checksum /user/ast/xyz

	 Sum computes the checksum of one or more files.  It is most
often used to see if a file copied from another machine has been
correctly received.  This program works best when both machines use the
same checksum algorithm.  See also crc.

(ast)

# svc
	 svc (1)
COMMAND		 svc - shell version control system
SYNTAX		 ci [-lu] file
SYNTAX		 co [-l] [-r rev] file
		 svc file
FLAGS		 -l For ci, checkin, checkout again, and lock file
     		 -l For co, checkout file and then lock the archive
     		 -u After checking in, do not delete the file
     		 -r Check out revision rev instead most recent revision
EXAMPLES	 ci -u file Check in file
        	 co -l file Check out file and lock archive
        	 co -r 2 file Check out version 2

Svc is the Shell Version Control system, patterned on RCS.  It
maintains a sequence of versions in archive files, so that new versions
can be checked in (added to the archive), and old versions can be
checked out (made available).  To create an archive for file, check it
in with the -u flag.  This action will prompt for a log message and
then create an archive called file,S in the current directory, or in
the subdirectory SVC if it exists.  The file will not be deleted, but
will be made unwritable.

To update the file, check it out with the -l flag.  Then modify it, and
check it back in, giving a new message when prompted.  After this
process has been repeated many times, the archive will contain the
entire history.  Any version can be checked out using the -r flag.  To
get a printout of the history, use svclog.

(ast)

# sync
	 sync (1)
COMMAND		 sync - flush the cache to disk
SYNTAX		 sync
FLAGS		 (none)
EXAMPLES	 sync Write out all modified cache blocks

MINIX maintains a cache of recently used disk blocks.  The sync command
writes any modified cache blocks back to the disk.  This is essential
before stopping the system, and should be done before running any a.out
program that might crash.

(ast)

# sz
	 sz (1)
COMMAND		 sz - send a file using the zmodem protocol
SYNTAX		 sz [-LNbdefnopqruvy+] [-ci command] [-Ll n] [-t timeout]
FLAGS		 -L Use n-byte packets
     		 -N Overwrite if source is newer/longer
     		 -b Binary file
     		 -c Send command for execution
     		 -d Convert dot to slash in names
     		 -e Escape for all control characters
     		 -f Send full path name
     		 -i Send command and return immediately
     		 -l Flow control every n packets
     		 -n Overwrite destination if source is newer
     		 -o Use old (16-bit) checksum
     		 -p Protect file if it already exists
     		 -q Quiet; opposite of verbose
     		 -r Resume interrupt file transfer
     		 -t Set timeout in tenths of a second
     		 -u Unlink file after successful transmission
     		 -v Verbose; opposite of quiet
     		 -y Yes, clobber existing files
     		 -+ Append to an existing file
EXAMPLES	 sz file </dev/tty1 >/dev/tty1 Send file

XMODEM, YMODEM, and ZMODEM are a family of protocols that are widely
used is the MS-DOS world for transferring information reliably from one
computer to another.  In all of these protocols, a series of bytes are
sent from one computer to the other, and then an acknowledgement is
sent back to confirm correct reception.  Checksums are used to detect
errors so that transmission is reliable even in the face of noisy
telephone lines.  Sz is a program that sends a file sent from another
computer using the zmodem protocol.  The file can be received using rz.
Both are a highly complex programs.  See Chap.  9 for more information.
For an alternative, see kermit.

(ast)

# tail
	 tail (1)
COMMAND		 tail - print the last few lines of a file
SYNTAX		 tail [-c n] [-f] [-n n] [file] ...

FLAGS		 -c The count refers to characters
     		 -f On FIFO or special file, keep reading after EOF
     		 -n The count refers to lines
EXAMPLES	 tail -n 6 Print last 6 lines of stdin
        	 tail -c 20 file Print the last 20 characters of file
        	 tail -n 1 file1 file2 Print last line of two files
        	 tail -n +8 file Print the tail starting with line 8

The last few lines of one or more files are printed.  The default count
is 10 lines.  The default file is stdin.  If the value of n for the -c
or -n flags starts with a + sign, counting starts at the beginning,
rather than the end of the file.

(ast)

# tar
	 tar (1)
COMMAND		 tar - tape archiver
SYNTAX		 tar [Fcotvx] [f] tarfile file ...
FLAGS		 F Force tar to continue after an error
     		 c Create a new archive; add named files
     		 o Set uid/gid to original values on extraction
     		 f Next argument is name of tarfile
     		 t Print a table listing the archive's contents
     		 v Verbose mode-tell what is going on as it happens
     		 x The named files are extracted from the archive
EXAMPLES	 tar c /dev/fd1 	Back up current directory to /dev/fd1
        	 tar xv /dev/fd1 file1 file2 
					Extract two files from the archive
        	 tar cf - | (cd dest; tar xf -) 
					Copy current directory to dest

Tar is a POSIX-compatible archiver, except that it does not use tape.
It's primary advantage over ar is that the tar format is somewhat more
standardized than the ar format, making it theoretically possible to
transport MINIX files to another computer, but do not bet on it.  If
the target machine runs MSDOS try doswrite.

(ast)

# term
	 term (1)
COMMAND		 term - turn PC into a dumb terminal [IBM]
SYNTAX		 term [baudrate] [parity] [bits_per_character]
FLAGS		 (none)
EXAMPLES	 term 2400 Talk to modem at 2400 baud
        	 term 1200 7 even 1200 baud, 7 bits/char, even parity
        	 term 8 9600 9600 baud, 8 bits/char, no parity

Term allows MINIX to talk to a terminal or modem over RS232 port 1.
The program first sets the baudrate, parity and character length, and
then forks.  The parent sits in a loop copying from stdin (usually the
console's keyboard), to the terminal or modem (/dev/tty1).  The child
sits in a loop copying from the terminal or modem (/dev/tty1) to
standard output.  Thus when RS232 port 1 is connected to a modem, every
keystroke typed on the keyboard is sent to the modem, and every
character arriving from the modem is displayed

Standard input and output may be redirected, to provide a primitive
file transfer program, with no checking.  To exit term, hit the middle
button on the numeric pad.  

Important note: to use term, it is essential that /etc/ttys is
configured so that there is no shell hanging on /dev/tty1.  If there
is, both the shell and term will try to read from /dev/tty1, and
nothing will work.

(ast)

# termcap
	 termcap (1)
COMMAND		 termcap - print the current termcap entry
SYNTAX		 termcap [type]
FLAGS		 (none)
EXAMPLES	 termcap Print the termcap entry

Termcap reads the /etc/termcap entry corresponding to the terminal type
supplied as the argument.  If none is given, the current $TERM is used.
It then prints out all the parameters that apply.

(ast)

# test [ 
	 test (1),  [ (1)
COMMAND		 test - test for a condition
SYNTAX		 test expr
FLAGS		 (none)
EXAMPLES	 test -r file See if file is readable

Test checks to see if files exist, are readable, etc.  and returns an
exit status of zero if true and nonzero if false.  The legal operators
are

	-r file		true if the file is readable
	-w file		true if the file is writable
	-x file		true if the file is executable
	-f file		true if the file is not a directory
	-d file		true if the file is a directory
	-s file		true if the file exists and has a size > 0
	-t fd		true if file descriptor fd (default 1) is a terminal
	-z s		true if the string s has zero length
	-n s		true if the string s has nonzero length
	s1 = s2		true if the strings s1 and s2 are identical
	s1 != s2	true if the strings s1 and s2 are different
	m -eq m		true if the integers m and n are numerically equal


The operators -gt, -ge, -ne, -le, and -lt may be used as well.  These
operands may be combined with -a (Boolean and), -o (Boolean or), !
(negation).  The priority of -a is higher than that of -o.  Parentheses
are permitted, but must be escaped to keep the shell from trying to
interpret them.

The square bracket "[" is usually defined as a link to test, allowing
one to write concise conditional statements such as
	if [ x%1 != x ]; then echo "OK"; fi

(ast, rev. by asw 14.02.95))

# time
	 time (1)
COMMAND		 time - report how long a command takes
SYNTAX		 time command
FLAGS		 (none)
EXAMPLES	 time a.out Report how long a.out takes
        	 time ls -l *.c Report how long ls takes

The command is executed and the real time, user time, and system time
(in hours, minutes, and seconds) are printed.  Shell scripts cannot be
timed.

(ast)

# to
	 to (1)
COMMAND		 to - output half of a connection [IBM]
SYNTAX		 to port
FLAGS		 (none)
EXAMPLES	 cat f1 f2 | to mach4 Send the catted files to port

To and from are used together to provide connection-oriented service.
On the sending machine, the last member of a pipeline is to port.  On
the receiving machine, the first member of a pipe line is from port.
The ne t result is that the output of the sending pipeline goes into
the input of the receiving pipeline, making pipelines work across the
network.  As a simple example, consider:

	on machine1:	cat f1 f2 | to Johnny
	on machine2:	from Johnny | sort >x

The effect of these two commands is that the files f1 and f2 are
concatenated, transferred to machine 2, and sorted there, with the
output going to a file x on machine 2.  The string Johnny is used by
the transaction system to identify which sender goes with which
receiver; any unique string can be used.  Multiple transfers may take
place simultaneously between different pairs of machines on the same
Ethernet.

(ast)

# touch
	 touch (1)
COMMAND		 touch - update a file's time of last modification
SYNTAX		 touch [-c] file ...
FLAGS		 -c Do not create the file
EXAMPLES	 touch *.h Make the .h files look recent

The time of last modification is set to the current time.  This command
is mostly used to trick make into thinking that a file is more recent
than it really is.  If the file being touched does not exist, it is
created, unless the -c\f R flag is present.

(ast)

# tr
	 tr (1)
COMMAND		 tr - translate character codes
SYNTAX		 tr [-cds] [string1] [string2]
FLAGS		 -c Complement the set of characters in string1
     		 -d Delete all characters specified in string1
     		 -s Squeeze all runs of characters in string1 to one character

EXAMPLES	 tr '[a-z]' '[A-Z]' <x >y	Convert upper case to l
ower case
        	 tr -d '0123456789'<f1 >f2	Delete all digits from f1

	 Tr performs simple character translation.  When no flag is
specified, each character in string1 is mapped onto the corresponding
character in string2 .

(ast)

# traverse
	 traverse (1)
COMMAND		 traverse - print directory tree under the named directory
SYNTAX		 traverse dir
FLAGS		 (none)
EXAMPLES	 traverse . Print tree starting at working dir

Traverse prints the tree structure starting at the named directory. 
All the subdirectories are listed, with the depth shown by indentation.

(ast)

# treecmp
	 treecmp (1)
COMMAND		 treecmp - recursively list differences in two directory trees
SYNTAX		 treecmp [-cv] olddir newdir
FLAGS		 -c (changes) list the names of changed or new files
     		 -v (verbose) list all directories processed
EXAMPLES	 treecmp -v /usr/ast/V1 /usr/ast/V2 Compare two trees

Treecmp recursively descends the directory tree of its second argument
and compares all files to those at the corresponding position in the
first argument.  If the two trees are identical, i.e., all the
corresponding directories and files are the same, there is no output.
Otherwise, a list of files missing from one of the trees or present in
both but whose contents are not identical in both are printed.  When
the -c flag is given, only files that are changed from the old version
or are new (i.e., absent in the old version) are listed.

(ast)

# true
	 true (1)
COMMAND		 true - exit with the value true
SYNTAX		 true
FLAGS		 (none)
EXAMPLES	 while true 		List the directory until DEL is hit
		 do ls -l
		 done

This command returns the value true .  It is used for shell
programming.  The program is in reality not a program at all.  It is
the null file.

(ast)

# tset
	 tset (1)
COMMAND		 tset - set the $TERM variable
SYNTAX		 tset [device]
FLAGS		 (none)
EXAMPLES	 eval \`tset\` Set TERM

Tset is used almost exclusively to set the shell variable TERM from
inside profiles.  If an argument is supplied, that is used as the value of
TERM.  Otherwise it looks in /etc/ttytype.

(ast)

# tsort
	 tsort (1)
COMMAND		 tsort - topological sort [IBM]
SYNTAX		 tsort file
FLAGS		 (none)
EXAMPLES	 lorder *.s | tsort Give library ordering
        	 ar cr libc.a \`lorder *.s | tsort\` Build library

Tsort accepts a file of lines containing ordered pairs and builds a
total ordering from the partial orderings.

(ast)

# tty
	 tty (1)
COMMAND		 tty - print the device name of this tty
SYNTAX		 tty [-s]
FLAGS		 -s Silent mode, only the exit status is affected.
EXAMPLES	 tty~~~ Print the tty name

Print the name of the controlling tty.  If the flag -s is given, tty is
equivalent to the call to isatty().

(ast)

# umount
	 umount (1)
COMMAND		 umount - unmount a mounted file system
SYNTAX		 /etc/umount special
FLAGS		 (none)
EXAMPLES	 /etc/umount /dev/fd1 Unmount diskette 1

A mounted file system is unmounted after the cache has been flushed to
disk.  A diskette should never be removed while it is mounted.  If this
happens, and is discovered before another diskette is inserted, the
original one can be replaced without harm.  Attempts to unmount a file
system holding working directories or open files will be rejected with
a device busy message.

(ast)

# unexpand
	 unexpand (1)
COMMAND		 unexpand - convert spaces to tabs
SYNTAX		 unexpand [-a]
FLAGS		 -a All spaces are unexpanded
EXAMPLES	 unexpand oldfile >newfile Convert leading spaces to tabs

Unexpand replaces spaces in the named files with tabs.  If no files are
listed, stdin is given.  The -a flag is used to force all sequences of
spaces to be expanded, instead of just leading spaces (the default).

(ast)

# uniq
	 uniq (1)
COMMAND		 uniq - delete consecutive identical lines in a file
SYNTAX		 uniq [-cdu] [-n] [+n] [input [o
utput]]
FLAGS		 -c Give count of identical lines in the input
     		 -d Only duplicate lines are written to output
     		 -u Only unique lines are written to output
     		 -n Skip the first n columns when matching
     		 +n Skip the first n fields when matching
EXAMPLES	 uniq +2 file Ignore first 2 fields when comparing
        	 uniq -d inf outf Write duplicate lines to outf

	 Uniq examines a file for consecutive lines that are identical.
All but duplicate entries are deleted, and the file is written to
output.  The +n option skips the first n fields, where a field is
defined as a run of characters separated by white space.  The -n option
skips the first n spaces.  Fields are skipped first.

(ast)

# unshar
	 unshar (1)
COMMAND		 unshar - Remove files from a shell archive
SYNTAX		 unshar [-btvx] sharfile member ...
FLAGS		 -b Unshar brutally, overwriting files if need be
     		 -t Tell what is in the archive but do not extract
     		 -v Verbose mode
     		 -x Extract only the members listed
EXAMPLES	 unshar arch.sh 	Extract all members of the archive
        	 unshar -t arch.sh 	List the contents of the archive
        	 unshar -xf1 -xf2 arch.sh 
					Extract f1 and f2 from arch.sh
        	 uniq -d inf outf 	Write duplicate lines to outf

	 Unshar extracts members of a shell archive, the same as sh,
except much faster.  It expects shell archives created with shar.  It
also has options to list the contents of a shell archive, and to
selectively extract some members but not all.

(ast)

# update
	 update (1)
COMMAND		 update - periodically write the buffer cache to disk
SYNTAX		 /etc/update
FLAGS		 (none)
EXAMPLES	 /etc/update & Start a process that flushes the cache

When the system is booted, update is started up in the background from
/etc/rc to issue a sync system call every 30 sec.

(ast)

# users
	 users (1)
COMMAND		 users - list the logged-in users
SYNTAX		 users
FLAGS		 (none)
EXAMPLES	 users list the users

Users prints one line containing the names of all the currently
logged-in users.

(ast)

# uud
	 uud (1)
COMMAND		 uud - decode a binary file encoded with uue
SYNTAX		 uud [-n] [-s srcdir] [-t dstdir/] 
file
FLAGS		 -n Do not verify checksums
     		 -s Name of directory where .uue file is
     		 -t Name of directory where output goes
EXAMPLES	 uud file.uue  Re-create the original file
        	 uud - <file.uue The - means use stdin

Uud decodes a file encoded with uue or UNIX uuencode.  The decoded file
is given the name that the original file had.  The name information is
part of the encoded file.  Mail headers and other junk before the
encoded file are skipped.

(ast)

# uue
	 uue (1)
COMMAND		 uue - encode a binary file to ASCII (e.g., for mailing)
SYNTAX		 uue [-n] file [-]
FLAGS		 -n How many lines to put in each file
EXAMPLES	 uue file Encode file to file.uue
        	 uue file - >x Encode file and write on stdout
        	 uue -800 file Output on file.uaa, file.uab etc.

Uuencode is a famous program that converts an arbitrary (usually
binary) file to an encoding using only 64 ASCII characters.  Uudecode
converts it back to the original file.  The uue and uud programs are
the MINIX versions of these programs, and are compatible with the
UNIX ones.  The files produced can even be sent successfully over
BITNET, which is notorious for mangling files.  It is possible to have
uue automatically split the encoded file up into small chunks.  The
output files then get the suffixes .uaa, .uab, etc., instead of .uue.
When uud is given file.uaa to decode, it automatically includes the
subsequent pieces.  The encoding takes 3 bytes (24 bits) from the input
file and renders it as 4 bytes in the output file.

(ast)

# virecover
	 virecover (1)
COMMAND		 virecover - recover from a crash
SYNTAX		 virecover [file]
FLAGS		 (none)
EXAMPLES	 virecover prog.c Recover prog.c

Virecover is used to recover an edit session after a crash.  Both elvis
and ex keep a scratch files in /usr/tmp.  After an editor crash, this
information is used to reconstruct the file.  If virecover is called
with no file name, it expects one of these temporary files on stdin.

(ast)

# vol
	 vol (1)
COMMAND		 vol - split stdin into diskette-sized volumes
SYNTAX		 vol [-u] size block_special
FLAGS		 -u Unsave from diskettes
EXAMPLES	 tar c - . | vol 360 /dev/fd0 Prompt for disk every 360K
        	 vol -u 360 /dev/fd0 | tar x -  Restore a saved file system

It occasionally happens that a program generates an output stream
intended for diskette but the stream is to large to fit on one
diskette.  Vol is a program that accepts such a stream, and pauses
every n blocks to request a new diskette to be inserted.  This makes it
possible to save arbitrarily long streams on a series of diskettes, as
shown in the examples above.

(ast)

# wc
	 wc (1)
COMMAND		 wc - count characters, words, and lines in a file
SYNTAX		 wc [-clw] file ...
FLAGS		 -c Print character count
     		 -l Print line count
     		 -w Print word count
EXAMPLES	 wc file1 file2 Print all three counts for both files
        	 wc -l file Print line count only

	 Wc reads each argument and computes the number of characters,
words and lines it contains.  A word is delimited by white space
(space, tab, or line feed).  If no flags are present, all three counts
are printed.

(ast)

# whatis
	 whatis (1)
COMMAND		 whatis - tell what the program does
SYNTAX		 whatis name ...
FLAGS		 (none)
EXAMPLES	 whatis head Gives a summary of what the head program does

Whatis searches the /usr/etc/whatis database for the arguments.  For
each name, it prints the corresponding entry.

(ast)

# whatsnew
	 whatsnew (1)
COMMAND		 whatsnew - print a newly modified file, marking changes
SYNTAX		 whatsnew [-n] file.c file.c.cdif
FLAGS		 -n Output line length
EXAMPLES	 whatsnew file.c file.c.cdif 
					Print file.c with changes marked
        	 whatsnew -70 file.c file.c.cdif 
					Same as above, but with 70 col line

It commonly occurs that cdifs are posted to USENET.  After installing a
cdif file, it is sometimes desirable to print out the new file, with
the changes marked on it.  Whatsnew does precisely this, with the
changes + and !  printed in the right-hand margin.

(ast)

# whereis
	 whereis (1)
COMMAND		 whereis - examine system directories for a given file
SYNTAX		 whereis file
FLAGS		 (none)
EXAMPLES	 whereis stat.h Prints: /usr/include/sys/stat.h

Whereis searches a fixed set of system directories, /bin, /lib,
/usr/bin, and others, and prints all occurrences of the argument name
in any of them.

(ast)

# which
	 which (1)
COMMAND		 which - examine $PATH to see which file will be executed
SYNTAX		 which name
FLAGS		 (none)
EXAMPLES	 which a.out Tells which a.out will be executed

The $PATH shell variable controls the MINIX search rules.  If a command
a.out is given, the shell first tries to find an executable file in the
working directory.  If that fails, it looks in various system
directories, such as /bin and /usr/bin.  The which command makes the
same search and gives the absolute path of the program that will be
chosen, followed by other occurrences of the file name along the path.

(ast)

# who
	 who (1)
COMMAND		 who - print list of currently logged in users
SYNTAX		 who [file]
FLAGS		 (none)
EXAMPLES	 who    Print user names, terminals and times

Who prints a list of currently logged in users.  For each one, the user
name, terminal, and login time is printed.  This program gets its
information from the file /etc/utmp, which is updated by init and
login.  If the file does not exist, neither of these will create it,
and who will not work.  Note that if you decide to create an empty
/usr/adm/wtmp to enable the login accounting, it will grow forever and
eventually fill up your disk unless you manually truncate it from time
to time

If an optional file name is provided, the logins in that file will be
printed.

(ast)

# whoami
	 whoami (1)
COMMAND		 whoami - print current user name
SYNTAX		 whoami
FLAGS		 (none)
EXAMPLES	 whoami Print user name

In case you forget who you are logged in as, whoami will tell you.  If
you use su to become somebody else, whoami will give the current
effective user.

(ast)

# width
	 width (1)
COMMAND		 width - force all the lines of a file to a given width
SYNTAX		 width [-n [ infile [outfile]
FLAGS		 -n Outline line size
EXAMPLES	 width -60 x y Copy x to y, force lines to 60 cols
        	 width x Copy default (80) column lines to stdout

The input file is copied to the output file.  All lines are forced to a
given size (default: 80 columns) by padding with spaces or truncating.
Tabs are expanded to spaces.

(ast)

# write
	 write (1)
COMMAND		 write - send a message to a logged-in user
SYNTAX		 write [-cv] user [tty]
FLAGS		 -c Use cbreak mode
     		 -v Verbose mode
EXAMPLES	 write ast Send a message to ast
        	 write ast tty1 Send a message to ast on tty1

Write lets a user send messages to another logged-in user.  Lines typed
by the user appear on the other user's screen a line at a time (a
character at a time in the case of cbreak mode).  The file
/usr/adm/wtmp is searched to determine which tty to send to.  If the
user is logged onto more than one terminal, the tty argument selects
the terminal.  Type CTRL- D to terminate the command.  Use !  as a
shell escape.  

(ast)

# finger 
FINGER (1) USER COMMANDS FINGER (1)

NAME  
     finger - display information about local and remote users.  

SYNOPSYS  
     [0m[1mfinger[0m [ -dv ] [ [0m[4muser[0m [ @ [0m[4mhostname[0m ] ] 

AVAILABILITY  
     This  command  is  available  with  the  TemariNET  software
     package.  

DESCRIPTION  
     The [0m[1mfinger[0m command displays information about  users  logged
     on a  system.   When a [0m[4muser[0m argument is given, more detailed
     information is provided for the [0m[4muser[0m specified, whether they 
     are logged in or not.  If the user is not a local user,  the
     [0m[1mhostname[0m parameter must be provided as well.  

     If  only  the  [0m[1mhostname[0m  parameter  is provided, then [0m[1mfinger[0m
     displays information about each logged in user on the remote 
     host.  

OPTIONS  

     -d  
          Debug mode.  This is really only useful  for  debugging
          purposes.  

     -v  
          Verbose mode.  This is the same as the -d option.  

EXAMPLES  
     finger root 
     finger @nyx.cs.du.edu 
     finger root@nyx.cs.du.edu 

FILES  
     /etc/utmp 
     /usr/adm/wtmp 
     /etc/passwd 
     $HOME/.project 
     $HOME/.plan 

SEE ALSO  
     passwd(1), who(1) 

NOTES  
     Since  Minix  does  not  (yet) handle "TTY Idle" times, idle
     times are not displayed.  

     The Minix login program does not support the "-h" option, so 
     no "Where" field can be displayed.  

AUTHOR  
     Fred N. van Kempen - waltje@uwalt.nl.mugnet.org 

# fingerd
FINGERD (1M)          MAINTENANCE COMMANDS           FINGERD (1M)



NAME  
     fingerd - remote user information server 

SYNOPSIS  
     /etc/tnet/bin/fingerd 

AVAILABILITY  
     This  command  is  available  with  the  TemariNET  software
     package.  

DESCRIPTION  
     [0m[1mfingerd[0m is the server side of the Name/Finger protocol  (RFC
     742).  The  Name/Finger protocol provides a remote interface
     for  programs  which  display  information  on  systems  and
     individual  users.    Little  structure  is imposed upon the
     format of the exchange between the client and server.    The
     client  provides  a  single  command  to  the  server, which
     returns a printable reply.  

     [0m[1mfingerd[0m listens on TCP port 79. Once a connection  is  made,
     it   reads   a   single   command   line   terminated  by  a
     <CARRIAGE-RETURN/LINE-FEED>, generates a report, and returns 
     it to the calling client.  [0m[1mfingerd[0m closes its connections as 
     soon as the output is finished.  

     If the line is null (only a CR/LF is sent) then [0m[1mfingerd[0m will 
     return a report that lists all users logged into the  system
     at that moment.  

     If  a  user name is specified (e.g., [0m[1meric[0m <CR/LF>), then the
     response lists more extended information for that particular 
     user, whether they are logged in or not.  

FILES  

     /etc/utmp  
          For who's currently logged in.  

     /usr/adm/wtmp  
          For last login times.  

     /etc/passwd  
          For user names.  

     $HOME/.project  
          To display user's project file.  

     $HOME/.plan  
          To display user's plan file.  

SEE ALSO  
     finger(1) 
     Harrenstien, Ken, [0m[4mNAME/FINGER,[0m RFC 742, Network  Information
     Center,  SRI  International,  Menlo  Park,  Calif., December
     1977.  

AUTHOR  
     Kevin J. Duling - kduling@carl.org 

# ftp
FTP (1C)                  USER COMMANDS                  FTP (1C)



NAME  
     ftp - file transfer program 

SYNOPSYS  
     [0m[1mftp[0m [ [0m[4mhostname[0m ] [ [0m[4mport[0m ] 

AVAILABILITY  
     This  command  is  available  with  the  TemariNET  software
     package.  

DESCRIPTION  
     [0m[1mftp[0m is the user interface  for  the  ARPANET  standard  File
     Transfer Protocol  (FTP).  [0m[1mftp[0m transfers files to and from a
     remote network site.  The client host with which [0m[1mftp[0m  is  to
     communicate may  be  specified on the command line.  If this
     is done, [0m[1mftp[0m immediately attempts to establish a  connection
     to  an  FTP  server  on that host; otherwise, [0m[1mftp[0m enters its
     command interpreter and awaits instructions from  the  user.
     When [0m[1mftp[0m is awaiting commands from the user, it displays the 
     prompt `ftp>'.  

USAGE  

     ascii  
          Set file transfer mode to ascii.  

     binary  
          Set file transfer mode to binary.  

     bye  
          Close connection and exit.  

     cd  
          Change directory on remote host.  

     close  
          Close connection.  

     dir  
          Display long form remote host directory listing.  

     exit  
          Close connection and exit.  

     del  
          Remove file on remote host.  

     get  
          Retrieve a file from remote host.  

     help  
          Display this text.  

     open  
          Open connection to remote host.  

     pwd  
          Display current directory on remote host.  

     mkdir  
          Create directory on remote host.  

     rmdir  
          Remove directory on remote host.  

     lcd  
          Change directory on local host.  

     lmkdir  
          Create directory on local host.  

     lpwd  
          Display current directory on local host.  

     lrmdir  
          Remove directory on local host.  

     ls  
          Display remote host directory listing.  

     mget  
          Retrieve multiple files from remote host.  

     mput  
          Send multiple files to remote host.  

     noop  
          Send the ftp NOOP command.  

     put  
          Send a file to remote host.  

     quit  
          Close connection and exit.  

     quote  
          Send raw ftp command to remote host.  

     remotehelp  
          Display ftp command implemented on remote host.  

     rm  
          Remove file on remote host.  

     user  
          Enter remote user information.  

EXAMPLE  
     ftp nyx.cs.du.edu 

AUTHOR  
     Michael Temari - temari@temari.ae.ge.com 

# hostname
HOSTNAME (1)              USER COMMANDS              HOSTNAME (1)



NAME  
     hostname - print name of host system 

SYNOPSIS  
     [0m[1mhostname[0m [ -s ] [ [0m[4mname-of-host[0m ] 

AVAILABILITY  
     This  command  is  available  with  the  TemariNET  software
     package.  

DESCRIPTION  
     The hostname command prints the name  of  the  current  host
     machine.   The  super-user can set the hostname by giving an
     argument.  

OPTIONS  

     -s  
          Reports only  the  hostname.    The  domain   name   is
          suppressed.  

SEE ALSO  
     gethostname(2),       getdomainname(2),      sethostname(2),
     setdomainname(2) 

AUTHOR  
     Michael Temari - temari@temari.ae.ge.com 

# nsquery
NSQUERY (1M)          MAINTENANCE COMMANDS           NSQUERY (1M)



NAME  
     nsquery - Remote File Sharing name server query 

SYNOPSIS  
     [0m[1mnsquery[0m [ -h [0m[4mname[0m ] 

AVAILABILITY  
     This  command  is  available  with  the  TemariNET  software
     package.  

DESCRIPTION  
     [0m[1mnsquery[0m provides information about  resources  available  to
     the  host from both the local domain and from other domains.
     All resources are reported, regardless of whether  the  host
     is authorized  to  access  them.  When used with no options,
     [0m[1mnsquery[0m identifies all resources in  the  domain  that  have
     been advertised as sharable.  A report on selected resources 
     can be obtained by specifying [0m[4mname,[0m where [0m[4mname[0m is: 

     nodename  
          The  report will include only those resources available
          from [0m[4mnodename.[0m 

     domain  
          The report will include only those resources  available
          from [0m[4mdomain.[0m 

     domain.nodename  
          The  report will include only those resources available
          from [0m[4mdomain.nodename.[0m 

     When the name does not include the delimiter ".", it will be 
     interpreted as a [0m[4mnodename[0m within the local domain.   If  the
     name  ends with a delimiter ".", it will be interpreted as a
     [0m[4mdomain[0m name.  

     The information contained in the  report  on  each  resource
     includes  its  advertised  name  (  [0m[4mdomain.resource[0m  ),  the
     read/write permissions, the server ( [0m[4mnodename.domain[0m )  that
     advertised the resource, and a brief textual description.  

     When [0m[1m-h[0m is used, the header is not printed.  

     A  remote  domain  must  be  listed in your rfmaster file in
     order to query that domain.  

EXIT CODES  
     If no entries are found when [0m[1mnsquery[0m is executed, the report 
     header is printed.  

OPTIONS  

     -h  
          Suppress header line in output.  

NOTES  
     If your host cannot contact the domain name server, an error 
     message will be sent to standard error.  

AUTHOR  
     Michael Temari - temari@temari.ae.ge.com 

# telnet
TELNET (1C)          COMMUNICATION PROGRAMS           TELNET (1C)



NAME  
     telnet  - user interface to a remote system using the [0m[1mTELNET[0m
     protocol 

SYNOPSIS  
     [0m[1mtelnet[0m [ -bdtv ] [0m[1mhostname[0m [ [0m[4mport[0m ] 

DESCRIPTION  
     [0m[1mtelnet[0m communicates with a  remote  host  using  the  [0m[1mTELNET[0m
     protocol.   Once a connection is made, [0m[1mtelnet[0m is in an input
     mode.  In this mode, the text the user types is sent to  the
     remote host.  

     While connected to a remote host, telnet command mode may be 
     entered  by  typing  the  telnet [0m[1mescape-character[0m (initially
     `^]', (contol-right-bracket)). While in  command  mode,  the
     telnet commands are available.  

USAGE  
     Telnet Commands 

     The following commands are available in command mode: 

     q  
          Quit. This closes the connection to the remote host and 
          terminates telnet.  

     !   
          Shell escape.    This  allows  temporary  access to the
          Minix shell.  Typing [0m[1mexit[0m  or  [0m[1m^D[0m  will  terminate  the
          shell and return to the telnet process.  

OPTIONS  

     -b  
          Binary mode.    This  places  both local telnet and the
          remote host in binary mode.  

     -d  
          Debug mode.    All  packets  sent  and   received   are
          displayed on stdout.  

     -t  
          I've got no clue what this is for...  

     -v  
          Verbose mode.  This has the same effect as -d.  

EXAMPLE  
     telnet nyx.cs.du.edu 

SEE ALSO  
     sh(1), hosts(5) 

BUGS  
     Only  /bin/sh  or  /usr/bin/sh are available when a shell is
     requested.  The user's default login shell is not checked.  

AUTHOR  
     Michael Temari - temari@temari.ae.ge.com 

# whois
WHOIS (1)                 USER COMMANDS                 WHOIS (1)



NAME  
     whois - Internet user name directory service 

SYNOPSIS  
     [0m[1mwhois[0m [ -h [0m[4mhost[0m ] [0m[4midentifier[0m 

AVAILABILITY  
     This  command  is  available  with  the  TemariNET  software
     package.  

DESCRIPTION  
     [0m[1mwhois[0m searches  for  an  [0m[1mInternet[0m  directory  entry  for  an
     [0m[4midentifier[0m  which  is either a name (such as ``Smith'') or a
     handle (such as  ``SRI-NIC''). To force a name-only  search,
     precede  the  name  with    a period; to force a handle-only
     search, precede the handle with an exclamation point.  

     To search for a group or  organization  entry,  precede  the
     argument with   [0m[1m*[0m (an asterisk).  The entire membership list
     of the group will be displayed  with the record.  

     You may of course use an exclamation point and asterisk,  or
     a period and asterisk together.  

EXAMPLES  
     example% whois Smith 
     example% whois !SRI-NIC 
     example% whois .Smith, John 

AUTHOR  
     DDN Network Information Center 

# xd
	xd (1)

COMMAND:
	xd - hexadecimal dump

SYNTAX:
	xd [-b|c|d|o|x] [-io|id|in|ix] [-8] [-m<count>] [-s<count>] [file]

FLAGS:
	-b binary dump
	-c dump characters only
	-d decimal dump
	-o octal dump
	-x hexadecimal dump (default)
	-i index base: io octal, id decimal, ix hexadecimal (default)
        -in no index display
	-8 display 8 bit characters (default is 7 bits)
	-s skip <count> (hexadecimal) bytes
	-m max <count> (hexadecimal) bytes displayed
        
EXAMPLES:
	xd			# dump standard input until eof
	xd file.txt		# dump file.txt in hexadecimal
	xd -b x.bin		# examine x.bin as binary bytes
	xd -c dat.dbf 		# display characters only
	xd -s400 /dev/mem | more
				# dump memory starting at 0x000400
	xd -s0b8000 -m100 /dev/mem
				# examine 1st 256 bytes of video buffer

DESCRIPTION:

	Xd displays the contents of a file or standard input in 
binary, octal, decimal, or hexadecimal. It writes to its standard
output.
	The default output consists of an index count (in hexadecimal)
and a display of 16 bytes in hexadecimal, followed by a string of the
corresponding ASCII characters.
	The -b, -o, or -d options select binary, octal, or decimal 
base for the data display. In binary 6 bytes are displayed, and in 
octal or decimal 12 bytes are displayed on each line. The -c option
selects characters only in the data display; in this mode 64 characters 
are displayed on each line. Non-printable characters are shown as 
periods. 
	The -8 option displays characters with the high bit set; by
default these are treated as non-printable.
	The -io or -id options select octal or decimal base for the
index count. -in selects no index count.
	The -s and -m options allow skipping any desired number of
bytes at the beginning of a file and reading a limited number of bytes
from the file.  This is particularly useful for examining memory (as
/dev/mem).  The s parameter is rounded down and the m parameter is
rounded up modulo 16 bytes, so at least one full line of output is 
produced.  If eof is reached on the input before a line is complete the 
missing bytes are marked by periods.
	Xd is meant to be a replacement for od, with a display similar
to the dump display of CP/M DDT or MS-DOS DEBUG, more convenient than
od's word-oriented display for a little-endian byte-oriented machine.

SEE ALSO:
	od(1)

AUTHOR:
	Albert S. Woodhull  awoodhull@hamp.hampshire.edu   16.02.95

# minicom
		Manual for "Minicom".

Minicom is a complete communication program for the Minix operating
system. It has been ported to a variety of Unix systems without much trouble.

Features are:
- window based, user-friendly.
- Terminal emulation: vt100, Minix, Ansi(IBM)
- Supports COLOR!
- Status Line.
- Dialing directory with auto-dial and automatic re-dial.
- Up and download programs run in a window.
- Kermit can be run from within the program.
- Supports UUCP lock files.
- Script files for auto login.
- Capture file.
- Auto baudrate selection.
- Multiple users, protected with an access list. Every user has his
  own dialing directory, and most default-options (as set by root)
  can be changed and saved into a personal startup file.
- Multiple users. Only root can change the configuration files, but
  every user has his own dialing-directory (and his own upload/download/
  script directories)
- Multiple configuration files with access control.
  
                       ===== Invocation ====

The syntax is: minicom [-som] [-c on|off] [-a on|off] [configuration].

Before processing the options, minicom searches for the environment
variable 'MINICOM'. In this variable, options can be given just as
on the command line. This way, it becomes possible to decide which
options to use in advance, typically in your .profile depending on which
terminal you are using. This variable is simply set by

       MINICOM='-m -c on'
       export MINICOM.

The options on the command line override those of the MINICOM variable.

The options mean:
  -s : setup. This is allowed for root only. When this option is used,
       minicom does _not_ initialize, but puts you directly into the
       configuration menu. This is very handy if minicom refuses to
       start up because your system has changed, or for the first time
       you run minicom: many defaults are based on 'virgin' 1.5.10 systems.

  -o:  do not initialize. Minicom will skip the initialization code.
       This option is handy if you quitted from minicom without resetting,
       and then want to restart a session. It is potentially dangerous
       though: no check for lock files etc. is made, so a normal user
       could interfere with things like uucp... Maybe this will be taken
       out later. For now it is assumed, that users who are given access
       to a modem are responsible enough for their actions.

  -m:  override command-key with the Meta or ALT key. This can also
       be configured in on of minicom's menu's, but if you use different
       terminals all the time, of which some don't have a Meta or ALT
       key, it's handy to set the default command key to ^A and use this
       option when you have a keyboard supporting Meta or ALT keys.

  -a:  attribute usage. Some terminals, notably televideo's, have a rotten
       attribute handling (serial instead of parallel). By default, minicom
       uses '-a on', but if you are using such a terminal you can (must!)
       supply the option '-a off'. The trailing 'on' or 'off' is needed.

  -c:  color usage. Some terminals (such as the Minix console) support
       color with the standard ANSI escape sequences. Because there is
       apparently no termcap support for color, these escape sequences are
       hard-coded into minicom. Therefore this option is off by default.
       You can turn it on with '-c on'. This, and the '-m' option, are
       good candidates to put into the MINICOM environment variable.

The configuration argument is more interesting. Normally, minicom gets
its defaults from a file called "minirc.dfl". If you however give an argument
to minicom, it will try to get its defaults from a file called
"minirc.argument". So it is possible to create multiple configuration files,
for different ports, different users etc. Most sensible is to use device
names, such as tty1, tty64, sio2 etc. If a user creates his own configuration
file, it will show up in his home directory as '.minirc.dfl'.

                     ===== Using Minicom =====

Minicom is windows-based. To popup a window with the function you want,
press Control-A, and then the function key (a-z or A-Z). By pressing
Control-A first and then 'z', a help screen comes up with a short summary
of all commands. This escape key can be altered, as written above, but
we'll stick to Control-A for now.

For every menu the next keys can be used:
- Move up:    arrow-up or 'k'
- Move down:  arrow-down or 'j'
- Move left:  arrow-left or 'h'
- Move right: arrow-right or 'l'
- Choose:     Enter
- Cancel:     ESCape (or ESC-ESC, see the comment at the end of this file)

The screen is divided into two portions: the upper 24 lines are the
terminal-emulator screen. In this window, ANSI or VT100 escape sequences
are interpreted. If MINIX emulation is chosen, this window will be
25 lines long (if possible).
If there is a line left at the bottom, a status line is placed there.
If this is not possible the status line will be showed every time
you press Control-A.

Possible commands are listed next, in alfabetical order.

Control-A.
   Pressing Control-A a second time will just send a Control-A to the
   remote system.
  
A. Toggle 'Add Linefeed' on/off. If it is on, a linefeed is added before
   every carriage return displayed on the screen.
  
B. A break signal is sent to the modem.
  
C. Clears the screen.

D. Dial a number, or go to the dialing directory.
  
G. Run script (Go). Runs a login script.
  
H. Hangup.
  
J. Jump to a shell. On return, the whole screen will be redrawn.
  
K. Run Kermit in a window.
  
L. Turn Capture file on off. If turned on, all output sent to the screen
   will be captured in the file too.
  
M. Sends the modem initialization string.
  
O. Configure minicom. Puts you in the configuration menu.
  
P. Communication Parameters. Allows you to change the baudrate, parity and
   number of bits.
  
Q. Exit minicom without resetting the modem.
  
R. Recieve files. Choose from various protocols (external).
  
S. Send files. Ditto.
  
T. Choose Terminal emulation: Minix-Ansi(color)-vt100.
  
W. Toggle linewrap on/off.
  
X. Exit minicom, reset modem.
  
Z. Pop up the help screen.


		=== The dialing directory ===
		
By pressing Control-A D the program asks:
"Number to dial: (enter for dialing directory) " _
You can now directly enter a number to dial, or press enter. Then
the dialing directory will be drawn. You can add, delete or edit
entries. By choosing "dial" the phone number of the highlighted entry will 
be dialed. While the modem is dialing, you can press any key to
cancel dialing. Your dialing directory will be saved into a the file
".dialdir" in your home directory.
You can scroll up and down with the arrow keys, but you can also scroll
complete pages by pressing the PageUp or PageDown key. If you don't
have those, use Control-B (Backward) and Control-F (Forward).

The "edit" menu speaks for itself, but I will discuss it briefly here.
  A - Name              : The name for this entry
  B - Number            : and its telephone number.
  C - Script            : the script that must be executed after a succesfull
                          connection is made (see the manual for runscript)
  D - Username          : The username that is passed to the runscript program.
                          It is passed in the environment string "$LOGIN".
  E - Password          : The password is passed as "$PASS".
  F - Terminal Emulation: Use MINIX, ANSI or VT100 emulation.
  G - Line settings     : baudrate, bits and parity to use for this connection.


                === The setup Menu ===

By pressing Control-A O you will be thrown into the setup menu. Most
settings there can be changed by everyone, but some are restricted
to root only. Those priviliged settings are marked with a star (*).

"Filenames and paths"
  This menu defines your default directories.
  A - upload:         where the uploaded files go to.
  B - download:       Yup, you guessed it.
  C - script:         Where you keep your login scripts.
  D - Script program: Which program to use as the script
                      interpreter. Defaults to the program "runscript",
                      but if you want to use something else (eg,
                      /bin/sh or "expect") it is possible.
                      Stdin and stdout are connected to the modem,
                      stderr to the screen.

  
  If the path is relative (ie, does not start with a slash) then it's
  relative to your home directory, except for the script interpreter.

"File Transfer Protocols"
  Protocols defined here will show up when Control-A s/r is pressed.
  "Name" is the name that will show up in the menu. "Program" is
  the path to the protocol. "NeedName" defines if the program needs an
  argument, eg. a file to be transmitted. Finally, Up/Down defines
  if this entry should show up in the upload or the download menu.
  All file transfer protocols are run with the UID of the user, and
  not with UID=root.

"Kermit protocol"
 *A - Kermit program:       where to find kermit, and options to it.
 *B - Everybody may use it: If option 'c' is on, I would turn this off!
 *C - Kermit runs as root:  Be careful!

"Serial port setup"
 *A - Serial device:        /dev/tty1 for most people, or maybe /dev/tty64
                            if you use the VC package.
 *B - Device lock file:     This should be /usr/spool/uucp/LCK..tty1 or
                            something.
 *C - Callin program:       If you have a uugetty or something on your
                            serial port, it could be that you want a
                            program to be run to switch the modem cq. port
                            into dialin/dialout mode. This is the program
                            to get into dialin mode.
 *D - Callout program:      And this to get into dialout mode.
  E - Baud/Par/Bits:        Default parameters at startup.
  
  If one of the entries is left blank, it will not be used. So if you
  don't care about locking, and don't have a getty running on your
  modemline, entries B - D should be left blank.
  Be warned! The callin and callout programs are run with the effective
  user id of "root", eg 0!

"Modem and Dialing"
  Here, the parameters for your modem are defined. I will not explain
  this further because the defaults are for generic Hayes modems,
  and should work always. This file is not a Hayes tutorial :-)
  The only thing worth noticing is that control characters can be
  sent by prefixing them with a '^', in which '^^' means '^' itself.
  Some options however, don't have much to do with the modem but more
  with the behaviour of minicom itself:
  I - Dial time			The number of seconds before minicom
  				times out if no connection is established.
  J - Delay before redial	Minicom will redial if no connection was
  				made, but it first waits some time.
  K - Number of tries		Maximum number of times that minicom
  				attempts to dial.
  L - Autobaud detect		If this is on, minicom tries to match
  				the dialed party's speed.
  M - Drop DTR to hangup	Normally minicom hangs up by sending
  				a Hayes-type hangup sequence but if
  				your Minix supports it, it can also
  				hangup by dropping the DTR line.
  Note that a special exception is made for this menu: every user
  can change all parameters here, but they will not be saved.

"Screen and keyboard"
  A - Command key is:           the 'Hot Key' that brings you into
                                command mode. If this is set to 'ALT' or
                                'meta key', you can directly call commands
                                by alt-key instead of HotKey-key.
  B - Backspace key sends:      There still are some systems that want a
                                VT100 to send DEL instead of BS. With this
                                option you can enable that stupidity.
  				(Eh, it's even on by default..)
  C - Status line is:           enabled or disabled. Some slow terminals
                                (for example, X-terminals) cause the status
                                line to jump "up and down" when scrolling,
                                so you can turn it off if desired. It will
                                still be shown in command-mode.
"Save setup as dfl"
  Save the parameters as the default for the next time the program is
  started. Instead of dfl, any other parameter name may appear, depending
  on which one was used when the program was started.

"Save setup as.."
  Save the parameters under a special name. Whenever Minicom is started
  with this name as an argument, it will use these parameters. This
  option is ofcourse priviliged to root.

"Exit"
  Escape from this menu (can also be done with ESC) without saving.

"Exit from minicom"
  Only root will see this menu entry, if he/she started minicom with the '-s'
  option. This way, it is possible to change the configuration without
  actually running minicom.

                ===== Access Control =====

Since Minicom runs setuid root, you probably want to restrict access to
it. This is possible by using a configuration file in the same directory
as the default files, called "minicom.users". The syntax of this file
is as following:

<username> <configuration> [configuration..]

To allow user 'miquels' to use the default configuration, enter the 
following line into "minicom.users":

miquels dfl

If you want users to use more than the default, just add the names of
those configurations behind the user name. Oh yeah, if "minicom.users"
does not exist, everybody may use all configurations. This is ofcourse
a security problem!


		===== Last remarks =====

If minicom is hung, kill it with SIGTERM . (This means kill -15, or
since sigterm is default, just plain "kill <minicompid>". This will
cause a graceful exit of minicom, doing resets and everything.

Since some OS's have no decent timing in the terminal driver, some keys
have to be pressed TWICE. This holds especially for the escape key.
Since a lot of escape sequences begin with ESC (Arrow up is ESC [ A)
Minicom does not know if the escape character it gets is you pressing
the escape key, or part of a sequence.

The last version of Minicom, V1.2, solved this in a rather crude way:
to get the escape key, you had to press it *twice*..
Support for timing (with select) was already built in to minicom
(see file wkeys.c) and works great under BSD, but alas, not under Minix.
The same problem, but worse, was with Televideo type terminals. Since they
use a lot of escape sequences that start with 'Control-A', you had to
press 'Control-A' twice when you want to pop up a window or something..

As of release 1.3 this has bettered a little: now a 1-second timeout
is builtin, like in vi. And... surprise: a special Minix-dependant
*hack* :-) was added. Now, minicom can separate the escape key and
escape-sequences. To see how dirty this was done, look into wkeys.c.
But, it works like a charm!


Well, I guess this about covers it. I hope everything is clear enough
and wish you a lot of fun.
Miquel.

# runscript
		Manual for "runscript"

In this package, a simple script-interpreter is included. It can
be used to login to other systems and things like that.
Try running the demo:

	runscript scriptdemo

for fun.

Runscript reckognizes the following keywords:

expect    send      !         goto      gosub     return
exit      print     set       inc       dec       if
timeout   verbose   sleep     break     call

The program expects that it's standard input and standard output are
connected to the "remote end", that is the modem port, and that it
can write to the local screen through standard error. This is naturally
the case when you run it from within minicom.
The next statements can be used:

send <string>
  <string> is sent to the modem. It is followed by a "\r". <string> can be:
  - regular text, eg 'send hello'
  - text enclosed in quotes, eg 'send "hello world"'
  - and within <string> the following escape sequences are reckognized:
    \n - newline
    \r - carriage return
    \a - bell
    \b - backspace
    \c - don't send the default '\r'.
    \f - formfeed
    and \ooo can be used to send an arbitrary character, where ooo is
    an octal number.
    Also $(environment_variable) can be used, for example $(TERM).
    Minicom passes two special environment variables: $(LOGIN), which is the
    username, and $(PASS), which is the password, as defined in the proper
    entry of the dialing directory.

print <string>
  Prints <string> to the local screen. Default followed by '\r\n'.
  See the description of 'send' above.

label:
  Declares a label (with the name 'label') to use with goto or gosub.

goto <label>
  Jump to another place in the program.

gosub <label>
  Jumps to another place in the program. When the statement 'return'
  is encountered, control returns to the statement after the gosub.
  Gosub's can be nested.

return
  Return from a gosub.

! <command>
  Runs a shell for you in which 'command' is executed. On return,
  the variable '$?' is set to the exit status of this command,
  so you can subsequently test it using 'if'.

exit [value]
  Exit from "runscript" with an optional exit status. (default 1)

set <variable> <value>
  Sets the value of <variable> (which is a single letter a-z) to the
  value <value>. If <variable> does not exist, it will be created.
  <value> can be a integer value or another variable.

inc <variable>
  Increments the value of <vaiable> by one.

dec <variable>
  Decrements the value of <variable> by one.

if <value> <operator> <value> <statement>
  Conditional execution of <statement>. <operator> can be <, > or =.
  Eg, 'if a > 3 goto exitlabel'.

timeout <value>
  Sets the global timeout. By default, 'runscript' will exit after
  120 seconds. This can be changed with this command. Warning: this
  command acts differently within an 'expect' statement, but more
  about that later.

verbose <on|off>
  By default, this is 'on'. That means that anything that is being
  read from the modem by 'runscript', gets echoed to the screen.
  This is so that you can see what 'runscript' is doing.

sleep <value>
  Suspend execution for <value> seconds.

expect {
  pattern  [statement]
  pattern  [statement]
  [timeout <value> [statement] ]
  ....
}
  The most important command of all. Expect keeps reading from the input
  until it reads a pattern that matches one of the specified ones.
  If expect encounters an optional statement after that pattern, it
  will execute it. Otherwise the default is to just break out of the
  expect. 'pattern' is a string, just as in 'send' (see above).
  Normally, expect will timeout in 60 seconds and just exit, but this
  can be changed with the timeout command.

break
  Break out of an 'expect' statement. This is normally only useful
  as argument to 'timeout' within an expect, because the default
  action of timeout is to exit immediately.

call <scriptname>
  Transfers control to another scriptfile. When that scriptfile
  finishes without errors, the original script will continue.

Well, I don't think this is enough information to make you an
experienced 'programmer' :-) in 'runscript', but together with the
examples it shouldn't be too hard to write some useful script
files. Things will be easier if you have experience with BASIC :-)

Miquel.

SEE ALSO: /usr/local/doc/scriptdemo

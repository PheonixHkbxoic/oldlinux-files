<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0159)http://216.239.51.100/search?q=cache:li1XVu3eo1gC:www.geocities.com/potato.geo/bootlinuxcd-old.html+linux+kernel+source+code+achieve+cdrom+iso&hl=zh-CN&start=1 -->
<HTML><HEAD><TITLE>Making Bootable Linux CDs</TITLE>
<META http-equiv=Content-Type content="text/html; charset=ISO-8859-1">
<META content="MSHTML 6.00.2600.0" name=GENERATOR></HEAD>
<BODY bgColor=#e0e0e0>
<TABLE width="100%" border=1>
  <TBODY>
  <TR>
    <TD>
      <TABLE cellSpacing=0 cellPadding=10 width="100%" bgColor=#ffffff border=1 
      color="#ffffff">
        <TBODY>
        <TR>
          <TD><FONT face=arial,sans-serif color=black size=-1>This is <B><FONT 
            color=#0039b6>G</FONT> <FONT color=#c41200>o</FONT> <FONT 
            color=#f3c518>o</FONT> <FONT color=#0039b6>g</FONT> <FONT 
            color=#30a72f>l</FONT> <FONT color=#c41200>e</FONT></B>'s <A 
            href="http://www.google.com/help/features.html#cached"><FONT 
            color=blue>cache</FONT></A> of <A 
            href="http://www.geocities.com/potato.geo/bootlinuxcd-old.html"><FONT 
            color=blue>http://www.geocities.com/potato.geo/bootlinuxcd-old.html</FONT></A>.<BR><B><FONT 
            color=#0039b6>G</FONT> <FONT color=#c41200>o</FONT> <FONT 
            color=#f3c518>o</FONT> <FONT color=#0039b6>g</FONT> <FONT 
            color=#30a72f>l</FONT> <FONT color=#c41200>e</FONT></B>'s cache is 
            the snapshot that we took of the page as we crawled the web.<BR>The 
            page may have changed since that time. Click here for the <A 
            href="http://www.geocities.com/potato.geo/bootlinuxcd-old.html"><FONT 
            color=blue>current page</FONT></A> without highlighting.<BR>To link 
            to or bookmark this page, use the following url: 
            <CODE>http://www.google.com/search?q=cache:li1XVu3eo1gC:www.geocities.com/potato.geo/bootlinuxcd-old.html+linux+kernel+source+code+achieve+cdrom+iso&amp;hl=zh-CN&amp;start=1</CODE></FONT><BR><BR>
            <CENTER><FONT size=-1><I>Google is not affiliated with the authors 
            of this page nor responsible for its 
        content.</I></FONT></CENTER></TD></TR>
        <TR>
          <TD>
            <TABLE cellSpacing=0 cellPadding=0 border=0>
              <TBODY>
              <TR>
                <TD><FONT face=arial,sans-serif color=black size=-1>These 
                  search terms have been highlighted:&nbsp;</FONT></TD>
                <TD bgColor=#ffff66><B><FONT face=arial,sans-serif color=black 
                  size=-1>linux&nbsp;</FONT></B></TD>
                <TD bgColor=#a0ffff><B><FONT face=arial,sans-serif color=black 
                  size=-1>kernel&nbsp;</FONT></B></TD>
                <TD bgColor=#99ff99><B><FONT face=arial,sans-serif color=black 
                  size=-1>source&nbsp;</FONT></B></TD>
                <TD bgColor=#ff9999><B><FONT face=arial,sans-serif color=black 
                  size=-1>code&nbsp;</FONT></B></TD>
                <TD bgColor=#ff66ff><B><FONT face=arial,sans-serif color=black 
                  size=-1>achieve&nbsp;</FONT></B></TD>
                <TD bgColor=#880000><B><FONT face=arial,sans-serif color=white 
                  size=-1>cdrom&nbsp;</FONT></B></TD>
                <TD bgColor=#00aa00><B><FONT face=arial,sans-serif color=white 
                  size=-1>iso&nbsp;</FONT></B></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<HR>

<TABLE width="100%">
  <TBODY>
  <TR>
    <TD vAlign=top width="15%">
      <TABLE cellSpacing=0 cellPadding=1 width="100%" border=0>
        <TBODY>
        <TR>
          <TD bgColor=#000000>
            <TABLE cellSpacing=0 cellPadding=5 width="100%" border=0>
              <TBODY>
              <TR>
                <TD align=middle bgColor=#0098e8><FONT 
                  color=#ffffff><I><B>Retinix</B></I></FONT> </TD></TR>
              <TR>
                <TD align=middle bgColor=#e8e8e8>
                  <TABLE cellSpacing=0 cellPadding=1>
                    <TBODY>
                    <TR>
                      <TD><A 
                        href="http://www.geocities.com/potato.geo/index.html">News</A> 
                      </TD></TR>
                    <TR>
                      <TD><A 
                        href="http://www.geocities.com/potato.geo/about.html">About 
                        Retinix</A> </TD></TR>
                    <TR>
                      <TD><A 
                        href="http://www.geocities.com/potato.geo/articles.html">Articles</A> 
                      </TD></TR>
                    <TR>
                      <TD><A 
                        href="http://www.geocities.com/potato.geo/projects.html">Projects</A> 
                      </TD></TR>
                    <TR>
                      <TD><A 
                        href="http://www.geocities.com/potato.geo/links.html">Links</A> 
                      </TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
    <TD width="5%"></TD>
    <TD vAlign=top width="80%"><!-- :Making Bootable Linux CDs: -->
      <H3>Making Bootable <B 
      style="COLOR: black; BACKGROUND-COLOR: #ffff66">Linux</B> CDs</H3>
      <H4>Introduction</H4>
      <BLOCKQUOTE>Why put <B 
        style="COLOR: black; BACKGROUND-COLOR: #ffff66">linux</B> on a bootable 
        CD? Why not! Its a great idea if you need to take a 'toolkit' of 
        programs to a customer site. You can fit quite a lot on a 650mb CD. The 
        <A href="http://www.thinknic.com/">ThinkNIC</A> takes this CD based <B 
        style="COLOR: black; BACKGROUND-COLOR: #ffff66">Linux</B> approach in 
        creating a purpose built thin client. <A 
        href="http://www.demolinux.org/">DemoLinux</A> is a distribution that 
        only works on a CD. The possibilities are endless.... probably 8-). 
      </BLOCKQUOTE>
      <H4>Research</H4>
      <BLOCKQUOTE>Unfortunately, when I first started looking for information 
        on the net, there didn't seem to be too much info about how to make 
        bootable <B style="COLOR: black; BACKGROUND-COLOR: #ffff66">Linux</B> 
        CDs. I have , however, now found a few good sites. Check out the 
        following: 
        <UL>
          <LI><A href="http://mlp.rhic.bnl.gov/RescueCD">RescueCD</A> by Martin 
          L. Purschke 
          <LI><A href="http://www.equusasinus.com/lxa/index.html"><B 
          style="COLOR: black; BACKGROUND-COLOR: #ffff66">Linux</B> Appliance 
          Construction Set</A> by Michael W. Shaffer </LI></UL>The standard for 
        booting CDs is called 'El Torito'. The concept is that your BIOS treats 
        your CD like a floppy initially and expects to find the 'image' of a 
        bootable floppy on the CD. Your imaginary boot floppy is meant to have 
        <B style="COLOR: white; BACKGROUND-COLOR: #880000">CDROM</B> drivers on 
        it which can somehow access the CD in full. This seemed overly 
        complicated until I came across <A 
        href="http://www.kernel.org/pub/linux/utils/boot/syslinux">SysLinux</A>. 
        Its a boot loader that is part of Debian I think. It primarily is a 
        floppy bootloader (like LOADLIN), but it now has an extra bit called 
        ISOLINUX, that simplifies booting off a CD. The key benefit is that you 
        no longer need a special floppy image. ISOLINUX will load the <B 
        style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> and an initrd 
        for you and away you go. </BLOCKQUOTE>
      <H4>The boot process</H4>
      <BLOCKQUOTE>The usual <B 
        style="COLOR: black; BACKGROUND-COLOR: #ffff66">Linux</B> boot process 
        is something like: 
        <UL>
          <LI>The PC starts up and runs LILO or some other bootloader 
          <LI>LILO knows where the <B 
          style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> image is 
          and starts to load it 
          <LI>The <B style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> 
          runs. When its finished doing all its checks, it attempts to mount the 
          root filesystem. The major and minor numbers for this device are 
          usually encoded in the <B 
          style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> itself or 
          passed to it as arguments from LILO 
          <LI>Once the file system is mounted, /sbin/init is executed and your 
          system starts up as per your inittab ... and your /etc/rc*.d scripts 
          </LI></UL>Our CD boot process is somewhat different. Again we need a 
        boot loader, but we don't necessarily know what device our <B 
        style="COLOR: white; BACKGROUND-COLOR: #880000">CDROM</B> is. It could 
        be /dev/hdb, /dev/hdc, /dev/hdd. Even if we told the boot loader where 
        the <B style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> is, we 
        would still need to tell the <B 
        style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> where its 
        root filesystem is. ISOLINUX helps us get around this, by working out 
        where the CD is. This allows us to boot the <B 
        style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B>, but it 
        doesn't really help us to load the initial root filesystem. Many boot 
        disks use a thing called an initrd (Initial ram disk) to get around 
        this. initrd is an initial root filing system running in RAM. It loads 
        prior to when the <B 
        style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> attempts to 
        mount the 'real' root file system. Yes this is odd. The idea is is that 
        your initrd starts up, loads some critical modules, then mounts your 
        real root file system. 
        <P>Now have a look at my CD startup process. 
        <UL>
          <LI>The CD is installed with ISOLINUX, so it boots first. 
          <LI>ISOLINUX loads the <B 
          style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> from the 
          /isolinux directory on the CD. 
          <LI>ISOLINUX now loads the initrd.gz compressed ext2 file system. Its 
          important to note that ISOLINUX loads this, and not the <B 
          style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B>. The <B 
          style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> will grab 
          it later. 
          <LI>The <B style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> 
          starts up and eventually decompresses the initrd.gz to ram (in 
          /dev/ram0 actually) and mounts it as root. You have to enable INITRD 
          support in the <B 
          style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> to have 
          this happen. 
          <LI>The <B style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> 
          tries to execute the /linuxrc file in the new root filesystem. 
          <LI>The linuxrc program tries to mount the <B 
          style="COLOR: white; BACKGROUND-COLOR: #880000">CDROM</B> (It has to 
          make a few guesses to work out where it is), then creates another ram 
          based ext2 filing system in /dev/ram1. The new root filesystem is 
          retrieved off the CD and effectively 'copied' into the /dev/ram1 
          device. We mount the new filesystem just so we can add a softlink in 
          its /dev directory for the CD (so w don't have to work out where the 
          CD is again). 
          <LI>When the linuxrc script finishes, control returns to the <B 
          style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> and it 
          attempts to mount its configured root filesystem. In this case, I've 
          rdev'd the <B 
          style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> to make it 
          use /dev/ram1 as the root filesystem. This will mount our newly 
          created ram based root file system. In this file system I have an 
          /sbin/init and the system starts up running entirely in RAM. 
        </LI></UL>So why does it have to be a two phase process? <B 
        style="COLOR: black; BACKGROUND-COLOR: #ffff66">Linux</B> doesn't really 
        know how to boot off a CD yet. The beauty of the initrd phase is that 
        the initrd filesystem is loaded by the bootloader (ie. not the <B 
        style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B>). It means 
        that we can effectively boot off any device, so long as the bootloader 
        is able to read from it. </BLOCKQUOTE>
      <H4>Basic Requirements</H4>
      <BLOCKQUOTE>First, you're going to need a machine to create the CD on. 
        I'm using Slackware 7.1 on a machine with a HP9100i CDwriter. I 
        installed the cdrecord, mkisofs etc tools. I've had to compile into the 
        <B style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> all the 
        necessary SCSI options to use the IDE CD-Writer (See the CD Writer 
        HOWTO), plus I have loop file support compiled in. I'd suggest you buy 
        yourself a couple of blank CD-RWs to play with as you're going to be 
        formatting, burning, trying it out ... repeatedly. 
        <P>You'll also need <A 
        href="http://www.kernel.org/pub/linux/utils/boot/syslinux">Syslinux</A>. 
        You need <A href="http://www.web-sites.co.uk/nasm">Nasm</A> to build it. 
        However, if you're too lazy to do this, all you need is the <A 
        href="http://www.geocities.com/potato.geo/bootcd/ISOLINUX.BIN">ISOLINUX.BIN</A> 
        file that is created. </P></BLOCKQUOTE>
      <H4>Create a <B style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> 
      for the CD</H4>
      <BLOCKQUOTE>Now you need to create a <B 
        style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> that can load 
        the initrd. I'll assume you know how to build a <B 
        style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B>. All the 
        experimentation here was done with a 2.2.18 <B 
        style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B>. You must 
        compile in initrd support and RAM disk support. I am using the default 
        4096K RAM disk size. Other things that you'll need are ISO9660 
        filesystem support, ext2 filesystem support. Once you have this <B 
        style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B>, you need to 
        set the root device on it: <PRE>   eg. Say you've just done a make bzImage

    rdev /usr/src/<B style="COLOR: black; BACKGROUND-COLOR: #ffff66">linux</B>/arch/i386/boot/bzImage /dev/ram1

   NB: If you don't have a /dev/ram1 on your system, create one with:

    mknod -m 640 /dev/ram1 b 1 1
</PRE></BLOCKQUOTE>
      <H4>Create a directory tree</H4>
      <BLOCKQUOTE>You're going to have to create a directory structure to 
        build all this. I have a base directory /src/<B 
        style="COLOR: white; BACKGROUND-COLOR: #00aa00">iso</B> and everything 
        sits under it. The key directories are: 
        <P>
        <TABLE cellPadding=5>
          <TBODY>
          <TR>
            <TD><CODE>cdimage/</CODE></TD>
            <TD>This is what mkisofs will use to write an image to the 
CD</TD></TR>
          <TR>
            <TD><CODE>initrd/</CODE></TD>
            <TD>Holds the tree of our initrd filesystem</TD></TR>
          <TR>
            <TD><CODE>root/</CODE></TD>
            <TD>Holds the tree of our real (final) root 
          filesystem</TD></TR></TBODY></TABLE></P></BLOCKQUOTE>
      <H4>Setting up initrd</H4>
      <BLOCKQUOTE>The contents of initrd are essentially a mini working <B 
        style="COLOR: black; BACKGROUND-COLOR: #ffff66">linux</B> system. You'll 
        need some libraries, a shell and a few tools, notably 'mke2fs, mount, 
        umount'. The key part is the /linuxrc script. Here's mine: <PRE>#!/bin/sh

echo "INITRD startup"

mount -t proc none /proc
# find the <B style="COLOR: white; BACKGROUND-COLOR: #880000">CDROM</B>
CD=`fcd`
mount -t iso9660 $CD /<B style="COLOR: white; BACKGROUND-COLOR: #880000">cdrom</B>


PATH=$PATH:/sbin:/usr/sbin

if [ -r  /<B style="COLOR: white; BACKGROUND-COLOR: #880000">cdrom</B>/rootfs.gz ]; then 
    echo "   expanding real root fs..."
    gunzip -c /<B style="COLOR: white; BACKGROUND-COLOR: #880000">cdrom</B>/rootfs.gz | dd of=/dev/ram1

    mkdir /ram
    mount /dev/ram1 /ram

    cd /ram/dev
    ln -s "$CD" <B style="COLOR: white; BACKGROUND-COLOR: #880000">cdrom</B>
    cd /
    umount /ram
    umount /<B style="COLOR: white; BACKGROUND-COLOR: #880000">cdrom</B>
    umount /proc
    echo "INITRD all done"
    exit
fi
    
# if we arrive here, we drop into the emergency shell. 
exec /bin/sh
</PRE>We mount /proc so that some system info becomes visible, then 
        mount the CD. fcd is a program I wrote that simply scans all the IDE 
        devices until it sees the first <B 
        style="COLOR: white; BACKGROUND-COLOR: #880000">CDROM</B> drive. Now we 
        need to get our real root filesystemi into /dev/ram1. I have it stored 
        in a tarred gzip file on the CD. I originally used mke2fs to create the 
        filesystem. It actually requires quite a lot of extra libraries to make 
        mke2fs work. Being the minimalist that I am, I just created a blank 4mb 
        ext2 filesystem and copied the real root fs tree to it, then gzipped it. 
        All the linuxrc does is to gunzip it into a dd and voila we have our 
        real root filesystem. 
        <P>The last step is simply to exit. The <B 
        style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> should now 
        take over, and mount /dev/ram1 as /, and try to run /sbin/init. 
      </P></BLOCKQUOTE>
      <H4>Burning a CD with a <B 
      style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> and initrd</H4>
      <BLOCKQUOTE>Putting a <B 
        style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> and initrd on 
        the CD provides the basics of what we're trying to <B 
        style="COLOR: black; BACKGROUND-COLOR: #ff66ff">achieve</B>, so you 
        might like to try burning a CD at this stage to see whether it works. 
        <P>The contents of our CD will look like the following: <PRE> /
  isolinux/
           isolinux.cfg   - the isolinux config file
           isolinux.bin   - the isolinux boot program
           vmlinuz        - our <B style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> with initrd support
           initrd.gz      - our initial ram disk
</PRE>The isolinux.cfg file contains: <PRE>   label <B style="COLOR: black; BACKGROUND-COLOR: #ffff66">linux
    </B><B style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> vmlinuz
    append initrd=initrd.gz
</PRE>Its similar to a LILO config. The main things are the <B 
        style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> name and the 
        append string which includes the name of our initrd. The fact that its 
        gzipped doesn't matter. the <B 
        style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> will 
        automatically decompress it later. 
        <P>To burn the CD, I have the cd tree shown above under my /src/<B 
        style="COLOR: white; BACKGROUND-COLOR: #00aa00">iso</B>/cdimage 
        directory (.ie I have a /src/<B 
        style="COLOR: white; BACKGROUND-COLOR: #00aa00">iso</B>/cdimage/isolinux 
        directory). I run mkisofs as per the isolinux.doc that comes with 
        Syslinux: <PRE>        mkisofs -o /<B style="COLOR: white; BACKGROUND-COLOR: #00aa00">iso</B>.img -b isolinux/isolinux.bin -c isolinux/boot.cat \
                -no-emul-boot -boot-load-size 4 -boot-info-table -l \
                -R -r /src/<B style="COLOR: white; BACKGROUND-COLOR: #00aa00">iso</B>/cdimage
</PRE>The boot.cat file is created by the mkisofs command. The -l , -R 
        and -r options are essentially for RockRidge extensions which allow us 
        to have softlinks on the CD and mixed case filenames. We should end up 
        with a couple of meg <B 
        style="COLOR: white; BACKGROUND-COLOR: #00aa00">iso</B>.img file. You 
        can now burn this to the CD using cdrecord (I'll leave this up to you as 
        your speed and dev settings are undoubtedly different to me). 
        <P>Reboot your system, enter the BIOS setup screens to check that your 
        system will boot off a CD and load the CD and see if it boots. 
        Hopefully, you should see 'Loading vmlinuz', then 'Loading initrd.gz', 
        then the <B style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> 
        should do its stuff. You should end up at a shell prompt. You won't be 
        able to do much though. Because there was no real ramdisk.tgz file to 
        load, you're stuck inside the initrd. </P></BLOCKQUOTE>
      <H4>The 'Real' root filesystem</H4>
      <BLOCKQUOTE>You can't do too much with an initrd only system. You really 
        need to create a useable root filesystem. Again, I'm using a 4mb RAM 
        disk, so its a bit of a squeeze (why didn't I go for a bigger RAM disk? 
        I just hate wasting space, and I wanted this to be useable on machines 
        with 16mb of ram or more). I chose <A 
        href="http://busybox.lineo.com/">Busybox</A> to provide most of my /bin 
        tools. In 0.51 of Busybox, you even get things like vi and wget. Its 
        getting fatter at 250Kb or so these days with every tool compiled in 
        (NB: You can reduce its <B 
        style="COLOR: black; BACKGROUND-COLOR: #ff9999">code</B> size by editing 
        Config.h and commenting out the defines for the tools you don't want), 
        but 250K is fine for our 4mb filesystem. I've put some libraries in too: 
<PRE>   ld-2.1.3.so
   ld-<B style="COLOR: black; BACKGROUND-COLOR: #ffff66">linux</B>.so.2 -&gt; ld-2.1.3.so
   libbz2.so.1.0 -&gt; libbz2.so.1.0.0
   libbz2.so.1.0.0
   libc-2.1.3.so
   libc.so.6 -&gt; libc-2.1.3.so
   libcom_err.so.2 -&gt; libcom_err.so.2.0
   libcom_err.so.2.0
   libdl-2.1.3.so
   libdl.so.2 -&gt; libdl-2.1.3.so
   libe2p.so.2 -&gt; libe2p.so.2.3
   libe2p.so.2.3
   libext2fs.so.2 -&gt; libext2fs.so.2.4
   libext2fs.so.2.4
   libm-2.1.3.so
   libm.so.6 -&gt; libm-2.1.3.so
   libncurses.so.5 -&gt; libncurses.so.5.0
   libncurses.so.5.0
   libtermcap.so.2 -&gt; libtermcap.so.2.0.8
   libtermcap.so.2.0.8
   libuuid.so.1 -&gt; libuuid.so.1.2
   libuuid.so.1.2
</PRE>Not all of these are really required to get the system up and 
        running. I think some are left over from when I had mke2fs. /bin is just 
        busybox and a sh*#load of soft links. I have an /sbin/init (not linked 
        to busybox, its a real sysvinit). In /etc I have an inittab, termcap and 
        an rc.d directory. Currently I just have an rc.S startup script that is 
        run during the sysinit phase of the init startup. The key parts of my 
        inittab are: <PRE>   id:1:initdefault:

   si::sysinit:/etc/rc.d/rc.S
   l0:0:wait:/bin/sh
   l1:1:wait:/bin/sh
</PRE>/etc/fstab looks like: <PRE>   /dev/ram1       /        ext2        defaults   1   1
   none             /dev/pts  devpts     gid=5,mode=620  0   0
   none             /proc    proc        defaults   0   0
</PRE>I also have an empty /initrd directory. This means that once that 
        the initrd phase has finished, and the real root filesystem on /dev/ram1 
        is mounted, the initrd filesystem (on /dev/ram0) is moved under /initrd. 
        This means we can unmount it and free the ramdisk space. 
        <P>My /etc/rc.d/rc.S script looks like: <PRE>#!/bin/sh

PATH=/bin;export PATH
echo "System init"
mount -t proc none /proc
mount -o remount,rw /
echo "Find the extras on the CD and mount it"
if [ -r /dev/<B style="COLOR: white; BACKGROUND-COLOR: #880000">cdrom</B> ] ; then
   mount -t iso9660 /dev/<B style="COLOR: white; BACKGROUND-COLOR: #880000">cdrom</B> /<B style="COLOR: white; BACKGROUND-COLOR: #880000">cdrom</B>
   if [ -r /<B style="COLOR: white; BACKGROUND-COLOR: #880000">cdrom</B>/part1.ext2 ] ;then
      echo "Mounting loopback device"
      mount -o loop,ro /<B style="COLOR: white; BACKGROUND-COLOR: #880000">cdrom</B>/part1.ext2 /a
   else
      echo "Mounting HD partition instead"
      mount /dev/hda9 /a
   fi
fi
cd /
umount /initrd
freeramdisk /dev/ram0
</PRE>First we mount /proc, and then remount / (remember we have a valid 
        entry for / in /etc/fstab now) as read/write. Now we check if the 
        /dev/<B style="COLOR: white; BACKGROUND-COLOR: #880000">cdrom</B> device 
        is there (it should have been created in the initrd phase), then mount 
        the cd. The next bits are part of my 'in-progress' work on bootable CDs. 
        In order to gain access to more libraries and binaries on the CD, we try 
        and mount a loop filesystem off the CD in /part1.ext2. We mount it on /a 
        (I just wanted to save typing). However, since I'm still debugging this, 
        I just get it to mount an existing partition on my hard disk on /a. /a 
        contains a bin directory and other directories for starting up X 
        windows. Potentially, it could contain everything else one would usually 
        find in a <B style="COLOR: black; BACKGROUND-COLOR: #ffff66">linux</B> 
        distribution. 
        <P>Currently (23 April 01), I haven't finalised how things will be 
        structured in the root filesystem. I don't really want to add more to 
        it, as I need some space for writing logs and other files. The default 
        behaviour is to look for libs in /lib and /usr/lib. The latter directory 
        doesn't exist, but I have the ability to soft-link it to a directory 
        under /a. </P></BLOCKQUOTE>
      <H4>An example <B style="COLOR: white; BACKGROUND-COLOR: #00aa00">ISO</B> 
      image to try out</H4>
      <BLOCKQUOTE>I've uploaded a very basic <B 
        style="COLOR: white; BACKGROUND-COLOR: #00aa00">ISO</B> that you can 
        burn to a CD and have a play with. It doesn't do too much as yet, but it 
        has the full set of busybox 0.51 commands available and I've added some 
        scripts to simplify the setting up of your lan card and IP address 
        details. 
        <P>First, download the <A 
        href="http://www.geocities.com/potato.geo/bootcd/iso.img.gz"><B 
        style="COLOR: white; BACKGROUND-COLOR: #00aa00">iso</B>.img.gz</A> file. 
        Decompress it with gunzip and burn it to a CD (I'd suggest a CDRW) using 
        cdrecord or if you want to do it from Windows, you probably just need to 
        rename it to blah.<B 
        style="COLOR: white; BACKGROUND-COLOR: #00aa00">iso</B> and Easy CD 
        Creator or whathaveyou should be able to burn it. 
        <P>The CD contains my own initrd.gz and rootfs.gz. You can have a look 
        at these by decompressing them and mounting them as ext2 filesystems on 
        a loopback mount. 
        <P>Reboot with the CD in your CD drive and you should get some ISOLINUX 
        message and away it goes. I've enabled framebuffer support, so if you 
        have an old PC you may not see past the initrd.gz loading bit. If your 
        video card is VESA 2 compliant you should get a penguin up the top of 
        the screen followed by the usual blurb of console messages. 
        <P>You'll get an sulogin prompt (please enter the root password or press 
        ctrl-D), so enter the root password (a single space) and you should be 
        at a bash prompt. 
        <P>To configure your LAN card enter <I>cfgcard</I> and follow the 
        prompts. The list of cards that is shown is simply the modules directory 
        on the CD. Cards like 3c509 are obvious, but others are not. I have an 
        rtl8139 based card which is the most common el-cheapo 10/100Mbps card 
        you can buy. 
        <P>Now do a <I>cfglan</I> which allows you to set the IP address, 
        netmask and default gateway etc. 
        <P>Everything else is up to you. You can get DNS working if you just 
        create an /etc/resolv.conf. Busybox includes nslookup and telnet, so 
        have fun. 
        <P>Note that to keep the size of the <B 
        style="COLOR: white; BACKGROUND-COLOR: #00aa00">ISO</B> quite small, I 
        have not included any X related stuff.... for now. </P></BLOCKQUOTE>
      <H4>A smaller initrd</H4>
      <BLOCKQUOTE>If you look at the <A 
        href="http://www.geocities.com/potato.geo/bootcd/iso.img.gz"><B 
        style="COLOR: white; BACKGROUND-COLOR: #00aa00">iso</B>.img.gz</A> image 
        I uploaded to play with you'll notice that the initrd.gz file is quite 
        large. Around 600kb. Being the minimalist I am, I thought this was an 
        awful waste considering the limited job that the initrd does. Most of 
        the space is taken up with the enormous libc library. I could have 
        looked at smaller libc libraries or tried statically linking a C 
        program, but having spent my early programming days dabbling in assembly 
        language, I thought it a good opportunity to write the equivalent of my 
        linuxrc file in 386 assembly. 
        <P>With a little help from the framework behind the great asmutils (see 
        <A 
        href="http://www.linuxassembly.org/">http://www.linuxassembly.org/</A>), 
        I hacked together a little program that did everything except gunzip the 
        rootfs.gz file. Instead, I just dd'd an uncompressed copy directly from 
        the disk. Of course, I was a bit perturbed by the length of time it was 
        taking to load a 4mb file from <B 
        style="COLOR: white; BACKGROUND-COLOR: #880000">CDROM</B>, so I looked 
        into writing my own gunzip in assembly (well I actually searched to see 
        if anyone else had achieved this feat ... sadly no). Figuring that 
        gunzip was too difficult to convert from C into assembly, I looked at 
        other compression sources and eventually came across a thing called the 
        <A href="http://sed.free.fr/624">624</A>. It was designed for the 4k 
        intro 'scene'. I think the basic goal of it was to crunch a 6k assembly 
        program down to about 4k and attach a very small decruncher to it. The 
        author had the compressor part written in C and the decruncher part 
        written in 386 asm. Cool. I just mangled the <B 
        style="COLOR: black; BACKGROUND-COLOR: #ff9999">code</B> so that it 
        wasn't compressing such small files and it wasn't decompressing as part 
        of an executable. 
        <P>My complete linuxrc (that doesn't require any external libraries) is 
        now about 1kbyte in length. Cool. Here's the <B 
        style="COLOR: black; BACKGROUND-COLOR: #99ff99">source</B> for <A 
        href="http://www.geocities.com/potato.geo/bootcd/linuxrc.asm">linuxrc.asm</A>. 
        The <B style="COLOR: black; BACKGROUND-COLOR: #99ff99">source</B> for 
        the compressor is <A 
        href="http://www.geocities.com/potato.geo/bootcd/pcomp.c">pcomp.c</A>. 
        You'll need to compile it with something like <CODE>gcc -o pcomp 
        pcomp.c</CODE>. The new linuxrc first looks for an uncompressed 4mb 
        filesystem file called 'rootfs' in the root directory of the CD. If that 
        doesn't exist it looks for a file called 'rootfs.lz' in the same 
        directory. This must be a file compressed with pcomp (To run pcomp, just 
        do something like 'pcomp rootfs' and it should create a 'rootfs.lz' 
        file). 
        <P>Finally, the new improved 'basic' <B 
        style="COLOR: white; BACKGROUND-COLOR: #00aa00">iso</B> image to play 
        with is <A 
        href="http://www.geocities.com/potato.geo/bootcd/iso.small.gz"><B 
        style="COLOR: white; BACKGROUND-COLOR: #00aa00">iso</B>.small.gz</A>. 
        Download it, gunzip it, and burn it to a CD and give it a go. The root 
        password is a 'space', and the <I>cfgcard</I> and <I>cfglan</I> stuff 
        should work. </P></BLOCKQUOTE>
      <H4>Framework for extensibility</H4>
      <BLOCKQUOTE>OR ... how to add your own extra bits. These so called 
        'basic images' that I have to download here all have the /usr directory 
        in the ram based root filesystem as a softlink to /<B 
        style="COLOR: white; BACKGROUND-COLOR: #880000">cdrom</B>/usr. Which 
        means that you can add your own tools and utilities under /usr on the 
        CD. ie. Create a /usr/bin on the CD and add in all the tools that 
        Busybox doesn't include. Add some libraries into /usr/lib ... and what 
        I've been working on is the basic requirements to get X up and running. 
        One thing to remember is that you really do have to burn the CD with 
        RockRidge extensions on in order for softlinks and mixed case filenames 
        to be created properly on the CD. 
        <P>To build it all yourself, you'll have to do something like this from 
        a real <B style="COLOR: black; BACKGROUND-COLOR: #ffff66">linux</B> 
        system: <PRE>   losetup /dev/loop3 /<B style="COLOR: white; BACKGROUND-COLOR: #00aa00">iso</B>.small
   mount -t iso9660 /dev/loop3 /mnt
   mkdir /cdimage
   cd /mnt
   tar cf - . | (cd /cdimage ; tar xf - )
   # Now make sure you have a /cdimage/usr directory and add your own
   # tools in there. When you're finished, just use mkisofs on the /cdimage
   # directory to build a new image to burn to the CD.
</PRE></BLOCKQUOTE>
      <H4>Framebuffer</H4>
      <BLOCKQUOTE>One of my experimental aims is to have an X windows 
        environment on a boot CD. To <B 
        style="COLOR: black; BACKGROUND-COLOR: #ff66ff">achieve</B> the widest 
        possible compatibility, I've chosen to enable the Framebuffer console 
        mode and to use the XF86_FBDev X server (its just the one from Slackware 
        7.1 at the moment). Note: Even though I am aiming for wide compatibility 
        just so I can run X, Framebuffer mode doesn't work with pre VESA 2.0 
        video cards which means you may not want to add in Framebuffer if all 
        you really need is a console prompt. To activate Framebuffer console 
        mode you need to make sure some things are compiled into the <B 
        style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B>, typically 
        this includes: <PRE>   [*] VGA text console
   [*] Video mode selection support
   [*] Support for frame buffer devices (EXPERIMENTAL)
   [*] VESA VGA graphics console
   [*] Advanced low level driver options
   &lt;*&gt; 8 bpp packed pixels support
   &lt;*&gt; 16 bpp packed pixels support
   &lt;*&gt; 24 bpp packed pixels support
   &lt;*&gt; 32 bpp packed pixels support
   &lt;*&gt; VGA characters/attributes support
   [*] Select compiled-in fonts
   [*]   VGA 8x8 font
   [*]   VGA 8x16 font
</PRE>The other thing that I didn't realise until later is you have to 
        make sure you set a graphical mode for the console when it boots in 
        order to use the X server in default mode. This means putting a specific 
        vga= setting appended to the <B 
        style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> at boot time. 
        Specifically, you need to change the /isolinux/isolinux.cfg file on the 
        CD so it looks something like: <PRE>label <B style="COLOR: black; BACKGROUND-COLOR: #ffff66">linux
 </B><B style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> vmlinuz
 append initrd=initrd.gz vga=791
</PRE>The '791' means to start up in 1024x768x16bit colour mode. Hard 
        coding the display resolution is fine if you know for certain that your 
        video card/monitor can handle it, but what I've done is to let the user 
        choose a display option at boot time. My isolinux.cfg looks like this: <PRE>timeout 30
prompt 1
display menu.txt
default 1
label 1
 <B style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> vmlinuz
 append initrd=initrd.gz

label 2
 <B style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> vmlinuz
 append initrd=initrd.gz vga=788

label 2
 <B style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> vmlinuz
 append initrd=initrd.gz vga=791
</PRE>menu.txt is a simple text file that looks like: <PRE>   1) Text Mode
   2) 800x600 x 16bit colour
   3) 1024x768 x 16bit colour
</PRE>The user just enters '1' if they want text mode, 2 for 800x600 and 
        so on. </BLOCKQUOTE>
      <H3>Notes</H3>
      <BLOCKQUOTE>
        <UL>
          <LI>The isolinux.cfg file seems rather dodgy if I put something like: <PRE>  label <B style="COLOR: black; BACKGROUND-COLOR: #ffff66">linux
     </B><B style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> vmlinuz
     append initrd=initrd.gz root=/dev/ram
</PRE>but seems to work OK if I take out the 
          <CODE>root=/dev/ram</CODE> and simply use rdev to set the root fs in 
          the <B style="COLOR: black; BACKGROUND-COLOR: #a0ffff">kernel</B> to 
          /dev/ram1. 
          <LI>You can't make /linuxrc start init properly. It just keeps 
          spitting out a 'Usage' string. I think its because init is unable to 
          start as pid 1. 
          <LI>mkisofs will only write 8.3 style uppercase only filenames by 
          default. If you want filenames up to 31 chars long, then specify the 
          <B>-l</B> option. If you want mixed case filenames you need to enable 
          the Rock Ridge extensions with the <B>-R</B> option, and may want to 
          use the <B>-r</B> option as well which assigns sensible user/group 
          ownership to all files. You will definately need the -R option if you 
          want to copy whole unix directory trees to the CD. </LI></UL></BLOCKQUOTE>
      <BLOCKQUOTE></BLOCKQUOTE><BR>
      <P align=right><I>May 04,2001</I></P></TD></TR></TBODY></TABLE><!-- text below generated by server. PLEASE REMOVE --></OBJECT></LAYER>
<DIV></DIV></SPAN></STYLE></NOSCRIPT></TABLE></SCRIPT></APPLET>
<SCRIPT language=JavaScript src=""></SCRIPT>

<SCRIPT language=JavaScript src=""></SCRIPT>

<SCRIPT language=javascript>geovisit();</SCRIPT>
<NOSCRIPT><IMG height=1 src="Making Bootable Linux CDs.files/visit.gif" width=1 
border=0></NOSCRIPT> <IMG height=1 alt=1 
src="Making Bootable Linux CDs.files/serv.gif" width=1> </BODY></HTML>

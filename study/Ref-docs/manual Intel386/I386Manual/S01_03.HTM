<html><!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html>

	<head>
		<title>80386 Programmer's Reference Manual -- Section 1.3</title>
	</head>

	<body>
		<b>up:</b> <a href="C01.HTM" tppabs="http://webster.cs.ucr.edu/Page_TechDocs/Doc386/C01.HTM">Chapter 1 -- Introduction to the 80386</a><br>
		<b>prev:</b> <a href="S01_02.HTM" tppabs="http://webster.cs.ucr.edu/Page_TechDocs/Doc386/S01_02.HTM">1.2 Related Literature</a><br>
		<b>next:</b> <a href="C02.HTM" tppabs="http://webster.cs.ucr.edu/Page_TechDocs/Doc386/C02.HTM">Chapter 2 -- Basic Programming Model</a>
		<p>
		<hr>
		<p>
		<h1>1.3 Notational Conventions</h1>
		This manual uses special notations for data-structure formats, for symbolic representation of instructions, for hexadecimal numbers, and for super- and sub-scripts. Subscript characters are surrounded by {curly brackets}, for example 10{2} = 10 base 2. Superscript characters are preceeded by a caret and enclosed within (parentheses), for example 10^(3) = 10 to the third power. A review of these notations will make it easier to read the manual.
		<h2>1.3.1 Data-Structure Formats</h2>
		In illustrations of data structures in memory, smaller addresses appear at the lower-right part of the figure; addresses increase toward the left and upwards. Bit positions are numbered from right to left. <a href="#fig1-1">Figure 1-1</a> illustrates this convention.
		<h2>1.3.2 Undefined Bits and Software Compatibility</h2>
		In many register and memory layout descriptions, certain bits are marked as undefined. When bits are marked as undefined (as illustrated in <a href="#fig1-1">Figure 1-1</a> ), it is essential for compatibility with future processors that software treat these bits as undefined. Software should follow these guidelines in dealing with undefined bits:
		<ul>
			<li>Do not depend on the states of any undefined bits when testing the values of registers that contain such bits. Mask out the undefined bits before testing.
			<li>Do not depend on the states of any undefined bits when storing them in memory or in another register.
			<li>Do not depend on the ability to retain information written into any undefined bits.
			<li>When loading a register, always load the undefined bits as zeros or reload them with values previously stored from the same register.
		</ul>
		<p>
		<hr>
		<p><em>
		<h3>Note</h3>
		Depending upon the values of undefined register bits will make software dependent upon the unspecified manner in which the 80386 handles these bits. Depending upon undefined values risks making software incompatible with future processors that define usages for these bits. AVOID ANY SOFTWARE DEPENDENCE UPON THE STATE OF UNDEFINED 80386 REGISTER BITS. </em>
		<p>
		<hr>
		<p><a name="fig1-1"><img align="center" src="FIG1-1.GIF" tppabs="http://webster.cs.ucr.edu/Page_TechDocs/Doc386/FIG1-1.GIF" border="0">
		<h2>1.3.3 Instruction Operands</h2>
		When instructions are represented symbolically, a subset of the 80386 Assembly Language is used. In this subset, an instruction has the following format:
		<pre>



label: prefix mnemonic argument1, argument2, argument3
</pre>
		where:
		<ul>
			<li>A <tt>label</tt> is an identifier that is followed by a colon.
			<li>A <tt>prefix</tt> is an optional reserved name for one of the instruction prefixes.
			<li>A <tt>mnemonic</tt> is a reserved name for a class of instruction opcodes that have the same function.
			<li>The operands <tt>argument1</tt>, <tt>argument2</tt>, and <tt>argument3</tt> are optional. There may be from zero to three operands, depending on the opcode. When present, they take the form of either literals or identifiers for data items. Operand identifiers are either reserved names of registers or are assumed to be assigned to data items declared in another part of the program (which may not be shown in the example). When two operands are present in an instruction that modifies data, the right operand is
		</ul>
		<p>the source and the left operand is the destination. For example: LOADREG: <a href="MOV.HTM" tppabs="http://webster.cs.ucr.edu/Page_TechDocs/Doc386/MOV.HTM">MOV</a> EAX, SUBTOTAL In this example LOADREG is a label, <a href="MOV.HTM" tppabs="http://webster.cs.ucr.edu/Page_TechDocs/Doc386/MOV.HTM">MOV</a> is the mnemonic identifier of an opcode, EAX is the destination operand, and SUBTOTAL is the source operand.
		<h2>1.3.4 Hexadecimal Numbers</h2>
		Base 16 numbers are represented by a string of hexadecimal digits followed by the character H. A hexadecimal digit is a character from the set (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F). In some cases, especially in examples of program syntax, a leading zero is added if the number would otherwise begin with one of the digits A-F. For example, 0FH is equivalent to the decimal number 15.
		<h2>1.3.5 Sub- and Super-Scripts</h2>
		This manual uses special notation to represent sub- and super-script characters. Sub-script characters are surrounded by {curly brackets}, for example 10{2} = 10 base 2. Super-script characters are preceeded by a caret and enclosed within (parentheses), for example 10^(3) = 10 to the third power.
		<p>
		<hr>
		<p><b>up:</b> <a href="C01.HTM" tppabs="http://webster.cs.ucr.edu/Page_TechDocs/Doc386/C01.HTM">Chapter 1 -- Introduction to the 80386</a><br>
		<b>prev:</b> <a href="S01_02.HTM" tppabs="http://webster.cs.ucr.edu/Page_TechDocs/Doc386/S01_02.HTM">1.2 Related Literature</a><br>
		<b>next:</b> <a href="C02.HTM" tppabs="http://webster.cs.ucr.edu/Page_TechDocs/Doc386/C02.HTM">Chapter 2 -- Basic Programming Model</a>
	</body>


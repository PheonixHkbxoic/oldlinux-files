<html><!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html>

	<head>
		<title>80386 Programmer's Reference Manual -- Section 16.2</title>
	</head>

	<body>
		<b>up:</b> <a href="C16.HTM" tppabs="http://webster.cs.ucr.edu/Page_TechDocs/Doc386/C16.HTM">Chapter 16 -- Mixing 16-Bit and 32 Bit Code</a><br>
		<b>prev:</b> <a href="S16_01.HTM" tppabs="http://webster.cs.ucr.edu/Page_TechDocs/Doc386/S16_01.HTM">16.1 How the 80386 Implements 16-Bit and 32-Bit Features</a><br>
		<b>next:</b> <a href="S16_03.HTM" tppabs="http://webster.cs.ucr.edu/Page_TechDocs/Doc386/S16_03.HTM">16.3 Sharing Data Segments Among Mixed Code Segments</a>
		<p>
		<hr>
		<p>
		<h1>16.2 Mixing 32-Bit and 16-Bit Operations</h1>
		The 80386 has two instruction prefixes that allow mixing of 32-bit and 16-bit operations within one segment:
		<ul>
			<li>The operand-size prefix (66H)
			<li>The address-size prefix (67H)
		</ul>
		<p>These prefixes reverse the default size selected by the D-bit. For example, the processor can interpret the word-move instruction <a href="MOV.HTM" tppabs="http://webster.cs.ucr.edu/Page_TechDocs/Doc386/MOV.HTM">MOV</a> mem, reg in any of four ways:
		<ul>
			<li>In a USE32 segment:
			<ol>
				<li>Normally moves 32 bits from a 32-bit register to a 32-bit effective address in memory.
				<li>If preceded by an operand-size prefix, moves 16 bits from a 16-bit register to 32-bit effective address in memory.
				<li>If preceded by an address-size prefix, moves 32 bits from a 32-bit register to a16-bit effective address in memory.
				<li>If preceded by both an address-size prefix and an operand-size prefix, moves 16 bits from a 16-bit register to a 16-bit effective address in memory.
			</ol>
			<li>In a USE16 segment:
			<ol>
				<li>Normally moves 16 bits from a 16-bit register to a 16-bit effective address in memory.
				<li>If preceded by an operand-size prefix, moves 32 bits from a 32-bit register to 16-bit effective address in memory.
				<li>If preceded by an address-size prefix, moves 16 bits from a 16-bit register to a32-bit effective address in memory.
				<li>If preceded by both an address-size prefix and an operand-size prefix, moves 32 bits from a 32-bit register to a 32-bit effective address in memory.
			</ol>
		</ul>
		These examples illustrate that any instruction can generate any combination of operand size and address size regardless of whether the instruction is in a USE16 or USE32 segment. The choice of the USE16 or USE32 attribute for a code segment is based upon these criteria:
		<ol>
			<li>The need to address instructions or data in segments that are larger than 64 Kilobytes.
			<li>The predominant size of operands.
			<li>The addressing modes desired. (Refer to <a href="C17.HTM" tppabs="http://webster.cs.ucr.edu/Page_TechDocs/Doc386/C17.HTM">Chapter 17</a> for an explanation of the additional addressing modes that are available when 32-bit addressing is used.)
		</ol>
		Choosing a setting of the D-bit that is contrary to the predominant size of operands requires the generation of an excessive number of operand-size prefixes.
		<p>
		<hr>
		<p><b>up:</b> <a href="C16.HTM" tppabs="http://webster.cs.ucr.edu/Page_TechDocs/Doc386/C16.HTM">Chapter 16 -- Mixing 16-Bit and 32 Bit Code</a><br>
		<b>prev:</b> <a href="S16_01.HTM" tppabs="http://webster.cs.ucr.edu/Page_TechDocs/Doc386/S16_01.HTM">16.1 How the 80386 Implements 16-Bit and 32-Bit Features</a><br>
		<b>next:</b> <a href="S16_03.HTM" tppabs="http://webster.cs.ucr.edu/Page_TechDocs/Doc386/S16_03.HTM">16.3 Sharing Data Segments Among Mixed Code Segments</a>
	</body>


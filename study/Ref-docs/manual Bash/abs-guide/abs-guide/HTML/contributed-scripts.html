<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Contributed Scripts</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.64
"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Bibliography"
HREF="biblio.html"><LINK
REL="NEXT"
TITLE="A Sed and Awk Micro-Primer"
HREF="sedawk.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="APPENDIX"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-family: sans-serif;"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="biblio.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="sedawk.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="APPENDIX"
><H1
><A
NAME="CONTRIBUTED-SCRIPTS"
>Appendix A. Contributed Scripts</A
></H1
><P
>These scripts, while not fitting into the text of this document, do
    illustrate some interesting shell programming techniques. They are useful,
    too. Have fun analyzing and running them.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="MANVIEW"
></A
><P
><B
>Example A-1. <B
CLASS="COMMAND"
>manview</B
>: Viewing formatted manpages
      </B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# manview.sh: Formats the source of a man page for viewing.
   3&nbsp;
   4&nbsp;# This is useful when writing man page source and you want to
   5&nbsp;# look at the intermediate results on the fly while working on it.
   6&nbsp;
   7&nbsp;E_WRONGARGS=65
   8&nbsp;
   9&nbsp;if [ -z "$1" ]
  10&nbsp;then
  11&nbsp;  echo "Usage: `basename $0` [filename]"
  12&nbsp;  exit $E_WRONGARGS
  13&nbsp;fi
  14&nbsp;
  15&nbsp;groff -Tascii -man $1 | less
  16&nbsp;# From the man page for groff.
  17&nbsp;
  18&nbsp;# If the man page includes tables and/or equations,
  19&nbsp;# then the above code will barf.
  20&nbsp;# The following line can handle such cases.
  21&nbsp;#
  22&nbsp;#   gtbl &#60; "$1" | geqn -Tlatin1 | groff -Tlatin1 -mtty-char -man
  23&nbsp;#
  24&nbsp;#   Thanks, S.C.
  25&nbsp;
  26&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="MAILFORMAT"
></A
><P
><B
>Example A-2. <B
CLASS="COMMAND"
>mailformat</B
>: Formatting an e-mail message</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# mail-format.sh: Format e-mail messages.
   3&nbsp;
   4&nbsp;# Gets rid of carets, tabs, also fold excessively long lines.
   5&nbsp;
   6&nbsp;# =================================================================
   7&nbsp;#                 Standard Check for Script Argument(s)
   8&nbsp;ARGS=1
   9&nbsp;E_BADARGS=65
  10&nbsp;E_NOFILE=66
  11&nbsp;
  12&nbsp;if [ $# -ne $ARGS ]  # Correct number of arguments passed to script?
  13&nbsp;then
  14&nbsp;  echo "Usage: `basename $0` filename"
  15&nbsp;  exit $E_BADARGS
  16&nbsp;fi
  17&nbsp;
  18&nbsp;if [ -f "$1" ]       # Check if file exists.
  19&nbsp;then
  20&nbsp;    file_name=$1
  21&nbsp;else
  22&nbsp;    echo "File \"$1\" does not exist."
  23&nbsp;    exit $E_NOFILE
  24&nbsp;fi
  25&nbsp;# =================================================================
  26&nbsp;
  27&nbsp;MAXWIDTH=70          # Width to fold long lines to.
  28&nbsp;
  29&nbsp;sed '
  30&nbsp;s/^&#62;//
  31&nbsp;s/^  *&#62;//
  32&nbsp;s/^  *//
  33&nbsp;s/		*//
  34&nbsp;' $1 | fold -s --width=$MAXWIDTH
  35&nbsp;          # -s option to "fold" breaks lines at whitespace, if possible.
  36&nbsp;
  37&nbsp;# This script was inspired by an article in a well-known trade journal
  38&nbsp;# extolling a 164K Windows utility with similar functionality.
  39&nbsp;
  40&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="RN"
></A
><P
><B
>Example A-3. <B
CLASS="COMMAND"
>rn</B
>: A simple-minded file rename utility</B
></P
><P
>This script is a modification of <A
HREF="textproc.html#LOWERCASE"
>Example 12-15</A
>.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#! /bin/bash
   2&nbsp;#
   3&nbsp;# Very simpleminded filename "rename" utility (based on "lowercase.sh").
   4&nbsp;#
   5&nbsp;# The "ren" utility, by Vladimir Lanin (lanin@csd2.nyu.edu),
   6&nbsp;# does a much better job of this.
   7&nbsp;
   8&nbsp;
   9&nbsp;ARGS=2
  10&nbsp;E_BADARGS=65
  11&nbsp;ONE=1                     # For getting singular/plural right (see below).
  12&nbsp;
  13&nbsp;if [ $# -ne "$ARGS" ]
  14&nbsp;then
  15&nbsp;  echo "Usage: `basename $0` old-pattern new-pattern"
  16&nbsp;  # As in "rn gif jpg", which renames all gif files in working directory to jpg.
  17&nbsp;  exit $E_BADARGS
  18&nbsp;fi
  19&nbsp;
  20&nbsp;number=0                  # Keeps track of how many files actually renamed.
  21&nbsp;
  22&nbsp;
  23&nbsp;for filename in *$1*      #Traverse all matching files in directory.
  24&nbsp;do
  25&nbsp;   if [ -f "$filename" ]  # If finds match...
  26&nbsp;   then
  27&nbsp;     fname=`basename $filename`            # Strip off path.
  28&nbsp;     n=`echo $fname | sed -e "s/$1/$2/"`   # Substitute new for old in filename.
  29&nbsp;     mv $fname $n                          # Rename.
  30&nbsp;     let "number += 1"
  31&nbsp;   fi
  32&nbsp;done   
  33&nbsp;
  34&nbsp;if [ "$number" -eq "$ONE" ]                # For correct grammar.
  35&nbsp;then
  36&nbsp; echo "$number file renamed."
  37&nbsp;else 
  38&nbsp; echo "$number files renamed."
  39&nbsp;fi 
  40&nbsp;
  41&nbsp;exit 0
  42&nbsp;
  43&nbsp;
  44&nbsp;# Exercise:
  45&nbsp;# --------
  46&nbsp;# What type of files will this not work on?
  47&nbsp;# How can this be fixed?</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ENCRYPTEDPW"
></A
><P
><B
>Example A-4. <B
CLASS="COMMAND"
>encryptedpw</B
>: Uploading to an ftp site,
      using a locally encrypted password</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# Example "ex72.sh" modified to use encrypted password.
   4&nbsp;
   5&nbsp;#  Note that this is still somewhat insecure,
   6&nbsp;#+ since the decrypted password is sent in the clear.
   7&nbsp;# Use something like "ssh" if this is a concern.
   8&nbsp;
   9&nbsp;E_BADARGS=65
  10&nbsp;
  11&nbsp;if [ -z "$1" ]
  12&nbsp;then
  13&nbsp;  echo "Usage: `basename $0` filename"
  14&nbsp;  exit $E_BADARGS
  15&nbsp;fi  
  16&nbsp;
  17&nbsp;Username=bozo           # Change to suit.
  18&nbsp;pword=/home/bozo/secret/password_encrypted.file
  19&nbsp;# File containing encrypted password.
  20&nbsp;
  21&nbsp;Filename=`basename $1`  # Strips pathname out of file name
  22&nbsp;
  23&nbsp;Server="XXX"
  24&nbsp;Directory="YYY"         # Change above to actual server name &#38; directory.
  25&nbsp;
  26&nbsp;
  27&nbsp;Password=`cruft &#60;$pword`          # Decrypt password.
  28&nbsp;#  Uses the author's own "cruft" file encryption package,
  29&nbsp;#+ based on the classic "onetime pad" algorithm,
  30&nbsp;#+ and obtainable from:
  31&nbsp;#+ Primary-site:   ftp://metalab.unc.edu /pub/Linux/utils/file
  32&nbsp;#+                 cruft-0.2.tar.gz [16k]
  33&nbsp;
  34&nbsp;
  35&nbsp;ftp -n $Server &#60;&#60;End-Of-Session
  36&nbsp;user $Username $Password
  37&nbsp;binary
  38&nbsp;bell
  39&nbsp;cd $Directory
  40&nbsp;put $Filename
  41&nbsp;bye
  42&nbsp;End-Of-Session
  43&nbsp;# -n option to "ftp" disables auto-logon.
  44&nbsp;# "bell" rings 'bell' after each file transfer.
  45&nbsp;
  46&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="COPYCD"
></A
><P
><B
>Example A-5. <B
CLASS="COMMAND"
>copy-cd</B
>: Copying a data CD</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# copy-cd.sh: copying a data CD
   3&nbsp;
   4&nbsp;CDROM=/dev/cdrom                           # CD ROM device
   5&nbsp;OF=/home/bozo/projects/cdimage.iso         # output file
   6&nbsp;#       /xxxx/xxxxxxx/                     Change to suit your system.
   7&nbsp;BLOCKSIZE=2048
   8&nbsp;SPEED=2                                    # May use higher speed if supported.
   9&nbsp;
  10&nbsp;echo; echo "Insert source CD, but do *not* mount it."
  11&nbsp;echo "Press ENTER when ready. "
  12&nbsp;read ready                                 # Wait for input, $ready not used.
  13&nbsp;
  14&nbsp;echo; echo "Copying the source CD to $OF."
  15&nbsp;echo "This may take a while. Please be patient."
  16&nbsp;
  17&nbsp;dd if=$CDROM of=$OF bs=$BLOCKSIZE          # Raw device copy.
  18&nbsp;
  19&nbsp;
  20&nbsp;echo; echo "Remove data CD."
  21&nbsp;echo "Insert blank CDR."
  22&nbsp;echo "Press ENTER when ready. "
  23&nbsp;read ready                                 # Wait for input, $ready not used.
  24&nbsp;
  25&nbsp;echo "Copying $OF to CDR."
  26&nbsp;
  27&nbsp;cdrecord -v -isosize speed=$SPEED dev=0,0 $OF
  28&nbsp;# Uses Joerg Schilling's "cdrecord" package (see its docs).
  29&nbsp;# http://www.fokus.gmd.de/nthp/employees/schilling/cdrecord.html
  30&nbsp;
  31&nbsp;
  32&nbsp;echo; echo "Done copying $OF to CDR on device $CDROM."
  33&nbsp;
  34&nbsp;echo "Do you want to erase the image file (y/n)? "  # Probably a huge file.
  35&nbsp;read answer
  36&nbsp;
  37&nbsp;case "$answer" in
  38&nbsp;[yY]) rm -f $OF
  39&nbsp;      echo "$OF erased."
  40&nbsp;      ;;
  41&nbsp;*)    echo "$OF not erased.";;
  42&nbsp;esac
  43&nbsp;
  44&nbsp;echo
  45&nbsp;
  46&nbsp;# Exercise:
  47&nbsp;# Change the above "case" statement to also accept "yes" and "Yes" as input.
  48&nbsp;
  49&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="DAYSBETWEEN"
></A
><P
><B
>Example A-6. <B
CLASS="COMMAND"
>days-between</B
>: Calculate number of days between two dates</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# days-between.sh:    Number of days between two dates.
   3&nbsp;# Usage: ./days-between.sh [M]M/[D]D/YYYY [M]M/[D]D/YYYY
   4&nbsp;
   5&nbsp;ARGS=2                # Two command line parameters expected.
   6&nbsp;E_PARAM_ERR=65        # Param error.
   7&nbsp;
   8&nbsp;REFYR=1600            # Reference year.
   9&nbsp;CENTURY=100
  10&nbsp;DIY=365
  11&nbsp;ADJ_DIY=367           # Adjusted for leap year + fraction.
  12&nbsp;MIY=12
  13&nbsp;DIM=31
  14&nbsp;LEAPCYCLE=4
  15&nbsp;
  16&nbsp;MAXRETVAL=256         # Largest permissable
  17&nbsp;                      # positive return value from a function.
  18&nbsp;
  19&nbsp;diff=		      # Declare global variable for date difference.
  20&nbsp;value=                # Declare global variable for absolute value.
  21&nbsp;day=                  # Declare globals for day, month, year.
  22&nbsp;month=
  23&nbsp;year=
  24&nbsp;
  25&nbsp;
  26&nbsp;Param_Error ()        # Command line parameters wrong.
  27&nbsp;{
  28&nbsp;  echo "Usage: `basename $0` [M]M/[D]D/YYYY [M]M/[D]D/YYYY"
  29&nbsp;  echo "       (date must be after 1/3/1600)"
  30&nbsp;  exit $E_PARAM_ERR
  31&nbsp;}  
  32&nbsp;
  33&nbsp;
  34&nbsp;Parse_Date ()                 # Parse date from command line params.
  35&nbsp;{
  36&nbsp;  month=${1%%/**}
  37&nbsp;  dm=${1%/**}                 # Day and month.
  38&nbsp;  day=${dm#*/}
  39&nbsp;  let "year = `basename $1`"  # Not a filename, but works just the same.
  40&nbsp;}  
  41&nbsp;
  42&nbsp;
  43&nbsp;check_date ()                 # Checks for invalid date(s) passed.
  44&nbsp;{
  45&nbsp;  [ "$day" -gt "$DIM" ] || [ "$month" -gt "$MIY" ] || [ "$year" -lt "$REFYR" ] &#38;&#38; Param_Error
  46&nbsp;  # Exit script on bad value(s).
  47&nbsp;  # Uses "or-list / and-list".
  48&nbsp;  #
  49&nbsp;  # Exercise: Implement more rigorous date checking.
  50&nbsp;}
  51&nbsp;
  52&nbsp;
  53&nbsp;strip_leading_zero () # Better to strip possible leading zero(s)
  54&nbsp;{                     # from day and/or month
  55&nbsp;  val=${1#0}          # since otherwise Bash will interpret them
  56&nbsp;  return $val         # as octal values (POSIX.2, sect 2.9.2.1).
  57&nbsp;}
  58&nbsp;
  59&nbsp;
  60&nbsp;day_index ()          # Gauss' Formula:
  61&nbsp;{                     # Days from Jan. 3, 1600 to date passed as param.
  62&nbsp;
  63&nbsp;  day=$1
  64&nbsp;  month=$2
  65&nbsp;  year=$3
  66&nbsp;
  67&nbsp;  let "month = $month - 2"
  68&nbsp;  if [ "$month" -le 0 ]
  69&nbsp;  then
  70&nbsp;    let "month += 12"
  71&nbsp;    let "year -= 1"
  72&nbsp;  fi  
  73&nbsp;
  74&nbsp;  let "year -= $REFYR"
  75&nbsp;  let "indexyr = $year / $CENTURY"
  76&nbsp;
  77&nbsp;
  78&nbsp;  let "Days = $DIY*$year + $year/$LEAPCYCLE - $indexyr + $indexyr/$LEAPCYCLE + $ADJ_DIY*$month/$MIY + $day - $DIM"
  79&nbsp;  # For an in-depth explanation of this algorithm, see
  80&nbsp;  # http://home.t-online.de/home/berndt.schwerdtfeger/cal.htm
  81&nbsp;
  82&nbsp;
  83&nbsp;  if [ "$Days" -gt "$MAXRETVAL" ]  # If greater than 256,
  84&nbsp;  then                             # then change to negative value
  85&nbsp;    let "dindex = 0 - $Days"       # which can be returned from function.
  86&nbsp;  else let "dindex = $Days"
  87&nbsp;  fi
  88&nbsp;
  89&nbsp;  return $dindex
  90&nbsp;
  91&nbsp;}  
  92&nbsp;
  93&nbsp;
  94&nbsp;calculate_difference ()            # Difference between to day indices.
  95&nbsp;{
  96&nbsp;  let "diff = $1 - $2"             # Global variable.
  97&nbsp;}  
  98&nbsp;
  99&nbsp;
 100&nbsp;abs ()                             # Absolute value
 101&nbsp;{                                  # Uses global "value" variable.
 102&nbsp;  if [ "$1" -lt 0 ]                # If negative
 103&nbsp;  then                             # then
 104&nbsp;    let "value = 0 - $1"           # change sign,
 105&nbsp;  else                             # else
 106&nbsp;    let "value = $1"               # leave it alone.
 107&nbsp;  fi
 108&nbsp;}
 109&nbsp;
 110&nbsp;
 111&nbsp;
 112&nbsp;if [ $# -ne "$ARGS" ]              # Require two command line params.
 113&nbsp;then
 114&nbsp;  Param_Error
 115&nbsp;fi  
 116&nbsp;
 117&nbsp;Parse_Date $1
 118&nbsp;check_date $day $month $year      # See if valid date.
 119&nbsp;
 120&nbsp;strip_leading_zero $day           # Remove any leading zeroes
 121&nbsp;day=$?                            # on day and/or month.
 122&nbsp;strip_leading_zero $month
 123&nbsp;month=$?
 124&nbsp;
 125&nbsp;day_index $day $month $year
 126&nbsp;date1=$?
 127&nbsp;
 128&nbsp;abs $date1                         # Make sure it's positive
 129&nbsp;date1=$value                       # by getting absolute value.
 130&nbsp;
 131&nbsp;Parse_Date $2
 132&nbsp;check_date $day $month $year
 133&nbsp;
 134&nbsp;strip_leading_zero $day
 135&nbsp;day=$?
 136&nbsp;strip_leading_zero $month
 137&nbsp;month=$?
 138&nbsp;
 139&nbsp;day_index $day $month $year
 140&nbsp;date2=$?
 141&nbsp;
 142&nbsp;abs $date2                         # Make sure it's positive.
 143&nbsp;date2=$value
 144&nbsp;
 145&nbsp;calculate_difference $date1 $date2
 146&nbsp;
 147&nbsp;abs $diff                          # Make sure it's positive.
 148&nbsp;diff=$value
 149&nbsp;
 150&nbsp;echo $diff
 151&nbsp;
 152&nbsp;exit 0
 153&nbsp;# Compare this script with the implementation of Gauss' Formula in C at
 154&nbsp;# http://buschencrew.hypermart.net/software/datedif</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="COLLATZ"
></A
><P
><B
>Example A-7. Collatz series</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# collatz.sh
   3&nbsp;
   4&nbsp;#  The notorious "hailstone" or Collatz series.
   5&nbsp;#  -------------------------------------------
   6&nbsp;#  1) Get the integer "seed" from the command line.
   7&nbsp;#  2) NUMBER &#60;--- seed
   8&nbsp;#  3) Print NUMBER.
   9&nbsp;#  4)  If NUMBER is even, divide by 2, or
  10&nbsp;#  5)+ if odd, multiply by 3 and add 1.
  11&nbsp;#  6) NUMBER &#60;--- result 
  12&nbsp;#  7) Loop back to step 3 (for specified number of iterations).
  13&nbsp;#
  14&nbsp;#  The theory is that every sequence,
  15&nbsp;#+ no matter how large the initial value,
  16&nbsp;#+ eventually settles down to repeating "4,2,1..." cycles,
  17&nbsp;#+ even after fluctuating through a wide range of values.
  18&nbsp;#
  19&nbsp;#  This is an instance of an "iterate",
  20&nbsp;#+ an operation that feeds its output back into the input.
  21&nbsp;#  Sometimes the result is a "chaotic" series.
  22&nbsp;
  23&nbsp;ARGS=1
  24&nbsp;E_BADARGS=65
  25&nbsp;
  26&nbsp;if [ $# -ne $ARGS ]           # Need a seed number.
  27&nbsp;then
  28&nbsp;  echo "Usage: `basename $0` NUMBER"
  29&nbsp;  exit $E_BADARGS
  30&nbsp;fi
  31&nbsp;
  32&nbsp;MAX_ITERATIONS=200
  33&nbsp;# For large seed numbers (&#62;32000), increase MAX_ITERATIONS.
  34&nbsp;
  35&nbsp;h=$1                          # Seed
  36&nbsp;
  37&nbsp;echo
  38&nbsp;echo "C($1) --- $MAX_ITERATIONS Iterations"
  39&nbsp;echo
  40&nbsp;
  41&nbsp;for ((i=1; i&#60;=MAX_ITERATIONS; i++))
  42&nbsp;do
  43&nbsp;
  44&nbsp;echo -n "$h	"
  45&nbsp;#          ^^^^^
  46&nbsp;#           tab
  47&nbsp;
  48&nbsp;  let "remainder = h % 2"
  49&nbsp;  if [ "$remainder" -eq 0 ]   # Even?
  50&nbsp;  then
  51&nbsp;    let "h /= 2"              # Divide by 2.
  52&nbsp;  else
  53&nbsp;    let "h = h*3 + 1"         # Multiply by 3 and add 1.
  54&nbsp;  fi
  55&nbsp;
  56&nbsp;
  57&nbsp;COLUMNS=10                    # Output 10 values per line.
  58&nbsp;let "line_break = i % $COLUMNS"
  59&nbsp;if [ "$line_break" -eq 0 ]
  60&nbsp;then
  61&nbsp;  echo
  62&nbsp;fi  
  63&nbsp;
  64&nbsp;done
  65&nbsp;
  66&nbsp;echo
  67&nbsp;
  68&nbsp;#  For more information on this mathematical function,
  69&nbsp;#+ see "Computers, Pattern, Chaos, and Beauty", by Pickover, p. 185 ff.,
  70&nbsp;#+ as listed in the bibliography.
  71&nbsp;
  72&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>+</P
><P
>The following two scripts are by Mark Moraes of the University
    of Toronto. See the enclosed file <SPAN
CLASS="QUOTE"
>"Moraes-COPYRIGHT"</SPAN
>
    for permissions and restrictions.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="BEHEAD"
></A
><P
><B
>Example A-8. <B
CLASS="COMMAND"
>behead</B
>: Removing mail and news message headers
      </B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#! /bin/sh
   2&nbsp;# Strips off the header from a mail/News message i.e. till the first
   3&nbsp;# empty line
   4&nbsp;# Mark Moraes, University of Toronto
   5&nbsp;
   6&nbsp;# ==&#62; These comments added by author of this document.
   7&nbsp;
   8&nbsp;if [ $# -eq 0 ]; then
   9&nbsp;# ==&#62; If no command line args present, then works on file redirected to stdin.
  10&nbsp;	sed -e '1,/^$/d' -e '/^[ 	]*$/d'
  11&nbsp;	# --&#62; Delete empty lines and all lines until 
  12&nbsp;	# --&#62; first one beginning with white space.
  13&nbsp;else
  14&nbsp;# ==&#62; If command line args present, then work on files named.
  15&nbsp;	for i do
  16&nbsp;		sed -e '1,/^$/d' -e '/^[ 	]*$/d' $i
  17&nbsp;		# --&#62; Ditto, as above.
  18&nbsp;	done
  19&nbsp;fi
  20&nbsp;
  21&nbsp;# ==&#62; Exercise: Add error checking and other options.
  22&nbsp;# ==&#62;
  23&nbsp;# ==&#62; Note that the small sed script repeats, except for the arg passed.
  24&nbsp;# ==&#62; Does it make sense to embed it in a function? Why or why not?</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="FTPGET"
></A
><P
><B
>Example A-9. <B
CLASS="COMMAND"
>ftpget</B
>: Downloading files via ftp
      </B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#! /bin/sh 
   2&nbsp;# $Id: ftpget,v 1.2 91/05/07 21:15:43 moraes Exp $ 
   3&nbsp;# Script to perform batch anonymous ftp. Essentially converts a list of
   4&nbsp;# of command line arguments into input to ftp.
   5&nbsp;# Simple, and quick - written as a companion to ftplist 
   6&nbsp;# -h specifies the remote host (default prep.ai.mit.edu) 
   7&nbsp;# -d specifies the remote directory to cd to - you can provide a sequence 
   8&nbsp;# of -d options - they will be cd'ed to in turn. If the paths are relative, 
   9&nbsp;# make sure you get the sequence right. Be careful with relative paths - 
  10&nbsp;# there are far too many symlinks nowadays.  
  11&nbsp;# (default is the ftp login directory)
  12&nbsp;# -v turns on the verbose option of ftp, and shows all responses from the 
  13&nbsp;# ftp server.  
  14&nbsp;# -f remotefile[:localfile] gets the remote file into localfile 
  15&nbsp;# -m pattern does an mget with the specified pattern. Remember to quote 
  16&nbsp;# shell characters.  
  17&nbsp;# -c does a local cd to the specified directory
  18&nbsp;# For example, 
  19&nbsp;# 	ftpget -h expo.lcs.mit.edu -d contrib -f xplaces.shar:xplaces.sh \
  20&nbsp;#		-d ../pub/R3/fixes -c ~/fixes -m 'fix*' 
  21&nbsp;# will get xplaces.shar from ~ftp/contrib on expo.lcs.mit.edu, and put it in
  22&nbsp;# xplaces.sh in the current working directory, and get all fixes from
  23&nbsp;# ~ftp/pub/R3/fixes and put them in the ~/fixes directory. 
  24&nbsp;# Obviously, the sequence of the options is important, since the equivalent
  25&nbsp;# commands are executed by ftp in corresponding order
  26&nbsp;#
  27&nbsp;# Mark Moraes (moraes@csri.toronto.edu), Feb 1, 1989 
  28&nbsp;# ==&#62; Angle brackets changed to parens, so Docbook won't get indigestion.
  29&nbsp;#
  30&nbsp;
  31&nbsp;
  32&nbsp;# ==&#62; These comments added by author of this document.
  33&nbsp;
  34&nbsp;# PATH=/local/bin:/usr/ucb:/usr/bin:/bin
  35&nbsp;# export PATH
  36&nbsp;# ==&#62; Above 2 lines from original script probably superfluous.
  37&nbsp;
  38&nbsp;TMPFILE=/tmp/ftp.$$
  39&nbsp;# ==&#62; Creates temp file, using process id of script ($$)
  40&nbsp;# ==&#62; to construct filename.
  41&nbsp;
  42&nbsp;SITE=`domainname`.toronto.edu
  43&nbsp;# ==&#62; 'domainname' similar to 'hostname'
  44&nbsp;# ==&#62; May rewrite this to parameterize this for general use.
  45&nbsp;
  46&nbsp;usage="Usage: $0 [-h remotehost] [-d remotedirectory]... [-f remfile:localfile]... \
  47&nbsp;		[-c localdirectory] [-m filepattern] [-v]"
  48&nbsp;ftpflags="-i -n"
  49&nbsp;verbflag=
  50&nbsp;set -f 		# So we can use globbing in -m
  51&nbsp;set x `getopt vh:d:c:m:f: $*`
  52&nbsp;if [ $? != 0 ]; then
  53&nbsp;	echo $usage
  54&nbsp;	exit 65
  55&nbsp;fi
  56&nbsp;shift
  57&nbsp;trap 'rm -f ${TMPFILE} ; exit' 0 1 2 3 15
  58&nbsp;echo "user anonymous ${USER-gnu}@${SITE} &#62; ${TMPFILE}"
  59&nbsp;# ==&#62; Added quotes (recommended in complex echoes).
  60&nbsp;echo binary &#62;&#62; ${TMPFILE}
  61&nbsp;for i in $*   # ==&#62; Parse command line args.
  62&nbsp;do
  63&nbsp;	case $i in
  64&nbsp;	-v) verbflag=-v; echo hash &#62;&#62; ${TMPFILE}; shift;;
  65&nbsp;	-h) remhost=$2; shift 2;;
  66&nbsp;	-d) echo cd $2 &#62;&#62; ${TMPFILE}; 
  67&nbsp;	    if [ x${verbflag} != x ]; then
  68&nbsp;	        echo pwd &#62;&#62; ${TMPFILE};
  69&nbsp;	    fi;
  70&nbsp;	    shift 2;;
  71&nbsp;	-c) echo lcd $2 &#62;&#62; ${TMPFILE}; shift 2;;
  72&nbsp;	-m) echo mget "$2" &#62;&#62; ${TMPFILE}; shift 2;;
  73&nbsp;	-f) f1=`expr "$2" : "\([^:]*\).*"`; f2=`expr "$2" : "[^:]*:\(.*\)"`;
  74&nbsp;	    echo get ${f1} ${f2} &#62;&#62; ${TMPFILE}; shift 2;;
  75&nbsp;	--) shift; break;;
  76&nbsp;	esac
  77&nbsp;done
  78&nbsp;if [ $# -ne 0 ]; then
  79&nbsp;	echo $usage
  80&nbsp;	exit 65   # ==&#62; Changed from "exit 2" to conform with standard.
  81&nbsp;fi
  82&nbsp;if [ x${verbflag} != x ]; then
  83&nbsp;	ftpflags="${ftpflags} -v"
  84&nbsp;fi
  85&nbsp;if [ x${remhost} = x ]; then
  86&nbsp;	remhost=prep.ai.mit.edu
  87&nbsp;	# ==&#62; Rewrite to match your favorite ftp site.
  88&nbsp;fi
  89&nbsp;echo quit &#62;&#62; ${TMPFILE}
  90&nbsp;# ==&#62; All commands saved in tempfile.
  91&nbsp;
  92&nbsp;ftp ${ftpflags} ${remhost} &#60; ${TMPFILE}
  93&nbsp;# ==&#62; Now, tempfile batch processed by ftp.
  94&nbsp;
  95&nbsp;rm -f ${TMPFILE}
  96&nbsp;# ==&#62; Finally, tempfile deleted (you may wish to copy it to a logfile).
  97&nbsp;
  98&nbsp;
  99&nbsp;# ==&#62; Exercises:
 100&nbsp;# ==&#62; ---------
 101&nbsp;# ==&#62; 1) Add error checking.
 102&nbsp;# ==&#62; 2) Add bells &#38; whistles.</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>+</P
><P
>Antek Sawicki contributed the following script, which makes very
      clever use of the parameter substitution operators discussed in
      <A
HREF="parameter-substitution.html"
>Section 9.3</A
>.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="PW"
></A
><P
><B
>Example A-10. <B
CLASS="COMMAND"
>password</B
>: Generating random
      8-character passwords</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# May need to be invoked with  #!/bin/bash2  on older machines.
   3&nbsp;#
   4&nbsp;# Random password generator for bash 2.x by Antek Sawicki &#60;tenox@tenox.tc&#62;,
   5&nbsp;# who generously gave permission to the document author to use it here.
   6&nbsp;#
   7&nbsp;# ==&#62; Comments added by document author ==&#62;
   8&nbsp;
   9&nbsp;
  10&nbsp;MATRIX="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
  11&nbsp;LENGTH="8"
  12&nbsp;# ==&#62; May change 'LENGTH' for longer password, of course.
  13&nbsp;
  14&nbsp;
  15&nbsp;while [ "${n:=1}" -le "$LENGTH" ]
  16&nbsp;# ==&#62; Recall that := is "default substitution" operator.
  17&nbsp;# ==&#62; So, if 'n' has not been initialized, set it to 1.
  18&nbsp;do
  19&nbsp;	PASS="$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}"
  20&nbsp;	# ==&#62; Very clever, but tricky.
  21&nbsp;
  22&nbsp;	# ==&#62; Starting from the innermost nesting...
  23&nbsp;	# ==&#62; ${#MATRIX} returns length of array MATRIX.
  24&nbsp;
  25&nbsp;	# ==&#62; $RANDOM%${#MATRIX} returns random number between 1
  26&nbsp;	# ==&#62; and length of MATRIX - 1.
  27&nbsp;
  28&nbsp;	# ==&#62; ${MATRIX:$(($RANDOM%${#MATRIX})):1}
  29&nbsp;	# ==&#62; returns expansion of MATRIX at random position, by length 1. 
  30&nbsp;	# ==&#62; See {var:pos:len} parameter substitution in Section 3.3.1
  31&nbsp;	# ==&#62; and following examples.
  32&nbsp;
  33&nbsp;	# ==&#62; PASS=... simply pastes this result onto previous PASS (concatenation).
  34&nbsp;
  35&nbsp;	# ==&#62; To visualize this more clearly, uncomment the following line
  36&nbsp;	# ==&#62;             echo "$PASS"
  37&nbsp;	# ==&#62; to see PASS being built up,
  38&nbsp;	# ==&#62; one character at a time, each iteration of the loop.
  39&nbsp;
  40&nbsp;	let n+=1
  41&nbsp;	# ==&#62; Increment 'n' for next pass.
  42&nbsp;done
  43&nbsp;
  44&nbsp;echo "$PASS"      # ==&#62; Or, redirect to file, as desired.
  45&nbsp;
  46&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>+</P
><P
>James R. Van Zandt contributed this script, which uses named pipes
      and, in his words, <SPAN
CLASS="QUOTE"
>"really exercises quoting and escaping"</SPAN
>.
      </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="FIFO"
></A
><P
><B
>Example A-11. <B
CLASS="COMMAND"
>fifo</B
>: Making daily backups, using named pipes</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# ==&#62; Script by James R. Van Zandt, and used here with his permission.
   3&nbsp;
   4&nbsp;# ==&#62; Comments added by author of this document.
   5&nbsp;
   6&nbsp;  
   7&nbsp;  HERE=`uname -n`    # ==&#62; hostname
   8&nbsp;  THERE=bilbo
   9&nbsp;  echo "starting remote backup to $THERE at `date +%r`"
  10&nbsp;  # ==&#62; `date +%r` returns time in 12-hour format, i.e. "08:08:34 PM".
  11&nbsp;  
  12&nbsp;  # make sure /pipe really is a pipe and not a plain file
  13&nbsp;  rm -rf /pipe
  14&nbsp;  mkfifo /pipe       # ==&#62; Create a "named pipe", named "/pipe".
  15&nbsp;  
  16&nbsp;  # ==&#62; 'su xyz' runs commands as user "xyz".
  17&nbsp;  # ==&#62; 'ssh' invokes secure shell (remote login client).
  18&nbsp;  su xyz -c "ssh $THERE \"cat &#62;/home/xyz/backup/${HERE}-daily.tar.gz\" &#60; /pipe"&#38;
  19&nbsp;  cd /
  20&nbsp;  tar -czf - bin boot dev etc home info lib man root sbin share usr var &#62;/pipe
  21&nbsp;  # ==&#62; Uses named pipe, /pipe, to communicate between processes:
  22&nbsp;  # ==&#62; 'tar/gzip' writes to /pipe and 'ssh' reads from /pipe.
  23&nbsp;
  24&nbsp;  # ==&#62; The end result is this backs up the main directories, from / on down.
  25&nbsp;
  26&nbsp;  # ==&#62; What are the advantages of a "named pipe" in this situation,
  27&nbsp;  # ==&#62; as opposed to an "anonymous pipe", with |?
  28&nbsp;  # ==&#62; Will an anonymous pipe even work here?
  29&nbsp;
  30&nbsp;
  31&nbsp;  exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>+</P
><P
>Stephane Chazelas contributed the following script to
      demonstrate that generating prime numbers does not require
      arrays.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="PRIMES"
></A
><P
><B
>Example A-12. Generating prime numbers using the modulo operator</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# primes.sh: Generate prime numbers, without using arrays.
   3&nbsp;
   4&nbsp;#  This does *not* use the classic "Sieve of Erastosthenes" algorithm,
   5&nbsp;#+ but instead uses the more intuitive method of testing each candidate number
   6&nbsp;#+ for factors (divisors), using the "%" modulo operator.
   7&nbsp;#
   8&nbsp;# Script contributed by Stephane Chazelas,
   9&nbsp;
  10&nbsp;
  11&nbsp;LIMIT=1000                    # Primes 2 - 1000
  12&nbsp;
  13&nbsp;Primes()
  14&nbsp;{
  15&nbsp; (( n = $1 + 1 ))             # Bump to next integer.
  16&nbsp; shift                        # Next parameter in list.
  17&nbsp;#  echo "_n=$n i=$i_"
  18&nbsp; 
  19&nbsp; if (( n == LIMIT ))
  20&nbsp; then echo $*
  21&nbsp; return
  22&nbsp; fi
  23&nbsp;
  24&nbsp; for i; do                    # "i" gets set to "@", previous values of $n.
  25&nbsp;#   echo "-n=$n i=$i-"
  26&nbsp;   (( i * i &#62; n )) &#38;&#38; break   # Optimization.
  27&nbsp;   (( n % i )) &#38;&#38; continue    # Sift out non-primes using modulo operator.
  28&nbsp;   Primes $n $@               # Recursion inside loop.
  29&nbsp;   return
  30&nbsp;   done
  31&nbsp;
  32&nbsp;   Primes $n $@ $n            # Recursion outside loop.
  33&nbsp;                              # Successively accumulate positional parameters.
  34&nbsp;			      # "$@" is the accumulating list of primes.
  35&nbsp;}
  36&nbsp;
  37&nbsp;Primes 1
  38&nbsp;
  39&nbsp;exit 0
  40&nbsp;
  41&nbsp;# Uncomment lines 17 and 25 to help figure out what is going on.
  42&nbsp;
  43&nbsp;# Compare the speed of this algorithm for generating primes
  44&nbsp;# with the Sieve of Erastosthenes (ex68.sh).
  45&nbsp;
  46&nbsp;# Exercise: Rewrite this script without recursion, for faster execution.</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>+</P
><P
>Jordi Sanfeliu gave permission to use his elegant
      <I
CLASS="EMPHASIS"
>tree</I
> script.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="TREE"
></A
><P
><B
>Example A-13. <B
CLASS="COMMAND"
>tree</B
>: Displaying a directory tree</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/sh
   2&nbsp;#         @(#) tree      1.1  30/11/95       by Jordi Sanfeliu
   3&nbsp;#                                         email: mikaku@arrakis.es
   4&nbsp;#
   5&nbsp;#         Initial version:  1.0  30/11/95
   6&nbsp;#         Next version   :  1.1  24/02/97   Now, with symbolic links
   7&nbsp;#         Patch by       :  Ian Kjos, to support unsearchable dirs
   8&nbsp;#                           email: beth13@mail.utexas.edu
   9&nbsp;#
  10&nbsp;#         Tree is a tool for view the directory tree (obvious :-) )
  11&nbsp;#
  12&nbsp;
  13&nbsp;# ==&#62; 'Tree' script used here with the permission of its author, Jordi Sanfeliu.
  14&nbsp;# ==&#62; Comments added by the author of this document.
  15&nbsp;# ==&#62; Argument quoting added.
  16&nbsp;
  17&nbsp;
  18&nbsp;search () {
  19&nbsp;   for dir in `echo *`
  20&nbsp;   # ==&#62; `echo *` lists all the files in current working directory, without line breaks.
  21&nbsp;   # ==&#62; Similar effect to     for dir in *
  22&nbsp;   # ==&#62; but "dir in `echo *`" will not handle filenames with blanks.
  23&nbsp;   do
  24&nbsp;      if [ -d "$dir" ] ; then   # ==&#62; If it is a directory (-d)...
  25&nbsp;         zz=0   # ==&#62; Temp variable, keeping track of directory level.
  26&nbsp;         while [ $zz != $deep ]    # Keep track of inner nested loop.
  27&nbsp;         do
  28&nbsp;            echo -n "|   "    # ==&#62; Display vertical connector symbol,
  29&nbsp;	                      # ==&#62; with 2 spaces &#38; no line feed in order to indent.
  30&nbsp;            zz=`expr $zz + 1` # ==&#62; Increment zz.
  31&nbsp;         done
  32&nbsp;         if [ -L "$dir" ] ; then   # ==&#62; If directory is a symbolic link...
  33&nbsp;            echo "+---$dir" `ls -l $dir | sed 's/^.*'$dir' //'`
  34&nbsp;	    # ==&#62; Display horiz. connector and list directory name, but...
  35&nbsp;	    # ==&#62; delete date/time part of long listing.
  36&nbsp;         else
  37&nbsp;            echo "+---$dir"      # ==&#62; Display horizontal connector symbol...
  38&nbsp;                                 # ==&#62; and print directory name.
  39&nbsp;            if cd "$dir" ; then  # ==&#62; If can move to subdirectory...
  40&nbsp;               deep=`expr $deep + 1`   # ==&#62; Increment depth.
  41&nbsp;               search     # with recursivity ;-)
  42&nbsp;	                  # ==&#62; Function calls itself.
  43&nbsp;               numdirs=`expr $numdirs + 1`   # ==&#62; Increment directory count.
  44&nbsp;            fi
  45&nbsp;         fi
  46&nbsp;      fi
  47&nbsp;   done
  48&nbsp;   cd ..   # ==&#62; Up one directory level.
  49&nbsp;   if [ "$deep" ] ; then  # ==&#62; If depth = 0 (returns TRUE)...
  50&nbsp;      swfi=1              # ==&#62; set flag showing that search is done.
  51&nbsp;   fi
  52&nbsp;   deep=`expr $deep - 1`  # ==&#62; Decrement depth.
  53&nbsp;}
  54&nbsp;
  55&nbsp;# - Main -
  56&nbsp;if [ $# = 0 ] ; then
  57&nbsp;   cd `pwd`    # ==&#62; No args to script, then use current working directory.
  58&nbsp;else
  59&nbsp;   cd $1       # ==&#62; Otherwise, move to indicated directory.
  60&nbsp;fi
  61&nbsp;echo "Initial directory = `pwd`"
  62&nbsp;swfi=0      # ==&#62; Search finished flag.
  63&nbsp;deep=0      # ==&#62; Depth of listing.
  64&nbsp;numdirs=0
  65&nbsp;zz=0
  66&nbsp;
  67&nbsp;while [ "$swfi" != 1 ]   # While flag not set...
  68&nbsp;do
  69&nbsp;   search   # ==&#62; Call function after initializing variables.
  70&nbsp;done
  71&nbsp;echo "Total directories = $numdirs"
  72&nbsp;
  73&nbsp;exit 0
  74&nbsp;# ==&#62; Challenge: try to figure out exactly how this script works.</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Noah Friedman gave permission to use his <I
CLASS="EMPHASIS"
>string
      function</I
> script, which essentially reproduces some of the
      C-library string manipulation functions.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="STRING"
></A
><P
><B
>Example A-14. <B
CLASS="COMMAND"
>string functions</B
>: C-like string functions</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# string.bash --- bash emulation of string(3) library routines
   4&nbsp;# Author: Noah Friedman &#60;friedman@prep.ai.mit.edu&#62;
   5&nbsp;# ==&#62;     Used with his kind permission in this document.
   6&nbsp;# Created: 1992-07-01
   7&nbsp;# Last modified: 1993-09-29
   8&nbsp;# Public domain
   9&nbsp;
  10&nbsp;# Conversion to bash v2 syntax done by Chet Ramey
  11&nbsp;
  12&nbsp;# Commentary:
  13&nbsp;# Code:
  14&nbsp;
  15&nbsp;#:docstring strcat:
  16&nbsp;# Usage: strcat s1 s2
  17&nbsp;#
  18&nbsp;# Strcat appends the value of variable s2 to variable s1. 
  19&nbsp;#
  20&nbsp;# Example:
  21&nbsp;#    a="foo"
  22&nbsp;#    b="bar"
  23&nbsp;#    strcat a b
  24&nbsp;#    echo $a
  25&nbsp;#    =&#62; foobar
  26&nbsp;#
  27&nbsp;#:end docstring:
  28&nbsp;
  29&nbsp;###;;;autoload   ==&#62; Autoloading of function commented out.
  30&nbsp;function strcat ()
  31&nbsp;{
  32&nbsp;    local s1_val s2_val
  33&nbsp;
  34&nbsp;    s1_val=${!1}                        # indirect variable expansion
  35&nbsp;    s2_val=${!2}
  36&nbsp;    eval "$1"=\'"${s1_val}${s2_val}"\'
  37&nbsp;    # ==&#62; eval $1='${s1_val}${s2_val}' avoids problems,
  38&nbsp;    # ==&#62; if one of the variables contains a single quote.
  39&nbsp;}
  40&nbsp;
  41&nbsp;#:docstring strncat:
  42&nbsp;# Usage: strncat s1 s2 $n
  43&nbsp;# 
  44&nbsp;# Line strcat, but strncat appends a maximum of n characters from the value
  45&nbsp;# of variable s2.  It copies fewer if the value of variabl s2 is shorter
  46&nbsp;# than n characters.  Echoes result on stdout.
  47&nbsp;#
  48&nbsp;# Example:
  49&nbsp;#    a=foo
  50&nbsp;#    b=barbaz
  51&nbsp;#    strncat a b 3
  52&nbsp;#    echo $a
  53&nbsp;#    =&#62; foobar
  54&nbsp;#
  55&nbsp;#:end docstring:
  56&nbsp;
  57&nbsp;###;;;autoload
  58&nbsp;function strncat ()
  59&nbsp;{
  60&nbsp;    local s1="$1"
  61&nbsp;    local s2="$2"
  62&nbsp;    local -i n="$3"
  63&nbsp;    local s1_val s2_val
  64&nbsp;
  65&nbsp;    s1_val=${!s1}                       # ==&#62; indirect variable expansion
  66&nbsp;    s2_val=${!s2}
  67&nbsp;
  68&nbsp;    if [ ${#s2_val} -gt ${n} ]; then
  69&nbsp;       s2_val=${s2_val:0:$n}            # ==&#62; substring extraction
  70&nbsp;    fi
  71&nbsp;
  72&nbsp;    eval "$s1"=\'"${s1_val}${s2_val}"\'
  73&nbsp;    # ==&#62; eval $1='${s1_val}${s2_val}' avoids problems,
  74&nbsp;    # ==&#62; if one of the variables contains a single quote.
  75&nbsp;}
  76&nbsp;
  77&nbsp;#:docstring strcmp:
  78&nbsp;# Usage: strcmp $s1 $s2
  79&nbsp;#
  80&nbsp;# Strcmp compares its arguments and returns an integer less than, equal to,
  81&nbsp;# or greater than zero, depending on whether string s1 is lexicographically
  82&nbsp;# less than, equal to, or greater than string s2.
  83&nbsp;#:end docstring:
  84&nbsp;
  85&nbsp;###;;;autoload
  86&nbsp;function strcmp ()
  87&nbsp;{
  88&nbsp;    [ "$1" = "$2" ] &#38;&#38; return 0
  89&nbsp;
  90&nbsp;    [ "${1}" '&#60;' "${2}" ] &#62; /dev/null &#38;&#38; return -1
  91&nbsp;
  92&nbsp;    return 1
  93&nbsp;}
  94&nbsp;
  95&nbsp;#:docstring strncmp:
  96&nbsp;# Usage: strncmp $s1 $s2 $n
  97&nbsp;# 
  98&nbsp;# Like strcmp, but makes the comparison by examining a maximum of n
  99&nbsp;# characters (n less than or equal to zero yields equality).
 100&nbsp;#:end docstring:
 101&nbsp;
 102&nbsp;###;;;autoload
 103&nbsp;function strncmp ()
 104&nbsp;{
 105&nbsp;    if [ -z "${3}" -o "${3}" -le "0" ]; then
 106&nbsp;       return 0
 107&nbsp;    fi
 108&nbsp;   
 109&nbsp;    if [ ${3} -ge ${#1} -a ${3} -ge ${#2} ]; then
 110&nbsp;       strcmp "$1" "$2"
 111&nbsp;       return $?
 112&nbsp;    else
 113&nbsp;       s1=${1:0:$3}
 114&nbsp;       s2=${2:0:$3}
 115&nbsp;       strcmp $s1 $s2
 116&nbsp;       return $?
 117&nbsp;    fi
 118&nbsp;}
 119&nbsp;
 120&nbsp;#:docstring strlen:
 121&nbsp;# Usage: strlen s
 122&nbsp;#
 123&nbsp;# Strlen returns the number of characters in string literal s.
 124&nbsp;#:end docstring:
 125&nbsp;
 126&nbsp;###;;;autoload
 127&nbsp;function strlen ()
 128&nbsp;{
 129&nbsp;    eval echo "\${#${1}}"
 130&nbsp;    # ==&#62; Returns the length of the value of the variable
 131&nbsp;    # ==&#62; whose name is passed as an argument.
 132&nbsp;}
 133&nbsp;
 134&nbsp;#:docstring strspn:
 135&nbsp;# Usage: strspn $s1 $s2
 136&nbsp;# 
 137&nbsp;# Strspn returns the length of the maximum initial segment of string s1,
 138&nbsp;# which consists entirely of characters from string s2.
 139&nbsp;#:end docstring:
 140&nbsp;
 141&nbsp;###;;;autoload
 142&nbsp;function strspn ()
 143&nbsp;{
 144&nbsp;    # Unsetting IFS allows whitespace to be handled as normal chars. 
 145&nbsp;    local IFS=
 146&nbsp;    local result="${1%%[!${2}]*}"
 147&nbsp; 
 148&nbsp;    echo ${#result}
 149&nbsp;}
 150&nbsp;
 151&nbsp;#:docstring strcspn:
 152&nbsp;# Usage: strcspn $s1 $s2
 153&nbsp;#
 154&nbsp;# Strcspn returns the length of the maximum initial segment of string s1,
 155&nbsp;# which consists entirely of characters not from string s2.
 156&nbsp;#:end docstring:
 157&nbsp;
 158&nbsp;###;;;autoload
 159&nbsp;function strcspn ()
 160&nbsp;{
 161&nbsp;    # Unsetting IFS allows whitspace to be handled as normal chars. 
 162&nbsp;    local IFS=
 163&nbsp;    local result="${1%%[${2}]*}"
 164&nbsp; 
 165&nbsp;    echo ${#result}
 166&nbsp;}
 167&nbsp;
 168&nbsp;#:docstring strstr:
 169&nbsp;# Usage: strstr s1 s2
 170&nbsp;# 
 171&nbsp;# Strstr echoes a substring starting at the first occurrence of string s2 in
 172&nbsp;# string s1, or nothing if s2 does not occur in the string.  If s2 points to
 173&nbsp;# a string of zero length, strstr echoes s1.
 174&nbsp;#:end docstring:
 175&nbsp;
 176&nbsp;###;;;autoload
 177&nbsp;function strstr ()
 178&nbsp;{
 179&nbsp;    # if s2 points to a string of zero length, strstr echoes s1
 180&nbsp;    [ ${#2} -eq 0 ] &#38;&#38; { echo "$1" ; return 0; }
 181&nbsp;
 182&nbsp;    # strstr echoes nothing if s2 does not occur in s1
 183&nbsp;    case "$1" in
 184&nbsp;    *$2*) ;;
 185&nbsp;    *) return 1;;
 186&nbsp;    esac
 187&nbsp;
 188&nbsp;    # use the pattern matching code to strip off the match and everything
 189&nbsp;    # following it
 190&nbsp;    first=${1/$2*/}
 191&nbsp;
 192&nbsp;    # then strip off the first unmatched portion of the string
 193&nbsp;    echo "${1##$first}"
 194&nbsp;}
 195&nbsp;
 196&nbsp;#:docstring strtok:
 197&nbsp;# Usage: strtok s1 s2
 198&nbsp;#
 199&nbsp;# Strtok considers the string s1 to consist of a sequence of zero or more
 200&nbsp;# text tokens separated by spans of one or more characters from the
 201&nbsp;# separator string s2.  The first call (with a non-empty string s1
 202&nbsp;# specified) echoes a string consisting of the first token on stdout. The
 203&nbsp;# function keeps track of its position in the string s1 between separate
 204&nbsp;# calls, so that subsequent calls made with the first argument an empty
 205&nbsp;# string will work through the string immediately following that token.  In
 206&nbsp;# this way subsequent calls will work through the string s1 until no tokens
 207&nbsp;# remain.  The separator string s2 may be different from call to call.
 208&nbsp;# When no token remains in s1, an empty value is echoed on stdout.
 209&nbsp;#:end docstring:
 210&nbsp;
 211&nbsp;###;;;autoload
 212&nbsp;function strtok ()
 213&nbsp;{
 214&nbsp; :
 215&nbsp;}
 216&nbsp;
 217&nbsp;#:docstring strtrunc:
 218&nbsp;# Usage: strtrunc $n $s1 {$s2} {$...}
 219&nbsp;#
 220&nbsp;# Used by many functions like strncmp to truncate arguments for comparison.
 221&nbsp;# Echoes the first n characters of each string s1 s2 ... on stdout. 
 222&nbsp;#:end docstring:
 223&nbsp;
 224&nbsp;###;;;autoload
 225&nbsp;function strtrunc ()
 226&nbsp;{
 227&nbsp;    n=$1 ; shift
 228&nbsp;    for z; do
 229&nbsp;        echo "${z:0:$n}"
 230&nbsp;    done
 231&nbsp;}
 232&nbsp;
 233&nbsp;# provide string
 234&nbsp;
 235&nbsp;# string.bash ends here
 236&nbsp;
 237&nbsp;
 238&nbsp;# ========================================================================== #
 239&nbsp;# ==&#62; Everything below here added by the document author.
 240&nbsp;
 241&nbsp;# ==&#62; Suggested use of this script is to delete everything below here,
 242&nbsp;# ==&#62; and "source" this file into your own scripts.
 243&nbsp;
 244&nbsp;# strcat
 245&nbsp;string0=one
 246&nbsp;string1=two
 247&nbsp;echo
 248&nbsp;echo "Testing \"strcat\" function:"
 249&nbsp;echo "Original \"string0\" = $string0"
 250&nbsp;echo "\"string1\" = $string1"
 251&nbsp;strcat string0 string1
 252&nbsp;echo "New \"string0\" = $string0"
 253&nbsp;echo
 254&nbsp;
 255&nbsp;# strlen
 256&nbsp;echo
 257&nbsp;echo "Testing \"strlen\" function:"
 258&nbsp;str=123456789
 259&nbsp;echo "\"str\" = $str"
 260&nbsp;echo -n "Length of \"str\" = "
 261&nbsp;strlen str
 262&nbsp;echo
 263&nbsp;
 264&nbsp;
 265&nbsp;
 266&nbsp;# Exercise:
 267&nbsp;# --------
 268&nbsp;# Add code to test all the other string functions above.
 269&nbsp;
 270&nbsp;
 271&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Stephane Chazelas demonstrates object-oriented programming a
      Bash script.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="OBJORIENTED"
></A
><P
><B
>Example A-15. Object-oriented database</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# obj-oriented.sh: Object-oriented programming in a shell script.
   3&nbsp;# Script by Stephane Chazelas.
   4&nbsp;
   5&nbsp;
   6&nbsp;person.new()        # Looks almost like a class declaration in C++.
   7&nbsp;{
   8&nbsp;  local obj_name=$1 name=$2 firstname=$3 birthdate=$4
   9&nbsp;
  10&nbsp;  eval "$obj_name.set_name() {
  11&nbsp;          eval \"$obj_name.get_name() {
  12&nbsp;                   echo \$1
  13&nbsp;                 }\"
  14&nbsp;        }"
  15&nbsp;
  16&nbsp;  eval "$obj_name.set_firstname() {
  17&nbsp;          eval \"$obj_name.get_firstname() {
  18&nbsp;                   echo \$1
  19&nbsp;                 }\"
  20&nbsp;        }"
  21&nbsp;
  22&nbsp;  eval "$obj_name.set_birthdate() {
  23&nbsp;          eval \"$obj_name.get_birthdate() {
  24&nbsp;            echo \$1
  25&nbsp;          }\"
  26&nbsp;          eval \"$obj_name.show_birthdate() {
  27&nbsp;            echo \$(date -d \"1/1/1970 0:0:\$1 GMT\")
  28&nbsp;          }\"
  29&nbsp;          eval \"$obj_name.get_age() {
  30&nbsp;            echo \$(( (\$(date +%s) - \$1) / 3600 / 24 / 365 ))
  31&nbsp;          }\"
  32&nbsp;        }"
  33&nbsp;
  34&nbsp;  $obj_name.set_name $name
  35&nbsp;  $obj_name.set_firstname $firstname
  36&nbsp;  $obj_name.set_birthdate $birthdate
  37&nbsp;}
  38&nbsp;
  39&nbsp;echo
  40&nbsp;
  41&nbsp;person.new self Bozeman Bozo 101272413
  42&nbsp;# Create an instance of "person.new" (actually passing args to the function).
  43&nbsp;
  44&nbsp;self.get_firstname       #   Bozo
  45&nbsp;self.get_name            #   Bozeman
  46&nbsp;self.get_age             #   28
  47&nbsp;self.get_birthdate       #   101272413
  48&nbsp;self.show_birthdate      #   Sat Mar 17 20:13:33 MST 1973
  49&nbsp;
  50&nbsp;echo
  51&nbsp;
  52&nbsp;# typeset -f
  53&nbsp;# to see the created functions (careful, it scrolls off the page).
  54&nbsp;
  55&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="biblio.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sedawk.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Bibliography</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>A Sed and Awk Micro-Primer</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Miscellaneous Commands</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.64
"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="External Filters, Programs and Commands"
HREF="external.html"><LINK
REL="PREVIOUS"
TITLE="Math Commands"
HREF="mathc.html"><LINK
REL="NEXT"
TITLE="System and Administrative Commands"
HREF="system.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-family: sans-serif;"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="mathc.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 12. External Filters, Programs and Commands</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="system.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="EXTMISC"
>12.9. Miscellaneous Commands</A
></H1
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="MISCCOMMANDLISTING1"
></A
>Command Listing</B
></P
><DL
><DT
><B
CLASS="COMMAND"
>jot</B
>, <B
CLASS="COMMAND"
>seq</B
></DT
><DD
><P
>These utilities emit a sequence of integers, with a
	      user selected increment. This can be used to advantage in
	      a <A
HREF="loops.html#FORLOOPREF1"
>for loop</A
>.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX53"
></A
><P
><B
>Example 12-34. Using <B
CLASS="COMMAND"
>seq</B
> to generate loop arguments</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;for a in `seq 80`  # or   for a in $( seq 80 )
   4&nbsp;# Same as   for a in 1 2 3 4 5 ... 80   (saves much typing!).
   5&nbsp;# May also use 'jot' (if present on system).
   6&nbsp;do
   7&nbsp;  echo -n "$a "
   8&nbsp;done
   9&nbsp;# Example of using the output of a command to generate 
  10&nbsp;# the [list] in a "for" loop.
  11&nbsp;
  12&nbsp;echo; echo
  13&nbsp;
  14&nbsp;
  15&nbsp;COUNT=80  # Yes, 'seq' may also take a replaceable parameter.
  16&nbsp;
  17&nbsp;for a in `seq $COUNT`  # or   for a in $( seq $COUNT )
  18&nbsp;do
  19&nbsp;  echo -n "$a "
  20&nbsp;done
  21&nbsp;
  22&nbsp;echo
  23&nbsp;
  24&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><A
NAME="RUNPARTSREF"
></A
><B
CLASS="COMMAND"
>run-parts</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>run-parts</B
> command

		<A
NAME="AEN8523"
HREF="#FTN.AEN8523"
>[1]</A
>
	      
	      executes all the scripts in a target directory, sequentially
	      in ASCII-sorted filename order. Of course, the scripts
	      need to have execute permission.</P
><P
>The <A
HREF="system.html#CRONREF"
>crond</A
> <A
HREF="communications.html#DAEMONREF"
>daemon</A
> invokes
	      <B
CLASS="COMMAND"
>run-parts</B
> to run the scripts in
	      the <TT
CLASS="FILENAME"
>/etc/cron.*</TT
>
	      directories.</P
></DD
><DT
><B
CLASS="COMMAND"
>yes</B
></DT
><DD
><P
>In its default behavior the <B
CLASS="COMMAND"
>yes</B
>
	      command feeds a continuous string of the character
	      <TT
CLASS="COMPUTEROUTPUT"
>y</TT
> followed
	      by a line feed to <TT
CLASS="FILENAME"
>stdout</TT
>. A
	      <B
CLASS="KEYCAP"
>control</B
>-<B
CLASS="KEYCAP"
>c</B
>
	      terminates the run. A different output string
	      may be specified, as in <TT
CLASS="USERINPUT"
><B
>yes different
	      string</B
></TT
>, which would continually output
	      <TT
CLASS="COMPUTEROUTPUT"
>different string</TT
> to
	      <TT
CLASS="FILENAME"
>stdout</TT
>.  One might well ask the purpose
	      of this. From the command line or in a script, the output
	      of <B
CLASS="COMMAND"
>yes</B
> can be redirected or piped into a
	      program expecting user input. In effect, this becomes a sort
	      of poor man's version of <B
CLASS="COMMAND"
>expect</B
>.</P
><P
><TT
CLASS="USERINPUT"
><B
>yes | fsck /dev/hda1</B
></TT
> runs
	      <B
CLASS="COMMAND"
>fsck</B
> non-interactively (careful!).</P
><P
><TT
CLASS="USERINPUT"
><B
>yes | rm -r dirname</B
></TT
> has same effect as
	     <TT
CLASS="USERINPUT"
><B
>rm -rf dirname</B
></TT
> (careful!).</P
><DIV
CLASS="WARNING"
><TABLE
CLASS="WARNING"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/warning.png"
HSPACE="5"
ALT="Warning"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Be very cautious when piping <B
CLASS="COMMAND"
>yes</B
>
	     to a potentially dangerous system command, such as
	     <A
HREF="system.html#FSCKREF"
>fsck</A
> or
	     <A
HREF="system.html#FDISKREF"
>fdisk</A
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>banner</B
></DT
><DD
><P
>Prints arguments as a large vertical banner to
	      <TT
CLASS="FILENAME"
>stdout</TT
>, using an ASCII character
	      (default '#'). This may be redirected to a printer for
	      hardcopy.</P
></DD
><DT
><B
CLASS="COMMAND"
>printenv</B
></DT
><DD
><P
>Show all the environmental variables set for a particular
	      user.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>printenv | grep HOME</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>HOME=/home/bozo</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><B
CLASS="COMMAND"
>lp</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>lp</B
> and <B
CLASS="COMMAND"
>lpr</B
>
	      commands send file(s) to the print queue, to be printed as
	      hard copy.

	      <A
NAME="AEN8600"
HREF="#FTN.AEN8600"
>[2]</A
>

	      These commands trace the origin of their names to the
	      line printers of another era.</P
><P
><TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>lp file1.txt</B
></TT
>
	        or <TT
CLASS="PROMPT"
>bash </TT
><TT
CLASS="USERINPUT"
><B
>lp
		&#60;file1.txt</B
></TT
></P
><P
>It is often useful to pipe the formatted output from
	        <B
CLASS="COMMAND"
>pr</B
> to <B
CLASS="COMMAND"
>lp</B
>.</P
><P
><TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>pr -options file1.txt | lp</B
></TT
>
	        </P
><P
>Formatting packages, such as <B
CLASS="COMMAND"
>groff</B
> and
	        <I
CLASS="EMPHASIS"
>Ghostscript</I
> may send their output
		directly to <B
CLASS="COMMAND"
>lp</B
>.</P
><P
><TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>groff -Tascii file.tr | lp</B
></TT
>
	        </P
><P
><TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>gs -options | lp file.ps</B
></TT
>
	        </P
><P
>Related commands are <B
CLASS="COMMAND"
>lpq</B
>, for viewing
	        the print queue, and <B
CLASS="COMMAND"
>lprm</B
>, for removing
		jobs from the print queue.</P
></DD
><DT
><B
CLASS="COMMAND"
>tee</B
></DT
><DD
><P
>[UNIX borrows an idea here from the plumbing trade.]</P
><P
>This is a redirection operator, but with a difference. Like the
	      plumber's <I
CLASS="EMPHASIS"
>tee</I
>, it permits <SPAN
CLASS="QUOTE"
>"siponing
		off"</SPAN
> the output of a command 
	      or commands within a pipe, but without affecting the result. This is
	      useful for printing an ongoing process to a file or paper, perhaps to
	      keep track of it for debugging purposes.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>                    tee
                  |------&#62; to file
                  |
   ===============|===============
   command---&#62;----|-operator--&#62;---&#62; result of command(s)
   ===============================
 	      </PRE
></TD
></TR
></TABLE
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;cat listfile* | sort | tee check.file | uniq &#62; result.file</PRE
></TD
></TR
></TABLE
>
	      (The file <TT
CLASS="FILENAME"
>check.file</TT
> contains
	      the concatenated sorted <SPAN
CLASS="QUOTE"
>"listfiles"</SPAN
>,
	      before the duplicate lines are removed by <A
HREF="textproc.html#UNIQREF"
>uniq</A
>.)</P
></DD
><DT
><B
CLASS="COMMAND"
>mkfifo</B
></DT
><DD
><P
><A
NAME="NAMEDPIPEREF"
></A
>This obscure command
	      creates a <I
CLASS="EMPHASIS"
>named pipe</I
>, a temporary
	      <I
CLASS="EMPHASIS"
>first-in-first-out buffer</I
> for
	      transferring data between processes.

		<A
NAME="AEN8660"
HREF="#FTN.AEN8660"
>[3]</A
>

	      Typically, one process writes to the FIFO, and the other
	      reads from it. See <A
HREF="contributed-scripts.html#FIFO"
>Example A-11</A
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>pathchk</B
></DT
><DD
><P
>This command checks the validity of a filename. If the
	      filename exceeds the maximum allowable length (255
	      characters) or one or more of the directories in
	      its path is not searchable, then an error message
	      results. Unfortunately, <B
CLASS="COMMAND"
>pathchk</B
> does
	      not return a recognizable error code, and it is therefore
	      pretty much useless in a script.</P
></DD
><DT
><A
NAME="DDREF"
></A
><B
CLASS="COMMAND"
>dd</B
></DT
><DD
><P
>This is the somewhat obscure and much feared <SPAN
CLASS="QUOTE"
>"data
	      duplicator"</SPAN
> command.  Originally a utility
	      for exchanging data on magnetic tapes between UNIX
	      minicomputers and IBM mainframes, this command still
	      has its uses.  The <B
CLASS="COMMAND"
>dd</B
> command simply
	      copies a file (or <TT
CLASS="FILENAME"
>stdin/stdout</TT
>), but
	      with conversions. Possible conversions are ASCII/EBCDIC,
	        
		<A
NAME="AEN8690"
HREF="#FTN.AEN8690"
>[4]</A
>

	      upper/lower case, swapping of byte pairs between input
	      and output, and skipping and/or truncating the head or
	      tail of the input file. A <TT
CLASS="USERINPUT"
><B
>dd --help</B
></TT
>
	      lists the conversion and other options that this powerful
	      utility takes.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# Exercising 'dd'.
   2&nbsp;
   3&nbsp;n=3
   4&nbsp;p=5
   5&nbsp;input_file=project.txt
   6&nbsp;output_file=log.txt
   7&nbsp;
   8&nbsp;dd if=$input_file of=$output_file bs=1 skip=$((n-1)) count=$((p-n+1)) 2&#62; /dev/null
   9&nbsp;# Extracts characters n to p from file $input_file.
  10&nbsp;
  11&nbsp;
  12&nbsp;
  13&nbsp;
  14&nbsp;echo -n "hello world" | dd cbs=1 conv=unblock 2&#62; /dev/null
  15&nbsp;# Echoes "hello world" vertically.
  16&nbsp;
  17&nbsp;
  18&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
></P
><P
>To demonstrate just how versatile <B
CLASS="COMMAND"
>dd</B
> is,
	     let's use it to capture keystrokes.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="DDKEYPRESS"
></A
><P
><B
>Example 12-35. Capturing Keystrokes</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# Capture keystrokes without needing to press ENTER.
   3&nbsp;
   4&nbsp;
   5&nbsp;keypresses=4                      # Number of keypresses to capture.
   6&nbsp;
   7&nbsp;
   8&nbsp;old_tty_setting=$(stty -g)        # Save old terminal settings.
   9&nbsp;
  10&nbsp;echo "Press $keypresses keys."
  11&nbsp;stty -icanon -echo                # Disable canonical mode.
  12&nbsp;                                  # Disable local echo.
  13&nbsp;keys=$(dd bs=1 count=$keypresses 2&#62; /dev/null)
  14&nbsp;# 'dd' uses stdin, if "if" not specified.
  15&nbsp;
  16&nbsp;stty "$old_tty_setting"           # Restore old terminal settings.
  17&nbsp;
  18&nbsp;echo "You pressed the \"$keys\" keys."
  19&nbsp;
  20&nbsp;# Thanks, S.C. for showing the way.
  21&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>The <B
CLASS="COMMAND"
>dd</B
> command can do random access on a
	      data stream.

	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo -n . | dd bs=1 seek=4 of=file conv=notrunc
   2&nbsp;# The "conv=notrunc" option means that the output file will not be truncated.		
   3&nbsp;
   4&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
>
            </P
><P
>The <B
CLASS="COMMAND"
>dd</B
> command can copy raw data
	      and disk images to and from devices, such as floppies and
	      tape drives (<A
HREF="contributed-scripts.html#COPYCD"
>Example A-5</A
>). A common use is
	      creating boot floppies.</P
><P
>		<TT
CLASS="USERINPUT"
><B
>dd if=kernel-image of=/dev/fd0H1440</B
></TT
>
             </P
><P
>Similarly, <B
CLASS="COMMAND"
>dd</B
> can copy the entire
	       contents of a floppy, even one formatted with a
	       <SPAN
CLASS="QUOTE"
>"foreign"</SPAN
> OS, to the hard drive as an
	       image file.</P
><P
>		<TT
CLASS="USERINPUT"
><B
>dd if=/dev/fd0 of=/home/bozo/projects/floppy.img</B
></TT
>
             </P
><P
>	      Other applications of <B
CLASS="COMMAND"
>dd</B
> include
	      initializing temporary swap files (<A
HREF="zeros.html#EX73"
>Example 29-2</A
>)
	      and ramdisks (<A
HREF="zeros.html#RAMDISK"
>Example 29-3</A
>). It can even do a
	      low-level copy of an entire hard drive partition, although
	      this is not necessarily recommended.</P
><P
>People (with presumably nothing better to do with
	      their time) are constantly thinking of interesting
	      applications of <B
CLASS="COMMAND"
>dd</B
>.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="BLOTOUT"
></A
><P
><B
>Example 12-36. Securely deleting a file</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# blotout.sh: Erase all traces of a file.
   3&nbsp;
   4&nbsp;#  This script overwrites a target file alternately
   5&nbsp;#+ with random bytes, then zeros before finally deleting it.
   6&nbsp;#  After that, even examining the raw disk sectors
   7&nbsp;#+ will not reveal the original file data.
   8&nbsp;
   9&nbsp;PASSES=7         # Number of file-shredding passes.
  10&nbsp;BLOCKSIZE=1      #  I/O with /dev/urandom requires unit block size,
  11&nbsp;                 #+ otherwise you get weird results.
  12&nbsp;E_BADARGS=70
  13&nbsp;E_NOT_FOUND=71
  14&nbsp;E_CHANGED_MIND=72
  15&nbsp;
  16&nbsp;if [ -z "$1" ]   # No filename specified.
  17&nbsp;then
  18&nbsp;  echo "Usage: `basename $0` filename"
  19&nbsp;  exit $E_BADARGS
  20&nbsp;fi
  21&nbsp;
  22&nbsp;file=$1
  23&nbsp;
  24&nbsp;if [ ! -e "$file" ]
  25&nbsp;then
  26&nbsp;  echo "File \"$file\" not found."
  27&nbsp;  exit $E_NOT_FOUND
  28&nbsp;fi  
  29&nbsp;
  30&nbsp;echo; echo -n "Are you absolutely sure you want to blot out \"$file\" (y/n)? "
  31&nbsp;read answer
  32&nbsp;case "$answer" in
  33&nbsp;[nN]) echo "Changed your mind, huh?"
  34&nbsp;      exit $E_CHANGED_MIND
  35&nbsp;      ;;
  36&nbsp;*)    echo "Blotting out file \"$file\".";;
  37&nbsp;esac
  38&nbsp;
  39&nbsp;
  40&nbsp;flength=$(ls -l "$file" | awk '{print $5}')  # Field 5 is file length.
  41&nbsp;
  42&nbsp;pass_count=1
  43&nbsp;
  44&nbsp;echo
  45&nbsp;
  46&nbsp;while [ "$pass_count" -le "$PASSES" ]
  47&nbsp;do
  48&nbsp;  echo "Pass #$pass_count"
  49&nbsp;  sync         # Flush buffers.
  50&nbsp;  dd if=/dev/urandom of=$file bs=$BLOCKSIZE count=$flength
  51&nbsp;               # Fill with random bytes.
  52&nbsp;  sync         # Flush buffers again.
  53&nbsp;  dd if=/dev/zero of=$file bs=$BLOCKSIZE count=$flength
  54&nbsp;               # Fill with zeros.
  55&nbsp;  sync         # Flush buffers yet again.
  56&nbsp;  let "pass_count += 1"
  57&nbsp;  echo
  58&nbsp;done  
  59&nbsp;
  60&nbsp;
  61&nbsp;rm -f $file    # Finally, delete scrambled and shredded file.
  62&nbsp;sync           # Flush buffers a final time.
  63&nbsp;
  64&nbsp;echo "File \"$file\" blotted out and deleted."; echo
  65&nbsp;
  66&nbsp;
  67&nbsp;#  This is a fairly secure, if inefficient and slow method
  68&nbsp;#+ of thoroughly "shredding" a file. The "shred" command,
  69&nbsp;#+ part of the GNU "fileutils" package, does the same thing,
  70&nbsp;#+ but more efficiently.
  71&nbsp;
  72&nbsp;#  The file cannot not be "undeleted" or retrieved by normal methods.
  73&nbsp;#  However...
  74&nbsp;#+ this simple method will likely *not* withstand forensic analysis.
  75&nbsp;
  76&nbsp;
  77&nbsp;#  Tom Vier's "wipe" file-deletion package does a much more thorough job
  78&nbsp;#+ of file shredding than this simple script.
  79&nbsp;#     http://www.ibiblio.org/pub/Linux/utils/file/wipe-2.0.0.tar.bz2
  80&nbsp;
  81&nbsp;#  For an in-depth analysis on the topic of file deletion and security,
  82&nbsp;#+ see Peter Gutmann's paper,
  83&nbsp;#+     "Secure Deletion of Data From Magnetic and Solid-State Memory".
  84&nbsp;#           http://www.cs.auckland.ac.nz/~pgut001/secure_del.html
  85&nbsp;
  86&nbsp;
  87&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><A
NAME="ODREF"
></A
><B
CLASS="COMMAND"
>od</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>od</B
>, or <I
CLASS="EMPHASIS"
>octal
	      dump</I
> filter converts input (or files) to octal
	      (base-8) or other bases. This is useful for viewing or
	      processing binary data files or otherwise unreadable system
	      device files, such as <TT
CLASS="FILENAME"
>/dev/urandom</TT
>,
	      and as a filter for binary data. See <A
HREF="randomvar.html#SEEDINGRANDOM"
>Example 9-22</A
> and <A
HREF="textproc.html#RND"
>Example 12-10</A
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>hexdump</B
></DT
><DD
><P
>Performs a hexadecimal, octal, decimal, or ASCII
	      dump of a binary file. This command is the rough equivalent
	      of <B
CLASS="COMMAND"
>od</B
>, above, but not nearly as
	      useful.</P
></DD
><DT
><B
CLASS="COMMAND"
>m4</B
></DT
><DD
><P
>A hidden treasure, <B
CLASS="COMMAND"
>m4</B
> is a
	      powerful macro processor
		 <A
NAME="AEN8764"
HREF="#FTN.AEN8764"
>[5]</A
>
	      utility, virtually a complete language. In
	      fact, <B
CLASS="COMMAND"
>m4</B
> combines some of the
	      functionality of <A
HREF="internal.html#EVALREF"
>eval</A
>,
	      <A
HREF="textproc.html#TRREF"
>tr</A
>, and <A
HREF="awk.html#AWKREF"
>awk</A
>.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="M4"
></A
><P
><B
>Example 12-37. Using m4</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# m4.sh: Using the m4 macro processor
   3&nbsp;
   4&nbsp;# Strings
   5&nbsp;string=abcdA01
   6&nbsp;echo "len($string)" | m4                       # 7
   7&nbsp;echo "substr($string,4)" | m4                  # A01
   8&nbsp;echo "regexp($string,[0-1][0-1],\&#38;Z)" | m4     # 01Z
   9&nbsp;
  10&nbsp;# Arithmetic
  11&nbsp;echo "incr(22)" | m4                           # 23
  12&nbsp;echo "eval(99 / 3)" | m4                       # 33
  13&nbsp;
  14&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
></DL
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN8523"
HREF="extmisc.html#AEN8523"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>This is actually a script adapted from
		the Debian Linux distribution.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN8600"
HREF="extmisc.html#AEN8600"
>[2]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>The <I
CLASS="EMPHASIS"
>print queue</I
> is
	      the group of jobs <SPAN
CLASS="QUOTE"
>"waiting in line"</SPAN
> to be
	      printed.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN8660"
HREF="extmisc.html#AEN8660"
>[3]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>For an excellent overview of this
		  topic, see Andy Vaught's article, <A
HREF="http://www2.linuxjournal.com/lj-issues/issue41/2156.html"
TARGET="_top"
>Introduction
		  to Named Pipes</A
>, in the September, 1997 issue
		  of <A
HREF="http://www.linuxjournal.com"
TARGET="_top"
>Linux
		  Journal</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN8690"
HREF="extmisc.html#AEN8690"
>[4]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>EBCDIC (pronounced
		  <SPAN
CLASS="QUOTE"
>"ebb-sid-ic"</SPAN
>) is an acronym for Extended
		  Binary Coded Decimal Interchange Code. This is an IBM
		  data format no longer in much use. A bizarre
		  application of the <TT
CLASS="OPTION"
>conv=ebcdic</TT
> option
		  of <B
CLASS="COMMAND"
>dd</B
> is as a quick 'n easy, but
		  not very secure text file encoder.
		    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;cat $file | dd conv=swab,ebcdic &#62; $file_encrypted
   2&nbsp;# Encode (looks like gibberish).		    
   3&nbsp;# Might as well switch bytes (swab), too, for a little extra obscurity.
   4&nbsp;
   5&nbsp;cat $file_encrypted | dd conv=swab,ascii &#62; $file_plaintext
   6&nbsp;# Decode.</PRE
></TD
></TR
></TABLE
>
                </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN8764"
HREF="extmisc.html#AEN8764"
>[5]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>A <I
CLASS="EMPHASIS"
>macro</I
> is a
		 symbolic constant that expands into a command string
		 or a set of operations on parameters.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="mathc.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="system.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Math Commands</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="external.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>System and Administrative Commands</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
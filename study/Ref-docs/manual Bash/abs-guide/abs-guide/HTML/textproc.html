<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Text Processing Commands</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.64
"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="External Filters, Programs and Commands"
HREF="external.html"><LINK
REL="PREVIOUS"
TITLE="Time / Date Commands"
HREF="timedate.html"><LINK
REL="NEXT"
TITLE="File and Archiving Commands"
HREF="filearchiv.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-family: sans-serif;"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="timedate.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 12. External Filters, Programs and Commands</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="filearchiv.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="TEXTPROC"
>12.4. Text Processing Commands</A
></H1
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="TPCOMMANDLISTING1"
></A
>Command Listing</B
></P
><DL
><DT
><A
NAME="SORTREF"
></A
><B
CLASS="COMMAND"
>sort</B
></DT
><DD
><P
>File sorter, often used as a filter in a pipe. This
	      command sorts a text stream or file forwards or backwards,
	      or according to various keys or character positions. Using
	      the <TT
CLASS="OPTION"
>-m</TT
> option, it merges presorted input
	      files.  The <I
CLASS="EMPHASIS"
>info page</I
> lists its many
	      capabilities and options. See <A
HREF="loops.html#FINDSTRING"
>Example 10-8</A
>
	      and <A
HREF="loops.html#SYMLINKS"
>Example 10-9</A
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>tsort</B
></DT
><DD
><P
>Topological sort, reading in pairs of
	      whitespace-separated strings and sorting according to
	      input patterns.</P
></DD
><DT
><A
NAME="DIFFREF"
></A
><B
CLASS="COMMAND"
>diff</B
>, <B
CLASS="COMMAND"
>patch</B
></DT
><DD
><P
><B
CLASS="COMMAND"
>diff</B
>: flexible file comparison
	      utility. It compares the target files line-by-line
	      sequentially.  In some applications, such as comparing
	      word dictionaries, it may be helpful to filter the
	      files through <A
HREF="textproc.html#SORTREF"
>sort</A
>
	      and <B
CLASS="COMMAND"
>uniq</B
> before piping them
	      to <B
CLASS="COMMAND"
>diff</B
>. <TT
CLASS="USERINPUT"
><B
>diff file-1
	      file-2</B
></TT
> outputs the lines in the files that
	      differ, with carets showing which file each particular
	      line belongs to.</P
><P
>The <TT
CLASS="OPTION"
>--side-by-side</TT
> option to
	    <B
CLASS="COMMAND"
>diff</B
> outputs each compared file, line by line,
	    in separate columns, with non-matching lines marked.</P
><P
>There are available various fancy frontends for
	    <B
CLASS="COMMAND"
>diff</B
>, such as <B
CLASS="COMMAND"
>spiff</B
>,
	    <B
CLASS="COMMAND"
>wdiff</B
>, <B
CLASS="COMMAND"
>xdiff</B
>, and
	    <B
CLASS="COMMAND"
>mgdiff</B
>. </P
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <B
CLASS="COMMAND"
>diff</B
> command returns an exit
	    status of 0 if the compared files are identical, and 1 if
	    they differ. This permits use of <B
CLASS="COMMAND"
>diff</B
>
	    in a test construct within a shell script (see
	    below).</P
></TD
></TR
></TABLE
></DIV
><P
>A common use for <B
CLASS="COMMAND"
>diff</B
> is generating
	      difference files to be used with <B
CLASS="COMMAND"
>patch</B
>
	      The <TT
CLASS="OPTION"
>-e</TT
> option outputs files suitable
	      for <B
CLASS="COMMAND"
>ed</B
> or <B
CLASS="COMMAND"
>ex</B
>
	      scripts.</P
><P
><B
CLASS="COMMAND"
>patch</B
>: flexible versioning
	      utility. Given a difference file generated by
	      <B
CLASS="COMMAND"
>diff</B
>, <B
CLASS="COMMAND"
>patch</B
> can
	      upgrade a previous version of a package to a newer version.
	      It is much more convenient to distribute a relatively
	      small <SPAN
CLASS="QUOTE"
>"diff"</SPAN
> file than the entire body of a
	      newly revised package. Kernel <SPAN
CLASS="QUOTE"
>"patches"</SPAN
> have
	      become the preferred method of distributing the frequent
	      releases of the Linux kernel.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;patch -p1 &#60;patch-file
   2&nbsp;# Takes all the changes listed in 'patch-file'
   3&nbsp;# and applies them to the files referenced therein.
   4&nbsp;# This upgrades to a newer version of the package.</PRE
></TD
></TR
></TABLE
></P
><P
>Patching the kernel:</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;cd /usr/src
   2&nbsp;gzip -cd patchXX.gz | patch -p0
   3&nbsp;# Upgrading kernel source using 'patch'.
   4&nbsp;# From the Linux kernel docs "README",
   5&nbsp;# by anonymous author (Alan Cox?).</PRE
></TD
></TR
></TABLE
></P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <B
CLASS="COMMAND"
>diff</B
> command can also
	      recursively compare directories (for the filenames
	      present).</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>diff -r ~/notes1 ~/notes2</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Only in /home/bozo/notes1: file02
 Only in /home/bozo/notes1: file03
 Only in /home/bozo/notes2: file04</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Use <B
CLASS="COMMAND"
>zdiff</B
> to compare
	      <I
CLASS="EMPHASIS"
>gzipped</I
> files.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>diff3</B
></DT
><DD
><P
>An extended version of <B
CLASS="COMMAND"
>diff</B
> that compares
	      three files at a time. This command returns an exit value
	      of 0 upon successful execution, but unfortunately this gives
	      no information about the results of the comparison.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>diff3 file-1 file-2 file-3</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>====
 1:1c
   This is line 1 of "file-1".
 2:1c
   This is line 1 of "file-2".
 3:1c
   This is line 1 of "file-3"</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
></DD
><DT
><B
CLASS="COMMAND"
>sdiff</B
></DT
><DD
><P
>Compare and/or edit two files in order to merge
	      them into an output file. Because of its interactive nature,
	      this command would find little use in a script.</P
></DD
><DT
><B
CLASS="COMMAND"
>cmp</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>cmp</B
> command is a simpler version of
	      <B
CLASS="COMMAND"
>diff</B
>, above. Whereas <B
CLASS="COMMAND"
>diff</B
>
	      reports the differences between two files,
	      <B
CLASS="COMMAND"
>cmp</B
> merely shows at what point they
	      differ.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Like <B
CLASS="COMMAND"
>diff</B
>, <B
CLASS="COMMAND"
>cmp</B
>
	    returns an exit status of 0 if the compared files are
	    identical, and 1 if they differ. This permits use in a test
	    construct within a shell script.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="FILECOMP"
></A
><P
><B
>Example 12-8. Using <B
CLASS="COMMAND"
>cmp</B
> to compare two files
	        within a script.</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;ARGS=2  # Two args to script expected.
   4&nbsp;E_BADARGS=65
   5&nbsp;
   6&nbsp;if [ $# -ne "$ARGS" ]
   7&nbsp;then
   8&nbsp;  echo "Usage: `basename $0` file1 file2"
   9&nbsp;  exit $E_BADARGS
  10&nbsp;fi
  11&nbsp;
  12&nbsp;
  13&nbsp;cmp $1 $2 &#62; /dev/null  # /dev/null buries the output of the "cmp" command.
  14&nbsp;# Also works with 'diff', i.e.,   diff $1 $2 &#62; /dev/null
  15&nbsp;
  16&nbsp;if [ $? -eq 0 ]        # Test exit status of "cmp" command.
  17&nbsp;then
  18&nbsp;  echo "File \"$1\" is identical to file \"$2\"."
  19&nbsp;else  
  20&nbsp;  echo "File \"$1\" differs from file \"$2\"."
  21&nbsp;fi
  22&nbsp;
  23&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Use <B
CLASS="COMMAND"
>zcmp</B
> on
	      <I
CLASS="EMPHASIS"
>gzipped</I
> files.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>comm</B
></DT
><DD
><P
>Versatile file comparison utility. The files must be
	      sorted for this to be useful.</P
><P
><B
CLASS="COMMAND"
>comm
		<TT
CLASS="REPLACEABLE"
><I
>-options</I
></TT
>
		<TT
CLASS="REPLACEABLE"
><I
>first-file</I
></TT
>
		<TT
CLASS="REPLACEABLE"
><I
>second-file</I
></TT
></B
></P
><P
><TT
CLASS="USERINPUT"
><B
>comm file-1 file-2</B
></TT
> outputs three columns:
	      <UL
><LI
><P
>column 1 = lines unique to <TT
CLASS="FILENAME"
>file-1</TT
></P
></LI
><LI
><P
>column 2 = lines unique to <TT
CLASS="FILENAME"
>file-2</TT
></P
></LI
><LI
><P
>column 3 = lines common to both.</P
></LI
></UL
></P
><P
>The options allow suppressing output of one or more columns.
	      <UL
><LI
><P
><TT
CLASS="OPTION"
>-1</TT
> suppresses column
		    <TT
CLASS="LITERAL"
>1</TT
></P
></LI
><LI
><P
><TT
CLASS="OPTION"
>-2</TT
> suppresses column
		    <TT
CLASS="LITERAL"
>2</TT
></P
></LI
><LI
><P
><TT
CLASS="OPTION"
>-3</TT
> suppresses column
		    <TT
CLASS="LITERAL"
>3</TT
></P
></LI
><LI
><P
><TT
CLASS="OPTION"
>-12</TT
> suppresses both columns
		    <TT
CLASS="LITERAL"
>1</TT
> and <TT
CLASS="LITERAL"
>2</TT
>, etc.</P
></LI
></UL
>
	    </P
></DD
><DT
><A
NAME="UNIQREF"
></A
><B
CLASS="COMMAND"
>uniq</B
></DT
><DD
><P
>This filter removes duplicate lines from a sorted
	      file. It is often seen in a pipe coupled with
	      <A
HREF="textproc.html#SORTREF"
>sort</A
>.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;cat list-1 list-2 list-3 | sort | uniq &#62; final.list
   2&nbsp;# Concatenates the list files,
   3&nbsp;# sorts them,
   4&nbsp;# removes duplicate lines,
   5&nbsp;# and finally writes the result to an output file.</PRE
></TD
></TR
></TABLE
></P
><P
>The useful <TT
CLASS="OPTION"
>-c</TT
> option prefixes each line of
	       the input file with its number of occurrences.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>cat testfile</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>This line occurs only once.
 This line occurs twice.
 This line occurs twice.
 This line occurs three times.
 This line occurs three times.
 This line occurs three times.</TT
>
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>uniq -c testfile</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>      1 This line occurs only once.
       2 This line occurs twice.
       3 This line occurs three times.</TT
>
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>sort testfile | uniq -c | sort -nr</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>      3 This line occurs three times.
       2 This line occurs twice.
       1 This line occurs only once.</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	     </P
><P
>The <TT
CLASS="USERINPUT"
><B
>sort INPUTFILE | uniq -c | sort -nr</B
></TT
>
	       command string produces a <I
CLASS="EMPHASIS"
>frequency
	       of occurrence</I
> listing on the
	       <TT
CLASS="FILENAME"
>INPUTFILE</TT
> file (the
	       <TT
CLASS="OPTION"
>-nr</TT
> options to <B
CLASS="COMMAND"
>sort</B
>
	       cause a reverse numerical sort). This template finds
	       use in analysis of log files and dictionary lists, and
	       wherever the lexical structure of a document needs to
	       be examined.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="WF"
></A
><P
><B
>Example 12-9. Word Frequency Analysis</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# wf.sh: Crude word frequency analysis on a text file.
   3&nbsp;
   4&nbsp;
   5&nbsp;# Check for input file on command line.
   6&nbsp;ARGS=1
   7&nbsp;E_BADARGS=65
   8&nbsp;E_NOFILE=66
   9&nbsp;
  10&nbsp;if [ $# -ne $ARGS ]    # Correct number of arguments passed to script?
  11&nbsp;then
  12&nbsp;  echo "Usage: `basename $0` filename"
  13&nbsp;  exit $E_BADARGS
  14&nbsp;fi
  15&nbsp;
  16&nbsp;if [ ! -f "$1" ]       # Check if file exists.
  17&nbsp;then
  18&nbsp;  echo "File \"$1\" does not exist."
  19&nbsp;  exit $E_NOFILE
  20&nbsp;fi
  21&nbsp;
  22&nbsp;
  23&nbsp;
  24&nbsp;########################################################
  25&nbsp;# main ()
  26&nbsp;sed -e 's/\.//g'  -e 's/ /\
  27&nbsp;/g' "$1" | tr 'A-Z' 'a-z' | sort | uniq -c | sort -nr
  28&nbsp;#                           =========================
  29&nbsp;#                            Frequency of occurrence
  30&nbsp;
  31&nbsp;#  Filter out periods and
  32&nbsp;#+ change space between words to linefeed,
  33&nbsp;#+ then shift characters to lowercase, and
  34&nbsp;#+ finally prefix occurrence count and sort numerically.
  35&nbsp;########################################################
  36&nbsp;
  37&nbsp;# Exercises:
  38&nbsp;# ---------
  39&nbsp;# 1) Add 'sed' commands to filter out other punctuation, such as commas.
  40&nbsp;# 2) Modify to also filter out multiple spaces and other whitespace.
  41&nbsp;# 3) Add a secondary sort key, so that instances of equal occurrence
  42&nbsp;#+   are sorted alphabetically.
  43&nbsp;
  44&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>	       <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>cat testfile</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>This line occurs only once.
 This line occurs twice.
 This line occurs twice.
 This line occurs three times.
 This line occurs three times.
 This line occurs three times.</TT
>
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>./wf.sh testfile</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>      6 this
       6 occurs
       6 line
       3 times
       3 three
       2 twice
       1 only
       1 once</TT
>
 	       </PRE
></TD
></TR
></TABLE
>
	     </P
></DD
><DT
><A
NAME="EXPANDREF"
></A
><B
CLASS="COMMAND"
>expand</B
>, <B
CLASS="COMMAND"
>unexpand</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>expand</B
> filter converts tabs to
	      spaces. It is often used in a pipe.</P
><P
>The <B
CLASS="COMMAND"
>unexpand</B
> filter
	      converts spaces to tabs. This reverses the effect of
	      <B
CLASS="COMMAND"
>expand</B
>.</P
></DD
><DT
><A
NAME="CUTREF"
></A
><B
CLASS="COMMAND"
>cut</B
></DT
><DD
><P
>A tool for extracting fields from files. It is similar to the 
	      <TT
CLASS="USERINPUT"
><B
>print $N</B
></TT
> command set in <A
HREF="awk.html#AWKREF"
>awk</A
>, but more limited. It may be
	      simpler to use <B
CLASS="COMMAND"
>cut</B
> in a script than
	      <B
CLASS="COMMAND"
>awk</B
>. Particularly important are the
	      <TT
CLASS="OPTION"
>-d</TT
> (delimiter) and <TT
CLASS="OPTION"
>-f</TT
>
	      (field specifier) options.</P
><P
>Using <B
CLASS="COMMAND"
>cut</B
> to obtain a listing of the
	      mounted filesystems: 
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;cat /etc/mtab | cut -d ' ' -f1,2</PRE
></TD
></TR
></TABLE
></P
><P
>Using <B
CLASS="COMMAND"
>cut</B
> to list the OS and kernel version:
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;uname -a | cut -d" " -f1,3,11,12</PRE
></TD
></TR
></TABLE
></P
><P
>Using <B
CLASS="COMMAND"
>cut</B
> to extract message headers from
	      an e-mail folder:

	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>grep '^Subject:' read-messages | cut -c10-80</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Re: Linux suitable for mission-critical apps?
 MAKE MILLIONS WORKING AT HOME!!!
 Spam complaint
 Re: Spam complaint</TT
></PRE
></TD
></TR
></TABLE
>
	    </P
><P
>Using <B
CLASS="COMMAND"
>cut</B
> to parse a file:
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# List all the users in /etc/passwd.
   2&nbsp;
   3&nbsp;FILENAME=/etc/passwd
   4&nbsp;
   5&nbsp;for user in $(cut -d: -f1 $FILENAME)
   6&nbsp;do
   7&nbsp;  echo $user
   8&nbsp;done
   9&nbsp;
  10&nbsp;# Thanks, Oleg Philon for suggesting this.</PRE
></TD
></TR
></TABLE
></P
><P
><TT
CLASS="USERINPUT"
><B
>cut -d ' ' -f2,3 filename</B
></TT
> is equivalent to
	      <TT
CLASS="USERINPUT"
><B
>awk -F'[ ]' '{ print $2, $3 }' filename</B
></TT
></P
><P
>See also <A
HREF="mathc.html#BASE"
>Example 12-31</A
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>paste</B
></DT
><DD
><P
>Tool for merging together different files into a single,
	      multi-column file.  In combination with
	      <B
CLASS="COMMAND"
>cut</B
>, useful for creating system log
	      files.
	    </P
></DD
><DT
><B
CLASS="COMMAND"
>join</B
></DT
><DD
><P
>Consider this a special-purpose cousin of
	      <B
CLASS="COMMAND"
>paste</B
>. This powerful utility allows
	      merging two files in a meaningful fashion, which essentially
	      creates a simple version of a relational database.</P
><P
>The <B
CLASS="COMMAND"
>join</B
> command operates on
	      exactly two files, but pastes together only those lines
	      with a common tagged field (usually a numerical label),
	      and writes the result to <TT
CLASS="FILENAME"
>stdout</TT
>.
	      The files to be joined should be sorted according to the
	      tagged field for the matchups to work properly.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;File: 1.data
   2&nbsp;
   3&nbsp;100 Shoes
   4&nbsp;200 Laces
   5&nbsp;300 Socks</PRE
></TD
></TR
></TABLE
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;File: 2.data
   2&nbsp;
   3&nbsp;100 $40.00
   4&nbsp;200 $1.00
   5&nbsp;300 $2.00</PRE
></TD
></TR
></TABLE
></P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>join 1.data 2.data</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>File: 1.data 2.data

 100 Shoes $40.00
 200 Laces $1.00
 300 Socks $2.00</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The tagged field appears only once in the
	      output.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>head</B
></DT
><DD
><P
>lists the beginning of a file to
	      <TT
CLASS="FILENAME"
>stdout</TT
> (the default is
	      <TT
CLASS="LITERAL"
>10</TT
> lines, but this can be changed). It
	      has a number of interesting options.

	    <DIV
CLASS="EXAMPLE"
><HR><A
NAME="RND"
></A
><P
><B
>Example 12-10. Generating 10-digit random numbers</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# rnd.sh: Outputs a 10-digit random number
   3&nbsp;
   4&nbsp;# Script by Stephane Chazelas.
   5&nbsp;
   6&nbsp;head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'
   7&nbsp;
   8&nbsp;
   9&nbsp;# =================================================================== #
  10&nbsp;
  11&nbsp;# Analysis
  12&nbsp;# --------
  13&nbsp;
  14&nbsp;# head:
  15&nbsp;# -c4 option takes first 4 bytes.
  16&nbsp;
  17&nbsp;# od:
  18&nbsp;# -N4 option limits output to 4 bytes.
  19&nbsp;# -tu4 option selects unsigned decimal format for output.
  20&nbsp;
  21&nbsp;# sed: 
  22&nbsp;# -n option, in combination with "p" flag to the "s" command,
  23&nbsp;# outputs only matched lines.
  24&nbsp;
  25&nbsp;
  26&nbsp;
  27&nbsp;# The author of this script explains the action of 'sed', as follows.
  28&nbsp;
  29&nbsp;# head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'
  30&nbsp;# ----------------------------------&#62; |
  31&nbsp;
  32&nbsp;# Assume output up to "sed" --------&#62; |
  33&nbsp;# is 0000000 1198195154\n
  34&nbsp;
  35&nbsp;# sed begins reading characters: 0000000 1198195154\n.
  36&nbsp;# Here it finds a newline character,
  37&nbsp;# so it is ready to process the first line (0000000 1198195154).
  38&nbsp;# It looks at its &#60;range&#62;&#60;action&#62;s. The first and only one is
  39&nbsp;
  40&nbsp;#   range     action
  41&nbsp;#   1         s/.* //p
  42&nbsp;
  43&nbsp;# The line number is in the range, so it executes the action:
  44&nbsp;# tries to substitute the longest string ending with a space in the line
  45&nbsp;# ("0000000 ") with nothing (//), and if it succeeds, prints the result
  46&nbsp;# ("p" is a flag to the "s" command here, this is different from the "p" command).
  47&nbsp;
  48&nbsp;# sed is now ready to continue reading its input. (Note that before
  49&nbsp;# continuing, if -n option had not been passed, sed would have printed
  50&nbsp;# the line once again).
  51&nbsp;
  52&nbsp;# Now, sed reads the remainder of the characters, and finds the end of the file.
  53&nbsp;# It is now ready to process its 2nd line (which is also numbered '$' as
  54&nbsp;# it's the last one).
  55&nbsp;# It sees it is not matched by any &#60;range&#62;, so its job is done.
  56&nbsp;
  57&nbsp;# In few word this sed commmand means:
  58&nbsp;# "On the first line only, remove any character up to the right-most space,
  59&nbsp;# then print it."
  60&nbsp;
  61&nbsp;# A better way to do this would have been:
  62&nbsp;#           sed -e 's/.* //;q'
  63&nbsp;
  64&nbsp;# Here, two &#60;range&#62;&#60;action&#62;s (could have been written
  65&nbsp;#           sed -e 's/.* //' -e q):
  66&nbsp;
  67&nbsp;#   range                    action
  68&nbsp;#   nothing (matches line)   s/.* //
  69&nbsp;#   nothing (matches line)   q (quit)
  70&nbsp;
  71&nbsp;# Here, sed only reads its first line of input.
  72&nbsp;# It performs both actions, and prints the line (substituted) before quitting
  73&nbsp;# (because of the "q" action) since the "-n" option is not passed.
  74&nbsp;
  75&nbsp;# =================================================================== #
  76&nbsp;
  77&nbsp;# A simpler altenative to the above 1-line script would be:
  78&nbsp;#           head -c4 /dev/urandom| od -An -tu4
  79&nbsp;
  80&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
>	    

	      See also <A
HREF="filearchiv.html#EX52"
>Example 12-28</A
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>tail</B
></DT
><DD
><P
>lists the end of a file to <TT
CLASS="FILENAME"
>stdout</TT
>
	      (the default is <TT
CLASS="LITERAL"
>10</TT
> lines).  Commonly used
	      to keep track of changes to a system logfile, using the
	      <TT
CLASS="OPTION"
>-f</TT
> option, which outputs lines appended
	      to the file.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX12"
></A
><P
><B
>Example 12-11. Using <B
CLASS="COMMAND"
>tail</B
> to monitor the system log</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;filename=sys.log
   4&nbsp;
   5&nbsp;cat /dev/null &#62; $filename; echo "Creating / cleaning out file."
   6&nbsp;# Creates file if it does not already exist,
   7&nbsp;# and truncates it to zero length if it does.
   8&nbsp;# : &#62; filename   also works.
   9&nbsp;
  10&nbsp;tail /var/log/messages &#62; $filename  
  11&nbsp;# /var/log/messages must have world read permission for this to work.
  12&nbsp;
  13&nbsp;echo "$filename contains tail end of system log."
  14&nbsp;
  15&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>See also <A
HREF="moreadv.html#EX41"
>Example 12-4</A
>, <A
HREF="filearchiv.html#EX52"
>Example 12-28</A
> and
		<A
HREF="debugging.html#ONLINE"
>Example 30-5</A
>.</P
></DD
><DT
><A
NAME="GREPREF"
></A
><B
CLASS="COMMAND"
>grep</B
></DT
><DD
><P
>A multi-purpose file search tool that uses
	      <A
HREF="regexp.html#REGEXREF"
>regular expressions</A
>.
	      It was originally a command/filter in the
	      venerable <B
CLASS="COMMAND"
>ed</B
> line editor,
	      <TT
CLASS="USERINPUT"
><B
>g/re/p</B
></TT
>, that is, <I
CLASS="EMPHASIS"
>global -
	      regular expression - print</I
>.</P
><P
><P
><B
CLASS="COMMAND"
>grep</B
>   <TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>  [<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>...]</P
>Search the target file(s) for
	      occurrences of <TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
>, where
	      <TT
CLASS="REPLACEABLE"
><I
>pattern</I
></TT
> may be literal text
	      or a regular expression.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>grep '[rst]ystem.$' osinfo.txt</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>The GPL governs the distribution of the Linux operating system.</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
><P
>If no target file(s) specified, <B
CLASS="COMMAND"
>grep</B
>
	      works as a filter on <TT
CLASS="FILENAME"
>stdout</TT
>, as in
	      a <A
HREF="special-chars.html#PIPEREF"
>pipe</A
>.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ps ax | grep clock</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>765 tty1     S      0:00 xclock
 901 pts/1    S      0:00 grep clock</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
><P
>The <TT
CLASS="OPTION"
>-i</TT
> option causes a case-insensitive
	      search.</P
><P
>The <TT
CLASS="OPTION"
>-l</TT
> option lists only the files in which
	      matches were found, but not the matching lines.</P
><P
>The <TT
CLASS="OPTION"
>-n</TT
> option lists the matching lines,
	      together with line numbers.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>grep -n Linux osinfo.txt</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>2:This is a file containing information about Linux.
 6:The GPL governs the distribution of the Linux operating system.</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
><P
>The <TT
CLASS="OPTION"
>-v</TT
> (or <TT
CLASS="OPTION"
>--invert-match</TT
>)
	      option <I
CLASS="EMPHASIS"
>filters out</I
> matches.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;grep pattern1 *.txt | grep -v pattern2
   2&nbsp;
   3&nbsp;# Matches all lines in "*.txt" files containing "pattern1",
   4&nbsp;# but ***not*** "pattern2".	      </PRE
></TD
></TR
></TABLE
></P
><P
>The <TT
CLASS="OPTION"
>-c</TT
> (<TT
CLASS="OPTION"
>--count</TT
>)
	      option gives a numerical count of matches, rather than
	      actually listing the matches.

	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;grep -c txt *.sgml   # (number of occurrences of "txt" in "*.sgml" files)
   2&nbsp;
   3&nbsp;
   4&nbsp;#   grep -cz .
   5&nbsp;#            ^ dot
   6&nbsp;# means count (-c) zero-separated (-z) items matching "."
   7&nbsp;# that is, non-empty ones (containing at least 1 character).
   8&nbsp;# 
   9&nbsp;printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz .     # 4
  10&nbsp;printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz '$'   # 5
  11&nbsp;printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz '^'   # 5
  12&nbsp;#
  13&nbsp;printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -c '$'    # 9
  14&nbsp;# By default, newline chars (\n) separate items to match. 
  15&nbsp;
  16&nbsp;# Note that the -z option is GNU "grep" specific.
  17&nbsp;
  18&nbsp;
  19&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
>
            </P
><P
>When invoked with more than one target file given,
	      <B
CLASS="COMMAND"
>grep</B
> specifies which file contains
	      matches.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>grep Linux osinfo.txt misc.txt</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>osinfo.txt:This is a file containing information about Linux.
 osinfo.txt:The GPL governs the distribution of the Linux operating system.
 misc.txt:The Linux operating system is steadily gaining in popularity.</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>To force <B
CLASS="COMMAND"
>grep</B
> to show the filename
	      when searching only one target file, simply give
	      <TT
CLASS="FILENAME"
>/dev/null</TT
> as the second file.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>grep Linux osinfo.txt /dev/null</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>osinfo.txt:This is a file containing information about Linux.
 osinfo.txt:The GPL governs the distribution of the Linux operating system.</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></TD
></TR
></TABLE
></DIV
><P
>If there is a successful match, <B
CLASS="COMMAND"
>grep</B
>
	      returns an <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
>
	      of 0, which makes it useful in a condition test in a
	      script, especially in combination with the <TT
CLASS="OPTION"
>-q</TT
>
	      option to suppress output.
	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;SUCCESS=0                      # if grep lookup succeeds
   2&nbsp;word=Linux
   3&nbsp;filename=data.file
   4&nbsp;
   5&nbsp;grep -q "$word" "$filename"    # The "-q" option causes nothing to echo to stdout.
   6&nbsp;
   7&nbsp;if [ $? -eq $SUCCESS ]
   8&nbsp;then
   9&nbsp;  echo "$word found in $filename"
  10&nbsp;else
  11&nbsp;  echo "$word not found in $filename"
  12&nbsp;fi</PRE
></TD
></TR
></TABLE
>
            </P
><P
><A
HREF="debugging.html#ONLINE"
>Example 30-5</A
> demonstrates how to use
	      <B
CLASS="COMMAND"
>grep</B
> to search for a word pattern in
	      a system logfile.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="GRP"
></A
><P
><B
>Example 12-12. Emulating <SPAN
CLASS="QUOTE"
>"grep"</SPAN
> in a script</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# grp.sh: Very crude reimplementation of 'grep'.
   3&nbsp;
   4&nbsp;E_BADARGS=65
   5&nbsp;
   6&nbsp;if [ -z "$1" ]    # Check for argument to script.
   7&nbsp;then
   8&nbsp;  echo "Usage: `basename $0` pattern"
   9&nbsp;  exit $E_BADARGS
  10&nbsp;fi  
  11&nbsp;
  12&nbsp;echo
  13&nbsp;
  14&nbsp;for file in *     # Traverse all files in $PWD.
  15&nbsp;do
  16&nbsp;  output=$(sed -n /"$1"/p $file)  # Command substitution.
  17&nbsp;
  18&nbsp;  if [ ! -z "$output" ]           # What happens if "$output" is not quoted?
  19&nbsp;  then
  20&nbsp;    echo -n "$file: "
  21&nbsp;    echo $output
  22&nbsp;  fi              #  sed -ne "/$1/s|^|${file}: |p"  is equivalent to above.
  23&nbsp;
  24&nbsp;  echo
  25&nbsp;done  
  26&nbsp;
  27&nbsp;echo
  28&nbsp;
  29&nbsp;exit 0
  30&nbsp;
  31&nbsp;# Exercises:
  32&nbsp;# ---------
  33&nbsp;# 1) Add newlines to output, if more than one match in any given file.
  34&nbsp;# 2) Add features.</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><A
NAME="EGREPREF"
></A
><B
CLASS="COMMAND"
>egrep</B
>
	      is the same as <B
CLASS="COMMAND"
>grep -E</B
>. This
	      uses a somewhat different, extended set of <A
HREF="regexp.html#REGEXREF"
>regular expressions</A
>, which can
	      make the search somewhat more flexible.</P
><P
><B
CLASS="COMMAND"
>fgrep</B
> is the same as <B
CLASS="COMMAND"
>grep
	      -F</B
>. It does a literal string search (no regular
	      expressions), which allegedly speeds things up a
	      bit.</P
><P
><B
CLASS="COMMAND"
>agrep</B
> extends the capabilities of
	      <B
CLASS="COMMAND"
>grep</B
> to approximate matching. The search
	      string may differ by a specified number of characters from the
	      resulting matches. This utility is not part of the core Linux
	      distribution.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>To search compressed files, use
	      <B
CLASS="COMMAND"
>zgrep</B
>, <B
CLASS="COMMAND"
>zegrep</B
>,
	      or <B
CLASS="COMMAND"
>zfgrep</B
>. These also work
	      on non-compressed files, though slower than plain
	      <B
CLASS="COMMAND"
>grep</B
>, <B
CLASS="COMMAND"
>egrep</B
>,
	      <B
CLASS="COMMAND"
>fgrep</B
>.  They are handy for searching
	      through a mixed set of files, some compressed, some
	      not.</P
><P
>To search <A
HREF="filearchiv.html#BZIPREF"
>bzipped</A
>
	      files, use <B
CLASS="COMMAND"
>bzgrep</B
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>look</B
></DT
><DD
><P
>The command <B
CLASS="COMMAND"
>look</B
> works like
	      <B
CLASS="COMMAND"
>grep</B
>, but does a lookup on
	      a <SPAN
CLASS="QUOTE"
>"dictionary"</SPAN
>, a sorted word list.
	      By default, <B
CLASS="COMMAND"
>look</B
> searches for a match
	      in <TT
CLASS="FILENAME"
>/usr/dict/words</TT
>, but a different
	      dictionary file may be specified.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="LOOKUP"
></A
><P
><B
>Example 12-13. Checking words in a list for validity</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# lookup: Does a dictionary lookup on each word in a data file.
   3&nbsp;
   4&nbsp;file=words.data  # Data file from which to read words to test.
   5&nbsp;
   6&nbsp;echo
   7&nbsp;
   8&nbsp;while [ "$word" != end ]  # Last word in data file.
   9&nbsp;do
  10&nbsp;  read word      # From data file, because of redirection at end of loop.
  11&nbsp;  look $word &#62; /dev/null  # Don't want to display lines in dictionary file.
  12&nbsp;  lookup=$?      # Exit status of 'look' command.
  13&nbsp;
  14&nbsp;  if [ "$lookup" -eq 0 ]
  15&nbsp;  then
  16&nbsp;    echo "\"$word\" is valid."
  17&nbsp;  else
  18&nbsp;    echo "\"$word\" is invalid."
  19&nbsp;  fi  
  20&nbsp;
  21&nbsp;done &#60;"$file"    # Redirects stdin to $file, so "reads" come from there.
  22&nbsp;
  23&nbsp;echo
  24&nbsp;
  25&nbsp;exit 0
  26&nbsp;
  27&nbsp;# ----------------------------------------------------------------
  28&nbsp;# Code below line will not execute because of "exit" command above.
  29&nbsp;
  30&nbsp;
  31&nbsp;# Stephane Chazelas proposes the following, more concise alternative:
  32&nbsp;
  33&nbsp;while read word &#38;&#38; [[ $word != end ]]
  34&nbsp;do if look "$word" &#62; /dev/null
  35&nbsp;   then echo "\"$word\" is valid."
  36&nbsp;   else echo "\"$word\" is invalid."
  37&nbsp;   fi
  38&nbsp;done &#60;"$file"
  39&nbsp;
  40&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><B
CLASS="COMMAND"
>sed</B
>, <B
CLASS="COMMAND"
>awk</B
></DT
><DD
><P
>Scripting languages especially suited for parsing text
	      files and command output. May be embedded singly or in
	      combination in pipes and shell scripts.</P
></DD
><DT
><B
CLASS="COMMAND"
><A
HREF="sedawk.html#SEDREF"
>sed</A
></B
></DT
><DD
><P
>Non-interactive <SPAN
CLASS="QUOTE"
>"stream editor"</SPAN
>, permits using
	      many <B
CLASS="COMMAND"
>ex</B
> commands in batch mode. It
	      finds many uses in shell scripts.</P
></DD
><DT
><B
CLASS="COMMAND"
><A
HREF="awk.html#AWKREF"
>awk</A
></B
></DT
><DD
><P
>Programmable file extractor and formatter, good for
	      manipulating and/or extracting fields (columns) in
	      structured text files. Its syntax is similar to C.</P
></DD
><DT
><B
CLASS="COMMAND"
>wc</B
></DT
><DD
><P
><I
CLASS="EMPHASIS"
>wc</I
> gives a <SPAN
CLASS="QUOTE"
>"word count"</SPAN
> on a file or I/O stream:
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash $ </TT
><TT
CLASS="USERINPUT"
><B
>wc /usr/doc/sed-3.02/README</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>20     127     838 /usr/doc/sed-3.02/README</TT
>
 [20 lines  127 words  838 characters]</PRE
></TD
></TR
></TABLE
></P
><P
><TT
CLASS="USERINPUT"
><B
>wc -w</B
></TT
> gives only the word count.</P
><P
><TT
CLASS="USERINPUT"
><B
>wc -l</B
></TT
> gives only the line count.</P
><P
><TT
CLASS="USERINPUT"
><B
>wc -c</B
></TT
> gives only the character count.</P
><P
><TT
CLASS="USERINPUT"
><B
>wc -L</B
></TT
> gives only the length of the longest line.</P
><P
>Using <B
CLASS="COMMAND"
>wc</B
> to count how many
	    <I
CLASS="EMPHASIS"
>.txt</I
> files are in current working directory:
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;$ ls *.txt | wc -l
   2&nbsp;# Will work as long as none of the "*.txt" files have a linefeed in their name.
   3&nbsp;
   4&nbsp;# Alternative ways of doing this are:
   5&nbsp;#      find . -maxdepth 1 -name \*.txt -print0 | grep -cz .
   6&nbsp;#      (shopt -s nullglob; set -- *.txt; echo $#)
   7&nbsp;
   8&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
>
	    </P
><P
>Using <B
CLASS="COMMAND"
>wc</B
> to total up the size of all the
	      files whose names begin with letters in the range d - h
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>wc [d-h]* | grep total | awk '{print $3}'</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>71832</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><P
>Using <B
CLASS="COMMAND"
>wc</B
> to count the instances of the
	      word <SPAN
CLASS="QUOTE"
>"Linux"</SPAN
> in the main source file for
	      this book.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>grep Linux abs-book.sgml | wc -l</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>50</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><P
>See also <A
HREF="filearchiv.html#EX52"
>Example 12-28</A
> and <A
HREF="redircb.html#REDIR4"
>Example 16-5</A
>.</P
><P
>Certain commands include some of the
	      functionality of <B
CLASS="COMMAND"
>wc</B
> as options.
	      
	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;... | grep foo | wc -l
   2&nbsp;# This frequently used construct can be more concisely rendered.
   3&nbsp;
   4&nbsp;... | grep -c foo
   5&nbsp;# Just use the "-c" (or "--count") option of grep.
   6&nbsp;
   7&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><A
NAME="TRREF"
></A
><B
CLASS="COMMAND"
>tr</B
></DT
><DD
><P
>character translation filter.</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><A
HREF="special-chars.html#UCREF"
>Must use quoting and/or
	      brackets</A
>, as appropriate. Quotes prevent the
	      shell from reinterpreting the special characters in
	      <B
CLASS="COMMAND"
>tr</B
> command sequences. Brackets should be
	      quoted to prevent expansion by the shell.  </P
></TD
></TR
></TABLE
></DIV
><P
>Either <TT
CLASS="USERINPUT"
><B
>tr "A-Z" "*" &#60;filename</B
></TT
>
	      or <TT
CLASS="USERINPUT"
><B
>tr A-Z \* &#60;filename</B
></TT
> changes
	      all the uppercase letters in <TT
CLASS="FILENAME"
>filename</TT
>
	      to asterisks (writes to <TT
CLASS="FILENAME"
>stdout</TT
>).
	      On some systems this may not work, but <TT
CLASS="USERINPUT"
><B
>tr A-Z
	      '[**]'</B
></TT
> will.</P
><P
>The <TT
CLASS="OPTION"
>-d</TT
> option deletes a range of
	      characters.
	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo "abcdef"                 # abcdef
   2&nbsp;echo "abcdef" | tr -d b-d     # aef
   3&nbsp;
   4&nbsp;
   5&nbsp;tr -d 0-9 &#60;filename
   6&nbsp;# Deletes all digits from the file "filename".</PRE
></TD
></TR
></TABLE
></P
><P
>The <TT
CLASS="OPTION"
>--squeeze-repeats</TT
> (or
              <TT
CLASS="OPTION"
>-s</TT
>) option deletes all but the
              first instance of a string of consecutive characters.
              This option is useful for removing excess <A
HREF="special-chars.html#WHITESPACEREF"
>whitespace</A
>.



	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo "XXXXX" | tr --squeeze-repeats 'X'</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>X</TT
></PRE
></TD
></TR
></TABLE
></P
><P
>The <TT
CLASS="OPTION"
>-c</TT
> <SPAN
CLASS="QUOTE"
>"complement"</SPAN
>
	      option <I
CLASS="EMPHASIS"
>inverts</I
> the character set to
	      match. With this option, <B
CLASS="COMMAND"
>tr</B
> acts only
	      upon those characters <I
CLASS="EMPHASIS"
>not</I
> matching
	      the specified set.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo "acfdeb123" | tr -c b-d +</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>+c+d+b++++</TT
></PRE
></TD
></TR
></TABLE
>
            </P
><P
>Note that <B
CLASS="COMMAND"
>tr</B
> recognizes <A
HREF="regexp.html#POSIXREF"
>POSIX character classes</A
>.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo "abcd2ef1" | tr '[:alpha:]' -</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>----2--1</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX49"
></A
><P
><B
>Example 12-14. <B
CLASS="COMMAND"
>toupper</B
>: Transforms a file to all uppercase.</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# Changes a file to all uppercase.
   3&nbsp;
   4&nbsp;E_BADARGS=65
   5&nbsp;
   6&nbsp;if [ -z "$1" ]  # Standard check for command line arg.
   7&nbsp;then
   8&nbsp;  echo "Usage: `basename $0` filename"
   9&nbsp;  exit $E_BADARGS
  10&nbsp;fi  
  11&nbsp;
  12&nbsp;tr a-z A-Z &#60;"$1"
  13&nbsp;
  14&nbsp;# Same effect as above, but using POSIX character set notation:
  15&nbsp;#        tr '[:lower:]' '[:upper:]' &#60;"$1"
  16&nbsp;# Thanks, S.C.
  17&nbsp;
  18&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="LOWERCASE"
></A
><P
><B
>Example 12-15. <B
CLASS="COMMAND"
>lowercase</B
>: Changes all filenames in working directory to lowercase.</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#! /bin/bash
   2&nbsp;#
   3&nbsp;# Changes every filename in working directory to all lowercase.
   4&nbsp;#
   5&nbsp;# Inspired by a script of John Dubois,
   6&nbsp;# which was translated into into Bash by Chet Ramey,
   7&nbsp;# and considerably simplified by Mendel Cooper, author of this document.
   8&nbsp;
   9&nbsp;
  10&nbsp;for filename in *                # Traverse all files in directory.
  11&nbsp;do
  12&nbsp;   fname=`basename $filename`
  13&nbsp;   n=`echo $fname | tr A-Z a-z`  # Change name to lowercase.
  14&nbsp;   if [ "$fname" != "$n" ]       # Rename only files not already lowercase.
  15&nbsp;   then
  16&nbsp;     mv $fname $n
  17&nbsp;   fi  
  18&nbsp;done   
  19&nbsp;
  20&nbsp;exit 0
  21&nbsp;
  22&nbsp;
  23&nbsp;# Code below this line will not execute because of "exit".
  24&nbsp;#--------------------------------------------------------#
  25&nbsp;# To run it, delete script above line.
  26&nbsp;
  27&nbsp;# The above script will not work on filenames containing blanks or newlines.
  28&nbsp;
  29&nbsp;# Stephane Chazelas therefore suggests the following alternative:
  30&nbsp;
  31&nbsp;
  32&nbsp;for filename in *    # Not necessary to use basename,
  33&nbsp;                     # since "*" won't return any file containing "/".
  34&nbsp;do n=`echo "$filename/" | tr '[:upper:]' '[:lower:]'`
  35&nbsp;#                             POSIX char set notation.
  36&nbsp;#                    Slash added so that trailing newlines are not
  37&nbsp;#                    removed by command substitution.
  38&nbsp;   # Variable substitution:
  39&nbsp;   n=${n%/}          # Removes trailing slash, added above, from filename.
  40&nbsp;   [[ $filename == $n ]] || mv "$filename" "$n"
  41&nbsp;                     # Checks if filename already lowercase.
  42&nbsp;done
  43&nbsp;
  44&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="DU"
></A
><P
><B
>Example 12-16. <B
CLASS="COMMAND"
>du</B
>: DOS to UNIX text file conversion.</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# du.sh: DOS to UNIX text file converter.
   3&nbsp;
   4&nbsp;E_WRONGARGS=65
   5&nbsp;
   6&nbsp;if [ -z "$1" ]
   7&nbsp;then
   8&nbsp;  echo "Usage: `basename $0` filename-to-convert"
   9&nbsp;  exit $E_WRONGARGS
  10&nbsp;fi
  11&nbsp;
  12&nbsp;NEWFILENAME=$1.unx
  13&nbsp;
  14&nbsp;CR='\015'  # Carriage return.
  15&nbsp;# Lines in a DOS text file end in a CR-LF.
  16&nbsp;
  17&nbsp;tr -d $CR &#60; $1 &#62; $NEWFILENAME
  18&nbsp;# Delete CR and write to new file.
  19&nbsp;
  20&nbsp;echo "Original DOS text file is \"$1\"."
  21&nbsp;echo "Converted UNIX text file is \"$NEWFILENAME\"."
  22&nbsp;
  23&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ROT13"
></A
><P
><B
>Example 12-17. <B
CLASS="COMMAND"
>rot13</B
>: rot13, ultra-weak encryption.</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# rot13.sh: Classic rot13 algorithm, encryption that might fool a 3-year old.
   3&nbsp;
   4&nbsp;# Usage: ./rot13.sh filename
   5&nbsp;# or     ./rot13.sh &#60;filename
   6&nbsp;# or     ./rot13.sh and supply keyboard input (stdin)
   7&nbsp;
   8&nbsp;cat "$@" | tr 'a-zA-Z' 'n-za-mN-ZA-M'   # "a" goes to "n", "b" to "o", etc.
   9&nbsp;# The 'cat "$@"' construction
  10&nbsp;# permits getting input either from stdin or from files.
  11&nbsp;
  12&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="CRYPTOQUOTE"
></A
><P
><B
>Example 12-18. Generating <SPAN
CLASS="QUOTE"
>"Crypto-Quote"</SPAN
> Puzzles</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# crypto-quote.sh: Encrypt quotes
   3&nbsp;
   4&nbsp;# Will encrypt famous quotes in a simple monoalphabetic substitution.
   5&nbsp;#  The result is similar to the "Crypto Quote" puzzles
   6&nbsp;#+ seen in the Op Ed pages of the Sunday paper.
   7&nbsp;
   8&nbsp;
   9&nbsp;key=ETAOINSHRDLUBCFGJMQPVWZYXK
  10&nbsp;# The "key" is nothing more than a scrambled alphabet.
  11&nbsp;# Changing the "key" changes the encryption.
  12&nbsp;
  13&nbsp;# The 'cat "$@"' construction gets input either from stdin or from files.
  14&nbsp;# If using stdin, terminate input with a Control-D.
  15&nbsp;# Otherwise, specify filename as command-line parameter.
  16&nbsp;
  17&nbsp;cat "$@" | tr "a-z" "A-Z" | tr "A-Z" "$key"
  18&nbsp;#        |  to uppercase  |     encrypt       
  19&nbsp;# Will work on lowercase, uppercase, or mixed-case quotes.
  20&nbsp;# Passes non-alphabetic characters through unchanged.
  21&nbsp;
  22&nbsp;
  23&nbsp;# Try this script with something like
  24&nbsp;# "Nothing so needs reforming as other people's habits."
  25&nbsp;# --Mark Twain
  26&nbsp;#
  27&nbsp;# Output is:
  28&nbsp;# "CFPHRCS QF CIIOQ MINFMBRCS EQ FPHIM GIFGUI'Q HETRPQ."
  29&nbsp;# --BEML PZERC
  30&nbsp;
  31&nbsp;# To reverse the encryption:
  32&nbsp;# cat "$@" | tr "$key" "A-Z"
  33&nbsp;
  34&nbsp;
  35&nbsp;#  This simple-minded cipher can be broken by an average 12-year old
  36&nbsp;#+ using only pencil and paper.
  37&nbsp;
  38&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><TABLE
CLASS="SIDEBAR"
BORDER="1"
CELLPADDING="5"
><TR
><TD
><DIV
CLASS="SIDEBAR"
><A
NAME="AEN7144"
></A
><P
><B
><B
CLASS="COMMAND"
>tr</B
> variants</B
></P
><P
>	    The <B
CLASS="COMMAND"
>tr</B
> utility has two historic
	    variants. The BSD version does not use brackets
	    (<TT
CLASS="USERINPUT"
><B
>tr a-z A-Z</B
></TT
>), but the SysV one does
	    (<TT
CLASS="USERINPUT"
><B
>tr '[a-z]' '[A-Z]'</B
></TT
>). The GNU version
	    of <B
CLASS="COMMAND"
>tr</B
> resembles the BSD one, so quoting
	    letter ranges within brackets is mandatory.
	    </P
></DIV
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="FOLDREF"
></A
><B
CLASS="COMMAND"
>fold</B
></DT
><DD
><P
>A filter that wraps lines of input to a specified width.
	      This is especially useful with the <TT
CLASS="OPTION"
>-s</TT
>
	      option, which breaks lines at word spaces (see <A
HREF="textproc.html#EX50"
>Example 12-19</A
> and <A
HREF="contributed-scripts.html#MAILFORMAT"
>Example A-2</A
>).</P
></DD
><DT
><B
CLASS="COMMAND"
>fmt</B
></DT
><DD
><P
>Simple-minded file formatter, used as a filter in a
	      pipe to <SPAN
CLASS="QUOTE"
>"wrap"</SPAN
> long lines of text
	      output.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX50"
></A
><P
><B
>Example 12-19. Formatted file listing.</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;WIDTH=40                    # 40 columns wide.
   4&nbsp;
   5&nbsp;b=`ls /usr/local/bin`       # Get a file listing...
   6&nbsp;
   7&nbsp;echo $b | fmt -w $WIDTH
   8&nbsp;
   9&nbsp;# Could also have been done by
  10&nbsp;#  echo $b | fold - -s -w $WIDTH
  11&nbsp; 
  12&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>See also <A
HREF="moreadv.html#EX41"
>Example 12-4</A
>.</P
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A powerful alternative to <B
CLASS="COMMAND"
>fmt</B
> is
	      Kamil Toman's <B
CLASS="COMMAND"
>par</B
>
	      utility, available from <A
HREF="http://www.cs.berkeley.edu/~amc/Par/"
TARGET="_top"
>http://www.cs.berkeley.edu/~amc/Par/</A
>.
	      </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>ptx</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>ptx [targetfile]</B
> command
	      outputs a permuted index (cross-reference list) of the
	      targetfile. This may be further filtered and formatted in a
	      pipe, if necessary.</P
></DD
><DT
><B
CLASS="COMMAND"
>col</B
></DT
><DD
><P
>This deceptively named filter removes reverse line feeds
	      from an input stream. It also attempts to replace
	      whitespace with equivalent tabs. The chief use of
	      <B
CLASS="COMMAND"
>col</B
> is in filtering the output
	      from certain text processing utilities, such as
	      <B
CLASS="COMMAND"
>groff</B
> and <B
CLASS="COMMAND"
>tbl</B
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>column</B
></DT
><DD
><P
>Column formatter. This filter transforms list-type
	      text output into a <SPAN
CLASS="QUOTE"
>"pretty-printed"</SPAN
> table
	      by inserting tabs at appropriate places.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="COL"
></A
><P
><B
>Example 12-20. Using <B
CLASS="COMMAND"
>column</B
> to format a directory
	        listing</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# This is a slight modification of the example file in the "column" man page.
   3&nbsp;
   4&nbsp;
   5&nbsp;(printf "PERMISSIONS LINKS OWNER GROUP SIZE MONTH DAY HH:MM PROG-NAME\n" \
   6&nbsp;; ls -l | sed 1d) | column -t
   7&nbsp;
   8&nbsp;#  The "sed 1d" in the pipe deletes the first line of output,
   9&nbsp;#+ which would be "total        N",
  10&nbsp;#+ where "N" is the total number of files found by "ls -l".
  11&nbsp;
  12&nbsp;# The -t option to "column" pretty-prints a table.
  13&nbsp;
  14&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><B
CLASS="COMMAND"
>colrm</B
></DT
><DD
><P
>Column removal filter. This removes columns (characters)
	      from a file and writes the file, lacking the range of
	      specified columns, back to <TT
CLASS="FILENAME"
>stdout</TT
>.
	      <TT
CLASS="USERINPUT"
><B
>colrm 2 4 &#60;filename</B
></TT
> removes the
	      second through fourth characters from each line of the
	      text file <TT
CLASS="FILENAME"
>filename</TT
>.</P
><DIV
CLASS="WARNING"
><TABLE
CLASS="WARNING"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/warning.png"
HSPACE="5"
ALT="Warning"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If the file contains tabs or nonprintable
	      characters, this may cause unpredictable
	      behavior. In such cases, consider using
	      <A
HREF="textproc.html#EXPANDREF"
>expand</A
> and
	      <B
CLASS="COMMAND"
>unexpand</B
> in a pipe preceding
	      <B
CLASS="COMMAND"
>colrm</B
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>nl</B
></DT
><DD
><P
>Line numbering filter. <TT
CLASS="USERINPUT"
><B
>nl filename</B
></TT
>
	    lists <TT
CLASS="FILENAME"
>filename</TT
> to
	    <TT
CLASS="FILENAME"
>stdout</TT
>, but inserts consecutive
	    numbers at the beginning of each non-blank line. If
	    <TT
CLASS="FILENAME"
>filename</TT
> omitted, operates on
	    <TT
CLASS="FILENAME"
>stdin.</TT
></P
><P
>The output of <B
CLASS="COMMAND"
>nl</B
> is very similar to
	      <TT
CLASS="USERINPUT"
><B
>cat -n</B
></TT
>, however, by default
	      <B
CLASS="COMMAND"
>nl</B
> does not list blank lines.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="LNUM"
></A
><P
><B
>Example 12-21. <B
CLASS="COMMAND"
>nl</B
>: A self-numbering script.</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# This script echoes itself twice to stdout with its lines numbered.
   4&nbsp;
   5&nbsp;# 'nl' sees this as line 3 since it does not number blank lines.
   6&nbsp;# 'cat -n' sees the above line as number 5.
   7&nbsp;
   8&nbsp;nl `basename $0`
   9&nbsp;
  10&nbsp;echo; echo  # Now, let's try it with 'cat -n'
  11&nbsp;
  12&nbsp;cat -n `basename $0`
  13&nbsp;# The difference is that 'cat -n' numbers the blank lines.
  14&nbsp;# Note that 'nl -ba' will also do so.
  15&nbsp;
  16&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><B
CLASS="COMMAND"
>pr</B
></DT
><DD
><P
>Print formatting filter. This will paginate files
	      (or <TT
CLASS="FILENAME"
>stdout</TT
>) into sections suitable for
	      hard copy printing or viewing on screen.	Various options
	      permit row and column manipulation, joining lines, setting
	      margins, numbering lines, adding page headers, and merging
	      files, among other things. The <B
CLASS="COMMAND"
>pr</B
>
	      command combines much of the functionality of
	      <B
CLASS="COMMAND"
>nl</B
>, <B
CLASS="COMMAND"
>paste</B
>,
	      <B
CLASS="COMMAND"
>fold</B
>, <B
CLASS="COMMAND"
>column</B
>, and
	      <B
CLASS="COMMAND"
>expand</B
>.</P
><P
><TT
CLASS="USERINPUT"
><B
>pr -o 5 --width=65 fileZZZ | more</B
></TT
>
	     gives a nice paginated listing to screen of
	     <TT
CLASS="FILENAME"
>fileZZZ</TT
> with margins set at 5 and
	     65.</P
><P
>A particularly useful option is <TT
CLASS="OPTION"
>-d</TT
>,
	      forcing double-spacing (same effect as <B
CLASS="COMMAND"
>sed
	      -G</B
>).</P
></DD
><DT
><A
NAME="GETTEXTREF"
></A
><B
CLASS="COMMAND"
>gettext</B
></DT
><DD
><P
>A GNU utility for <A
HREF="localization.html"
>localization</A
> and
	      translating the text output of programs into
	      foreign languages. While primarily intended for C
	      programs, <B
CLASS="COMMAND"
>gettext</B
> also finds
	      use in shell scripts. See the <TT
CLASS="REPLACEABLE"
><I
>info
	      page</I
></TT
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>iconv</B
></DT
><DD
><P
>A utility for converting file(s) to a different encoding
	      (character set). Its chief use is for localization.</P
></DD
><DT
><B
CLASS="COMMAND"
>recode</B
></DT
><DD
><P
>Consider this a fancier version of
	      <B
CLASS="COMMAND"
>iconv</B
>, above. This very versatile utility
	      for converting a file to a different encoding is not part
	      of the standard Linux installation.</P
></DD
><DT
><B
CLASS="COMMAND"
>TeX</B
>, <B
CLASS="COMMAND"
>gs</B
></DT
><DD
><P
><B
CLASS="COMMAND"
>TeX</B
> and <B
CLASS="COMMAND"
>Postscript</B
>
	      are text markup languages used for preparing copy for
	      printing or formatted video display.</P
><P
><B
CLASS="COMMAND"
>TeX</B
> is Donald Knuth's elaborate
		typsetting system. It is often convenient to write a
		shell script encapsulating all the options and arguments
		passed to one of these markup languages.</P
><P
><I
CLASS="EMPHASIS"
>Ghostscript</I
>
		(<B
CLASS="COMMAND"
>gs</B
>) is a GPL-ed Postscript
		interpreter.</P
></DD
><DT
><B
CLASS="COMMAND"
>groff</B
>, <B
CLASS="COMMAND"
>tbl</B
>, <B
CLASS="COMMAND"
>eqn</B
></DT
><DD
><P
>Yet another text markup and display formatting language
	      is <B
CLASS="COMMAND"
>groff</B
>. This is the enhanced GNU version
	      of the venerable UNIX <B
CLASS="COMMAND"
>roff/troff</B
> display
	      and typesetting package. <I
CLASS="EMPHASIS"
>Manpages</I
>
	      use <B
CLASS="COMMAND"
>groff</B
> (see <A
HREF="contributed-scripts.html#MANVIEW"
>Example A-1</A
>).</P
><P
>The <B
CLASS="COMMAND"
>tbl</B
> table processing utility
	      is considered part of <B
CLASS="COMMAND"
>groff</B
>, as its
	      function is to convert table markup into
	      <B
CLASS="COMMAND"
>groff</B
> commands.</P
><P
>The <B
CLASS="COMMAND"
>eqn</B
> equation processing utility
	      is likewise part of <B
CLASS="COMMAND"
>groff</B
>, and
	      its function is to convert equation markup into
	      <B
CLASS="COMMAND"
>groff</B
> commands.</P
></DD
><DT
><B
CLASS="COMMAND"
>lex</B
>, <B
CLASS="COMMAND"
>yacc</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>lex</B
> lexical analyzer produces
	      programs for pattern matching. This has been replaced
	      by the nonproprietary <B
CLASS="COMMAND"
>flex</B
> on Linux
	      systems.</P
><P
>The <B
CLASS="COMMAND"
>yacc</B
> utility creates a
	      parser based on a set of specifications. This has been
	      replaced by the nonproprietary <B
CLASS="COMMAND"
>bison</B
>
	      on Linux systems.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="timedate.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="filearchiv.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Time / Date Commands</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="external.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>File and Archiving Commands</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
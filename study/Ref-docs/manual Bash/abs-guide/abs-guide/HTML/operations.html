<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Operations and Related Topics</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.64
"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="Basics"
HREF="part2.html"><LINK
REL="PREVIOUS"
TITLE="Testing Your Knowledge of Tests"
HREF="testtest.html"><LINK
REL="NEXT"
TITLE="Numerical Constants"
HREF="numerical-constants.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-family: sans-serif;"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="testtest.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="numerical-constants.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="OPERATIONS"
>Chapter 8. Operations and Related Topics</A
></H1
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="OPS"
>8.1. Operators</A
></H1
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="ASNOP1"
></A
>assignment</B
></P
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>variable assignment</I
></TT
></DT
><DD
><P
>Initializing or changing the value of a variable</P
></DD
><DT
>=</DT
><DD
><P
>All-purpose assignment operator, which works for both
	    arithmetic and string assignments.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;var=27
   2&nbsp;category=minerals  # No spaces allowed after the "=".</PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Do not confuse the <SPAN
CLASS="QUOTE"
>"="</SPAN
> assignment
	      operator with the <A
HREF="comparison-ops.html#EQUALSIGNREF"
>=</A
> test
	      operator.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#    = as a test operator
   2&nbsp;
   3&nbsp;if [ "$string1" = "$string2" ]
   4&nbsp;# if [ "X$string1" = "X$string2" ] is safer,
   5&nbsp;# to prevent an error message should one of the variables be empty.
   6&nbsp;# (The prepended "X" characters cancel out.) 
   7&nbsp;then
   8&nbsp;   command
   9&nbsp;fi</PRE
></TD
></TR
></TABLE
>
	    </P
></TD
></TR
></TABLE
></DIV
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="AROPS1"
></A
>arithmetic operators</B
></P
><DL
><DT
><SPAN
CLASS="TOKEN"
>+</SPAN
></DT
><DD
><P
>plus</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>-</SPAN
></DT
><DD
><P
>minus</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>*</SPAN
></DT
><DD
><P
>multiplication</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>/</SPAN
></DT
><DD
><P
>division</P
></DD
><DT
><A
NAME="EXPONENTIATIONREF"
></A
><SPAN
CLASS="TOKEN"
>**</SPAN
></DT
><DD
><P
>exponentiation
	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# Bash, version 2.02, introduced the "**" exponentiation operator.
   2&nbsp;
   3&nbsp;let "z=5**3"
   4&nbsp;echo "z = $z"   # z = 125</PRE
></TD
></TR
></TABLE
>
          </P
></DD
><DT
><A
NAME="MODULOREF"
></A
><SPAN
CLASS="TOKEN"
>%</SPAN
></DT
><DD
><P
>modulo, or mod (returns the remainder of an integer
	    division operation)</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo `expr 5 % 3`</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>2</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><P
>This operator finds use in, among other things,
	    generating numbers within a specific range (see <A
HREF="randomvar.html#EX21"
>Example 9-20</A
> and <A
HREF="randomvar.html#RANDOMTEST"
>Example 9-21</A
>) and
	    formatting program output (see <A
HREF="arrays.html#QFUNCTION"
>Example 26-7</A
> and
	    <A
HREF="contributed-scripts.html#COLLATZ"
>Example A-7</A
>). It can even be used to generate
	    prime numbers, (see <A
HREF="contributed-scripts.html#PRIMES"
>Example A-12</A
>). Modulo turns
	    up surprisingly often in various numerical recipes.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="GCD"
></A
><P
><B
>Example 8-1. Greatest common divisor</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# gcd.sh: greatest common divisor
   3&nbsp;#         Uses Euclid's algorithm
   4&nbsp;
   5&nbsp;#  The "greatest common divisor" (gcd) of two integers
   6&nbsp;#+ is the largest integer that will divide both, with no remainder.
   7&nbsp;
   8&nbsp;#  Euclid's algorithm uses successive division.
   9&nbsp;#  In each pass,
  10&nbsp;#+ dividend &#60;---  divisor
  11&nbsp;#+ divisor  &#60;---  remainder
  12&nbsp;#+ until remainder = 0.
  13&nbsp;#+ The gcd = dividend, on the final pass.
  14&nbsp;#
  15&nbsp;#  For an excellent discussion of Euclid's algorithm, see
  16&nbsp;#  Jim Loy's site, http://www.jimloy.com/number/euclids.htm.
  17&nbsp;
  18&nbsp;
  19&nbsp;# ------------------------------------------------------
  20&nbsp;# Argument check
  21&nbsp;ARGS=2
  22&nbsp;E_BADARGS=65
  23&nbsp;
  24&nbsp;if [ $# -ne "$ARGS" ]
  25&nbsp;then
  26&nbsp;  echo "Usage: `basename $0` first-number second-number"
  27&nbsp;  exit $E_BADARGS
  28&nbsp;fi
  29&nbsp;# ------------------------------------------------------
  30&nbsp;
  31&nbsp;
  32&nbsp;gcd ()
  33&nbsp;{
  34&nbsp;
  35&nbsp;  dividend=$1                    #  It does not matter
  36&nbsp;  divisor=$2                     #+ which of the two is larger.
  37&nbsp;                                 #  Why?
  38&nbsp;
  39&nbsp;  remainder=1                    #  If uninitialized variable used in loop,
  40&nbsp;                                 #+ it results in an error message
  41&nbsp;				 #+ on first pass through loop.
  42&nbsp;
  43&nbsp;  until [ "$remainder" -eq 0 ]
  44&nbsp;  do
  45&nbsp;    let "remainder = $dividend % $divisor"
  46&nbsp;    dividend=$divisor            # Now repeat with 2 smallest numbers.
  47&nbsp;    divisor=$remainder
  48&nbsp;  done                           # Euclid's algorithm
  49&nbsp;
  50&nbsp;}                                # Last $dividend is the gcd.
  51&nbsp;
  52&nbsp;
  53&nbsp;gcd $1 $2
  54&nbsp;
  55&nbsp;echo; echo "GCD of $1 and $2 = $dividend"; echo
  56&nbsp;
  57&nbsp;
  58&nbsp;# Exercise :
  59&nbsp;# --------
  60&nbsp;#  Check command-line arguments to make sure they are integers,
  61&nbsp;#+ and exit the script with an appropriate error message if not.
  62&nbsp;
  63&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>+=</SPAN
></DT
><DD
><P
><SPAN
CLASS="QUOTE"
>"plus-equal"</SPAN
> (increment variable by a constant)</P
><P
><TT
CLASS="USERINPUT"
><B
>let "var += 5"</B
></TT
> results in
	      <TT
CLASS="VARNAME"
>var</TT
> being incremented by
	      <TT
CLASS="LITERAL"
>5</TT
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>-=</SPAN
></DT
><DD
><P
><SPAN
CLASS="QUOTE"
>"minus-equal"</SPAN
> (decrement variable by a constant)</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>*=</SPAN
></DT
><DD
><P
><SPAN
CLASS="QUOTE"
>"times-equal"</SPAN
> (multiply variable by a constant)</P
><P
><TT
CLASS="USERINPUT"
><B
>let "var *= 4"</B
></TT
> results in <TT
CLASS="VARNAME"
>var</TT
>
	    being multiplied by <TT
CLASS="LITERAL"
>4</TT
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>/=</SPAN
></DT
><DD
><P
><SPAN
CLASS="QUOTE"
>"slash-equal"</SPAN
> (divide variable by a constant)</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>%=</SPAN
></DT
><DD
><P
><SPAN
CLASS="QUOTE"
>"mod-equal"</SPAN
> (remainder of dividing variable by a constant)</P
><P
><I
CLASS="EMPHASIS"
>Arithmetic operators often occur in an
        <A
HREF="moreadv.html#EXPRREF"
>expr</A
> or <A
HREF="internal.html#LETREF"
>let</A
> expression.</I
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ARITHOPS"
></A
><P
><B
>Example 8-2. Using Arithmetic Operations</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# Counting to 6 in 5 different ways.
   3&nbsp;
   4&nbsp;n=1; echo -n "$n "
   5&nbsp;
   6&nbsp;let "n = $n + 1"   # let "n = n + 1"   also works.
   7&nbsp;echo -n "$n "
   8&nbsp;
   9&nbsp;: $((n = $n + 1))
  10&nbsp;#  ":" necessary because otherwise Bash attempts
  11&nbsp;#+ to interpret "$((n = $n + 1))" as a command.
  12&nbsp;echo -n "$n "
  13&nbsp;
  14&nbsp;n=$(($n + 1))
  15&nbsp;echo -n "$n "
  16&nbsp;
  17&nbsp;: $[ n = $n + 1 ]
  18&nbsp;#  ":" necessary because otherwise Bash attempts
  19&nbsp;#+ to interpret "$[ n = $n + 1 ]" as a command.
  20&nbsp;# Works even if "n" was initialized as a string.
  21&nbsp;echo -n "$n "
  22&nbsp;
  23&nbsp;n=$[ $n + 1 ]
  24&nbsp;#  Works even if "n" was initialized as a string.
  25&nbsp;#* Avoid this type of construct, since it is obsolete and nonportable.
  26&nbsp;echo -n "$n "; echo
  27&nbsp;
  28&nbsp;# Thanks, Stephane Chazelas.
  29&nbsp;
  30&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
></DL
></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Integer variables in Bash are actually signed
	<I
CLASS="EMPHASIS"
>long</I
> (32-bit) integers, in the range of
	-2147483648 to 2147483647. An operation that takes a variable
	outside these limits will give an erroneous result.
	  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;a=2147483646
   2&nbsp;echo "a = $a"      # a = 2147483646
   3&nbsp;let "a+=1"         # Increment "a".
   4&nbsp;echo "a = $a"      # a = 2147483647
   5&nbsp;let "a+=1"         # increment "a" again, past the limit.
   6&nbsp;echo "a = $a"      # a = -2147483648
   7&nbsp;                   #      ERROR (out of range)</PRE
></TD
></TR
></TABLE
>
	</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Bash does not understand floating point arithmetic. It
        treats numbers containing a decimal point as strings.
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;a=1.5
   2&nbsp;
   3&nbsp;let "b = $a + 1.3"  # Error.
   4&nbsp;# t2.sh: let: b = 1.5 + 1.3: syntax error in expression (error token is ".5 + 1.3")
   5&nbsp;
   6&nbsp;echo "b = $b"       # b=1</PRE
></TD
></TR
></TABLE
>

        Use <A
HREF="mathc.html#BCREF"
>bc</A
> in scripts that that need floating
	point calculations or math library functions.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="FORMALPARA"
><P
><B
>bitwise operators. </B
>The bitwise operators seldom make an appearance in shell scripts.
	Their chief use seems to be manipulating and testing values
	read from ports or sockets. <SPAN
CLASS="QUOTE"
>"Bit flipping"</SPAN
> is more
	relevant to compiled languages, such as C and C++, which run
	fast enough to permit its use on the fly.</P
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="BITWSOPS1"
></A
>bitwise operators</B
></P
><DL
><DT
><SPAN
CLASS="TOKEN"
>&#60;&#60;</SPAN
></DT
><DD
><P
>bitwise left shift (multiplies by <TT
CLASS="LITERAL"
>2</TT
>
	      for each shift position)</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#60;&#60;=</SPAN
></DT
><DD
><P
><SPAN
CLASS="QUOTE"
>"left-shift-equal"</SPAN
></P
><P
><TT
CLASS="USERINPUT"
><B
>let "var &#60;&#60;= 2"</B
></TT
> results in <TT
CLASS="VARNAME"
>var</TT
>
	    left-shifted <TT
CLASS="LITERAL"
>2</TT
> bits (multiplied by <TT
CLASS="LITERAL"
>4</TT
>)</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#62;&#62;</SPAN
></DT
><DD
><P
>bitwise right shift (divides by <TT
CLASS="LITERAL"
>2</TT
>
	      for each shift position)</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#62;&#62;=</SPAN
></DT
><DD
><P
><SPAN
CLASS="QUOTE"
>"right-shift-equal"</SPAN
> (inverse of <SPAN
CLASS="TOKEN"
>&#60;&#60;=</SPAN
>)</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#38;</SPAN
></DT
><DD
><P
>bitwise and</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#38;=</SPAN
></DT
><DD
><P
><SPAN
CLASS="QUOTE"
>"bitwise and-equal"</SPAN
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>|</SPAN
></DT
><DD
><P
>bitwise OR</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>|=</SPAN
></DT
><DD
><P
><SPAN
CLASS="QUOTE"
>"bitwise OR-equal"</SPAN
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>~</SPAN
></DT
><DD
><P
>bitwise negate</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>!</SPAN
></DT
><DD
><P
>bitwise NOT</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>^</SPAN
></DT
><DD
><P
>bitwise XOR</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>^=</SPAN
></DT
><DD
><P
><SPAN
CLASS="QUOTE"
>"bitwise XOR-equal"</SPAN
></P
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="LOGOPS1"
></A
>logical operators</B
></P
><DL
><DT
><SPAN
CLASS="TOKEN"
>&#38;&#38;</SPAN
></DT
><DD
><P
>and (logical)</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;if [ $condition1 ] &#38;&#38; [ $condition2 ]
   2&nbsp;# Same as:  if [ $condition1 -a $condition2 ]
   3&nbsp;# Returns true if both condition1 and condition2 hold true...
   4&nbsp;
   5&nbsp;if [[ $condition1 &#38;&#38; $condition2 ]]    # Also works.
   6&nbsp;# Note that &#38;&#38; operator not permitted within [ ... ] construct.</PRE
></TD
></TR
></TABLE
></P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><SPAN
CLASS="TOKEN"
>&#38;&#38;</SPAN
> may also, depending on context, be
	    used in an <A
HREF="list-cons.html#LISTCONSREF"
>and list</A
>
	    to concatenate commands.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>||</SPAN
></DT
><DD
><P
>or  (logical)</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;if [ $condition1 ] || [ $condition2 ]
   2&nbsp;# Same as:  if [ $condition1 -o $condition2 ]
   3&nbsp;# Returns true if either condition1 or condition2 holds true...
   4&nbsp;
   5&nbsp;if [[ $condition1 || $condition2 ]]    # Also works.
   6&nbsp;# Note that || operator not permitted within [ ... ] construct.</PRE
></TD
></TR
></TABLE
></P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Bash tests the <A
HREF="exit-status.html#EXITSTATUSREF"
>exit
	    status</A
> of each statement linked with a logical
	    operator.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ANDOR"
></A
><P
><B
>Example 8-3. Compound Condition Tests Using &#38;&#38; and ||</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;a=24
   4&nbsp;b=47
   5&nbsp;
   6&nbsp;if [ "$a" -eq 24 ] &#38;&#38; [ "$b" -eq 47 ]
   7&nbsp;then
   8&nbsp;  echo "Test #1 succeeds."
   9&nbsp;else
  10&nbsp;  echo "Test #1 fails."
  11&nbsp;fi
  12&nbsp;
  13&nbsp;# ERROR:   if [ "$a" -eq 24 &#38;&#38; "$b" -eq 47 ]
  14&nbsp;#          attempts to execute  ' [ "$a" -eq 24 '
  15&nbsp;#          and fails to finding matching ']'.
  16&nbsp;#
  17&nbsp;#    if [[ $a -eq 24 &#38;&#38; $b -eq 24 ]]   works
  18&nbsp;#    (The "&#38;&#38;" has a different meaning in line 17 than in line 6.)
  19&nbsp;#    Thanks, Stephane Chazelas.
  20&nbsp;
  21&nbsp;
  22&nbsp;if [ "$a" -eq 98 ] || [ "$b" -eq 47 ]
  23&nbsp;then
  24&nbsp;  echo "Test #2 succeeds."
  25&nbsp;else
  26&nbsp;  echo "Test #2 fails."
  27&nbsp;fi
  28&nbsp;
  29&nbsp;
  30&nbsp;#  The -a and -o options provide
  31&nbsp;#+ an alternative compound condition test.
  32&nbsp;#  Thanks to Patrick Callahan for pointing this out.
  33&nbsp;
  34&nbsp;
  35&nbsp;if [ "$a" -eq 24 -a "$b" -eq 47 ]
  36&nbsp;then
  37&nbsp;  echo "Test #3 succeeds."
  38&nbsp;else
  39&nbsp;  echo "Test #3 fails."
  40&nbsp;fi
  41&nbsp;
  42&nbsp;
  43&nbsp;if [ "$a" -eq 98 -o "$b" -eq 47 ]
  44&nbsp;then
  45&nbsp;  echo "Test #4 succeeds."
  46&nbsp;else
  47&nbsp;  echo "Test #4 fails."
  48&nbsp;fi
  49&nbsp;
  50&nbsp;
  51&nbsp;a=rhino
  52&nbsp;b=crocodile
  53&nbsp;if [ "$a" = rhino ] &#38;&#38; [ "$b" = crocodile ]
  54&nbsp;then
  55&nbsp;  echo "Test #5 succeeds."
  56&nbsp;else
  57&nbsp;  echo "Test #5 fails."
  58&nbsp;fi
  59&nbsp;
  60&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>The <SPAN
CLASS="TOKEN"
>&#38;&#38;</SPAN
> and <SPAN
CLASS="TOKEN"
>||</SPAN
> operators also
	      find use in an arithmetic context.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $(( 1 &#38;&#38; 2 )) $((3 &#38;&#38; 0)) $((4 || 0)) $((0 || 0))</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>1 0 1 0</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="MISCOP1"
></A
>miscellaneous operators</B
></P
><DL
><DT
><A
NAME="COMMAOP"
></A
><SPAN
CLASS="TOKEN"
>,</SPAN
></DT
><DD
><P
>comma operator</P
><P
>The <B
CLASS="COMMAND"
>comma operator</B
> chains together
	      two or more arithmetic operations. All the operations are
	      evaluated (with possible <I
CLASS="EMPHASIS"
>side effects</I
>,
	      but only the last operation is returned.</P
><P
>	     <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;let "t1 = ((5 + 3, 7 - 1, 15 - 4))"
   2&nbsp;echo "t1 = $t1"               # t1 = 11
   3&nbsp;
   4&nbsp;let "t2 = ((a = 9, 15 / 3))"  # Set "a" and calculate "t2".
   5&nbsp;echo "t2 = $t2    a = $a"     # t2 = 5    a = 9</PRE
></TD
></TR
></TABLE
>
	     </P
><P
>The comma operator finds use mainly in <A
HREF="loops.html#FORLOOPREF1"
>for loops</A
>. See <A
HREF="loops.html#FORLOOPC"
>Example 10-11</A
>.</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="testtest.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="numerical-constants.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Testing Your Knowledge of Tests</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="part2.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Numerical Constants</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Internal Commands and Builtins</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.64
"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="Beyond the Basics"
HREF="part3.html"><LINK
REL="PREVIOUS"
TITLE="Testing and Branching"
HREF="testbranch.html"><LINK
REL="NEXT"
TITLE="External Filters, Programs and Commands"
HREF="external.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-family: sans-serif;"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="testbranch.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="external.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="INTERNAL"
>Chapter 11. Internal Commands and Builtins</A
></H1
><P
><A
NAME="BUILTINREF"
></A
>A <I
CLASS="FIRSTTERM"
>builtin</I
>
	is a <B
CLASS="COMMAND"
>command</B
> contained within the Bash tool
	set, literally <I
CLASS="EMPHASIS"
>built in</I
>. A builtin may
	be a synonym to a system command of the same name, but Bash
	reimplements it internally.
          
	  <A
NAME="AEN4919"
HREF="#FTN.AEN4919"
>[1]</A
>

	For example, the Bash <B
CLASS="COMMAND"
>echo</B
> command is not the
	same as <TT
CLASS="FILENAME"
>/bin/echo</TT
>, although their behavior
	is almost identical.</P
><P
><A
NAME="KEYWORDREF"
></A
>A <I
CLASS="FIRSTTERM"
>keyword</I
>
	is a <I
CLASS="EMPHASIS"
>reserved</I
> word, token or
	operator. Keywords have a special meaning to the shell,
	and indeed are the building blocks of the shell's
	syntax. As examples, <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>for</SPAN
>"</SPAN
>,
	<SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>while</SPAN
>"</SPAN
>, <SPAN
CLASS="QUOTE"
>"do"</SPAN
>, and
	<SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>!</SPAN
>"</SPAN
> are keywords. Similar to a
	<I
CLASS="EMPHASIS"
>builtin</I
>, a keyword is hard-coded into Bash,
	but unlike a builtin, a keyword is not by itself a command,
	but part of a larger command structure.

	   <A
NAME="AEN4936"
HREF="#FTN.AEN4936"
>[2]</A
>

	</P
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="INTIO1"
></A
>I/O</B
></P
><DL
><DT
><A
NAME="ECHOREF"
></A
><B
CLASS="COMMAND"
>echo</B
></DT
><DD
><P
>prints (to <TT
CLASS="FILENAME"
>stdout</TT
>) an expression
	      or variable (see <A
HREF="variables.html#EX9"
>Example 5-1</A
>). 
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo Hello
   2&nbsp;echo $a</PRE
></TD
></TR
></TABLE
></P
><P
>An <B
CLASS="COMMAND"
>echo</B
> requires the
	      <TT
CLASS="OPTION"
>-e</TT
> option to print escaped characters. See
	      <A
HREF="quoting.html#ESCAPED"
>Example 6-2</A
>.</P
><P
>Normally, each <B
CLASS="COMMAND"
>echo</B
> command prints
	      a terminal newline, but the <TT
CLASS="OPTION"
>-n</TT
> option
	      suppresses this.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An <B
CLASS="COMMAND"
>echo</B
> can be used to feed a
	      sequence of commands down a pipe.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;if echo "$VAR" | grep -q txt   # if [[ $VAR = *txt* ]]
   2&nbsp;then
   3&nbsp;  echo "$VAR contains the substring sequence \"txt\""
   4&nbsp;fi</PRE
></TD
></TR
></TABLE
></P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An <B
CLASS="COMMAND"
>echo</B
>, in combination with
	      <A
HREF="commandsub.html#COMMANDSUBREF"
>command substitution</A
>
	      can set a variable.</P
><P
><TT
CLASS="USERINPUT"
><B
>a=`echo
	      "HELLO" | tr A-Z a-z`</B
></TT
></P
><P
>See also <A
HREF="textproc.html#LOWERCASE"
>Example 12-15</A
>, <A
HREF="moreadv.html#EX57"
>Example 12-2</A
>, <A
HREF="mathc.html#MONTHLYPMT"
>Example 12-30</A
>, and <A
HREF="mathc.html#BASE"
>Example 12-31</A
>.</P
></TD
></TR
></TABLE
></DIV
><P
>Be aware that <B
CLASS="COMMAND"
>echo `command`</B
>
	      deletes any linefeeds that the output
	      of <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>
	      generates.</P
><P
>The <A
HREF="variables2.html#IFSREF"
>$IFS</A
> (internal field
	      separator) variable normally contains
	      <SPAN
CLASS="TOKEN"
>\n</SPAN
> (linefeed) as one of its set of
	      <A
HREF="special-chars.html#WHITESPACEREF"
>whitespace</A
>
	      characters. Bash therefore splits the output of
	      <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
> at linefeeds
	      into arguments to <B
CLASS="COMMAND"
>echo</B
>.  Then
	      <B
CLASS="COMMAND"
>echo</B
> outputs these arguments,
	      separated by spaces.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ls -l /usr/share/apps/kjezz/sounds</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>-rw-r--r--    1 root     root         1407 Nov  7  2000 reflect.au
 -rw-r--r--    1 root     root          362 Nov  7  2000 seconds.au</TT
>
 
 
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo `ls -l /usr/share/apps/kjezz/sounds`</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>total 40 -rw-r--r-- 1 root root 716 Nov 7 2000 reflect.au -rw-r--r-- 1 root root 362 Nov 7 2000 seconds.au</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This command is a shell builtin, and not the same as
	      <TT
CLASS="FILENAME"
>/bin/echo</TT
>, although its behavior is
	      similar.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>type -a echo</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>echo is a shell builtin
 echo is /bin/echo</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	  </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="PRINTFREF"
></A
><B
CLASS="COMMAND"
>printf</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>printf</B
>, formatted print, command is an
	      enhanced <B
CLASS="COMMAND"
>echo</B
>.  It is a limited variant of the
	      C language <TT
CLASS="FUNCTION"
>printf</TT
>, and the syntax is somewhat 
	      different.</P
><P
><B
CLASS="COMMAND"
>printf</B
>   <TT
CLASS="REPLACEABLE"
><I
>format-string</I
></TT
>...   <TT
CLASS="REPLACEABLE"
><I
>parameter</I
></TT
>... </P
><P
>This is the Bash builtin version
	      of the <TT
CLASS="FILENAME"
>/bin/printf</TT
> or
	      <TT
CLASS="FILENAME"
>/usr/bin/printf</TT
> command. See the
	      <B
CLASS="COMMAND"
>printf</B
> manpage (of the system command)
	      for in-depth coverage.</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Older versions of Bash may not support
	      <B
CLASS="COMMAND"
>printf</B
>.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX47"
></A
><P
><B
>Example 11-1. <B
CLASS="COMMAND"
>printf</B
> in action</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# printf demo
   3&nbsp;
   4&nbsp;PI=3.14159265358979
   5&nbsp;DecimalConstant=31373
   6&nbsp;Message1="Greetings,"
   7&nbsp;Message2="Earthling."
   8&nbsp;
   9&nbsp;echo
  10&nbsp;
  11&nbsp;printf "Pi to 2 decimal places = %1.2f" $PI
  12&nbsp;echo
  13&nbsp;printf "Pi to 9 decimal places = %1.9f" $PI  # It even rounds off correctly.
  14&nbsp;
  15&nbsp;printf "\n"                                  # Prints a line feed,
  16&nbsp;                                             # equivalent to 'echo'.
  17&nbsp;
  18&nbsp;printf "Constant = \t%d\n" $DecimalConstant  # Inserts tab (\t)
  19&nbsp;
  20&nbsp;printf "%s %s \n" $Message1 $Message2
  21&nbsp;
  22&nbsp;echo
  23&nbsp;
  24&nbsp;# ==========================================#
  25&nbsp;# Simulation of C function, 'sprintf'.
  26&nbsp;# Loading a variable with a formatted string.
  27&nbsp;
  28&nbsp;echo 
  29&nbsp;
  30&nbsp;Pi12=$(printf "%1.12f" $PI)
  31&nbsp;echo "Pi to 12 decimal places = $Pi12"
  32&nbsp;
  33&nbsp;Msg=`printf "%s %s \n" $Message1 $Message2`
  34&nbsp;echo $Msg; echo $Msg
  35&nbsp;
  36&nbsp;# As it happens, the 'sprintf' function can now be accessed
  37&nbsp;# as a loadable module to Bash, but this is not portable.
  38&nbsp;
  39&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Formatting error messages is a useful application of
	      <B
CLASS="COMMAND"
>printf</B
></P
><P
>	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;E_BADDIR=65
   2&nbsp;
   3&nbsp;var=nonexistent_directory
   4&nbsp;
   5&nbsp;error()
   6&nbsp;{
   7&nbsp;  printf "$@" &#62;&#38;2
   8&nbsp;  # Formats positional params passed, and sents them to stderr.
   9&nbsp;  echo
  10&nbsp;  exit $E_BADDIR
  11&nbsp;}
  12&nbsp;
  13&nbsp;cd $var || error $"Can't cd to %s." "$var"
  14&nbsp;
  15&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
>
            </P
></DD
><DT
><A
NAME="READREF"
></A
><B
CLASS="COMMAND"
>read</B
></DT
><DD
><P
><SPAN
CLASS="QUOTE"
>"Reads"</SPAN
> the value
	    of a variable from <TT
CLASS="FILENAME"
>stdin</TT
>, that
	    is, interactively fetches input from the keyboard. The
	    <TT
CLASS="OPTION"
>-a</TT
> option lets <B
CLASS="COMMAND"
>read</B
>
	    get array variables (see <A
HREF="arrays.html#EX67"
>Example 26-2</A
>).</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX36"
></A
><P
><B
>Example 11-2. Variable assignment, using <B
CLASS="COMMAND"
>read</B
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;echo -n "Enter the value of variable 'var1': "
   4&nbsp;# The -n option to echo suppresses newline.
   5&nbsp;
   6&nbsp;read var1
   7&nbsp;# Note no '$' in front of var1, since it is being set.
   8&nbsp;
   9&nbsp;echo "var1 = $var1"
  10&nbsp;
  11&nbsp;
  12&nbsp;echo
  13&nbsp;
  14&nbsp;# A single 'read' statement can set multiple variables.
  15&nbsp;echo -n "Enter the values of variables 'var2' and 'var3' (separated by a space or tab): "
  16&nbsp;read var2 var3
  17&nbsp;echo "var2 = $var2      var3 = $var3"
  18&nbsp;# If you input only one value, the other variable(s) will remain unset (null).
  19&nbsp;
  20&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Normally, inputting a <TT
CLASS="USERINPUT"
><B
>\</B
></TT
>
	      suppresses a newline during input to
	      a <B
CLASS="COMMAND"
>read</B
>. The <TT
CLASS="OPTION"
>-r</TT
>
	      option causes an inputted <TT
CLASS="USERINPUT"
><B
>\</B
></TT
> to be
	      interpreted literally.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="READR"
></A
><P
><B
>Example 11-3. Multi-line input to <B
CLASS="COMMAND"
>read</B
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;echo
   4&nbsp;
   5&nbsp;echo "Enter a string terminated by a \\, then press &#60;ENTER&#62;."
   6&nbsp;echo "Then, enter a second string, and again press &#60;ENTER&#62;."
   7&nbsp;read var1     # The "\" suppresses the newline, when reading "var1".
   8&nbsp;              #     first line \
   9&nbsp;              #     second line
  10&nbsp;
  11&nbsp;echo "var1 = $var1"
  12&nbsp;#     var1 = first line second line
  13&nbsp;
  14&nbsp;# For each line terminated by a "\",
  15&nbsp;# you get a prompt on the next line to continue feeding characters into var1.
  16&nbsp;
  17&nbsp;echo; echo
  18&nbsp;
  19&nbsp;echo "Enter another string terminated by a \\ , then press &#60;ENTER&#62;."
  20&nbsp;read -r var2  # The -r option causes the "\" to be read literally.
  21&nbsp;              #     first line \
  22&nbsp;
  23&nbsp;echo "var2 = $var2"
  24&nbsp;#     var2 = first line \
  25&nbsp;
  26&nbsp;# Data entry terminates with the first &#60;ENTER&#62;.
  27&nbsp;
  28&nbsp;echo 
  29&nbsp;
  30&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>The <B
CLASS="COMMAND"
>read</B
> command has some interesting
	      options that permit echoing a prompt and even reading keystrokes
	      without hitting <B
CLASS="KEYCAP"
>ENTER</B
>.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# Read a keypress without hitting ENTER.
   2&nbsp;
   3&nbsp;read -s -n1 -p "Hit a key " keypress
   4&nbsp;echo; echo "Keypress was "\"$keypress\""."
   5&nbsp;
   6&nbsp;# -s option means do not echo input.
   7&nbsp;# -n N option means accept only N characters of input.
   8&nbsp;# -p option means echo the following prompt before reading input.
   9&nbsp;
  10&nbsp;# Using these options is tricky, since they need to be in the correct order.</PRE
></TD
></TR
></TABLE
></P
><P
>The <B
CLASS="COMMAND"
>read</B
> command may also
	      <SPAN
CLASS="QUOTE"
>"read"</SPAN
> its variable value from a file
	      <A
HREF="io-redirection.html#IOREDIRREF"
>redirected</A
> to
	      <TT
CLASS="FILENAME"
>stdin</TT
>.  If the file contains
	      more than one line, only the first line is assigned
	      to the variable. If <B
CLASS="COMMAND"
>read</B
>
	      has more than one parameter, then each of
	      these variables gets assigned a successive <A
HREF="special-chars.html#WHITESPACEREF"
>whitespace-delineated</A
>
	      string. Caution!</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="READREDIR"
></A
><P
><B
>Example 11-4. Using <B
CLASS="COMMAND"
>read</B
> with
	        <A
HREF="io-redirection.html#IOREDIRREF"
>file redirection</A
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;read var1 &#60;data-file
   4&nbsp;echo "var1 = $var1"
   5&nbsp;# var1 set to the entire first line of the input file "data-file"
   6&nbsp;
   7&nbsp;read var2 var3 &#60;data-file
   8&nbsp;echo "var2 = $var2   var3 = $var3"
   9&nbsp;# Note non-intuitive behavior of "read" here.
  10&nbsp;# 1) Rewinds back to the beginning of input file.
  11&nbsp;# 2) Each variable is now set to a corresponding string,
  12&nbsp;#    separated by whitespace, rather than to an entire line of text.
  13&nbsp;# 3) The final variable gets the remainder of the line.
  14&nbsp;# 4) If there are more variables to be set than whitespace-terminated strings
  15&nbsp;#    on the first line of the file, then the excess variables remain empty.
  16&nbsp;
  17&nbsp;echo "------------------------------------------------"
  18&nbsp;
  19&nbsp;# How to resolve the above problem with a loop:
  20&nbsp;while read line
  21&nbsp;do
  22&nbsp;  echo "$line"
  23&nbsp;done &#60;data-file
  24&nbsp;# Thanks, Heiner Steven for pointing this out.
  25&nbsp;
  26&nbsp;echo "------------------------------------------------"
  27&nbsp;
  28&nbsp;# Use $IFS (Internal File Separator variable) to split a line of input to
  29&nbsp;# "read", if you do not want the default to be whitespace.
  30&nbsp;
  31&nbsp;echo "List of all users:"
  32&nbsp;OIFS=$IFS; IFS=:       # /etc/passwd uses ":" for field separator.
  33&nbsp;while read name passwd uid gid fullname ignore
  34&nbsp;do
  35&nbsp;  echo "$name ($fullname)"
  36&nbsp;done &#60;/etc/passwd   # I/O redirection.
  37&nbsp;IFS=$OIFS              # Restore originial $IFS.
  38&nbsp;# This code snippet also by Heiner Steven.
  39&nbsp;
  40&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="INTFILESYSTEM1"
></A
>Filesystem</B
></P
><DL
><DT
><B
CLASS="COMMAND"
>cd</B
></DT
><DD
><P
>The familiar <B
CLASS="COMMAND"
>cd</B
> change directory
	      command finds use in scripts where execution of a command
	      requires being in a specified directory.</P
><P
>  
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;(cd /source/directory &#38;&#38; tar cf - . ) | (cd /dest/directory &#38;&#38; tar xpvf -)</PRE
></TD
></TR
></TABLE
>
	      [from the <A
HREF="special-chars.html#COXEX"
>previously cited</A
>
	      example by Alan Cox]</P
><P
>The <TT
CLASS="OPTION"
>-P</TT
> (physical) option to
	      <B
CLASS="COMMAND"
>cd</B
> causes it to ignore symbolic
	      links.</P
><P
><B
CLASS="COMMAND"
>cd -</B
> changes to <A
HREF="variables2.html#OLDPWD"
>$OLDPWD</A
>, the previous working
	    directory.</P
></DD
><DT
><A
NAME="PWD2REF"
></A
><B
CLASS="COMMAND"
>pwd</B
></DT
><DD
><P
>Print Working Directory. This gives the user's
	      (or script's) current directory (see <A
HREF="internal.html#EX37"
>Example 11-5</A
>). The effect is identical to
	      reading the value of the builtin variable <A
HREF="variables2.html#PWDREF"
>$PWD</A
>.</P
></DD
><DT
><A
NAME="DIRSD"
></A
><B
CLASS="COMMAND"
>pushd</B
>, <B
CLASS="COMMAND"
>popd</B
>, <B
CLASS="COMMAND"
>dirs</B
></DT
><DD
><P
>This command set is a mechanism for bookmarking working directories,
	      a means of moving back and forth through directories in an orderly
	      manner.  A pushdown stack is used to keep track of directory names.
	      Options allow various manipulations of the directory stack.</P
><P
><A
NAME="PUSHDREF"
></A
><TT
CLASS="USERINPUT"
><B
>pushd
	      dir-name</B
></TT
> pushes the path
	      <TT
CLASS="REPLACEABLE"
><I
>dir-name</I
></TT
> onto the directory
	      stack and simultaneously changes the current working
	      directory to <TT
CLASS="REPLACEABLE"
><I
>dir-name</I
></TT
></P
><P
><A
NAME="POPDREF"
></A
><B
CLASS="COMMAND"
>popd</B
> removes (pops) the top directory path
	      name off the directory stack and simultaneously changes the
	      current working directory to that directory popped from the stack.
	      </P
><P
><B
CLASS="COMMAND"
>dirs</B
> lists the contents of the directory
	      stack (counterpart to <A
HREF="variables2.html#DIRSTACKREF"
>$DIRSTACK</A
>) A successful
	      <B
CLASS="COMMAND"
>pushd</B
> or <B
CLASS="COMMAND"
>popd</B
> will
	      automatically invoke <B
CLASS="COMMAND"
>dirs</B
>.</P
><P
>Scripts that require various changes to the current
	      working directory without hard-coding the directory name
	      changes can make good use of these commands. Note that
	      the implicit <TT
CLASS="VARNAME"
>$DIRSTACK</TT
> array variable,
	      accessible from within a script, holds the contents of
	      the directory stack.
	    </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX37"
></A
><P
><B
>Example 11-5. Changing the current working directory   </B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;dir1=/usr/local
   4&nbsp;dir2=/var/spool
   5&nbsp;
   6&nbsp;pushd $dir1
   7&nbsp;# Will do an automatic 'dirs' (list directory stack to stdout).
   8&nbsp;echo "Now in directory `pwd`." # Uses back-quoted 'pwd'.
   9&nbsp;
  10&nbsp;# Now, do some stuff in directory 'dir1'.
  11&nbsp;pushd $dir2
  12&nbsp;echo "Now in directory `pwd`."
  13&nbsp;
  14&nbsp;# Now, do some stuff in directory 'dir2'.
  15&nbsp;echo "The top entry in the DIRSTACK array is $DIRSTACK."
  16&nbsp;popd
  17&nbsp;echo "Now back in directory `pwd`."
  18&nbsp;
  19&nbsp;# Now, do some more stuff in directory 'dir1'.
  20&nbsp;popd
  21&nbsp;echo "Now back in original working directory `pwd`."
  22&nbsp;
  23&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="INTVAR1"
></A
>Variables</B
></P
><DL
><DT
><A
NAME="LETREF"
></A
><B
CLASS="COMMAND"
>let</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>let</B
> command carries out arithmetic
	      operations on variables. In many cases, it functions as a less
	      complex version of <A
HREF="moreadv.html#EXPRREF"
>expr</A
>.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX46"
></A
><P
><B
>Example 11-6. Letting <B
CLASS="COMMAND"
>let</B
> do some arithmetic.</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;echo
   4&nbsp;
   5&nbsp;let a=11          # Same as 'a=11'
   6&nbsp;let a=a+5         # Equivalent to  let "a = a + 5"
   7&nbsp;                  # (double quotes and spaces make it more readable)
   8&nbsp;echo "11 + 5 = $a"
   9&nbsp;
  10&nbsp;let "a &#60;&#60;= 3"     # Equivalent to  let "a = a &#60;&#60; 3"
  11&nbsp;echo "\"\$a\" (=16) left-shifted 3 places = $a"
  12&nbsp;
  13&nbsp;let "a /= 4"      # Equivalent to  let "a = a / 4"
  14&nbsp;echo "128 / 4 = $a"
  15&nbsp;
  16&nbsp;let "a -= 5"      # Equivalent to  let "a = a - 5"
  17&nbsp;echo "32 - 5 = $a"
  18&nbsp;
  19&nbsp;let "a = a * 10"  # Equivalent to  let "a = a * 10"
  20&nbsp;echo "27 * 10 = $a"
  21&nbsp;
  22&nbsp;let "a %= 8"      # Equivalent to  let "a = a % 8"
  23&nbsp;echo "270 modulo 8 = $a  (270 / 8 = 33, remainder $a)"
  24&nbsp;
  25&nbsp;echo
  26&nbsp;
  27&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><A
NAME="EVALREF"
></A
><B
CLASS="COMMAND"
>eval</B
></DT
><DD
><P
><TT
CLASS="USERINPUT"
><B
>eval arg1 [arg2] ... [argN]</B
></TT
></P
><P
>Translates into commands the arguments in a list
	      (useful for code generation within a script).</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX43"
></A
><P
><B
>Example 11-7. Showing the effect of <B
CLASS="COMMAND"
>eval</B
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;y=`eval ls -l`  # Similar to y=`ls -l`
   4&nbsp;echo $y         # but linefeeds removed because "echoed" variable is unquoted.
   5&nbsp;echo
   6&nbsp;echo "$y"       # Linefeeds preserved when variable is quoted.
   7&nbsp;
   8&nbsp;echo; echo
   9&nbsp;
  10&nbsp;y=`eval df`     # Similar to y=`df`
  11&nbsp;echo $y         # but linefeeds removed.
  12&nbsp;
  13&nbsp;#  When LF's not preserved, it may make it easier to parse output,
  14&nbsp;#+ using utilities such as "awk".
  15&nbsp;
  16&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX44"
></A
><P
><B
>Example 11-8. Forcing a log-off</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;y=`eval ps ax | sed -n '/ppp/p' | awk '{ print $1 }'`
   4&nbsp;# Finding the process number of 'ppp'.
   5&nbsp;
   6&nbsp;kill -9 $y   # Killing it
   7&nbsp;
   8&nbsp;# Above lines may be replaced by
   9&nbsp;#  kill -9 `ps ax | awk '/ppp/ { print $1 }'
  10&nbsp;
  11&nbsp;
  12&nbsp;chmod 666 /dev/ttyS3
  13&nbsp;# Doing a SIGKILL on ppp changes the permissions
  14&nbsp;# on the serial port. Restore them to previous state.
  15&nbsp;
  16&nbsp;rm /var/lock/LCK..ttyS3   # Remove the serial port lock file.
  17&nbsp;
  18&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ROT14"
></A
><P
><B
>Example 11-9. A version of <SPAN
CLASS="QUOTE"
>"rot13"</SPAN
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# A version of "rot13" using 'eval'.
   3&nbsp;# Compare to "rot13.sh" example.
   4&nbsp;
   5&nbsp;setvar_rot_13()              # "rot13" scrambling
   6&nbsp;{
   7&nbsp;  local varname=$1 varvalue=$2
   8&nbsp;  eval $varname='$(echo "$varvalue" | tr a-z n-za-m)'
   9&nbsp;}
  10&nbsp;
  11&nbsp;
  12&nbsp;setvar_rot_13 var "foobar"   # Run "foobar" through rot13.
  13&nbsp;echo $var                    # sbbone
  14&nbsp;
  15&nbsp;echo $var | tr a-z n-za-m    # foobar
  16&nbsp;                             # Back to original variable.
  17&nbsp;
  18&nbsp;# This example by Stephane Chazelas.
  19&nbsp;
  20&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <B
CLASS="COMMAND"
>eval</B
> command can be
	      risky, and normally should be avoided when there
	      exists a reasonable alternative. An <TT
CLASS="USERINPUT"
><B
>eval
	      $COMMANDS</B
></TT
> executes the contents of
	      <TT
CLASS="REPLACEABLE"
><I
>COMMANDS</I
></TT
>, which may
	      contain such unpleasant surprises as <B
CLASS="COMMAND"
>rm -rf
	      *</B
>. Running an <B
CLASS="COMMAND"
>eval</B
> on
	      unfamiliar code written by persons unknown is living
	      dangerously.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="SETREF"
></A
><B
CLASS="COMMAND"
>set</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>set</B
> command changes the value
	      of internal script variables. One use for this
	      is to toggle <A
HREF="options.html#OPTIONSREF"
>option
	      flags</A
> which help determine the behavior of the
	      script. Another application for it is to reset the <A
HREF="variables2.html#POSPARAMREF"
>positional parameters</A
> that
	      a script sees as the result of a command (<TT
CLASS="USERINPUT"
><B
>set
	      `command`</B
></TT
>). The script can then parse the
	      fields of the command output.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX34"
></A
><P
><B
>Example 11-10. Using <B
CLASS="COMMAND"
>set</B
> with positional
	      parameters</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# script "set-test"
   4&nbsp;
   5&nbsp;# Invoke this script with three command line parameters,
   6&nbsp;# for example, "./set-test one two three".
   7&nbsp;
   8&nbsp;echo
   9&nbsp;echo "Positional parameters before  set \`uname -a\` :"
  10&nbsp;echo "Command-line argument #1 = $1"
  11&nbsp;echo "Command-line argument #2 = $2"
  12&nbsp;echo "Command-line argument #3 = $3"
  13&nbsp;
  14&nbsp;echo
  15&nbsp;
  16&nbsp;set `uname -a` # Sets the positional parameters to the output
  17&nbsp;               # of the command `uname -a`
  18&nbsp;
  19&nbsp;echo "Positional parameters after  set \`uname -a\` :"
  20&nbsp;# $1, $2, $3, etc. reinitialized to result of `uname -a`
  21&nbsp;echo "Field #1 of 'uname -a' = $1"
  22&nbsp;echo "Field #2 of 'uname -a' = $2"
  23&nbsp;echo "Field #3 of 'uname -a' = $3"
  24&nbsp;echo
  25&nbsp;
  26&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>See also <A
HREF="loops.html#EX22A"
>Example 10-2</A
>.</P
></DD
><DT
><A
NAME="UNSETREF"
></A
><B
CLASS="COMMAND"
>unset</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>unset</B
> command deletes a
	      shell variable, effectively setting it to
	      <I
CLASS="EMPHASIS"
>null</I
>. Note that this command does
	      not affect positional parameters.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>unset PATH</B
></TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $PATH</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>&#13;</TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
></PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="UNS"
></A
><P
><B
>Example 11-11. <SPAN
CLASS="QUOTE"
>"unsetting"</SPAN
> a variable</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# unset.sh: Unsetting a variable.
   3&nbsp;
   4&nbsp;variable=hello                       # Initialized.
   5&nbsp;echo "variable = $variable"
   6&nbsp;
   7&nbsp;unset variable                       # Unset.
   8&nbsp;                                     # Same effect as   variable=
   9&nbsp;echo "(unset) variable = $variable"  # $variable is null.
  10&nbsp;
  11&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><A
NAME="EXPORTREF"
></A
><B
CLASS="COMMAND"
>export</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>export</B
> command makes
	      available variables to all child processes of the
	      running script or shell. Unfortunately, there is no way
	      to <B
CLASS="COMMAND"
>export</B
> variables back to the parent
	      process, to the process that called or invoked the script
	      or shell. One important use of <B
CLASS="COMMAND"
>export</B
>
	      command is in <A
HREF="files.html#FILESREF"
>startup files</A
>,
	      to initialize and make accessible environmental variables
	      to subsequent user processes.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="COLTOTALER3"
></A
><P
><B
>Example 11-12. Using <B
CLASS="COMMAND"
>export</B
> to pass a variable to an
	      embedded <A
HREF="awk.html#AWKREF"
>awk</A
> script</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# Yet another version of the "column totaler" script (col-totaler.sh)
   4&nbsp;# that adds up a specified column (of numbers) in the target file.
   5&nbsp;# This uses the environment to pass a script variable to 'awk'.
   6&nbsp;
   7&nbsp;ARGS=2
   8&nbsp;E_WRONGARGS=65
   9&nbsp;
  10&nbsp;if [ $# -ne "$ARGS" ] # Check for proper no. of command line args.
  11&nbsp;then
  12&nbsp;   echo "Usage: `basename $0` filename column-number"
  13&nbsp;   exit $E_WRONGARGS
  14&nbsp;fi
  15&nbsp;
  16&nbsp;filename=$1
  17&nbsp;column_number=$2
  18&nbsp;
  19&nbsp;#===== Same as original script, up to this point =====#
  20&nbsp;
  21&nbsp;export column_number
  22&nbsp;# Export column number to environment, so it's available for retrieval.
  23&nbsp;
  24&nbsp;
  25&nbsp;# Begin awk script.
  26&nbsp;# ------------------------------------------------
  27&nbsp;awk '{ total += $ENVIRON["column_number"]
  28&nbsp;}
  29&nbsp;END { print total }' $filename
  30&nbsp;# ------------------------------------------------
  31&nbsp;# End awk script.
  32&nbsp;
  33&nbsp;
  34&nbsp;# Thanks, Stephane Chazelas.
  35&nbsp;
  36&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>It is possible to initialize and export
		variables in the same operation, as in <B
CLASS="COMMAND"
>export
		var1=xxx</B
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>declare</B
>, <B
CLASS="COMMAND"
>typeset</B
></DT
><DD
><P
>The <A
HREF="declareref.html"
>declare</A
> and
	      <A
HREF="declareref.html"
>typeset</A
> commands specify
	      and/or restrict properties of variables.</P
></DD
><DT
><B
CLASS="COMMAND"
>readonly</B
></DT
><DD
><P
>Same as <A
HREF="declareref.html"
>declare -r</A
>,
	      sets a variable as read-only, or, in effect, as a
	      constant. Attempts to change the variable fail with an
	      error message. This is the shell analog of the C language
	      <B
CLASS="COMMAND"
>const</B
> type qualifier.</P
></DD
><DT
><A
NAME="GETOPTSX"
></A
><B
CLASS="COMMAND"
>getopts</B
></DT
><DD
><P
>This powerful tool parses command line arguments passed to the
	      script. This is the bash analog of the <B
CLASS="COMMAND"
>getopt</B
>
	      library function familiar to C programmers. It permits passing and
	      concatenating multiple options

	      <A
NAME="AEN5352"
HREF="#FTN.AEN5352"
>[3]</A
>

	      and associated arguments to a script (for
	      example <TT
CLASS="USERINPUT"
><B
>scriptname -abc -e
	      /usr/local</B
></TT
>).</P
><P
>The <B
CLASS="COMMAND"
>getopts</B
> construct uses two implicit
	      variables. <TT
CLASS="VARNAME"
>$OPTIND</TT
> is the argument
	      pointer (<I
CLASS="WORDASWORD"
>OPTion INDex</I
>)
	      and <TT
CLASS="VARNAME"
>$OPTARG</TT
> (<I
CLASS="WORDASWORD"
>OPTion
	      ARGument</I
>) the (optional) argument attached
	      to an option. A colon following the option name in the
	      declaration tags that option as having an associated
	      argument.</P
><P
>A <B
CLASS="COMMAND"
>getopts</B
> construct usually comes
	      packaged in a <A
HREF="loops.html#WHILELOOPREF"
>while
	      loop</A
>, which processes the options and
	      arguments one at a time, then decrements the implicit
	      <TT
CLASS="VARNAME"
>$OPTIND</TT
> variable to step to the
	      next.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>		<OL
TYPE="1"
><LI
><P
>The arguments must be passed from the
		      command line to the script preceded by
		      a minus (<TT
CLASS="OPTION"
>-</TT
>) or a plus
		      (<TT
CLASS="OPTION"
>+</TT
>).  It is the prefixed
		      <TT
CLASS="OPTION"
>-</TT
> or <TT
CLASS="OPTION"
>+</TT
> that lets
		      <B
CLASS="COMMAND"
>getopts</B
> recognize command-line
		      arguments as <I
CLASS="EMPHASIS"
>options</I
>.
		      In fact, <B
CLASS="COMMAND"
>getopts</B
> will not process
		      arguments without the prefixed <TT
CLASS="OPTION"
>-</TT
>
		      or <TT
CLASS="OPTION"
>+</TT
>, and will terminate option
		      processing at the first argument encountered
		      lacking them.</P
></LI
><LI
><P
>The <B
CLASS="COMMAND"
>getopts</B
> template
		      differs slightly from the standard <B
CLASS="COMMAND"
>while</B
>
		      loop, in that it lacks condition brackets.</P
></LI
><LI
><P
>The <B
CLASS="COMMAND"
>getopts</B
>
		     construct replaces the obsolete
		     <B
CLASS="COMMAND"
>getopt</B
> command.</P
></LI
></OL
>
	      </P
></TD
></TR
></TABLE
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;while getopts ":abcde:fg" Option
   2&nbsp;# Initial declaration.
   3&nbsp;# a, b, c, d, e, f, and g are the options (flags) expected.
   4&nbsp;# The : after option 'e' shows it will have an argument passed with it.
   5&nbsp;do
   6&nbsp;  case $Option in
   7&nbsp;    a ) # Do something with variable 'a'.
   8&nbsp;    b ) # Do something with variable 'b'.
   9&nbsp;    ...
  10&nbsp;    e)  # Do something with 'e', and also with $OPTARG,
  11&nbsp;        # which is the associated argument passed with option 'e'.
  12&nbsp;    ...
  13&nbsp;    g ) # Do something with variable 'g'.
  14&nbsp;  esac
  15&nbsp;done
  16&nbsp;shift $(($OPTIND - 1))
  17&nbsp;# Move argument pointer to next.
  18&nbsp;
  19&nbsp;# All this is not nearly as complicated as it looks &#60;grin&#62;.
  20&nbsp;	      </PRE
></TD
></TR
></TABLE
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX33"
></A
><P
><B
>Example 11-13. Using <B
CLASS="COMMAND"
>getopts</B
> to read the
	        options/arguments passed to a script</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# 'getopts' processes command line arguments to script.
   4&nbsp;# The arguments are parsed as "options" (flags) and associated arguments.
   5&nbsp;
   6&nbsp;# Try invoking this script with
   7&nbsp;# 'scriptname -mn'
   8&nbsp;# 'scriptname -oq qOption' (qOption can be some arbitrary string.)
   9&nbsp;# 'scriptname -qXXX -r'
  10&nbsp;#
  11&nbsp;# 'scriptname -qr'    - Unexpected result, takes "r" as the argument to option "q"
  12&nbsp;# 'scriptname -q -r'  - Unexpected result, same as above
  13&nbsp;#  If an option expects an argument ("flag:"), then it will grab
  14&nbsp;#  whatever is next on the command line.
  15&nbsp;
  16&nbsp;NO_ARGS=0 
  17&nbsp;OPTERROR=65
  18&nbsp;
  19&nbsp;if [ $# -eq "$NO_ARGS" ]  # Script invoked with no command-line args?
  20&nbsp;then
  21&nbsp;  echo "Usage: `basename $0` options (-mnopqrs)"
  22&nbsp;  exit $OPTERROR          # Exit and explain usage, if no argument(s) given.
  23&nbsp;fi  
  24&nbsp;# Usage: scriptname -options
  25&nbsp;# Note: dash (-) necessary
  26&nbsp;
  27&nbsp;
  28&nbsp;while getopts ":mnopq:rs" Option
  29&nbsp;do
  30&nbsp;  case $Option in
  31&nbsp;    m     ) echo "Scenario #1: option -m-";;
  32&nbsp;    n | o ) echo "Scenario #2: option -$Option-";;
  33&nbsp;    p     ) echo "Scenario #3: option -p-";;
  34&nbsp;    q     ) echo "Scenario #4: option -q-, with argument \"$OPTARG\"";;
  35&nbsp;    # Note that option 'q' must have an associated argument,
  36&nbsp;    # otherwise it falls through to the default.
  37&nbsp;    r | s ) echo "Scenario #5: option -$Option-"'';;
  38&nbsp;    *     ) echo "Unimplemented option chosen.";;   # DEFAULT
  39&nbsp;  esac
  40&nbsp;done
  41&nbsp;
  42&nbsp;shift $(($OPTIND - 1))
  43&nbsp;# Decrements the argument pointer so it points to next argument.
  44&nbsp;
  45&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="INTSCRBEH1"
></A
>Script Behavior</B
></P
><DL
><DT
><A
NAME="SOURCEREF"
></A
><B
CLASS="COMMAND"
>source</B
>, <SPAN
CLASS="TOKEN"
>.</SPAN
> (<A
HREF="special-chars.html#DOTREF"
>dot</A
> command)</DT
><DD
><P
>This command, when invoked from the command line, executes a script. Within
	      a script, a <TT
CLASS="USERINPUT"
><B
>source file-name</B
></TT
> loads the file
	      <TT
CLASS="FILENAME"
>file-name</TT
>. This is the 
	      shell scripting equivalent of a C/C++ <TT
CLASS="USERINPUT"
><B
>#include</B
></TT
>
	      directive. It is useful in situations when multiple scripts use a
	      common data file or function library.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX38"
></A
><P
><B
>Example 11-14. <SPAN
CLASS="QUOTE"
>"Including"</SPAN
> a data file</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;. data-file    # Load a data file.
   4&nbsp;# Same effect as "source data-file", but more portable.
   5&nbsp;
   6&nbsp;# The file "data-file" must be present in current working directory,
   7&nbsp;# since it is referred to by its 'basename'.
   8&nbsp;
   9&nbsp;# Now, reference some data from that file.
  10&nbsp;
  11&nbsp;echo "variable1 (from data-file) = $variable1"
  12&nbsp;echo "variable3 (from data-file) = $variable3"
  13&nbsp;
  14&nbsp;let "sum = $variable2 + $variable4"
  15&nbsp;echo "Sum of variable2 + variable4 (from data-file) = $sum"
  16&nbsp;echo "message1 (from data-file) is \"$message1\""
  17&nbsp;# Note:                            escaped quotes
  18&nbsp;
  19&nbsp;print_message This is the message-print function in the data-file.
  20&nbsp;
  21&nbsp;
  22&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><P
>File <TT
CLASS="FILENAME"
>data-file</TT
> for <A
HREF="internal.html#EX38"
>Example 11-14</A
>, above.
		Must be present in same directory.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# This is a data file loaded by a script.
   2&nbsp;# Files of this type may contain variables, functions, etc.
   3&nbsp;# It may be loaded with a 'source' or '.' command by a shell script.
   4&nbsp;
   5&nbsp;# Let's initialize some variables.
   6&nbsp;
   7&nbsp;variable1=22
   8&nbsp;variable2=474
   9&nbsp;variable3=5
  10&nbsp;variable4=97
  11&nbsp;
  12&nbsp;message1="Hello, how are you?"
  13&nbsp;message2="Enough for now. Goodbye."
  14&nbsp;
  15&nbsp;print_message ()
  16&nbsp;{
  17&nbsp;# Echoes any message passed to it.
  18&nbsp;
  19&nbsp;  if [ -z "$1" ]
  20&nbsp;  then
  21&nbsp;    return 1
  22&nbsp;    # Error, if argument missing.
  23&nbsp;  fi
  24&nbsp;
  25&nbsp;  echo
  26&nbsp;
  27&nbsp;  until [ -z "$1" ]
  28&nbsp;  do
  29&nbsp;    # Step through arguments passed to function.
  30&nbsp;    echo -n "$1"
  31&nbsp;    # Echo args one at a time, suppressing line feeds.
  32&nbsp;    echo -n " "
  33&nbsp;    # Insert spaces between words.
  34&nbsp;    shift
  35&nbsp;    # Next one.
  36&nbsp;  done  
  37&nbsp;
  38&nbsp;  echo
  39&nbsp;
  40&nbsp;  return 0
  41&nbsp;}  </PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><B
CLASS="COMMAND"
>exit</B
></DT
><DD
><P
>Unconditionally terminates a script. The
		<B
CLASS="COMMAND"
>exit</B
> command may optionally take an
		integer argument, which is returned to the shell as
		the <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
>
		of the script. It is a good practice to end all but the
		simplest scripts with an <TT
CLASS="USERINPUT"
><B
>exit 0</B
></TT
>,
		indicating a successful run.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If a script terminates with an <B
CLASS="COMMAND"
>exit</B
>
	      lacking an argument, the exit status of the script is the exit
	      status of the last command executed in the script, not counting
	      the <B
CLASS="COMMAND"
>exit</B
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="EXECREF"
></A
><B
CLASS="COMMAND"
>exec</B
></DT
><DD
><P
>This	shell builtin replaces the current process with
	      a specified command.  Normally, when the shell encounters
	      a command, it forks <A
NAME="FORKREF"
></A
> off

		 <A
NAME="AEN5455"
HREF="#FTN.AEN5455"
>[4]</A
>

	      a child process to actually execute the command.	Using the
	      <B
CLASS="COMMAND"
>exec</B
> builtin, the shell does not fork,
	      and the command exec'ed replaces the shell.  When used in
	      a script, therefore, it forces an exit from the script when
	      the <B
CLASS="COMMAND"
>exec</B
>'ed command terminates. For this
	      reason, if an <B
CLASS="COMMAND"
>exec</B
> appears in a script,
	      it would probably be the final command.</P
><P
>An <B
CLASS="COMMAND"
>exec</B
> also serves to reassign <A
HREF="io-redirection.html#FDREF"
>file descriptors</A
>.	<TT
CLASS="USERINPUT"
><B
>exec
	      &#60;zzz-file</B
></TT
> replaces <TT
CLASS="FILENAME"
>stdin</TT
>
	      with the file <TT
CLASS="FILENAME"
>zzz-file</TT
> (see <A
HREF="io-redirection.html#REDIR1"
>Example 16-1</A
>).</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX54"
></A
><P
><B
>Example 11-15. Effects of <B
CLASS="COMMAND"
>exec</B
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;exec echo "Exiting \"$0\"."   # Exit from script.
   4&nbsp;
   5&nbsp;# The following lines never execute.
   6&nbsp;
   7&nbsp;echo "This will never echo."
   8&nbsp;
   9&nbsp;exit 0  # Will not exit here.</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="OPTION"
>-exec</TT
> option to
	      <A
HREF="moreadv.html#FINDREF"
>find</A
> is
	      <TT
CLASS="REPLACEABLE"
><I
>not</I
></TT
> the same as the
	      <B
CLASS="COMMAND"
>exec</B
> shell builtin.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>shopt</B
></DT
><DD
><P
>This command permits changing shell options on the fly (see
	      <A
HREF="aliases.html#AL"
>Example 24-1</A
> and <A
HREF="aliases.html#UNAL"
>Example 24-2</A
>).  It often
	      appears in the Bash <A
HREF="files.html#FILESREF"
>startup
	      files</A
>, but also has its uses in scripts. Needs
	      <A
HREF="bash2.html#BASH2REF"
>version 2</A
> or later of Bash.

	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;shopt -s cdspell
   2&nbsp;# Allows minor misspelling directory names with 'cd'
   3&nbsp;command.</PRE
></TD
></TR
></TABLE
></P
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="INTCOMMAND1"
></A
>Commands</B
></P
><DL
><DT
><A
NAME="TRUEREF"
></A
><B
CLASS="COMMAND"
>true</B
></DT
><DD
><P
>A command that returns a successful
	    (<SPAN
CLASS="RETURNVALUE"
>zero</SPAN
>) <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
>, but does
	    nothing else.
	  </P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# Endless loop
   2&nbsp;while true   # alias for ":"
   3&nbsp;do
   4&nbsp;   operation-1
   5&nbsp;   operation-2
   6&nbsp;   ...
   7&nbsp;   operation-n
   8&nbsp;   # Need a way to break out of loop.
   9&nbsp;done</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><B
CLASS="COMMAND"
>false</B
></DT
><DD
><P
>A command that returns an unsuccessful <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
>,
	    but does nothing else.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# Null loop
   2&nbsp;while false
   3&nbsp;do
   4&nbsp;   # The following code will not execute.
   5&nbsp;   operation-1
   6&nbsp;   operation-2
   7&nbsp;   ...
   8&nbsp;   operation-n
   9&nbsp;   # Nothing happens!
  10&nbsp;done   </PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><B
CLASS="COMMAND"
>type [cmd]</B
></DT
><DD
><P
>Similar to the <A
HREF="filearchiv.html#WHICHREF"
>which</A
> external command,
	    <B
CLASS="COMMAND"
>type cmd</B
> gives the full pathname to
	    <SPAN
CLASS="QUOTE"
>"cmd"</SPAN
>. Unlike <B
CLASS="COMMAND"
>which</B
>,
	    <B
CLASS="COMMAND"
>type</B
> is a Bash builtin. The useful
	    <TT
CLASS="OPTION"
>-a</TT
> option to <B
CLASS="COMMAND"
>type</B
>
	    accesses identifies <TT
CLASS="REPLACEABLE"
><I
>keywords</I
></TT
>
	    and <TT
CLASS="REPLACEABLE"
><I
>builtins</I
></TT
>, and also locates
	    system commands with identical names.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>type '['</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>[ is a shell builtin</TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>type -a '['</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>[ is a shell builtin
 [ is /usr/bin/[</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><B
CLASS="COMMAND"
>hash [cmds]</B
></DT
><DD
><P
>Record the path name of specified commands (in the
	      shell hash table), so the shell or script will not need to search
	      the <TT
CLASS="VARNAME"
>$PATH</TT
> on subsequent calls to those
              commands. When <B
CLASS="COMMAND"
>hash</B
> is called with no
	      arguments,  it simply lists the commands that have been hashed.
	      The <TT
CLASS="OPTION"
>-r</TT
> option resets the hash table.</P
></DD
><DT
><B
CLASS="COMMAND"
>help</B
></DT
><DD
><P
><B
CLASS="COMMAND"
>help</B
> COMMAND looks up
	    a short usage summary of the shell builtin COMMAND.  This is
	    the counterpart to <A
HREF="filearchiv.html#WHATISREF"
>whatis</A
>,
	    but for builtins.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>help exit</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>exit: exit [n]
    Exit the shell with a status of N.  If N is omitted, the exit status
    is that of the last command executed.</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
></DD
></DL
></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN5595"
>11.1. Job Control Commands</A
></H1
><P
>Certain of the following job control commands take a
	  <SPAN
CLASS="QUOTE"
>"job identifier"</SPAN
> as an argument. See the <A
HREF="internal.html#JOBIDTABLE"
>table</A
> at end of the chapter.</P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><B
CLASS="COMMAND"
>jobs</B
></DT
><DD
><P
>Lists the jobs running in the background, giving the job number.
		Not as useful as <B
CLASS="COMMAND"
>ps</B
>.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>It is all too easy to confuse
		<I
CLASS="EMPHASIS"
>jobs</I
> and
		<I
CLASS="EMPHASIS"
>processes</I
>.  Certain <A
HREF="internal.html#BUILTINREF"
>builtins</A
>, such as
		<B
CLASS="COMMAND"
>kill</B
>, <B
CLASS="COMMAND"
>disown</B
>, and
		<B
CLASS="COMMAND"
>wait</B
> accept either a job number or a
		process number as an argument. The <B
CLASS="COMMAND"
>fg</B
>,
		<B
CLASS="COMMAND"
>bg</B
> and <B
CLASS="COMMAND"
>jobs</B
>
		commands accept only a job number.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>sleep 100 &#38;</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>[1] 1384</TT
>
 
 <TT
CLASS="PROMPT"
>bash $ </TT
><TT
CLASS="USERINPUT"
><B
>jobs</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>[1]+  Running                 sleep 100 &#38;</TT
></PRE
></TD
></TR
></TABLE
>
	      </P
><P
><SPAN
CLASS="QUOTE"
>"1"</SPAN
> is the job number (jobs are
		maintained by the current shell), and <SPAN
CLASS="QUOTE"
>"1384"</SPAN
>
		is the process number (processes are maintained by
		the system). To kill this job/process, either a <B
CLASS="COMMAND"
>kill
		%1</B
> or a <B
CLASS="COMMAND"
>kill 1384</B
> works.</P
><P
><I
CLASS="EMPHASIS"
>Thanks, S.C.</I
></P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>disown</B
></DT
><DD
><P
>Remove job(s) from the shell's table of active jobs.</P
></DD
><DT
><B
CLASS="COMMAND"
>fg</B
>, <B
CLASS="COMMAND"
>bg</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>fg</B
> command switches a job
	      running in the background into the foreground.  The
	      <B
CLASS="COMMAND"
>bg</B
> command restarts a suspended job, and
	      runs it in the background. If no job number is specified,
	      then the <B
CLASS="COMMAND"
>fg</B
> or <B
CLASS="COMMAND"
>bg</B
>
	      command acts upon the currently running job.</P
></DD
><DT
><A
NAME="WAITREF"
></A
><B
CLASS="COMMAND"
>wait</B
></DT
><DD
><P
>Stop script execution until all jobs running in
	        background have terminated, or until the job number or
	        process id specified as an option terminates. Returns the <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
> of waited-for
	        command.</P
><P
>You may use the <B
CLASS="COMMAND"
>wait</B
> command
		to prevent a script from exiting before a background
		job finishes executing (this would create a dreaded
		orphan process).</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX39"
></A
><P
><B
>Example 11-16. Waiting for a process to finish before proceeding</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;ROOT_UID=0   # Only users with $UID 0 have root privileges.
   4&nbsp;E_NOTROOT=65
   5&nbsp;E_NOPARAMS=66
   6&nbsp;
   7&nbsp;if [ "$UID" -ne "$ROOT_UID" ]
   8&nbsp;then
   9&nbsp;  echo "Must be root to run this script."
  10&nbsp;  # "Run along kid, it's past your bedtime."
  11&nbsp;  exit $E_NOTROOT
  12&nbsp;fi  
  13&nbsp;
  14&nbsp;if [ -z "$1" ]
  15&nbsp;then
  16&nbsp;  echo "Usage: `basename $0` find-string"
  17&nbsp;  exit $E_NOPARAMS
  18&nbsp;fi
  19&nbsp;
  20&nbsp;
  21&nbsp;echo "Updating 'locate' database..."
  22&nbsp;echo "This may take a while."
  23&nbsp;updatedb /usr &#38;     # Must be run as root.
  24&nbsp;
  25&nbsp;wait
  26&nbsp;# Don't run the rest of the script until 'updatedb' finished.
  27&nbsp;# You want the the database updated before looking up the file name.
  28&nbsp;
  29&nbsp;locate $1
  30&nbsp;
  31&nbsp;# Without the wait command, in the worse case scenario,
  32&nbsp;# the script would exit while 'updatedb' was still running,
  33&nbsp;# leaving it as an orphan process.
  34&nbsp;
  35&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Optionally, <B
CLASS="COMMAND"
>wait</B
> can take a job
		identifier as an argument, for example,
		<B
CLASS="COMMAND"
>wait%1</B
> or <B
CLASS="COMMAND"
>wait
		$PPID</B
>. See the <A
HREF="internal.html#JOBIDTABLE"
>job
		id table</A
>.</P
><P
><A
NAME="WAITHANG"
></A
></P
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Within a script, running a command in the background
		with an ampersand (&#38;) may cause the script
		to hang until <B
CLASS="KEYCAP"
>ENTER</B
> is hit. This
		seems to occur with commands that write to
		<TT
CLASS="FILENAME"
>stdout</TT
>. It can be a major annoyance.
		  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# test.sh		  
   3&nbsp;
   4&nbsp;ls -l &#38;
   5&nbsp;echo "Done."</PRE
></TD
></TR
></TABLE
>
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>./test.sh</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Done.
 [bozo@localhost test-scripts]$ total 1
 -rwxr-xr-x    1 bozo     bozo           34 Oct 11 15:09 test.sh
 _</TT
>
                </PRE
></TD
></TR
></TABLE
>
	       </P
><P
>Placing a <B
CLASS="COMMAND"
>wait</B
> after the background
                command seems to remedy this.
		  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# test.sh		  
   3&nbsp;
   4&nbsp;ls -l &#38;
   5&nbsp;echo "Done."
   6&nbsp;wait</PRE
></TD
></TR
></TABLE
>
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>./test.sh</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Done.
 [bozo@localhost test-scripts]$ total 1
 -rwxr-xr-x    1 bozo     bozo           34 Oct 11 15:09 test.sh</TT
>
                </PRE
></TD
></TR
></TABLE
>
	        <A
HREF="io-redirection.html#IOREDIRREF"
>Redirecting</A
> the
                output of the command to a file or even to
		<TT
CLASS="FILENAME"
>/dev/null</TT
> also takes care of this
		problem.
              </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>suspend</B
></DT
><DD
><P
>This has a similar effect to
		<B
CLASS="KEYCAP"
>Control</B
>-<B
CLASS="KEYCAP"
>Z</B
>, 
		but it suspends the shell (the shell's parent process should
		resume it at an appropriate time).</P
></DD
><DT
><B
CLASS="COMMAND"
>logout</B
></DT
><DD
><P
>Exit a login shell, optionally specifying an <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
>.</P
></DD
><DT
><A
NAME="TIMESREF"
></A
><B
CLASS="COMMAND"
>times</B
></DT
><DD
><P
>Gives statistics on the system time used in executing commands, in the
		following form:
		<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="COMPUTEROUTPUT"
>0m0.020s 0m0.020s</TT
></PRE
></TD
></TR
></TABLE
>
		This capability is of very limited value, since it is uncommon to
		profile and benchmark shell scripts.</P
></DD
><DT
><A
NAME="KILLREF"
></A
><B
CLASS="COMMAND"
>kill</B
></DT
><DD
><P
>Forcibly terminate a process by sending it an
	      appropriate <I
CLASS="EMPHASIS"
>terminate</I
> signal (see <A
HREF="system.html#KILLPROCESS"
>Example 13-4</A
>).</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="USERINPUT"
><B
>kill -l</B
></TT
> lists all the
		<A
HREF="debugging.html#SIGNALD"
>signals</A
>.  A <TT
CLASS="USERINPUT"
><B
>kill
		-9</B
></TT
> is a <SPAN
CLASS="QUOTE"
>"sure kill"</SPAN
>, which will
		usually terminate a process that stubbornly refuses to
		die with a plain <B
CLASS="COMMAND"
>kill</B
>. Sometimes, a
		<TT
CLASS="USERINPUT"
><B
>kill -15</B
></TT
> works. A <SPAN
CLASS="QUOTE"
>"zombie
		process"</SPAN
>, that is, a process whose <A
HREF="internal.html#FORKREF"
>parent</A
> has terminated, cannot be
		killed (you can't kill something that is already dead),
		but <B
CLASS="COMMAND"
>init</B
> will usually clean it up
		sooner or later.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>command</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>command COMMAND</B
> directive
	    disables aliases and functions for the command
	    <SPAN
CLASS="QUOTE"
>"COMMAND"</SPAN
>.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This is one of three shell directives that
	      effect script command processing. The others are
	      <A
HREF="internal.html#BLTREF"
>builtin</A
> and <A
HREF="internal.html#ENABLEREF"
>enable</A
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="BLTREF"
></A
><B
CLASS="COMMAND"
>builtin</B
></DT
><DD
><P
>Invoking <B
CLASS="COMMAND"
>builtin
	      BUILTIN_COMMAND</B
> runs the command
	      <SPAN
CLASS="QUOTE"
>"BUILTIN_COMMAND"</SPAN
> as a shell <A
HREF="internal.html#BUILTINREF"
>builtin</A
>, temporarily disabling
	      both functions and external system commands with the
	      same name.</P
></DD
><DT
><A
NAME="ENABLEREF"
></A
><B
CLASS="COMMAND"
>enable</B
></DT
><DD
><P
>This either enables or disables a shell
	      builtin command. As an example, <B
CLASS="COMMAND"
>enable -n
	      kill</B
> disables the shell builtin <A
HREF="internal.html#KILLREF"
>kill</A
>, so that when Bash
	      subsequently encounters <B
CLASS="COMMAND"
>kill</B
>, it invokes
	      <TT
CLASS="FILENAME"
>/bin/kill</TT
>.</P
><P
><A
NAME="ENABLEREF1"
></A
>The <TT
CLASS="OPTION"
>-a</TT
>
	      option to <B
CLASS="COMMAND"
>enable</B
> lists all the
	      shell builtins, indicating whether or not they
	      are enabled. The <TT
CLASS="OPTION"
>-f filename</TT
>
	      option lets <B
CLASS="COMMAND"
>enable</B
> load a <A
HREF="internal.html#BUILTINREF"
>builtin</A
> as a shared library
	      (DLL) module from a properly compiled object file.
	        <A
NAME="AEN5829"
HREF="#FTN.AEN5829"
>[5]</A
>.
	     </P
></DD
><DT
><B
CLASS="COMMAND"
>autoload</B
></DT
><DD
><P
>This is a port to Bash of the
	    <I
CLASS="EMPHASIS"
>ksh</I
> autoloader. With
	    <B
CLASS="COMMAND"
>autoload</B
> in place, a function with
	    an <SPAN
CLASS="QUOTE"
>"autoload"</SPAN
> declaration will load from an
	    external file at its first invocation.
	      <A
NAME="AEN5848"
HREF="#FTN.AEN5848"
>[6]</A
>
	    This saves system resources.</P
><P
>Note that <B
CLASS="COMMAND"
>autoload</B
> is not a part of the
	    core Bash installation. It needs to be loaded in with
	    <B
CLASS="COMMAND"
>enable -f</B
> (see above).</P
></DD
></DL
></DIV
><DIV
CLASS="TABLE"
><HR><A
NAME="JOBIDTABLE"
></A
><P
><B
>Table 11-1. Job Identifiers</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
>Notation</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="OPTION"
>%N</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Job number [N]</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="OPTION"
>%S</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Invocation (command line) of job begins with string <I
CLASS="EMPHASIS"
>S</I
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="OPTION"
>%?S</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Invocation (command line) of job contains within it string <I
CLASS="EMPHASIS"
>S</I
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="OPTION"
>%%</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><SPAN
CLASS="QUOTE"
>"current"</SPAN
> job (last job stopped in
	      foreground or started in background)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="OPTION"
>%+</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><SPAN
CLASS="QUOTE"
>"current"</SPAN
> job (last job stopped in
	      foreground or started in background)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="OPTION"
>%-</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Last job</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="OPTION"
>$!</TT
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Last background process</TD
></TR
></TBODY
></TABLE
><HR></DIV
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN4919"
HREF="internal.html#AEN4919"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>This is either for performance reasons (builtins
	    execute much faster than external commands, which usually
	    require <I
CLASS="EMPHASIS"
>forking</I
> off a process) or
	    because a particular builtin needs direct access to the
	    shell internals.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN4936"
HREF="internal.html#AEN4936"
>[2]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>An exception to this is the <A
HREF="timedate.html#TIMREF"
>time</A
> command, listed in the official
	     Bash documentation as a keyword.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN5352"
HREF="internal.html#AEN5352"
>[3]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>A option is an argument that acts as a
		flag, switching script behaviors on or off. The
		argument associated with a particular option indicates
		the behavior that the option (flag) switches on or
		off.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN5455"
HREF="internal.html#AEN5455"
>[4]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>When a command or the shell itself
		   initiates (or <I
CLASS="EMPHASIS"
>spawns</I
>) a new
		   subprocess to carry out a task, this is called
		   <I
CLASS="EMPHASIS"
>forking</I
>. This new process
		   is the <SPAN
CLASS="QUOTE"
>"child"</SPAN
>, and the process
		   that <I
CLASS="EMPHASIS"
>forked</I
> it off is the
		   <SPAN
CLASS="QUOTE"
>"parent"</SPAN
>. While the <I
CLASS="EMPHASIS"
>child
		   process</I
> is doing its work, the
		   <I
CLASS="EMPHASIS"
>parent process</I
> is still
		   running.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN5829"
HREF="internal.html#AEN5829"
>[5]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>The C source for a number of loadable builtins is
		    typically found in the <TT
CLASS="FILENAME"
>/usr/share/doc/bash-?.??/functions</TT
>
		    directory.</P
><P
>Note that the <TT
CLASS="OPTION"
>-f</TT
> option to
		    <B
CLASS="COMMAND"
>enable</B
> is not portable to all
		    systems.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN5848"
HREF="internal.html#AEN5848"
>[6]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>The same effect as
	      <B
CLASS="COMMAND"
>autoload</B
> can be achieved with <A
HREF="declareref.html"
>typeset -fu</A
>.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="testbranch.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="external.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Testing and Branching</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="part3.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>External Filters, Programs and Commands</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
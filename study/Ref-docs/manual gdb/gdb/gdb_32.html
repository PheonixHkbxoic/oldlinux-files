<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on November, 11  2002 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>Debugging with GDB: Remote Protocol</TITLE>

<META NAME="description" CONTENT="Debugging with GDB: Remote Protocol">
<META NAME="keywords" CONTENT="Debugging with GDB: Remote Protocol">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC631"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_31.html#SEC630"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC632"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_33.html#SEC638"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_33.html#SEC638"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> D. GDB Remote Serial Protocol </H1>
<!--docid::SEC631::-->
<P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_32.html#SEC632">D.1 Overview</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_32.html#SEC633">D.2 Packets</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_32.html#SEC634">D.3 Stop Reply Packets</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_32.html#SEC635">D.4 General Query Packets</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_32.html#SEC636">D.5 Register Packet Format</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_32.html#SEC637">D.6 Examples</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Overview"></A>
<HR SIZE="6">
<A NAME="SEC632"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC631"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC633"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC631"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC631"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_33.html#SEC638"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> D.1 Overview </H2>
<!--docid::SEC632::-->
<P>

There may be occasions when you need to know something about the
protocol--for example, if there is only one serial port to your target
machine, you might want your program to do something special if it
recognizes a packet meant for GDB.
</P><P>

In the examples below, <SAMP>`-&#62;'</SAMP> and <SAMP>`&#60;-'</SAMP> are used to indicate
transmitted and received data respectfully.
</P><P>

<A NAME="IDX1212"></A>
<A NAME="IDX1213"></A>
<A NAME="IDX1214"></A>
All GDB commands and responses (other than acknowledgments) are
sent as a <VAR>packet</VAR>.  A <VAR>packet</VAR> is introduced with the character
<SAMP>`$'</SAMP>, the actual <VAR>packet-data</VAR>, and the terminating character
<SAMP>`#'</SAMP> followed by a two-digit <VAR>checksum</VAR>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre><CODE>$</CODE><VAR>packet-data</VAR><CODE>#</CODE><VAR>checksum</VAR>
</FONT></pre></td></tr></table></P><P>

<A NAME="IDX1215"></A>
The two-digit <VAR>checksum</VAR> is computed as the modulo 256 sum of all
characters between the leading <SAMP>`$'</SAMP> and the trailing <SAMP>`#'</SAMP> (an
eight bit unsigned checksum).
</P><P>

Implementors should note that prior to GDB 5.0 the protocol
specification also included an optional two-digit <VAR>sequence-id</VAR>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre><CODE>$</CODE><VAR>sequence-id</VAR><CODE>:</CODE><VAR>packet-data</VAR><CODE>#</CODE><VAR>checksum</VAR>
</FONT></pre></td></tr></table></P><P>

<A NAME="IDX1216"></A>
That <VAR>sequence-id</VAR> was appended to the acknowledgment.  GDB
has never output <VAR>sequence-id</VAR>s.  Stubs that handle packets added
since GDB 5.0 must not accept <VAR>sequence-id</VAR>.
</P><P>

<A NAME="IDX1217"></A>
When either the host or the target machine receives a packet, the first
response expected is an acknowledgment: either <SAMP>`+'</SAMP> (to indicate
the package was received correctly) or <SAMP>`-'</SAMP> (to request
retransmission):
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>-&#62; <CODE>$</CODE><VAR>packet-data</VAR><CODE>#</CODE><VAR>checksum</VAR>
&#60;- <CODE>+</CODE>
</FONT></pre></td></tr></table></P><P>

The host (GDB) sends <VAR>command</VAR>s, and the target (the
debugging stub incorporated in your program) sends a <VAR>response</VAR>.  In
the case of step and continue <VAR>command</VAR>s, the response is only sent
when the operation has completed (the target has again stopped).
</P><P>

<VAR>packet-data</VAR> consists of a sequence of characters with the
exception of <SAMP>`#'</SAMP> and <SAMP>`$'</SAMP> (see <SAMP>`X'</SAMP> packet for additional
exceptions).
</P><P>

Fields within the packet should be separated using <SAMP>`,'</SAMP> <SAMP>`;'</SAMP> or
<A NAME="IDX1218"></A>
<SAMP>`:'</SAMP>.  Except where otherwise noted all numbers are represented in
HEX with leading zeros suppressed.
</P><P>

Implementors should note that prior to GDB 5.0, the character
<SAMP>`:'</SAMP> could not appear as the third character in a packet (as it
would potentially conflict with the <VAR>sequence-id</VAR>).
</P><P>

Response <VAR>data</VAR> can be run-length encoded to save space.  A <SAMP>`*'</SAMP>
means that the next character is an ASCII encoding giving a repeat count
which stands for that many repetitions of the character preceding the
<SAMP>`*'</SAMP>.  The encoding is <CODE>n+29</CODE>, yielding a printable character
where <CODE>n &#62;=3</CODE> (which is where rle starts to win).  The printable
characters <SAMP>`$'</SAMP>, <SAMP>`#'</SAMP>, <SAMP>`+'</SAMP> and <SAMP>`-'</SAMP> or with a numeric
value greater than 126 should not be used.
</P><P>

Some remote systems have used a different run-length encoding mechanism
loosely refered to as the cisco encoding.  Following the <SAMP>`*'</SAMP>
character are two hex digits that indicate the size of the packet.
</P><P>

So:
<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>"<CODE>0* </CODE>"
</FONT></pre></td></tr></table>means the same as "0000".
</P><P>

The error response returned for some packets includes a two character
error number.  That number is not well defined.
</P><P>

For any <VAR>command</VAR> not supported by the stub, an empty response
(<SAMP>`$#00'</SAMP>) should be returned.  That way it is possible to extend the
protocol.  A newer GDB can tell if a packet is supported based
on that response.
</P><P>

A stub is required to support the <SAMP>`g'</SAMP>, <SAMP>`G'</SAMP>, <SAMP>`m'</SAMP>, <SAMP>`M'</SAMP>, 
<SAMP>`c'</SAMP>, and <SAMP>`s'</SAMP> <VAR>command</VAR>s.  All other <VAR>command</VAR>s are 
optional.
</P><P>

<A NAME="Packets"></A>
<HR SIZE="6">
<A NAME="SEC633"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC632"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC634"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC634"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC631"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_33.html#SEC638"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> D.2 Packets </H2>
<!--docid::SEC633::-->
<P>

The following table provides a complete list of all currently defined
<VAR>command</VAR>s and their corresponding response <VAR>data</VAR>.
</P><P>

<DL COMPACT>

<DT><CODE>!</CODE> -- extended mode
<DD><A NAME="IDX1219"></A>
<P>

Enable extended mode.  In extended mode, the remote server is made
persistent.  The <SAMP>`R'</SAMP> packet is used to restart the program being
debugged.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`OK'</SAMP>
<DD>The remote target both supports and has enabled extended mode.
</DL>
<P>

<DT><CODE>?</CODE> -- last signal
<DD><A NAME="IDX1220"></A>
<P>

Indicate the reason the target halted.  The reply is the same as for
step and continue.
</P><P>

Reply:
See section <A HREF="gdb_32.html#SEC634">D.3 Stop Reply Packets</A>, for the reply specifications.
</P><P>

<DT><CODE>a</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>A</CODE><VAR>arglen</VAR><CODE>,</CODE><VAR>argnum</VAR><CODE>,</CODE><VAR>arg</VAR><CODE>,<small>...</small></CODE> --  set program arguments <STRONG>(reserved)</STRONG>
<DD><A NAME="IDX1221"></A>
<P>

Initialized <SAMP>`argv[]'</SAMP> array passed into program. <VAR>arglen</VAR>
specifies the number of bytes in the hex encoded byte stream <VAR>arg</VAR>.
See <CODE>gdbserver</CODE> for more details.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`OK'</SAMP>
<DD><DT><SAMP>`E<VAR>NN</VAR>'</SAMP>
<DD></DL>
<P>

<DT><CODE>b</CODE><VAR>baud</VAR> -- set baud <STRONG>(deprecated)</STRONG>
<DD><A NAME="IDX1222"></A>
<P>

Change the serial line speed to <VAR>baud</VAR>.
</P><P>

JTC: <EM>When does the transport layer state change?  When it's
received, or after the ACK is transmitted.  In either case, there are
problems if the command or the acknowledgment packet is dropped.</EM>
</P><P>

Stan: <EM>If people really wanted to add something like this, and get
it working for the first time, they ought to modify ser-unix.c to send
some kind of out-of-band message to a specially-setup stub and have the
switch happen "in between" packets, so that from remote protocol's point
of view, nothing actually happened.</EM>
</P><P>

<DT><CODE>B</CODE><VAR>addr</VAR>,<VAR>mode</VAR> -- set breakpoint <STRONG>(deprecated)</STRONG>
<DD><A NAME="IDX1223"></A>
<P>

Set (<VAR>mode</VAR> is <SAMP>`S'</SAMP>) or clear (<VAR>mode</VAR> is <SAMP>`C'</SAMP>) a
breakpoint at <VAR>addr</VAR>.
</P><P>

This packet has been replaced by the <SAMP>`Z'</SAMP> and <SAMP>`z'</SAMP> packets
(see  <A HREF="gdb_32.html#insert breakpoint or watchpoint packet">insert breakpoint or watchpoint packet</A>).
</P><P>

<DT><CODE>c</CODE><VAR>addr</VAR> -- continue
<DD><A NAME="IDX1224"></A>
<P>

<VAR>addr</VAR> is address to resume.  If <VAR>addr</VAR> is omitted, resume at
current address.
</P><P>

Reply:
See section <A HREF="gdb_32.html#SEC634">D.3 Stop Reply Packets</A>, for the reply specifications.
</P><P>

<DT><CODE>C</CODE><VAR>sig</VAR><CODE>;</CODE><VAR>addr</VAR> -- continue with signal
<DD><A NAME="IDX1225"></A>
<P>

Continue with signal <VAR>sig</VAR> (hex signal number).  If
<CODE>;</CODE><VAR>addr</VAR> is omitted, resume at same address.
</P><P>

Reply:
See section <A HREF="gdb_32.html#SEC634">D.3 Stop Reply Packets</A>, for the reply specifications.
</P><P>

<DT><CODE>d</CODE> -- toggle debug <STRONG>(deprecated)</STRONG>
<DD><A NAME="IDX1226"></A>
<P>

Toggle debug flag.
</P><P>

<DT><CODE>D</CODE> -- detach
<DD><A NAME="IDX1227"></A>
<P>

Detach GDB from the remote system.  Sent to the remote target
before GDB disconnects.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`<EM>no response</EM>'</SAMP>
<DD>GDB does not check for any response after sending this packet.
</DL>
<P>

<DT><CODE>e</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>E</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>f</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>F</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>g</CODE> -- read registers
<DD><A NAME="read registers packet"></A>
<A NAME="IDX1228"></A>
<P>

Read general registers.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`<VAR>XX<small>...</small></VAR>'</SAMP>
<DD>Each byte of register data is described by two hex digits.  The bytes
with the register are transmitted in target byte order.  The size of
each register and their position within the <SAMP>`g'</SAMP> <VAR>packet</VAR> are
determined by the GDB internal macros <VAR>REGISTER_RAW_SIZE</VAR>
and <VAR>REGISTER_NAME</VAR> macros.  The specification of several standard
<CODE>g</CODE> packets is specified below.
<DT><SAMP>`E<VAR>NN</VAR>'</SAMP>
<DD>for an error.
</DL>
<P>

<DT><CODE>G</CODE><VAR>XX<small>...</small></VAR> -- write regs
<DD><A NAME="IDX1229"></A>
<P>

See  <A HREF="gdb_32.html#read registers packet">read registers packet</A>, for a description of the <VAR>XX<small>...</small></VAR>
data.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`OK'</SAMP>
<DD>for success
<DT><SAMP>`E<VAR>NN</VAR>'</SAMP>
<DD>for an error
</DL>
<P>

<DT><CODE>h</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>H</CODE><VAR>c</VAR><VAR>t<small>...</small></VAR> -- set thread
<DD><A NAME="IDX1230"></A>
<P>

Set thread for subsequent operations (<SAMP>`m'</SAMP>, <SAMP>`M'</SAMP>, <SAMP>`g'</SAMP>,
<SAMP>`G'</SAMP>, et.al.).  <VAR>c</VAR> depends on the operation to be performed: it
should be <SAMP>`c'</SAMP> for step and continue operations, <SAMP>`g'</SAMP> for other
operations.  The thread designator <VAR>t<small>...</small></VAR> may be -1, meaning all
the threads, a thread number, or zero which means pick any thread.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`OK'</SAMP>
<DD>for success
<DT><SAMP>`E<VAR>NN</VAR>'</SAMP>
<DD>for an error
</DL>
<P>

<DT><CODE>i</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>nnn</VAR> -- cycle step <STRONG>(draft)</STRONG>
<DD><A NAME="cycle step packet"></A>
<A NAME="IDX1231"></A>
<P>

Step the remote target by a single clock cycle.  If <CODE>,</CODE><VAR>nnn</VAR> is
present, cycle step <VAR>nnn</VAR> cycles.  If <VAR>addr</VAR> is present, cycle
step starting at that address.
</P><P>

<DT><CODE>I</CODE> -- signal then cycle step <STRONG>(reserved)</STRONG>
<DD><A NAME="IDX1232"></A>
<P>

See  <A HREF="gdb_32.html#step with signal packet">step with signal packet</A>.  See  <A HREF="gdb_32.html#cycle step packet">cycle step packet</A>.
</P><P>

<DT><CODE>j</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>J</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>k</CODE> -- kill request
<DD><A NAME="IDX1233"></A>
<P>

FIXME: <EM>There is no description of how to operate when a specific
thread context has been selected (i.e. does 'k' kill only that
thread?)</EM>.
</P><P>

<DT><CODE>K</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>l</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>L</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>m</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR> -- read memory
<DD><A NAME="IDX1234"></A>
<P>

Read <VAR>length</VAR> bytes of memory starting at address <VAR>addr</VAR>.
Neither GDB nor the stub assume that sized memory transfers are
assumed using word aligned accesses. FIXME: <EM>A word aligned memory
transfer mechanism is needed.</EM>
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`<VAR>XX<small>...</small></VAR>'</SAMP>
<DD><VAR>XX<small>...</small></VAR> is mem contents. Can be fewer bytes than requested if able
to read only part of the data.  Neither GDB nor the stub assume
that sized memory transfers are assumed using word aligned
accesses. FIXME: <EM>A word aligned memory transfer mechanism is
needed.</EM>
<DT><SAMP>`E<VAR>NN</VAR>'</SAMP>
<DD><VAR>NN</VAR> is errno
</DL>
<P>

<DT><CODE>M</CODE><VAR>addr</VAR>,<VAR>length</VAR><CODE>:</CODE><VAR>XX<small>...</small></VAR> -- write mem
<DD><A NAME="IDX1235"></A>
<P>

Write <VAR>length</VAR> bytes of memory starting at address <VAR>addr</VAR>.
<VAR>XX<small>...</small></VAR> is the data.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`OK'</SAMP>
<DD>for success
<DT><SAMP>`E<VAR>NN</VAR>'</SAMP>
<DD>for an error (this includes the case where only part of the data was
written).
</DL>
<P>

<DT><CODE>n</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>N</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>o</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>O</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>p</CODE><VAR>n<small>...</small></VAR> -- read reg <STRONG>(reserved)</STRONG>
<DD><A NAME="IDX1236"></A>
<P>

See  <A HREF="gdb_32.html#write register packet">write register packet</A>.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`<VAR>r<small>...</small>.</VAR>'</SAMP>
<DD>The hex encoded value of the register in target byte order.
</DL>
<P>

<DT><CODE>P</CODE><VAR>n<small>...</small></VAR><CODE>=</CODE><VAR>r<small>...</small></VAR> -- write register
<DD><A NAME="write register packet"></A>
<A NAME="IDX1237"></A>
<P>

Write register <VAR>n<small>...</small></VAR> with value <VAR>r<small>...</small></VAR>, which contains two hex
digits for each byte in the register (target byte order).
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`OK'</SAMP>
<DD>for success
<DT><SAMP>`E<VAR>NN</VAR>'</SAMP>
<DD>for an error
</DL>
<P>

<DT><CODE>q</CODE><VAR>query</VAR> -- general query
<DD><A NAME="general query packet"></A>
<A NAME="IDX1238"></A>
<P>

Request info about <VAR>query</VAR>.  In general GDB queries have a
leading upper case letter.  Custom vendor queries should use a company
prefix (in lower case) ex: <SAMP>`qfsf.var'</SAMP>.  <VAR>query</VAR> may optionally
be followed by a <SAMP>`,'</SAMP> or <SAMP>`;'</SAMP> separated list.  Stubs must ensure
that they match the full <VAR>query</VAR> name.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`<VAR>XX<small>...</small></VAR>'</SAMP>
<DD>Hex encoded data from query.  The reply can not be empty.
<DT><SAMP>`E<VAR>NN</VAR>'</SAMP>
<DD>error reply
<DT><SAMP>`'</SAMP>
<DD>Indicating an unrecognized <VAR>query</VAR>.
</DL>
<P>

<DT><CODE>Q</CODE><VAR>var</VAR><CODE>=</CODE><VAR>val</VAR> -- general set
<DD><A NAME="IDX1239"></A>
<P>

Set value of <VAR>var</VAR> to <VAR>val</VAR>.
</P><P>

See  <A HREF="gdb_32.html#general query packet">general query packet</A>, for a discussion of naming conventions.
</P><P>

<DT><CODE>r</CODE> -- reset <STRONG>(deprecated)</STRONG>
<DD><A NAME="IDX1240"></A>
<P>

Reset the entire system.
</P><P>

<DT><CODE>R</CODE><VAR>XX</VAR> -- remote restart
<DD><A NAME="IDX1241"></A>
<P>

Restart the program being debugged.  <VAR>XX</VAR>, while needed, is ignored.
This packet is only available in extended mode.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`<EM>no reply</EM>'</SAMP>
<DD>The <SAMP>`R'</SAMP> packet has no reply.
</DL>
<P>

<DT><CODE>s</CODE><VAR>addr</VAR> -- step
<DD><A NAME="IDX1242"></A>
<P>

<VAR>addr</VAR> is address to resume.  If <VAR>addr</VAR> is omitted, resume at
same address.
</P><P>

Reply:
See section <A HREF="gdb_32.html#SEC634">D.3 Stop Reply Packets</A>, for the reply specifications.
</P><P>

<DT><CODE>S</CODE><VAR>sig</VAR><CODE>;</CODE><VAR>addr</VAR> -- step with signal
<DD><A NAME="step with signal packet"></A>
<A NAME="IDX1243"></A>
<P>

Like <SAMP>`C'</SAMP> but step not continue.
</P><P>

Reply:
See section <A HREF="gdb_32.html#SEC634">D.3 Stop Reply Packets</A>, for the reply specifications.
</P><P>

<DT><CODE>t</CODE><VAR>addr</VAR><CODE>:</CODE><VAR>PP</VAR><CODE>,</CODE><VAR>MM</VAR> -- search
<DD><A NAME="IDX1244"></A>
<P>

Search backwards starting at address <VAR>addr</VAR> for a match with pattern
<VAR>PP</VAR> and mask <VAR>MM</VAR>.  <VAR>PP</VAR> and <VAR>MM</VAR> are 4 bytes.
<VAR>addr</VAR> must be at least 3 digits.
</P><P>

<DT><CODE>T</CODE><VAR>XX</VAR> -- thread alive
<DD><A NAME="IDX1245"></A>
<P>

Find out if the thread XX is alive.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`OK'</SAMP>
<DD>thread is still alive
<DT><SAMP>`E<VAR>NN</VAR>'</SAMP>
<DD>thread is dead
</DL>
<P>

<DT><CODE>u</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>U</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>v</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>V</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>w</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>W</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>x</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>X</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR><VAR>:</VAR><VAR>XX<small>...</small></VAR> -- write mem (binary)
<DD><A NAME="IDX1246"></A>
<P>

<VAR>addr</VAR> is address, <VAR>length</VAR> is number of bytes, <VAR>XX<small>...</small></VAR>
is binary data.  The characters <CODE>$</CODE>, <CODE>#</CODE>, and <CODE>0x7d</CODE> are
escaped using <CODE>0x7d</CODE>.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`OK'</SAMP>
<DD>for success
<DT><SAMP>`E<VAR>NN</VAR>'</SAMP>
<DD>for an error
</DL>
<P>

<DT><CODE>y</CODE> -- reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>Y</CODE> reserved
<DD><P>

Reserved for future use.
</P><P>

<DT><CODE>z</CODE><VAR>type</VAR><CODE>,</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR> -- remove breakpoint or watchpoint <STRONG>(draft)</STRONG>
<DD><DT><CODE>Z</CODE><VAR>type</VAR><CODE>,</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR> -- insert breakpoint or watchpoint <STRONG>(draft)</STRONG>
<DD><A NAME="insert breakpoint or watchpoint packet"></A>
<A NAME="IDX1247"></A>
<A NAME="IDX1248"></A>
<P>

Insert (<CODE>Z</CODE>) or remove (<CODE>z</CODE>) a <VAR>type</VAR> breakpoint or
watchpoint starting at address <VAR>address</VAR> and covering the next
<VAR>length</VAR> bytes.
</P><P>

Each breakpoint and watchpoint packet <VAR>type</VAR> is documented
separately.
</P><P>

<EM>Implementation notes: A remote target shall return an empty string
for an unrecognized breakpoint or watchpoint packet <VAR>type</VAR>.  A
remote target shall support either both or neither of a given
<CODE>Z</CODE><VAR>type</VAR><small>...</small> and <CODE>z</CODE><VAR>type</VAR><small>...</small> packet pair.  To
avoid potential problems with duplicate packets, the operations should
be implemented in an idempotent way.</EM>
</P><P>

<DT><CODE>z</CODE><CODE>0</CODE><CODE>,</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR> -- remove memory breakpoint <STRONG>(draft)</STRONG>
<DD><DT><CODE>Z</CODE><CODE>0</CODE><CODE>,</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR> -- insert memory breakpoint <STRONG>(draft)</STRONG>
<DD><A NAME="IDX1249"></A>
<A NAME="IDX1250"></A>
<P>

Insert (<CODE>Z0</CODE>) or remove (<CODE>z0</CODE>) a memory breakpoint at address
<CODE>addr</CODE> of size <CODE>length</CODE>.
</P><P>

A memory breakpoint is implemented by replacing the instruction at
<VAR>addr</VAR> with a software breakpoint or trap instruction.  The
<CODE>length</CODE> is used by targets that indicates the size of the
breakpoint (in bytes) that should be inserted (e.g., the ARM and
MIPS can insert either a 2 or 4 byte breakpoint).
</P><P>

<EM>Implementation note: It is possible for a target to copy or move
code that contains memory breakpoints (e.g., when implementing
overlays).  The behavior of this packet, in the presence of such a
target, is not defined.</EM>
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`OK'</SAMP>
<DD>success
<DT><SAMP>`'</SAMP>
<DD>not supported
<DT><SAMP>`E<VAR>NN</VAR>'</SAMP>
<DD>for an error
</DL>
<P>

<DT><CODE>z</CODE><CODE>1</CODE><CODE>,</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR> -- remove hardware breakpoint <STRONG>(draft)</STRONG>
<DD><DT><CODE>Z</CODE><CODE>1</CODE><CODE>,</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR> -- insert hardware breakpoint <STRONG>(draft)</STRONG>
<DD><A NAME="IDX1251"></A>
<A NAME="IDX1252"></A>
<P>

Insert (<CODE>Z1</CODE>) or remove (<CODE>z1</CODE>) a hardware breakpoint at
address <CODE>addr</CODE> of size <CODE>length</CODE>.
</P><P>

A hardware breakpoint is implemented using a mechanism that is not
dependant on being able to modify the target's memory.
</P><P>

<EM>Implementation note: A hardware breakpoint is not affected by code
movement.</EM>
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`OK'</SAMP>
<DD>success
<DT><SAMP>`'</SAMP>
<DD>not supported
<DT><SAMP>`E<VAR>NN</VAR>'</SAMP>
<DD>for an error
</DL>
<P>

<DT><CODE>z</CODE><CODE>2</CODE><CODE>,</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR> -- remove write watchpoint <STRONG>(draft)</STRONG>
<DD><DT><CODE>Z</CODE><CODE>2</CODE><CODE>,</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR> -- insert write watchpoint <STRONG>(draft)</STRONG>
<DD><A NAME="IDX1253"></A>
<A NAME="IDX1254"></A>
<P>

Insert (<CODE>Z2</CODE>) or remove (<CODE>z2</CODE>) a write watchpoint.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`OK'</SAMP>
<DD>success
<DT><SAMP>`'</SAMP>
<DD>not supported
<DT><SAMP>`E<VAR>NN</VAR>'</SAMP>
<DD>for an error
</DL>
<P>

<DT><CODE>z</CODE><CODE>3</CODE><CODE>,</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR> -- remove read watchpoint <STRONG>(draft)</STRONG>
<DD><DT><CODE>Z</CODE><CODE>3</CODE><CODE>,</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR> -- insert read watchpoint <STRONG>(draft)</STRONG>
<DD><A NAME="IDX1255"></A>
<A NAME="IDX1256"></A>
<P>

Insert (<CODE>Z3</CODE>) or remove (<CODE>z3</CODE>) a read watchpoint.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`OK'</SAMP>
<DD>success
<DT><SAMP>`'</SAMP>
<DD>not supported
<DT><SAMP>`E<VAR>NN</VAR>'</SAMP>
<DD>for an error
</DL>
<P>

<DT><CODE>z</CODE><CODE>4</CODE><CODE>,</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR> -- remove access watchpoint <STRONG>(draft)</STRONG>
<DD><DT><CODE>Z</CODE><CODE>4</CODE><CODE>,</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR> -- insert access watchpoint <STRONG>(draft)</STRONG>
<DD><A NAME="IDX1257"></A>
<A NAME="IDX1258"></A>
<P>

Insert (<CODE>Z4</CODE>) or remove (<CODE>z4</CODE>) an access watchpoint.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`OK'</SAMP>
<DD>success
<DT><SAMP>`'</SAMP>
<DD>not supported
<DT><SAMP>`E<VAR>NN</VAR>'</SAMP>
<DD>for an error
</DL>
<P>

</DL>
<P>

<A NAME="Stop Reply Packets"></A>
<HR SIZE="6">
<A NAME="SEC634"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC633"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC635"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC635"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC631"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_33.html#SEC638"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> D.3 Stop Reply Packets </H2>
<!--docid::SEC634::-->
<P>

The <SAMP>`C'</SAMP>, <SAMP>`c'</SAMP>, <SAMP>`S'</SAMP>, <SAMP>`s'</SAMP> and <SAMP>`?'</SAMP> packets can
receive any of the below as a reply.  In the case of the <SAMP>`C'</SAMP>,
<SAMP>`c'</SAMP>, <SAMP>`S'</SAMP> and <SAMP>`s'</SAMP> packets, that reply is only returned
when the target halts.  In the below the exact meaning of <SAMP>`signal
number'</SAMP> is poorly defined.  In general one of the UNIX signal numbering
conventions is used.
</P><P>

<DL COMPACT>

<DT><SAMP>`S<VAR>AA</VAR>'</SAMP>
<DD><VAR>AA</VAR> is the signal number
<P>

<DT><SAMP>`<CODE>T</CODE><VAR>AA</VAR><VAR>n...</VAR><CODE>:</CODE><VAR>r...</VAR><CODE>;</CODE><VAR>n...</VAR><CODE>:</CODE><VAR>r...</VAR><CODE>;</CODE><VAR>n...</VAR><CODE>:</CODE><VAR>r...</VAR><CODE>;</CODE>'</SAMP>
<DD><A NAME="IDX1259"></A>
<P>

<VAR>AA</VAR> = two hex digit signal number; <VAR>n...</VAR> = register number
(hex), <VAR>r...</VAR>  = target byte ordered register contents, size defined
by <CODE>REGISTER_RAW_SIZE</CODE>; <VAR>n...</VAR> = <SAMP>`thread'</SAMP>, <VAR>r...</VAR> =
thread process ID, this is a hex integer; <VAR>n...</VAR> = (<SAMP>`watch'</SAMP> | 
<SAMP>`rwatch'</SAMP> | <SAMP>`awatch'</SAMP>, <VAR>r...</VAR> = data address, this is a hex
integer; <VAR>n...</VAR> = other string not starting with valid hex digit.
GDB should ignore this <VAR>n...</VAR>, <VAR>r...</VAR> pair and go on
to the next.  This way we can extend the protocol.
</P><P>

<DT><SAMP>`W<VAR>AA</VAR>'</SAMP>
<DD><P>

The process exited, and <VAR>AA</VAR> is the exit status.  This is only
applicable to certain targets.
</P><P>

<DT><SAMP>`X<VAR>AA</VAR>'</SAMP>
<DD><P>

The process terminated with signal <VAR>AA</VAR>.
</P><P>

<DT><SAMP>`N<VAR>AA</VAR>;<VAR>t<small>...</small></VAR>;<VAR>d<small>...</small></VAR>;<VAR>b<small>...</small></VAR> <STRONG>(obsolete)</STRONG>'</SAMP>
<DD><P>

<VAR>AA</VAR> = signal number; <VAR>t<small>...</small></VAR> = address of symbol
<CODE>_start</CODE>; <VAR>d<small>...</small></VAR> = base of data section; <VAR>b<small>...</small></VAR> =
base of bss section.  <EM>Note: only used by Cisco Systems targets.
The difference between this reply and the <SAMP>`qOffsets'</SAMP> query is that
the <SAMP>`N'</SAMP> packet may arrive spontaneously whereas the <SAMP>`qOffsets'</SAMP>
is a query initiated by the host debugger.</EM>
</P><P>

<DT><SAMP>`O<VAR>XX<small>...</small></VAR>'</SAMP>
<DD><P>

<VAR>XX<small>...</small></VAR> is hex encoding of ASCII data.  This can happen at
any time while the program is running and the debugger should continue
to wait for <SAMP>`W'</SAMP>, <SAMP>`T'</SAMP>, etc.
</P><P>

</DL>
<P>

<A NAME="General Query Packets"></A>
<HR SIZE="6">
<A NAME="SEC635"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC634"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC636"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC636"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC631"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_33.html#SEC638"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> D.4 General Query Packets </H2>
<!--docid::SEC635::-->
<P>

The following set and query packets have already been defined.
</P><P>

<DL COMPACT>

<DT><CODE>q</CODE><CODE>C</CODE> -- current thread
<DD><P>

Return the current thread id.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`<CODE>QC</CODE><VAR>pid</VAR>'</SAMP>
<DD>Where <VAR>pid</VAR> is a HEX encoded 16 bit process id.
<DT><SAMP>`*'</SAMP>
<DD>Any other reply implies the old pid.
</DL>
<P>

<DT><CODE>q</CODE><CODE>fThreadInfo</CODE> -- all thread ids
<DD><P>

<CODE>q</CODE><CODE>sThreadInfo</CODE>
</P><P>

Obtain a list of active thread ids from the target (OS).  Since there
may be too many active threads to fit into one reply packet, this query
works iteratively: it may require more than one query/reply sequence to
obtain the entire list of threads.  The first query of the sequence will
be the <CODE>qf</CODE><CODE>ThreadInfo</CODE> query; subsequent queries in the
sequence will be the <CODE>qs</CODE><CODE>ThreadInfo</CODE> query.
</P><P>

NOTE: replaces the <CODE>qL</CODE> query (see below).
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`<CODE>m</CODE><VAR>id</VAR>'</SAMP>
<DD>A single thread id
<DT><SAMP>`<CODE>m</CODE><VAR>id</VAR>,<VAR>id</VAR><small>...</small>'</SAMP>
<DD>a comma-separated list of thread ids
<DT><SAMP>`<CODE>l</CODE>'</SAMP>
<DD>(lower case 'el') denotes end of list.
</DL>
<P>

In response to each query, the target will reply with a list of one or
more thread ids, in big-endian hex, separated by commas.  GDB
will respond to each reply with a request for more thread ids (using the
<CODE>qs</CODE> form of the query), until the target responds with <CODE>l</CODE>
(lower-case el, for <CODE>'last'</CODE>).
</P><P>

<DT><CODE>q</CODE><CODE>ThreadExtraInfo</CODE><CODE>,</CODE><VAR>id</VAR> -- extra thread info
<DD><P>

Where <VAR>id</VAR> is a thread-id in big-endian hex.  Obtain a printable
string description of a thread's attributes from the target OS.  This
string may contain anything that the target OS thinks is interesting for
GDB to tell the user about the thread.  The string is displayed
in GDB's <SAMP>`info threads'</SAMP> display.  Some examples of
possible thread extra info strings are "Runnable", or "Blocked on
Mutex".
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`<VAR>XX<small>...</small></VAR>'</SAMP>
<DD>Where <VAR>XX<small>...</small></VAR> is a hex encoding of ASCII data, comprising
the printable string containing the extra information about the thread's
attributes.
</DL>
<P>

<DT><CODE>q</CODE><CODE>L</CODE><VAR>startflag</VAR><VAR>threadcount</VAR><VAR>nextthread</VAR> -- query <VAR>LIST</VAR> or <VAR>threadLIST</VAR> <STRONG>(deprecated)</STRONG>
<DD><P>

Obtain thread information from RTOS.  Where: <VAR>startflag</VAR> (one hex
digit) is one to indicate the first query and zero to indicate a
subsequent query; <VAR>threadcount</VAR> (two hex digits) is the maximum
number of threads the response packet can contain; and <VAR>nextthread</VAR>
(eight hex digits), for subsequent queries (<VAR>startflag</VAR> is zero), is
returned in the response as <VAR>argthread</VAR>.
</P><P>

NOTE: this query is replaced by the <CODE>q</CODE><CODE>fThreadInfo</CODE> query
(see above).
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`<CODE>q</CODE><CODE>M</CODE><VAR>count</VAR><VAR>done</VAR><VAR>argthread</VAR><VAR>thread<small>...</small></VAR>'</SAMP>
<DD>Where: <VAR>count</VAR> (two hex digits) is the number of threads being
returned; <VAR>done</VAR> (one hex digit) is zero to indicate more threads
and one indicates no further threads; <VAR>argthreadid</VAR> (eight hex
digits) is <VAR>nextthread</VAR> from the request packet; <VAR>thread<small>...</small></VAR>
is a sequence of thread IDs from the target.  <VAR>threadid</VAR> (eight hex
digits).  See <CODE>remote.c:parse_threadlist_response()</CODE>.
</DL>
<P>

<DT><CODE>q</CODE><CODE>CRC:</CODE><VAR>addr</VAR><CODE>,</CODE><VAR>length</VAR> -- compute CRC of memory block
<DD><P>

Reply:
<DL COMPACT>
<DT><SAMP>`<CODE>E</CODE><VAR>NN</VAR>'</SAMP>
<DD>An error (such as memory fault)
<DT><SAMP>`<CODE>C</CODE><VAR>CRC32</VAR>'</SAMP>
<DD>A 32 bit cyclic redundancy check of the specified memory region.
</DL>
<P>

<DT><CODE>q</CODE><CODE>Offsets</CODE> -- query sect offs
<DD><P>

Get section offsets that the target used when re-locating the downloaded
image.  <EM>Note: while a <CODE>Bss</CODE> offset is included in the
response, GDB ignores this and instead applies the <CODE>Data</CODE>
offset to the <CODE>Bss</CODE> section.</EM>
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`<CODE>Text=</CODE><VAR>xxx</VAR><CODE>;Data=</CODE><VAR>yyy</VAR><CODE>;Bss=</CODE><VAR>zzz</VAR>'</SAMP>
<DD></DL>
<P>

<DT><CODE>q</CODE><CODE>P</CODE><VAR>mode</VAR><VAR>threadid</VAR> -- thread info request
<DD><P>

Returns information on <VAR>threadid</VAR>.  Where: <VAR>mode</VAR> is a hex
encoded 32 bit mode; <VAR>threadid</VAR> is a hex encoded 64 bit thread ID.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`*'</SAMP>
<DD></DL>
<P>

See <CODE>remote.c:remote_unpack_thread_info_response()</CODE>.
</P><P>

<DT><CODE>q</CODE><CODE>Rcmd,</CODE><VAR>command</VAR> -- remote command
<DD><P>

<VAR>command</VAR> (hex encoded) is passed to the local interpreter for
execution.  Invalid commands should be reported using the output string.
Before the final result packet, the target may also respond with a
number of intermediate <CODE>O</CODE><VAR>output</VAR> console output packets.
<EM>Implementors should note that providing access to a stubs's
interpreter may have security implications</EM>.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`OK'</SAMP>
<DD>A command response with no output.
<DT><SAMP>`<VAR>OUTPUT</VAR>'</SAMP>
<DD>A command response with the hex encoded output string <VAR>OUTPUT</VAR>.
<DT><SAMP>`<CODE>E</CODE><VAR>NN</VAR>'</SAMP>
<DD>Indicate a badly formed request.
<DT><SAMP>`<SAMP>`'</SAMP>'</SAMP>
<DD>When <SAMP>`q'</SAMP><SAMP>`Rcmd'</SAMP> is not recognized.
</DL>
<P>

<DT><CODE>qSymbol::</CODE> -- symbol lookup
<DD><P>

Notify the target that GDB is prepared to serve symbol lookup
requests.  Accept requests from the target for the values of symbols.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`<CODE>OK</CODE>'</SAMP>
<DD>The target does not need to look up any (more) symbols.
<DT><SAMP>`<CODE>qSymbol:</CODE><VAR>sym_name</VAR>'</SAMP>
<DD>The target requests the value of symbol <VAR>sym_name</VAR> (hex encoded).
GDB may provide the value by using the
<CODE>qSymbol:</CODE><VAR>sym_value</VAR>:<VAR>sym_name</VAR> message, described below.
</DL>
<P>

<DT><CODE>qSymbol:</CODE><VAR>sym_value</VAR>:<VAR>sym_name</VAR> -- symbol value
<DD><P>

Set the value of <VAR>sym_name</VAR> to <VAR>sym_value</VAR>.
</P><P>

<VAR>sym_name</VAR> (hex encoded) is the name of a symbol whose value the
target has previously requested.
</P><P>

<VAR>sym_value</VAR> (hex) is the value for symbol <VAR>sym_name</VAR>.  If
GDB cannot supply a value for <VAR>sym_name</VAR>, then this field
will be empty.
</P><P>

Reply:
<DL COMPACT>
<DT><SAMP>`<CODE>OK</CODE>'</SAMP>
<DD>The target does not need to look up any (more) symbols.
<DT><SAMP>`<CODE>qSymbol:</CODE><VAR>sym_name</VAR>'</SAMP>
<DD>The target requests the value of a new symbol <VAR>sym_name</VAR> (hex
encoded).  GDB will continue to supply the values of symbols
(if available), until the target ceases to request them.
</DL>
<P>

</DL>
<P>

<A NAME="Register Packet Format"></A>
<HR SIZE="6">
<A NAME="SEC636"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC635"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC637"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC637"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC631"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_33.html#SEC638"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> D.5 Register Packet Format </H2>
<!--docid::SEC636::-->
<P>

The following <SAMP>`g'</SAMP>/<SAMP>`G'</SAMP> packets have previously been defined.
In the below, some thirty-two bit registers are transferred as
sixty-four bits.  Those registers should be zero/sign extended (which?)
to fill the space allocated.  Register bytes are transfered in target
byte order.  The two nibbles within a register byte are transfered
most-significant - least-significant.
</P><P>

<DL COMPACT>

<DT>MIPS32
<DD><P>

All registers are transfered as thirty-two bit quantities in the order:
32 general-purpose; sr; lo; hi; bad; cause; pc; 32 floating-point
registers; fsr; fir; fp.
</P><P>

<DT>MIPS64
<DD><P>

All registers are transfered as sixty-four bit quantities (including
thirty-two bit registers such as <CODE>sr</CODE>).  The ordering is the same
as <CODE>MIPS32</CODE>.
</P><P>

</DL>
<P>

<A NAME="Examples"></A>
<HR SIZE="6">
<A NAME="SEC637"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC636"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_33.html#SEC638"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC631"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC631"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_33.html#SEC638"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> D.6 Examples </H2>
<!--docid::SEC637::-->
<P>

Example sequence of a target being re-started.  Notice how the restart
does not get any direct output:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>-&#62; <CODE>R00</CODE>
&#60;- <CODE>+</CODE>
<EM>target restarts</EM>
-&#62; <CODE>?</CODE>
&#60;- <CODE>+</CODE>
&#60;- <CODE>T001:1234123412341234</CODE>
-&#62; <CODE>+</CODE>
</FONT></pre></td></tr></table></P><P>

Example sequence of a target being stepped by a single instruction:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>-&#62; <CODE>G1445<small>...</small></CODE>
&#60;- <CODE>+</CODE>
-&#62; <CODE>s</CODE>
&#60;- <CODE>+</CODE>
<EM>time passes</EM>
&#60;- <CODE>T001:1234123412341234</CODE>
-&#62; <CODE>+</CODE>
-&#62; <CODE>g</CODE>
&#60;- <CODE>+</CODE>
&#60;- <CODE>1455<small>...</small></CODE>
-&#62; <CODE>+</CODE>
</FONT></pre></td></tr></table></P><P>

<A NAME="Copying"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_32.html#SEC631"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_33.html#SEC638"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">

<address>

<p>Please send FSF &amp; GNU inquiries &amp; questions to <a
href="mailto:gnu@gnu.org">gnu@gnu.org</a>.  There are also <a
href="http://www.gnu.org/home.html#ContactInfo">other ways to
contact</a> the FSF.</p>

<p>These pages are maintained by <a
href="http://www.gnu.org/software/gdb/">the GDB developers</a>.</p>

<p>Copyright Free Software Foundation, Inc., 59 Temple Place - Suite
330, Boston, MA 02111, USA.</p>

<p>Verbatim copying and distribution of this entire article is
permitted in any medium, provided this notice is preserved.</p>

</address>

This document was generated
by <I>GDB Administrator</I> on <I>November, 11  2002</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>

Return-Path: <@relay.cs.net,@neat.ai.toronto.edu:erlebach@turing.toronto.edu>
From: Beverly Erlebacher <erlebach%turing.toronto.edu@relay.cs.net>
To: bob@wheaties.ai.mit.edu
Subject: texi2roff
Cc: erlebach%turing.toronto.edu@relay.cs.net
Date: 	Thu, 1 Sep 88 02:21:20 EDT

hi bob.  

someone in arizona found some pathological cases in the C++ docs that caused
texi2roff to emit troff commands that resulted in some strange output.  it
seems that there is no reliable way to get a double quote into an arbitrary
troff macro argument. i did come up with a fix that seems to work pretty 
well with -mm and -ms, and an awful kludge to take care of this case with -me.
in -me i had to replace " with '' in macro arguments. yucko.

another slightly icky problem i found was near the bottom of texinfo.texinfo
there is a case of
@group
@example
@end example
@end group
alas, -mm, unlike -ms and -me, has this idea that a "keep" (@group) is a
kind of "display" (@example) so uses the same macro with different arguments
for keeps and displays.  the example above causes texi2roff to generate
what -mm regards as an attempt at a nested display (not legit) and aborts
nroff with an error message.  i dont expect you to do anything about this,
i just wanted to tell somebody... :-)

anyhow, i made a few more changes to the program, and sent it in to rsalz.
i hope he gets it before he posts what i sent him last month.  good thing
he has been inactive, he must have a good sized backlog.

here's your copy of Release 1.0a.

yrs, b.

-----------

# More or less normal sort of shar file 
echo unbundling file: texi2roff.1 1>&2
sed -e 's/^X//' >texi2roff.1 <<'END_OF_texi2roff.1'
X.TH TEXI2ROFF 1
X.DA 31 Aug 88
X.SH NAME
Xtexi2roff \- convert Texinfo commands in documents 
Xto nroff/troff commands.
X.SH SYNOPSIS
X.B texi2roff
X.BR \-m {
X.B e
X|
X.B m
X|
X.B s
X}
X.RB [ \-It
X] [ file ... ]
X.SH DESCRIPTION
X.I texi2roff
Xconverts documents which use the Texinfo macro language for TeX
Xso they can be formatted by nroff or troff instead. 
X.PP
XThe named
X.IR file s
Xare read and processed in order. If no
X.I file
Xis given or if the
X.I file
Xis '\-'
X.I texi2roff
Xreads the standard input.
X.PP
XAll Texinfo commands are supported to some extent, even if by carefully
Xdiscarding them. Since Texinfo allows the use of arbitrary TeX
Xcommands provided the leading \e is replaced by @, some common
XTeX commands not explicitly in Texinfo are supported as well.  To
Xsee how various commands are handled examine the
Xtranslation tables.  Any command whose type is DISCARD will
Xdisappear with all contained text (unless the -t option is used).
X.PP
X.B \ef(CW
Xand 
X.B .ft\ CW
Xare used to change to constant-width (typewriter-like) font.
XIf this is not the standard at your site, run your
X.I texi2roff
Xoutput through sed or edit the translation tables.
X.SH OPTIONS
X.IP "\-m
Xindicates which macro package you intend to 
Xuse with nroff or troff.  Specify one of -me, -ms, or -mm.
XIf your site has both -ms and -msnew macros, use -msnew 
Xwith nroff/troff for better results.
X.IP "\-I
Xcauses Texinfo "Info file" menu and node contents and 'ifinfo' text
Xto appear in the output.  Info files are a kind of 
Xhypertext feature of Texinfo.  This material would not normally appear
Xin a printed Texinfo document, but may contain interesting information
Xor be useful when searching a document for a topic.
X.IP "\-t
X(transparent) prints contents of otherwise discarded commands,
Xfor people who are afraid of missing something.  For best results
Xwith the -t option, use -It.
X.SH DIAGNOSTICS
XErrors are reported giving file name and line number.
X.PP
XUnrecognized Texinfo commands may corrupt the program's command stack
Xbecause it is hard to tell how to discard them when their closing 
Xtokens are unknown. The program may guess
Xwrong about which command is at fault when giving an 
Xerror message for the closing token, but will generally
Xrecover and translate the remainder of the document after such errors.
X.SH HISTORY
XWritten in February 1988 
Xat the University of Toronto by Beverly Erlebacher
X(erlebach@csri.toronto.edu). Current version (1.0a) released in
XAugust 1988 by the same author.
X.SH BUGS
XAppendices will come out as unnumbered sections, instead of being
X"numbered" with consecutive capital letters.
XCross references are printed, but not with page numbers as Texinfo
Xdoes. Indices and tables of contents are not generated.
X.PP
XSince \efP is a toggle, not a stack, nested Texinfo commands that
Xgenerate nested font changes would not 'un-nest' correctly
Xif it were used as a close
Xto a font change.  The program needs a font stack. In the interim,
Xit uses \efR, which causes less trouble than \efP.
X.PP
XThere are a number of differences in formatting details
Xcompared to Texinfo. The -ms macros probably give the closest emulation.
XIndentation is occasionally imperfect.
X.PP
XSince literal double quotes (") cause bizarre effects
Xin macro arguments for -me macros, 
X.I texi2roff
Xreplaces them with \e(fm\e(fm (foot marks \(em \(fm\(fm)
Xwhen the -me option is used.
X.PP
X.I texi2roff
Xmay generate output which falls afoul of bugs 
Xor strange features in nroff/troff.
XThe program tries to avoid generating sequences that cause trouble.
X.PP
X"A program designed for inputs from people is
Xusually stressed beyond the breaking point by computer-generated
Xinputs." 
X.PP
X\&\(em Dennis Ritchie
END_OF_texi2roff.1
echo unbundling file: Readme 1>&2
sed -e 's/^X//' >Readme <<'END_OF_Readme'
Xtexi2roff - Texinfo to nroff/troff translator
X
XCopyright 1988  Beverly A. Erlebacher  (see copyright file)
X
XRaison d'etre:
X-------------
XI wrote texi2roff to help out Rayan Zachariassen, the author of
XZMailer.  Rayan had prepared his documentation using Texinfo at the
Xrequest of the GNU Project.  After he sent ZMailer to his alpha
Xtesters, he got many complaints from people who did not have TeX
Xinstalled and wanted documentation they could read or print with
Xnroff/troff.
X
XIn the expectation that there are other people in the same plight
Xwho would like to read documentation from the GNU project, I am
Xposting texi2roff.
X
XPlease Note:
X-----------
Xtexi2roff translates Texinfo documents, *NOT* TeX documents. Not
Xall GNU documentation uses Texinfo, although most of the recent
Xmaterial does. A Texinfo document can be distinguished from a TeX
Xdocument by the preponderance of commands starting with '@'. TeX
Xcommands start with '\'.
X
Xnroff vs. troff
X---------------
XI tested this program almost exclusively with nroff, so I expect
Xsome bugs in the troff oriented commands.  Please report bugs
X(and fixes!).
X
XPortability:
X-----------
XI developed texi2roff on Sun 2's and 3's running Sun OS 3.n and 4.0
Xand tested it on a Vax running 4.2BSD, a MIPS running 4.3BSD and an
XHP-9000 running HP-UX.  There is a -DBSD directive in the program which
Xonly controls which string header to #include and which of strchr() or
Xindex() is used.  It is reported to work with Microport SVR2, Xenix
XSystem III and several other environments. It even compiles with Turbo C
Xand runs under MSDOS (SoftQuad (sq.com) sells nroff/troff for MSDOS). 
XFor those using older C compilers, use -Dvoid=int.  
X
XThanks to Bob Webber (*not* the Bob Webber at Rutgers, this one is a
Xmetallurgist), Peter Lee, Wolf Paul, Eric Christensen and Bill Mitchell
Xfor testing this or an earlier version on a variety of machines, unix
Xvariants and compilers.
X
XIn order to make the program more portable, I've added support for -me
Xand -mm macros as well as the -ms macros it was developed with. 
XUnfortunately, the -mm macros I have here are not the standard System V
Xset. I would appreciate feedback on this - please report on any changes
Xnecessary.
X
XDesign and Future Enhancements:
X------------------------------
XBy isolating all explicit command strings in the table header files,
XI've made the program especially easy to modify and extend. Most
Xcustomizations or refinements can (and should!) be made by twiddling
Xthe strings in the tables.
X
XWhen modifying texi2roff, please respect the design, and keep all
Xexplicit roff command strings in the table header files. Note
Xthat the user's selection of macro package does not affect any code
Xin translate.c. Please strive to keep the program table-driven.
X
XI use a mixture of macros and raw commands which is causing some of
Xthe minor formatting problems.  Ideally, the program should have its
Xown macro package.
X
XMore of the discarded commands could be implemented and some of the
Xitems in the 'bugs' section of the manual page addressed.
X
XTexinfo is a moving target. I have provided crude support for some 
Xfeatures that will not appear until release 19 of Gnuemacs, since
XI dont have complete specs for them.  Most new commands can just be
Xadded to the tables and the program will handle them.
X
XI feel robustness is very important so I have made every effort to
Xdetect, report and recover gracefully from errors in the input.  As
Xtexi2roff is more than an order of magnitude faster than nroff, there
Xis no need to sacrifice other desirable attributes for speed.
X
X ...uunet!utai!utcsri!erlebach		erlebach@csri.toronto.edu
X
X	Beverly Erlebacher
X	Computer Systems Research Institute
X	10 King's College Road
X	University of Toronto,
X	Toronto, Ontario, Canada M5S 1A4
X
END_OF_Readme
echo unbundling file: copyright 1>&2
sed -e 's/^X//' >copyright <<'END_OF_copyright'
XCopyright notice for texi2roff - Texinfo to nroff/troff translator:
X
X/*
X * Copyright  1988 by  Beverly A. Erlebacher
X * Written by Beverly A. Erlebacher.  Not derived from licensed software.
X * This software is not subject to any license of the American Telephone
X * and Telegraph Company or of the Regents of the University of California.
X *
X * Permission is granted to anyone to use this software for any purpose on
X * any computer system, and to alter it and redistribute it freely, subject
X * to the following restrictions:
X *
X * 1. The author is not responsible for the consequences of use of this
X *    software, no matter how awful, even if they arise from flaws in it.
X *
X * 2. The origin of this software must not be misrepresented, either by
X *    explicit claim or by omission.  Since few users ever read sources,
X *    credits must appear in the documentation.
X *
X * 3. Altered versions must be plainly marked as such, and must not be
X *    misrepresented as being the original software.  Since few users
X *    ever read sources, credits must appear in the documentation.
X *
X * 4. This notice may not be removed or altered.
X *
X * 5. This release may be redistributed only in its original state:  existing
X *    material (e.g. sources) may not be deleted, changes may not be made to
X *    the originals, and new materials must be added as a supplementary
X *    distribution rather than interspersed with the originals.
X *
X */
X
XBeverly Erlebacher
XComputer Systems Research Institute
X10 King's College Road
XUniversity of Toronto,
XToronto, Ontario, Canada M5S 1A4
X
X ...uunet!utai!utcsri!erlebach		erlebach@csri.toronto.edu
X
END_OF_copyright
echo unbundling file: Makefile 1>&2
sed -e 's/^X//' >Makefile <<'END_OF_Makefile'
X
X# Makefile for Texinfo to nroff/troff translator (texi2roff)
X
XCC = cc
X
X# Flags:
X# -DBSD controls use of string(s).h and strchr/index only (not needed for Sun)
X# use -Dvoid=int for System III and V7
X
XCFLAGS = -O
X
XOBJECTS = texi2roff.o table.o translate.o
X
Xtexi2roff: $(OBJECTS)
X	$(CC) -o $@ $(CFLAGS) $(OBJECTS)
X
Xtexi2roff.o : texi2roff.h
X
Xtranslate.o : texi2roff.h
X
Xtable.o : texi2roff.h tablems.h tablemm.h tableme.h
X
Xclean:
X	-rm -f *.o core errs
X
Xbundle:
X	bundle texi2roff.1 Readme copyright Makefile  *.h *.c >bundled
X	ls -l bundled
END_OF_Makefile
echo unbundling file: tableme.h 1>&2
sed -e 's/^X//' >tableme.h <<'END_OF_tableme.h'
X/*
X * tableme.h - -me macros table and other explicit troff command strings
X *	     Release 1.0a	August 1988
X *
X * Copyright 1988  Beverly A.Erlebacher
X * erlebach@csri.toronto.edu	...uunet!utai!utcsri!erlebach
X *
X */
X
X/* 
X * string to emit before the first input. this is the place to put troff
X * commands controlling default point size, margin size, line length, etc.
X */
Xchar meinit[] = "";
X
X/*
X * miscellaneous commands, described in texi2roff.h 
X */
Xstruct misccmds mecmds = { "\n.pp\n", "\n.ip\n", "", "", "\\(fm\\(fm"};
X
X/*
X * patches for table entries for -I option 
X */
Xstruct tablerecd menodeentry = {
X    "@node",	"\n", "\n.lp\n\\s8Node:", "\\s0\n.br\n", PARAGRAPH};
X
Xstruct tablerecd memenuentry = {
X    "@menu",	"@end", "\n.(l I\n\\s8Menu: \n", "\\s0\n.)l\n", DISPLAY}; 
X
Xstruct tablerecd meifinfoentry = {
X    "@ifinfo",	"@end", "\n", "\n", PARAGRAPH}; 
X
Xstruct tablerecd metable[] = {
X    "@*",		"",	"\n.br\n",	"",		ESCAPED,
X    "@.",		"",	"\\&.",		"",		ESCAPED,
X    "@:",		"",	"",		"",		ESCAPED,
X    "@@",		"",	"@",		"",		ESCAPED,
X    "@TeX{",		"}",	"TeX",		"",		INPARA,
X    "@appendix",	"\n",	"\n.bp\n.uh ",	"\n.br\n",	HEADING,
X    "@appendixsec",	"\n",	"\n.uh ", 	"\n.br\n",	HEADING,
X    "@appendixsubsec",	"\n",	"\n.uh ", 	"\n.br\n",	HEADING,
X    "@appendixsubsubsec","\n",	"\n.uh ", 	"\n.br\n",	HEADING,
X    "@asis",		"\n",	"",		"",		PARAGRAPH,
X    "@asis{",		"}",	"",		"",		INPARA,
X    "@br",		"\n",	"\n.br\n.sp\n", "",		PARAGRAPH,
X    "@bullet",		"\n",	"\\(bu",	"",		CHAR,
X    "@bullet{",		"}",	"\\(bu",	"",		CHAR,
X    "@bye",		"\n",	"",		"",		DISCARD,
X    "@b{",		"}",	"\\fB",		"\\fR",		INPARA,
X    "@c",		"\n",	"",		"",		DISCARD,
X    "@center",		"\n",	"\n.ce\n",	"",		HEADING,
X    "@chapter",		"\n",	"\n.bp\n.sh 1 ","\n.br\n",	HEADING,
X    "@cindex", 		"\n",	"",		"",		DISCARD,
X    "@cite{",		"}",	"\\fI",		"\\fR",		INPARA,
X    "@code{",		"}",	"\\fB",		"\\fR",		INPARA,
X    "@comment",		"\n",	"",		"",		DISCARD,
X    "@contents",	"\n",	"",		"",		DISCARD,
X    "@copyright{",	"}",	"\\(co",	"",		CHAR,
X    "@ctrl{",		"}",	"\\f(CW^",	"\\fR",		INPARA,
X    "@dag",		"}{",	"\\(dg",	"",		CHAR,
X    "@dag{",		"}",	"\\(dg",	"",		CHAR,
X    "@ddag",		"}{",	"\\(dd",	"",		CHAR,
X    "@ddag{",		"}",	"\\(dd",	"",		CHAR,
X    "@deffn",		"@end", "\n.lp\n",	"",		HEADING,
X    "@deffnx",          "\n",   "\n.br\n",	"\n.br\n",	HEADING,
X    "@defspec",		"@end", "\n.lp\n",	"",		HEADING,
X    "@defspecx",        "\n",   "\n.br\n",	"\n.br\n",	HEADING,
X    "@defvar",		"@end", "\n.lp\n",	"",		HEADING,
X    "@defvarx",         "\n",   "\n.br\n",	"\n.br\n",	HEADING,
X    "@dfn{",		"}",	"\\fI",		"\\fR",		INPARA,
X    "@display",		"@end", "\n.(l I\n",	"\n.)l\n",	DISPLAY,
X    "@dots{",		"}",	"\\&...",	"",		INPARA,
X    "@eject",		"\n",	"\n.bp\n",	"",		PARAGRAPH,
X    "@emph{",		"}",	"\\fI",		"\\fR",		INPARA,
X    "@end",		"\n",	"",		"\n.sp\n.in\n", END,
X    "@enumerate",	"@end", "\n.(l L F\n.ba +5\n",
X					"\n.ba -5\n.)l\n",	ITEMIZING,
X    "@example",		"@end", "\n.(l I\n.ft CW\n",
X					"\n.)l\n.ft R\n",	DISPLAY,
X    "@file{",		"}",	"\\f(CW\\`",	"\\'\\fR",	INPARA,
X    "@finalout",	"\n",	"",		"",		DISCARD,
X    "@findex", 		"\n",	"",		"",		DISCARD,
X    "@footnote{",	"}",	"\n.(f \n",	"\n.)f\n",	FOOTNOTE,
X    "@group",		"@end", "\n.(b\n",	"\n.)b\n",	PARAGRAPH,
X    "@heading",		"\n",	"\n.uh ",	"\n.br\n",	HEADING,
X    "@headings",	"\n",	"",		"",		DISCARD,
X    "@iappendix",	"\n",	"\n.bp\n.uh ",	"\n.br\n",	HEADING,
X    "@iappendixsec",	"\n",	"\n.uh ",	"\n.br\n",	HEADING,
X    "@iappendixsubsec",	"\n",	"\n.uh ",	"\n.br\n",	HEADING,
X    "@ichapter",	"\n",	"\n.bp\n.uh ",	"\n.br\n",	HEADING,
X    "@ifinfo",		"@end", "",		"",		DISCARD,
X    "@iftex",		"@end", "",		"",		PARAGRAPH,
X    "@ignore",		"@end", "",		"",		DISCARD,
X    "@include",		"\n",	"",		"",		DISCARD,
X    "@inforef{",	"}",	"See Info file ","",		PARAGRAPH,
X    "@isection",	"\n",	"\n.uh ",	"\n.br\n",	HEADING,
X    "@isubsection",	"\n",	"\n.uh ",	"\n.br\n",	HEADING,
X    "@isubsubsection",	"\n",	"\n.uh ",	"\n.br\n",	HEADING,
X    "@item",		"\n",	"\n.ip ",	"\\ \n",	ITEM,
X    "@itemize",		"@end", "\n.(l L F\n.ba +5\n",
X					"\n.ba -5\n.)l\n",	ITEMIZING,
X    "@itemx",		"\n",	"\n.ip ",	"\\ \n",	ITEM,
X    "@iunnumbered",	"\n",	"\n.bp\n.uh ",	"\n.br\n",	HEADING,
X    "@iunnumberedsec",	"\n",	"\n.uh ",	"\n.br\n",	HEADING,
X    "@iunnumberedsubsec","\n",	"\n.uh ",	"\n.br\n",	HEADING,
X    "@i{",		"}",	"\\fI",		"\\fR",		INPARA,
X    "@kbd{",		"}",	"\\f(CW",	"\\fR",		INPARA,
X    "@key{",		"}",	"\\f(CW",	"\\fR",		INPARA,
X    "@kindex", 		"\n",	"",		"",		DISCARD,
X    "@majorheading",	"\n",	"\n.sp 4\n.uh ","\n.br\n",	HEADING,
X    "@menu",		"@end", "",		"",		DISCARD, 
X    "@minus{",		"}",	"\\-",		"",		CHAR,
X    "@need",		"\n",	"",		"",		DISCARD,
X    "@node",		"\n",	"",		"",		DISCARD,
X    "@noindent",	"\n",	"\n.lp\n",	"",		PARAGRAPH,
X    "@page",		"\n",	"\n.bp\n",	"",		PARAGRAPH,
X    "@pindex", 		"\n",	"",		"",		DISCARD,
X    "@printindex",	"\n",	"",		"",		DISCARD,
X    "@pxref{",		"}",	"see section  ","",		PARAGRAPH,
X    "@quotation",	"@end", "\n.(q\n.nh\n", "\n.)q\n",	DISPLAY,
X    "@r{",		"}",	"\\fR",		"\\fR",		INPARA,
X    "@refill",		"\n",	"",		"",		DISCARD,
X    "@samp{",		"}",	"\\f(CW\\`",	"\\'\\fR",	INPARA,
X    "@section",		"\n",	"\n.sh 2 ",	"\n.br\n",	HEADING,
X    "@setchapternewpage","\n",	"",		"",		DISCARD,
X    "@setfilename",	"\n",	"",		"",		DISCARD,
X    "@settitle",	"\n",	"\n.ds St ",
X		"\n.oh '\\\\*(St''%'\n.eh '%''\\\\*(St'\n",	HEADING,
X    "@smallbook",	"\n",	"",		"",		DISCARD,
X    "@smallexample",	"@end", "\n.(l I\n.ft CW\n",
X					"\n.)l\n.ft R\n",	DISPLAY,
X    "@sp",		"\n",	"\n.sp",	"\n",		PARAGRAPH,
X    "@strong{",		"}",	"\\fB",		"\\fR",		INPARA,
X    "@subheading",	"\n",	"\n.uh ",	"\n.br\n",	HEADING,
X    "@subsection",	"\n",	"\n.sh 3 ",	"\n.br\n",	HEADING,
X    "@subsubheading",	"\n",	"\n.uh ",	"\n.br\n",	HEADING,
X    "@subsubsection",	"\n",	"\n.sh 4 ",	"\n.br\n",	HEADING,
X    "@summarycontents", "\n",	"",		"",		DISCARD,
X    "@synindex",	"\n",	"",		"",		DISCARD,
X    "@t",		"\n",	"\t",		"",		CHAR,
X    "@table",		"@end", "\n.(l L F\n.ba +5\n",
X					"\n.ba -5\n.)l\n",	ITEMIZING,
X    "@tex",		"@end", "",		"",		DISCARD, 
X    "@tindex", 		"\n",	"",		"",		DISCARD,
X    "@titlefont{",	"}",	"\n.sz +10\n.ce\n",
X						"\n.sz -10\n",	PARAGRAPH,
X    "@titlepage",	"@end", "\n.tp\n",	"\n.bp\n",	PARAGRAPH,
X    "@t{",		"}",	"\\f(CW",	"\\fR",		INPARA,
X    "@unnumbered",	"\n",	"\n.bp\n.uh ",	"\n.br\n",	HEADING,
X    "@unnumberedsec",	"\n",	"\n.uh ",	"\n.br\n",	HEADING,
X    "@unnumberedsubsec","\n",	"\n.uh ",	"\n.br\n",	HEADING,
X    "@unnumberedsubsubsec","\n","\n.uh ",	"\n.br\n",	HEADING,
X    "@var{",		"}",	"\\fI",		"\\fR",		INPARA,
X    "@vfil", 		"\n",	"",		"",		DISCARD,
X    "@vindex", 		"\n",	"",		"",		DISCARD,
X    "@vskip",		"\n",	"",		"",		DISCARD,
X    "@w{",		"}",	"\n\\! ",	"\n",		INPARA,
X    "@xref{",		"}",	"See section ",	"",		PARAGRAPH,
X    "@{",		"",	"{",		"",		ESCAPED,
X    "@}",		"",	"}",		"",		ESCAPED
X};
X
END_OF_tableme.h
echo unbundling file: tablemm.h 1>&2
sed -e 's/^X//' >tablemm.h <<'END_OF_tablemm.h'
X/*
X * tablemm.h - -mm macros table and other explicit troff command strings
X *	     Release 1.0a	August 1988
X *
X * Copyright 1988  Beverly A.Erlebacher
X * erlebach@csri.toronto.edu	...uunet!utai!utcsri!erlebach
X *
X */
X
X/* 
X * string to emit before the first input. this is the place to put troff
X * commands controlling default point size, margin size, line length, etc.
X */
Xchar mminit[] =  ".PH '''\n.SA 1\n";
X
X/*
X * miscellaneous commands, described in texi2roff.h
X */
Xstruct misccmds mmcmds = { "\n.P 1\n", "\n.P 0\n", "", "", "\""};
X
X/*
X * patches for table entries for -I option
X */
Xstruct tablerecd mmnodeentry = {
X    "@node",	"\n", "\n.P 0\n\\s8Node:", "\\s0\n.br\n", PARAGRAPH};
X
Xstruct tablerecd mmmenuentry = {
X    "@menu",	"@end", "\n.DS L\n\\s8Menu: \n", "\\s0\n.DE\n", DISPLAY}; 
X
Xstruct tablerecd mmifinfoentry = {
X    "@ifinfo",	"@end", "\n", "\n", PARAGRAPH}; 
X
Xstruct tablerecd mmtable[] = {
X    "@*",		"",	"\n.br\n",	"",		ESCAPED,
X    "@.",		"",	"\\&.",		"",		ESCAPED,
X    "@:",		"",	"",		"",		ESCAPED,
X    "@@",		"",	"@",		"",		ESCAPED,
X    "@TeX{",		"}",	"TeX",		"",		INPARA,
X    "@appendix",	"\n",	"\n.bp\n.H ",	"\n.br\n",	HEADING,
X    "@appendixsec",	"\n",	"\n.H ",	"\n.br\n",	HEADING,
X    "@appendixsubsec",	"\n",	"\n.H ",	"\n.br\n",	HEADING,
X    "@appendixsubsubsec","\n",	"\n.H ",	"\n.br\n",	HEADING,
X    "@asis",		"\n",	"",		"",		PARAGRAPH,
X    "@asis{",		"}",	"",		"",		INPARA,
X    "@br",		"\n",	"\n.br\n.sp\n", "",		PARAGRAPH,
X    "@bullet",		"\n",	"\\(bu",	"",		CHAR,
X    "@bullet{",		"}",	"\\(bu",	"",		CHAR,
X    "@bye",		"\n",	"",		"",		DISCARD,
X    "@b{",		"}",	"\\fB",		"\\fR",		INPARA,
X    "@c",		"\n",	"",		"",		DISCARD,
X    "@center",		"\n",	"\n.ce\n",	"",		HEADING,
X    "@chapter",		"\n",	"\n.bp\n.H 1 ", "\n.br\n",	HEADING,
X    "@cindex",		"\n",	"",		"",		DISCARD,
X    "@cite{",		"}",	"\\fI",		"\\fR",		INPARA,
X    "@code{",		"}",	"\\fB",		"\\fR",		INPARA,
X    "@comment",		"\n",	"",		"",		DISCARD,
X    "@contents",	"\n",	"",		"",		DISCARD,
X    "@copyright{",	"}",	"\\(co",	"",		CHAR,
X    "@ctrl{",		"}",	"\\f(CW^",	"\\fR",		INPARA,
X    "@dag",		"}{",	"\\(dg",	"",		CHAR,
X    "@dag{",		"}",	"\\(dg",	"",		CHAR,
X    "@ddag",		"}{",	"\\(dd",	"",		CHAR,
X    "@ddag{",		"}",	"\\(dd",	"",		CHAR,
X    "@deffn",		"@end", "\n\\&\n.br\n",	"",		HEADING,
X    "@deffnx",		"\n",   "\n.br\n",	"\n.br\n",	HEADING,
X    "@defspec",		"@end", "\n\\&\n.br\n",	"",		HEADING,
X    "@defspecx",	"\n",   "\n.br\n",	"\n.br\n",	HEADING,
X    "@defvar",		"@end", "\n\\&\n.br\n",	"",		HEADING,
X    "@defvarx",		"\n",   "\n.br\n",	"\n.br\n",	HEADING,
X    "@dfn{",		"}",	"\\fI",		"\\fR",		INPARA,
X    "@display",		"@end", "\n.DS\n",	"\n.DE\n",	DISPLAY,
X    "@dots{",		"}",	"\\&...",	"",		INPARA,
X    "@eject",		"\n",	"\n.bp\n",	"",		PARAGRAPH,
X    "@emph{",		"}",	"\\fI",		"\\fR",		INPARA,
X    "@end",		"\n",	"",		"\n.sp\n.in\n", END,
X    "@enumerate",	"@end", "\n.VL 5 0\n",	"\n.LE\n",	ITEMIZING,
X    "@example",		"@end", "\n.DS 1\n.ft CW\n",
X					"\n.DE\n.ft R\n",	DISPLAY,
X    "@file{",		"}",	"\\f(CW\\`",	"\\'\\fR",	INPARA,
X    "@finalout",	"\n",	"",		"",		DISCARD,
X    "@findex",		"\n",	"",		"",		DISCARD,
X    "@footnote{",	"}",	"\n.FS \n",	"\n.FE\n",	FOOTNOTE,
X    "@group",		"@end", "\n.DS L F\n",	"\n.DE\n",	PARAGRAPH,
X    "@heading",		"\n",	"\n.sp 2\n.HU ","\n.br\n",	HEADING,
X    "@headings",	"\n",	"",		"",		DISCARD,
X    "@iappendix",	"\n",	"\n.bp\n.HU ",	"\n.br\n",	HEADING,
X    "@iappendixsec",	"\n",	"\n.HU ",	"\n.br\n",	HEADING,
X    "@iappendixsubsec",	"\n",	"\n.HU ",	"\n.br\n",	HEADING,
X    "@ichapter",	"\n",	"\n.bp\n.HU ",	"\n.br\n",	HEADING,
X    "@ifinfo",		"@end", "",		"",		DISCARD,
X    "@iftex",		"@end", "",		"",		PARAGRAPH,
X    "@ignore",		"@end", "",		"",		DISCARD,
X    "@include",		"\n",	"",		"",		DISCARD,
X    "@inforef{",	"}",	"See Info file ","",		PARAGRAPH,
X    "@isection",	"\n",	"\n.HU ",	"\n.br\n",	HEADING,
X    "@isubsection",	"\n",	"\n.HU ",	"\n.br\n",	HEADING,
X    "@isubsubsection",	"\n",	"\n.HU ",	"\n.br\n",	HEADING,
X    "@item",		"\n",	"\n.LI ",	"\\ \n",	ITEM,
X    "@itemize",		"@end", "\n.VL 5 0\n",	"\n.LE\n",	ITEMIZING,
X    "@itemx",		"\n",	"\n.LI ",	"\\ \n",	ITEM,
X    "@iunnumbered",	"\n",	"\n.bp\n.HU ",	"\n.br\n",	HEADING,
X    "@iunnumberedsec",	"\n",	"\n.HU ",	"\n.br\n",	HEADING,
X    "@iunnumberedsubsec","\n",	"\n.HU ",	"\n.br\n",	HEADING,
X    "@i{",		"}",	"\\fI",		"\\fR",		INPARA,
X    "@kbd{",		"}",	"\\f(CW",	"\\fR",		INPARA,
X    "@key{",		"}",	"\\f(CW",	"\\fR",		INPARA,
X    "@kindex",		"\n",	"",		"",		DISCARD,
X    "@majorheading",	"\n",	"\n.sp 4\n.HU ","\n.br\n",	HEADING,
X    "@menu",		"@end", "",		"",		DISCARD, 
X    "@minus{",		"}",	"\\-",		"",		CHAR,
X    "@need",		"\n",	"",		"",		DISCARD,
X    "@node",		"\n",	"",		"",		DISCARD,
X    "@noindent",	"\n",	"\n.P 0\n",	"",		PARAGRAPH,
X    "@page",		"\n",	"\n.bp\n",	"",		PARAGRAPH,
X    "@pindex",		"\n",	"",		"",		DISCARD,
X    "@printindex",	"\n",	"",		"",		DISCARD,
X    "@pxref{",		"}",	"see section ",	"",		PARAGRAPH,
X    "@quotation",	"@end", "\n.DS I F 5\n.nh\n", "\n.DE\n",DISPLAY,
X    "@r{",		"}",	"\\fR",		"\\fR",		INPARA,
X    "@refill",		"\n",	"",		"",		DISCARD,
X    "@samp{",		"}",	"\\f(CW\\`",	"\\'\\fR",	INPARA,
X    "@section",		"\n",	"\n.H 2 ",	"\n.br\n",	HEADING,
X    "@setchapternewpage","\n",	"",		"",		DISCARD,
X    "@setfilename",	"\n",	"",		"",		DISCARD,
X    "@settitle",	"\n",	"\n.ds St ",
X		     "\n.OH '\\\\*(St''%'\n.EH '%''\\\\*(St'\n",HEADING,
X    "@sp",		"\n",	"\n.sp",	"\n",		PARAGRAPH,
X    "@smallbook",	"\n",	"",		"",		DISCARD,
X    "@smallexample",	"@end", "\n.DS 1\n.ft CW\n",
X					"\n.DE\n.ft R\n",	DISPLAY,
X    "@strong{",		"}",	"\\fB",		"\\fR",		INPARA,
X    "@subheading",	"\n",	"\n.HU ",	"\n.br\n",	HEADING,
X    "@subsection",	"\n",	"\n.H 3 ",	"\n.br\n",	HEADING,
X    "@subsubheading",	"\n",	"\n.HU ",	"\n.br\n",	HEADING,
X    "@subsubsection",	"\n",	"\n.H 4 ",	"\n.br\n",	HEADING,
X    "@summarycontents", "\n",	"",		"",		DISCARD,
X    "@synindex",	"\n",	"",		"",		DISCARD,
X    "@t",		"\n",	"\t",		"",		CHAR,
X    "@table",		"@end", "\n.VL 5 0\n",	"\n.LE\n",	ITEMIZING,
X    "@tex",		"@end", "",		"",		DISCARD, 
X    "@tindex",		"\n",	"",		"",		DISCARD,
X    "@titlefont{",	"}",	"\n.ps +10\n.ce\n",
X						 "\n.ps -10\n",	PARAGRAPH,
X    "@titlepage",	"@end", "",		"\n.bp\n",	PARAGRAPH,
X    "@t{",		"}",	"\\f(CW",	"\\fR",		INPARA,
X    "@unnumbered",	"\n",	"\n.bp\n.HU ",	"\n.br\n",	HEADING,
X    "@unnumberedsec",	"\n",	"\n.HU ",	"\n.br\n",	HEADING,
X    "@unnumberedsubsec","\n",	"\n.HU ",	"\n.br\n",	HEADING,
X    "@unnumberedsubsubsec","\n","\n.HU ",	"\n.br\n",	HEADING,
X    "@var{",		"}",	"\\fI",		"\\fR",		INPARA,
X    "@vfil",		"\n",	"",		"",		DISCARD,
X    "@vindex",		"\n",	"",		"",		DISCARD,
X    "@vskip",		"\n",	"",		"",		DISCARD,
X    "@w{",		"}",	"\n\\! ",	"\n",		INPARA,
X    "@xref{",		"}",	"See section ",	"",		PARAGRAPH,
X    "@{",		"",	"{",		"",		ESCAPED,
X    "@}",		"",	"}",		"",		ESCAPED
X};
END_OF_tablemm.h
echo unbundling file: tablems.h 1>&2
sed -e 's/^X//' >tablems.h <<'END_OF_tablems.h'
X/*
X * tablems.h - -ms macros table and other explicit troff command strings
X *	     Release 1.0a	August 1988
X *
X * Copyright 1988  Beverly A.Erlebacher
X * erlebach@csri.toronto.edu	...uunet!utai!utcsri!erlebach
X *
X */
X
X/* 
X * string to emit before the first input. this is the place to put troff
X * commands controlling default point size, margin size, line length, etc.
X */
Xchar msinit[] = ".ND\n"; /* .ND suppresses date in footing */
X
X/*
X * miscellaneous commands, described in texi2roff.h
X */
Xstruct misccmds mscmds = { "\n.PP\n", "\n.IP\n", "\n.RS\n", "\n.RE\n", "\""};
X
X/*
X * patches for table entries for -I option
X */
Xstruct tablerecd msnodeentry = {
X    "@node",	"\n", "\n.LP\n\\s8Node:", "\\s0\n.br\n", PARAGRAPH};
X
Xstruct tablerecd msmenuentry = {
X    "@menu",	"@end", "\n.DS L\n\\s8Menu: \n", "\\s0\n.DE\n", DISPLAY}; 
X
Xstruct tablerecd msifinfoentry = {
X    "@ifinfo",	"@end", "\n", "\n", PARAGRAPH}; 
X
Xstruct tablerecd mstable[] = {
X    "@*",		"",	"\n.br\n",	"",		ESCAPED,
X    "@.",		"",	"\\&.",		"",		ESCAPED,
X    "@:",		"",	"",		"",		ESCAPED,
X    "@@",		"",	"@",		"",		ESCAPED,
X    "@TeX{",		"}",	"TeX",		"",		INPARA,
X    "@appendix",	"\n",	"\n.bp\n.SH\n", "\n.br\n",	HEADING,
X    "@appendixsec",	"\n",	"\n.SH\n",	"\n.br\n",	HEADING,
X    "@appendixsubsec",	"\n",	"\n.SH\n",	"\n.br\n",	HEADING,
X    "@appendixsubsubsec","\n",	"\n.SH\n",	"\n.br\n",	HEADING,
X    "@asis",		"\n",	"",		"",		PARAGRAPH,
X    "@asis{",		"}",	"",		"",		INPARA,
X    "@br",		"\n",	"\n.br\n.sp\n", "",		PARAGRAPH,
X    "@bullet",		"\n",	"\\(bu",	"",		CHAR,
X    "@bullet{",		"}",	"\\(bu",	"",		CHAR,
X    "@bye",		"\n",	"",		"",		DISCARD,
X    "@b{",		"}",	"\\fB",		"\\fR",		INPARA,
X    "@c",		"\n",	"",		"",		DISCARD,
X    "@center",		"\n",	"\n.ce\n",	"",		HEADING,
X    "@chapter",		"\n",	"\n.bp\n.NH\n", "\n.br\n",	HEADING,
X    "@cindex",		"\n",	"",		"",		DISCARD,
X    "@cite{",		"}",	"\\fI",		"\\fR",		INPARA,
X    "@code{",		"}",	"\\fB",		"\\fR",		INPARA,
X    "@comment",		"\n",	"",		"",		DISCARD,
X    "@contents",	"\n",	"",		"",		DISCARD,
X    "@copyright{",	"}",	"\\(co",	"",		CHAR,
X    "@ctrl{",		"}",	"\\f(CW^",	"\\fR",		INPARA,
X    "@dag",		"}{",	"\\(dg",	"",		CHAR,
X    "@dag{",		"}",	"\\(dg",	"",		CHAR,
X    "@ddag",		"}{",	"\\(dd",	"",		CHAR,
X    "@ddag{",		"}",	"\\(dd",	"",		CHAR,
X    "@deffn",		"@end", "\n.LP\n",	"",		HEADING,
X    "@deffnx",		"\n", 	"\n.br\n",	"\n.br\n",	HEADING,
X    "@defspec",		"@end", "\n.LP\n",	"",		HEADING,
X    "@defspecx",	"\n", 	"\n.br\n",	"\n.br\n",	HEADING,
X    "@defvar",		"@end", "\n.LP\n",	"",		HEADING,
X    "@defvarx",		"\n", 	"\n.br\n",	"\n.br\n",	HEADING,
X    "@dfn{",		"}",	"\\fI",		"\\fR",		INPARA,
X    "@display",		"@end", "\n.DS\n",	"\n.DE\n",	DISPLAY,
X    "@dots{",		"}",	"\\&...",	"",		INPARA,
X    "@eject",		"\n",	"\n.bp\n",	"",		PARAGRAPH,
X    "@emph{",		"}",	"\\fI",		"\\fR",		INPARA,
X    "@end",		"\n",	"",		"\n.sp\n.in\n", END,
X    "@enumerate",	"@end", "\n",		"\n",		ITEMIZING,
X    "@example",		"@end", "\n.DS\n.ft CW\n",
X					"\n.DE\n.ft R\n",	DISPLAY,
X    "@file{",		"}",	"\\f(CW\\`",	"\\'\\fR",	INPARA,
X    "@finalout",	"\n",	"",		"",		DISCARD,
X    "@findex",		"\n",	"",		"",		DISCARD,
X    "@footnote{",	"}",	"\n.FS \n",	"\n.FE\n",	FOOTNOTE,
X    "@group",		"@end", "\n.KS\n",	"\n.KE\n",	PARAGRAPH,
X    "@heading",		"\n",	"\n.sp 2\n.SH\n","\n.br\n",	HEADING,
X    "@headings",	"\n",	"",		"",		DISCARD,
X    "@iappendix",	"\n",	"\n.bp\n.SH\n", "\n.br\n",	HEADING,
X    "@iappendixsec",	"\n",	"\n.SH\n",	"\n.br\n",	HEADING,
X    "@iappendixsubsec",	"\n",	"\n.SH\n",	"\n.br\n",	HEADING,
X    "@ichapter",	"\n",	"\n.bp\n.SH\n", "\n.br\n",	HEADING,
X    "@ifinfo",		"@end", "",		"",		DISCARD,
X    "@iftex",		"@end", "",		"",		PARAGRAPH,
X    "@ignore",		"@end", "",		"",		DISCARD,
X    "@include",		"\n",	"",		"",		DISCARD,
X    "@inforef{",	"}",	"See Info file ","",		PARAGRAPH,
X    "@isection",	"\n",	"\n.SH\n",	"\n.br\n",	HEADING,
X    "@isubsection",	"\n",	"\n.SH\n",	"\n.br\n",	HEADING,
X    "@isubsubsection",	"\n",	"\n.SH\n",	"\n.br\n",	HEADING,
X    "@item",		"\n",	"\n.IP ",	"\\ \n",	ITEM,
X    "@itemize",		"@end", "\n",		"\n",		ITEMIZING,
X    "@itemx",		"\n",	"\n.IP ",	"\\ \n",	ITEM,
X    "@iunnumbered",	"\n",	"\n.bp\n.SH\n", "\n.br\n",	HEADING,
X    "@iunnumberedsec",	"\n",	"\n.SH\n",	"\n.br\n",	HEADING,
X    "@iunnumberedsubsec","\n",	"\n.SH\n",	"\n.br\n",	HEADING,
X    "@i{",		"}",	"\\fI",		"\\fR",		INPARA,
X    "@kbd{",		"}",	"\\f(CW",	"\\fR",		INPARA,
X    "@key{",		"}",	"\\f(CW",	"\\fR",		INPARA,
X    "@kindex",		"\n",	"",		"",		DISCARD,
X    "@majorheading",	"\n",	"\n.sp 4\n.SH\n","\n.br\n",	HEADING,
X    "@menu",		"@end", "",		"",		DISCARD, 
X    "@minus{",		"}",	"\\-",		"",		CHAR,
X    "@need",		"\n",	"",		"",		DISCARD,
X    "@node",		"\n",	"",		"",		DISCARD,
X    "@noindent",	"\n",	"\n.LP\n",	"",		PARAGRAPH,
X    "@page",		"\n",	"\n.bp\n",	"",		PARAGRAPH,
X    "@pindex",		"\n",	"",		"",		DISCARD,
X    "@printindex",	"\n",	"",		"",		DISCARD,
X    "@pxref{",		"}",	"see section ",	"",		PARAGRAPH,
X    "@quotation",	"@end", "\n.QP\n.nh\n", "\n.PP\n",	DISPLAY,
X    "@r{",		"}",	"\\fR",		"\\fR",		INPARA,
X    "@refill",		"\n",	"",		"",		DISCARD,
X    "@samp{",		"}",	"\\f(CW\\`",	"\\'\\fR",	INPARA,
X    "@section",		"\n",	"\n.NH 2\n",	"\n.br\n",	HEADING,
X    "@setchapternewpage","\n",	"",		"",		DISCARD,
X    "@setfilename",	"\n",	"",		"",		DISCARD,
X    "@settitle",	"\n",	"\n.ds St ",
X		     "\n.OH '\\\\*(St''%'\n.EH '%''\\\\*(St'\n",HEADING,
X    "@smallbook",	"\n",	"",		"",		DISCARD,
X    "@smallexample",	"@end", "\n.DS\n.ft CW\n",
X					"\n.DE\n.ft R\n",	DISPLAY,
X    "@sp",		"\n",	"\n.sp",	"\n",		PARAGRAPH,
X    "@strong{",		"}",	"\\fB",		"\\fR",		INPARA,
X    "@subheading",	"\n",	"\n.SH\n",	"\n.br\n",	HEADING,
X    "@subsection",	"\n",	"\n.NH 3\n",	"\n.br\n",	HEADING,
X    "@subsubheading",	"\n",	"\n.SH\n",	"\n.br\n",	HEADING,
X    "@subsubsection",	"\n",	"\n.NH 4\n",	"\n.br\n",	HEADING,
X    "@summarycontents", "\n",	"",		"",		DISCARD,
X    "@synindex",	"\n",	"",		"",		DISCARD,
X    "@t",		"\n",	"\t",		"",		CHAR,
X    "@table",		"@end", "\n",		"\n",		ITEMIZING,
X    "@tex",		"@end", "",		"",		DISCARD, 
X    "@tindex",		"\n",	"",		"",		DISCARD,
X    "@titlefont{",	"}",	"\n.ps +10\n.ce\n",
X						 "\n.ps -10\n",	PARAGRAPH,
X    "@titlepage",	"@end", "",		"\n.bp\n",	PARAGRAPH,
X    "@t{",		"}",	"\\f(CW",	"\\fR",		INPARA,
X    "@unnumbered",	"\n",	"\n.bp\n.SH\n", "\n.br\n",	HEADING,
X    "@unnumberedsec",	"\n",	"\n.SH\n",	"\n.br\n",	HEADING,
X    "@unnumberedsubsec","\n",	"\n.SH\n",	"\n.br\n",	HEADING,
X    "@unnumberedsubsubsec","\n","\n.SH\n",	"\n.br\n",	HEADING,
X    "@var{",		"}",	"\\fI",		"\\fR",		INPARA,
X    "@vfil",		"\n",	"",		"",		DISCARD,
X    "@vindex",		"\n",	"",		"",		DISCARD,
X    "@vskip",		"\n",	"",		"",		DISCARD,
X    "@w{",		"}",	"\n\\! ",	"\n",		INPARA,
X    "@xref{",		"}",	"See section ",	"",		PARAGRAPH,
X    "@{",		"",	"{",		"",		ESCAPED,
X    "@}",		"",	"}",		"",		ESCAPED
X};
END_OF_tablems.h
echo unbundling file: texi2roff.h 1>&2
sed -e 's/^X//' >texi2roff.h <<'END_OF_texi2roff.h'
X/*
X * texi2roff.h - header for Texinfo to nroff/troff translator texi2roff
X *	     Release 1.0a	August 1988
X *
X * Copyright 1988  Beverly A.Erlebacher
X * erlebach@csri.toronto.edu	...uunet!utai!utcsri!erlebach
X *
X */
X
X/* miscellaneous troff command strings in macro header files. */
Xstruct misccmds {
X    char * dfltpara;	/* emit when 2 consecutive newlines are detected */
X			/* in the input and the indentation level is <= 1. */
X    char * dfltipara;	/* same but for indentation level > 1.  */
X    char * indentstart; /* emit to increase indent level for itemized list */
X    char * indentend;	/* emit to decrease indent level for itemized list */
X    char * dblquote	/* emit to get double quote in macro argument. 	
X			 * although a literal " seems to work for -mm and 
X			 * -ms, -me chokes on it. if you have trouble with
X			 * -ms or -mm and ", use the -me string. if you
X			 * have SoftQuad's nroff/troff, you can use "\(dq"
X			 */
X};
X
Xextern struct misccmds * cmds;
X
Xstruct tablerecd {
X    char *  texstart;	/* starting token for a Texinfo command */
X    char *  texend;	/* ending token for a Texinfo command */
X    char *  trfstart;	/* troff commands to emit when texstart is found */
X    char *  trfend;	/* troff commands to emit when texend is found */
X    int	    type;	/* kind of Texinfo command, as #defined below */
X};
X
Xextern struct tablerecd * table;
Xextern int tablesize;
X
X/* Texinfo command types */
X
X#define ESCAPED	    0	/* special character (special to Texinfo) */
X#define INPARA	    1	/* in-paragraph command */
X#define HEADING	    2	/* chapter structuring command */
X#define DISCARD	    3	/* not supported - discard following text */
X#define PARAGRAPH   4	/* applies to following paragraph */
X#define ITEMIZING   5	/* starts itemized list */
X#define ITEM	    6	/* item in list */
X#define END	    7	/* end construct */
X#define CHAR	    8	/* really special char: dagger, bullet - scary, eh? */
X#define	FOOTNOTE    9	/* footnote */
X#define DISPLAY    10	/* text block of the kind called a 'display' */
X 
X/* nroff/troff macro packages supported */
X#define NONE	0	/* dummy value for error detection */
X#define MS	1
X#define ME	2
X#define MM	3
X
X/* useful confusion-reducing things */
X#define STREQ(s,t) (*(s)==*(t) && strcmp(s, t)==0)
X#define NO	0
X#define YES	1
END_OF_texi2roff.h
echo unbundling file: table.c 1>&2
sed -e 's/^X//' >table.c <<'END_OF_table.c'
X/*
X * table.c - set up translation tables for texi2roff
X *	     Release 1.0a	August 1988
X *
X * Copyright 1988  Beverly A.Erlebacher
X * erlebach@csri.toronto.edu	...uunet!utai!utcsri!erlebach
X *
X * When adding more commands: 
X *
X * - be sure that gettoken() can recognize not just the ending token
X *   (texend) but also the end of the starting token (texstart) for
X *   the command, if it doesnt already occur in a table.
X *
X * - keep the tables sorted
X *
X * - keep all troff output strings in the table macro header files
X *
X * - strive diligently to keep the program table-driven
X */
X
X#include <stdio.h>	/* just to get NULL */
X#include "texi2roff.h"
X#include "tablems.h"
X#include "tableme.h"
X#include "tablemm.h"
X
Xstruct misccmds * cmds;
Xstruct tablerecd * table;
Xint tablesize;
X
Xvoid
Xinitialize(macropkg, showInfo)
Xint macropkg;
Xint showInfo;
X{
X    extern void patchtable();
X
X    switch (macropkg) {
X    case MS:
X	table = mstable;
X	tablesize = sizeof mstable;
X	cmds = &mscmds;
X	if (showInfo == YES)
X	    (void) patchtable( &msnodeentry, &msmenuentry, &msifinfoentry);
X	puts(msinit);
X	break;
X    case MM:
X	table = mmtable;
X	tablesize = sizeof mmtable;
X	cmds = &mmcmds;
X	if (showInfo == YES)
X	  (void) patchtable( &mmnodeentry, &mmmenuentry, &mmifinfoentry);
X	puts(mminit);
X	break;
X    case ME:
X	table = metable;
X	tablesize = sizeof metable;
X	cmds = &mecmds;
X	if (showInfo == YES)
X	   (void) patchtable( &menodeentry, &memenuentry, &meifinfoentry);
X	puts( meinit);
X	break;
X    }
X}
X
X/*
X * real Texinfo has a sort of hypertext feature called Info files,
X * using menus, nodes and 'ifinfo' sections. Although i can't simulate
X * this here, and the material would not normally be printed by Texinfo,
X * it could be useful to the user searching through a machine-readable
X * manual. Specifying the -I option patches the table with alternative
X * troff commands to display rather than discard this material.
X */
X
Xvoid
Xpatchtable(nodeentry, menuentry, ifinfoentry)
Xstruct tablerecd * nodeentry;
Xstruct tablerecd * menuentry;
Xstruct tablerecd * ifinfoentry;
X{
X    struct tablerecd * tp;
X    extern struct tablerecd * lookup();
X
X    /* not everybody has structure assignment */
X    if ((tp = lookup("@menu")) != NULL) {
X	tp->trfstart = menuentry->trfstart;
X	tp->trfend = menuentry->trfend;
X	tp->type = menuentry->type;
X    }
X    if ((tp = lookup("@node")) != NULL) {
X	tp->trfstart = nodeentry->trfstart;
X	tp->trfend = nodeentry->trfend;
X	tp->type = nodeentry->type;
X    }
X    if ((tp = lookup("@ifinfo")) != NULL) {
X	tp->trfstart = ifinfoentry->trfstart;
X	tp->trfend = ifinfoentry->trfend;
X	tp->type = ifinfoentry->type;
X    }
X}
END_OF_table.c
echo unbundling file: texi2roff.c 1>&2
sed -e 's/^X//' >texi2roff.c <<'END_OF_texi2roff.c'
X/*
X * texi2roff.c - mainline for Texinfo to nroff/troff translator texi2roff
X * 		Release 1.0a 	August 1988
X *
X * Copyright 1988 Beverly A.Erlebacher
X * erlebach@csri.toronto.edu	...uunet!utai!utcsri!erlebach
X *
X */
X
X#include <stdio.h>
X#ifndef __TURBOC__
X#include <sys/types.h>
X#endif
X#include <sys/stat.h>
X#include "texi2roff.h"
X
Xchar *progname;
Xint transparent = NO;	/* for -t flag */
X
X/*
X * main - parse arguments, handle options
X *	- initialize tables and other strings
X * 	- open files and pass them to process().
X */
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X    int c, errflg = 0;
X    FILE *in;
X    char *inname;
X    int macropkg = NONE;	/* user's choice of MS, ME or MM */
X    int showInfo = NO; 	/* for -I flag: whether to display Info file material*/
X
X    extern int optind;
X    extern char *optarg;
X    extern int process();
X    extern void initialize();
X
X    progname = argv[0];
X
X    while ((c = getopt(argc, argv, "tIm:--")) != EOF)
X	switch (c) {
X  	case 't':
X  	    transparent = YES;
X  	    break;
X	case 'I':
X	    showInfo = YES;
X	    break;
X	case 'm':
X	    if (macropkg != NONE) {
X		errflg++;
X	    } else {
X		switch ( (char) *optarg) {
X		case 's':
X		    macropkg = MS;
X		    break;
X		case 'm':
X		    macropkg = MM;
X		    break;
X		case 'e':
X		    macropkg = ME;
X		    break;
X		default:
X		    errflg++;
X		    break;
X		}
X	    }
X	    break;
X	case '?':
X	    errflg++;
X	    break;
X	}
X
X    if (macropkg == NONE) {
X	errflg++;
X	}
X    if (errflg) {
X	(void) fprintf(stderr, "Usage: %s [-It] -m{e|m|s} [file ... ]\n",
X								progname);
X	exit(1);
X    }
X
X    (void) initialize(macropkg, showInfo);
X
X    if (optind >= argc) {
X	errflg += process(stdin, "stdin");
X	}
X    else
X	for (; optind < argc; optind++) {
X	    if (STREQ(argv[optind], "-")) {
X		inname = "stdin";
X		in = stdin;
X		}
X	    else {
X		if (( in = fopen(argv[optind], "r")) == NULL) {
X		    fprintf(stderr,"%s : can't open file %s\n",
X			    progname, argv[optind]);
X		    continue;
X		}
X		inname = argv[optind];
X	    }
X	    errflg += process(in, inname);
X	    if (in != stdin)
X		(void) fclose(in);
X	}
X    exit(errflg);
X}
X
X/*
X * process -  check opened files and pass them to translate().
X *	   -  report on disastrous translation failures
X */
Xint
Xprocess(fp, filename)
X    FILE *fp;
X    char *filename;
X{
X    struct stat statbuf;
X    extern int translate(/* FILE *, char * */);
X
X    if (fstat(fileno(fp), &statbuf) != 0){
X	fprintf(stderr,"%s : can't fstat file %s\n", progname, filename);
X	return 1;
X    }
X    if ((statbuf.st_mode & S_IFMT)==S_IFDIR) {
X	(void) fprintf(stderr, "%s : %s is a directory\n", progname, filename);
X	return 1;
X    }
X    /* translate returns 0 (ok) or -1 (disaster). to recover from a 
X     * disaster and continue with next file would require fixing up the
X     * state in translate.c, and the document would likely be useless anyway,
X     * since it would have to be incredibly corrupted to blow stacks.
X     */
X    if (translate(fp, filename) < 0) {
X	(void) fprintf(stderr,
X		"%s: error while processing file %s, translation aborted\n",
X		progname, filename);
X	exit(1); 
X    }
X    return 0;
X}
END_OF_texi2roff.c
echo unbundling file: translate.c 1>&2
sed -e 's/^X//' >translate.c <<'END_OF_translate.c'
X/*
X * translate.c - main guts of Texinfo to nroff/troff translator texi2roff
X * 		 Release 1.0a	 August 1988
X *
X * Copyright 1988 Beverly A.Erlebacher
X * erlebach@csri.toronto.edu	...uunet!utai!utcsri!erlebach
X *
X */
X
X#include <stdio.h>
X#ifdef BSD
X#include <strings.h>
X#define strchr	index
X#else
X#include <string.h>
X#endif
X#include "texi2roff.h"
X
X#define MAXLINELEN  256
X#define ERROR	    (-1)
X
Xextern int	transparent;		/* -t flag: dont discard things	   */
Xint		linecount;
Xint		displaylevel = 0;	/* nesting level of 'display' text */
Xint		ilevel = 0;	 	/* nesting level of itemized lists */
Xint		inmacroarg = NO;	/* protect roff macro args flag */
Xchar	        *filename;
Xchar 		*p;			/* pointer into input buffer */
X
X/* forward references */
Xextern char * gettoken();
Xextern char * eatwhitespace();
Xextern struct tablerecd * lookup();
Xextern char * itemize();
Xextern char * doitem();
Xextern char * interpret();
X
X/*
X * errormsg - print error messages to stderr
X */
X
Xvoid
Xerrormsg( message, other)
X    char	   *message;
X    char	   *other;
X{
X    (void) fprintf(stderr, "%s line %d : %s%s\n",
X	filename, linecount, message, other);
X}
X
X/*
X * translate - translate one Texinfo file
X */
X
Xint 
Xtranslate(in, inname)
X    FILE	   *in;
X    char	   *inname;
X{
X    char	    input[MAXLINELEN];
X    char	    output[MAXLINELEN];
X    char	    token[MAXLINELEN];
X    char	    *c,*d,lastchar;
X
X    filename = inname;
X    linecount = 0;
X    lastchar = '\n';
X
X    while (fgets(input, MAXLINELEN, in) != NULL) {
X	++linecount;
X	p = input;
X	*output = 0;
X	if (*p == '.')			/* protect leading '.' in input */
X	    (void) strcpy(output, "\\&");
X	else if (*p == '\n') {
X	    if (displaylevel > 0)
X		(void) strcat(output,"\\&\n");	  /* protect newline */
X	    else if (ilevel > 0)	/* indented paragraph */
X		(void) strcat(output, cmds->dfltipara);
X	    else			/* default paragraph */
X		(void) strcat(output,cmds->dfltpara);
X	}
X	while (*p != '\0') {
X	    p = gettoken(p, token);
X	    p = interpret(token, output);
X	    if (p == NULL)
X		return ERROR;
X	}
X
X	/*
X	 * output, stripping surplus newlines when possible.
X	 * ?roff may vanish lines w/leading '. also, empirically,
X	 * often lines with leading \ . so emit zero-width char \& .
X	 */
X	d = &lastchar;	/* character at end of previous output buffer */
X	for( c = output; *c != '\0'; d = c, ++c) {
X	    if (*c != '\n' || *d != '\n') {
X		if ( *d == '\n' && (*c == '\\' || *c == '\''))
X		    (void) fputs("\\&", stdout);
X		(void) putc(*c, stdout);
X	    }
X	}
X	lastchar = *d;
X    }
X    return 0;
X}
X
X/*
X * PUSH - macro to push pointer to table entry onto command stack
X */
X
X#define MAXDEPTH    20
X
X#define PUSH(tptr)							\
X    if (++stackptr == MAXDEPTH) {					\
X	errormsg("stack overflow - commands nested too deeply", "");	\
X	return NULL;							\
X    }									\
X    stack[stackptr] = tptr;
X
X/*
X * interpret - interprets and concatenates interpreted token onto outstring
X */
X
Xchar *
Xinterpret(token, outstring)
Xchar	*token;
Xchar	*outstring;
X{
X    static struct tablerecd *stack[MAXDEPTH];
X    static int	    stackptr = 0; /* zeroth element is not used */
X    static int      discarding = NO;
X    static int	    discardlevel = MAXDEPTH;
X    struct tablerecd *tptr;
X    char	    *s, *cp, tempstr[MAXLINELEN];
X
X    s = p;
X    if (stackptr > 0 && STREQ(token, stack[stackptr]->texend)) {
X    /* have fetched closing token of current Texinfo command */
X	if (STREQ(token, "@end")) {/* WARNING! only works from translate() */
X	    s = gettoken(eatwhitespace(s),tempstr);
X	    if	(! STREQ(&(stack[stackptr]->texstart[1]), tempstr)) {
X		errormsg("probably @end for unrecognized Texinfo cmd @",
X							    tempstr);
X		return s;
X	    }
X	}
X	if (!discarding)
X	    (void) strcat(outstring, stack[stackptr]->trfend);
X
X	if (stack[stackptr]->type == DISPLAY)
X	    --displaylevel;
X	else if (stack[stackptr]->type == ITEMIZING) {
X	    --ilevel;
X	    if (!discarding && ilevel > 0)
X		(void) strcat(outstring, cmds->indentend);
X	}
X
X	if (--stackptr < 0) {
X	    errormsg("stack underflow", "");
X	    return NULL;
X	}
X    	if (discarding && stackptr < discardlevel) {
X	    discarding = NO;
X	    discardlevel = MAXDEPTH;
X    	}
X	if (*token == '\n' || STREQ(token, "@end")) {
X	    inmacroarg = NO;
X	    return "";  		/* flush rest of line if any */
X	}
X    } else if (*token != '@') { 	/* ordinary piece of text */
X	if (!discarding)
X	    (void) strcat(outstring, token);
X	if (*token == '\n') {
X	    inmacroarg = NO;
X	    return "";
X	}
X    } else {				/* start of Texinfo command */
X	if ((tptr = lookup(token)) == NULL) 
X	    errormsg("unrecognized Texinfo command ", token);
X	else {
X	    switch (tptr->type) {
X	    case ESCAPED:
X		if (!discarding)
X		    (void) strcat(outstring, tptr->trfstart);
X		break;
X	    case DISPLAY:
X		++displaylevel;
X		PUSH(tptr);
X		if (!discarding)
X		    (void) strcat(outstring, tptr->trfstart);
X		break;
X	    case HEADING:
X		/*
X		 * not presently supporting  appendices (lettered
X		 * rather than numbered	 sections) they will come
X		 * out as unnumbered for now
X		 */
X		inmacroarg = YES;   /* protect ' and space in hdr macro args */
X		s = eatwhitespace(s);
X		/* fall through */
X	    case CHAR:	/* may be some need to distinguish these 3 in future */
X	    case INPARA:
X	    case PARAGRAPH:
X		PUSH(tptr);
X		if (!discarding)
X		    (void) strcat(outstring, tptr->trfstart);
X		break;
X	    case DISCARD:
X		PUSH(tptr);
X		if (!discarding && !transparent) {
X		    discarding = YES;
X		    discardlevel = stackptr;
X		}
X		break;
X	    case ITEMIZING:
X		if (!discarding) {
X		    (void) strcat(outstring, tptr->trfstart);
X		    if (ilevel > 0)
X			(void) strcat(outstring, cmds->indentstart);
X		}
X		PUSH(tptr);
X		++ilevel;
X		s = itemize(s, token);
X		break;
X	    case ITEM:
X		PUSH(tptr);
X		if (!discarding) {
X		    (void) strcat(outstring, tptr->trfstart);
X		    inmacroarg = YES;
X		    s = doitem(s,tempstr);
X		    inmacroarg = NO;
X		    (void) strcat(outstring,tempstr);
X		}
X		break;
X	    case END:
X		s = gettoken(eatwhitespace(s),tempstr);
X		errormsg("probably @end for unrecognized Texinfo cmd @",
X							tempstr);
X		break;
X	    case FOOTNOTE:
X		PUSH(tptr);
X		if (!discarding) {
X		    s = gettoken(eatwhitespace(s),tempstr);
X		    cp = outstring + strlen(outstring);
X		    (void) interpret(tempstr, outstring);
X		    (void) strcpy(tempstr, cp);
X		    (void) strcat(outstring, tptr->trfstart);
X			/* replicate footnote mark */
X		    (void) strcat(outstring, tempstr);
X		}
X		break;
X	    default:
X		/* can't happen */
X		errormsg("ack ptui, what was that thing? ", token);
X	    }
X	}
X    }
X    return s;
X}	
X
X/*
X * eatwhitespace - move input pointer to first char that isnt a blank or tab
X *	(note that newlines are *not* whitespace)
X */
X
Xchar	       *
Xeatwhitespace(s)
X    register char	   *s;
X{
X    while(*s == ' ' || *s == '\t')
X	++s ;
X    return s;
X}
X
X
X/* 
X * strpbrk_like - returns pointer to the leftmost occurrence in str of any
X *	character in set. this function provided by rayan zachariassen.
X * 	this isnt a full strpbrk(), it's just as much of one as is necessary
X *	here.  not everyone has a strpbrk() in their C library.
X*/
X
Xchar *
Xstrpbrk_like(str, set)
X    register char *str;
X    char *set;
X{
X    static int inited_set = 0;
X    static char set_vec[256] = { 0 };
X
X    if (!inited_set) {	/* we *know* it'll be the same every time... */
X	while (*set)
X 	    set_vec[(unsigned char)*set++] = 1;
X	inited_set = 1;
X	}
X    while (set_vec[*str] == 0)
X	if (!*str++)
X	    return 0;
X    return str;
X}
X
X
X/*
X * gettoken - fetch next token from input buffer. leave the input pointer
X *	pointing to char after token.	 may need to be modified when 
X *	new Texinfo commands are added which use different token boundaries.
X */
X 
Xchar	       *
Xgettoken(s, token)
X    char	   *s;
X    char	   *token;
X{
X    static char	   endchars[] = " \n\t@{}:.*";
X    char	   *q, *t;
X
X    q = s;
X    s = strpbrk_like(q, endchars);
X    if (s != q) {
X	switch (*s) {
X	case ' ':
X	case '\n':
X	case '\t':
X	case '@':
X	case '}':
X	case ':':
X	case '.':
X	case '*':
X	    --s;
X	    break;
X	case '{':
X	    break;
X	}
X    } else {	/* *s == *q */
X	switch (*s) {
X	case ' ':
X	case '\n':
X	case '\t':
X	case '{':
X	case ':':
X	case '.':
X	case '*':
X	    break;
X	case '}':
X	    if (*(s+1) == '{') /* footnotes with daggers and dbl daggers!! */
X		++s;
X	    break;
X	case '@':
X	    s = strpbrk_like(q + 1, endchars );
X	    /* handles 2 char @ tokens: @{ @} @@ @: @. @* */
X	    if ( strchr("{}@:.*", *s) == NULL
X			|| (s > q+1 && (*s =='}' || *s == '@')))
X		--s;
X	    break;
X	}
X    }
X    for (t = token; q <= s; ++q, ++t) {
X	switch (*q) {
X	    case '\\' :		 /* replace literal \ with \e */
X		*t = *q;
X	        *++t = 'e';
X		break;
X	    case ' '  :		/* protect spaces and ' in macro args */
X	    case '\'' :	
X		if (inmacroarg == YES) {
X		    *t = '\\';
X	            *++t = *q;
X		} else
X		    *t = *q;
X		break;
X	    case '\"' :		/* try to avoid " trouble in macro args */
X		if (inmacroarg == YES) {
X		    *t = 0;
X		    (void) strcat(t,cmds->dblquote);
X		    t += strlen(cmds->dblquote) - 1;
X		} else
X		    *t = *q;
X		break;
X	    default   :
X		*t = *q;
X		break;
X	}
X    }
X    *t = 0;
X    return ++s;
X}
X
X/*
X * lookup - find a Texinfo command starting token in the table
X */
X
Xstruct tablerecd *
Xlookup(token)
X    char	   *token;
X{
X    register struct tablerecd *tptr;
X    struct tablerecd *endoftable = table + tablesize/sizeof table[0];
X
X    /* this could be a binary search, but even in a large document,
X     * commands are infrequent compared to non-command tokens.
X     * the program is fast enough and this works.
X     */
X
X    for (tptr = table; tptr < endoftable; ++tptr) {
X	if (STREQ(tptr->texstart, token))
X	    return tptr;
X    }
X    return NULL;
X}
X
X/*
X * all the global data and code for handling itemized stuff is down here
X */
X
X#define MAXILEVEL	10
Xint icount[MAXILEVEL];
Xint what[MAXILEVEL];
Xchar item[MAXILEVEL][MAXLINELEN];
X
X#define ITEMIZE	    0
X#define ENUMERATE   1
X#define TABLE	    2
X#define APPLY	    3
X
X/*
X * itemize - handle the itemizing start commands @enumerate, @itemize
X *	and @table
X */
X
Xchar * itemize(s, token)
Xchar * s;
Xchar * token;
X{
Xstruct tablerecd *i;
X
X    if (STREQ(token,"@itemize")) {
X	what[ilevel] = ITEMIZE;
X	s = gettoken(eatwhitespace(s),item[ilevel]);
X	if (item[ilevel][0] == '\n') { /* this is an error in the input */
X	    --s;
X	    (void) strcpy(item[ilevel],"-");
X	    errormsg("missing itemizing argument ","");
X	} else {
X	    if (item[ilevel][0] == '@') {
X		if ((i = lookup(item[ilevel])) != NULL) 
X		    (void) strcpy(item[ilevel], i->trfstart);
X		else
X		    errormsg("unrecognized itemizing argument ", item[ilevel]);
X		}
X	    }
X	}
X
X    if (STREQ(token,"@enumerate")) {
X	what[ilevel] = ENUMERATE;
X	icount[ilevel] = 1;
X    } else if (STREQ(token,"@table")) {
X	what[ilevel] = TABLE;
X	s = gettoken(eatwhitespace(s),item[ilevel]);
X	if (item[ilevel][0] == '\n') {
X	    item[ilevel][0] = '\0';  /* do nothing special */
X	    --s;
X	} else {
X	    if (item[ilevel][0] =='@'
X	        && (((i = lookup(item[ilevel])) != NULL)
X		    || ((i = lookup(strcat(item[ilevel],"{"))) != NULL)))
X		what[ilevel] = APPLY;
X	    else
X		errormsg("unrecognized table itemizing argument ",item[ilevel]);
X	}
X    }
X
X    while (*s != '\n' && *s != '\0') 
X	++s;  /* flush rest of line */
X    return s;
X}
X
X/*
X * doitem - handle @item and @itemx
X */
X
Xchar *
Xdoitem(s,tag)
Xchar * s;
Xchar * tag;
X{
X    char temp[MAXLINELEN], temp2[MAXLINELEN];
X    struct tablerecd *tp;
X
X    switch (what[ilevel]) {
X    case ITEMIZE:
X	(void) strcpy(tag, item[ilevel]);
X	break;
X    case ENUMERATE:
X	(void) sprintf(tag, "%d.", icount[ilevel]++);
X	break;
X    case TABLE:
X	*tag = '\0';
X	s = gettoken(eatwhitespace(s), temp);
X	if (*temp == '\n') {
X	    *tag++ = '-';
X	    errormsg("missing table item tag","");
X	}else {
X	    while (temp[0] != '\n') {
X		(void) strcat(tag, temp);
X	    	s = gettoken(s, temp);
X	    }
X	}
X	--s;
X	break;
X    case APPLY:
X	*tag = '\0';
X	temp2[0] = '\0';
X	s = gettoken(eatwhitespace(s), temp);
X	while (temp[0] != '\n') {
X	    (void) interpret(temp, temp2);
X	    s = gettoken(s, temp);
X	}
X	--s;
X	if ( (tp = lookup(item[ilevel])) != NULL ||
X		(tp = lookup(strcat(item[ilevel],"{"))) != NULL) {
X	    (void) strcat(tag, tp->trfstart);
X	    (void) strcat(tag, temp2);
X	    (void) strcat(tag, tp->trfend);
X	} else { /* this is an error in the input */
X	    (void) strcpy(tag,temp);
X	    errormsg("error applying Texinfo command to table item tag ",temp);
X	}
X	break;
X    }
X    return s;
X}
END_OF_translate.c



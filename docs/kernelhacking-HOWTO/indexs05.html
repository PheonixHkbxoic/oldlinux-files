<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>Tools</title>
<meta name="generator" content="DocBook XSL Stylesheets V1.40">
<link rel="home" href="index.html" title="Kernel Hacking HOWTO">
<link rel="up" href="index.html" title="Kernel Hacking HOWTO">
<link rel="previous" href="indexs04.html" title="Source Tour">
<link rel="next" href="indexs06.html" title="Tasks">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Tools</th></tr>
<tr>
<td width="20%" align="left">
<a href="indexs04.html">Prev</a> </td>
<th width="60%" align="center"> </th>
<td width="20%" align="right"> <a href="indexs06.html">Next</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="sect1">
<a name="tools"></a><div class="titlepage"><div><h2 class="title" style="clear: both">
<a name="tools"></a>Tools</h2></div></div>
<p>This section aims to explain the development tools that are fundamental to the kernel development process.</p>
<div class="sect2">
<a name="editors"></a><div class="titlepage"><div><h3 class="title">
<a name="editors"></a>Editors</h3></div></div>
<p>There is a wide choice when it comes to choosing an editor.  Many heated debates have taken place over which editor(s) is best suited to (kernel) programming.  In order to appease both sides and to give a balanced view, both vim and emacs will be presented here!  The idea is help the undecided programmer figure out which editor best suits his or her needs.</p>
</div>
<div class="sect2">
<a name="vim"></a><div class="titlepage"><div><h3 class="title">
<a name="vim"></a>vim</h3></div></div>
<p>Just about every UNIX-like system has at least vi available, if not vim (vi-improved) which has some extra, tasty features like syntax highlighting.</p>
<p>Reasons to use vim for kernel programming:</p>
<div class="itemizedlist"><ul>
<li><p>
<a name="id46571700"></a>Integrates really nicely with ctags.  If you <b>make tags</b> in the top level kernel source directory, you can then quickly access function &amp; variable definitions by pressing Ctrl-] while the cursor is over the function or variable in question.</p></li>
<li><p>
<a name="id46571725"></a>Auto-completion of variable and function names can save edit-compile cycles by reducing spelling mistakes.  This particularly applies to kernel programming as some of the function names are quite long and involved.  To use this feature, type the first part of the variable or function and press Ctrl-P repeatedly to search backwards through the document for possible matches.</p></li>
<li><p>
<a name="id46571740"></a>Fast loading time.</p></li>
<li><p>
<a name="id46571743"></a>Small memory footprint; leaves more memory for kernel recompiles.</p></li>
<li><p>
<a name="id46571748"></a>Highly configurable.  Amongst other things, command keystrokes are easily re-mapped; useful if you find a common command awkward or uncomfortable.</p></li>
<li><p>
<a name="id46571753"></a>As of version 6.0, integrates with cscope as well.  (Thanks to Bohdan Vlasyuk for this addition)</p></li>
</ul></div>
<p>Other reasons to use vim:</p>
<div class="itemizedlist"><ul>
<li><p>
<a name="id46571770"></a>If you can use vim, you will always have an editor to hand.  Even the most basic rescue boot disks have at least vi.  In short, one day you'll need to know how to use it, be it sooner or later!  The more proficient you are, the less painful that experience will be.</p></li>
<li><p>
<a name="id46571782"></a>The keyboard shortcuts involve less hand movement, for an unmodified key map at least.</p></li>
</ul></div>
<p>Reasons not to use vim</p>
<div class="itemizedlist"><ul>
<li><p>
<a name="id46571792"></a>Constant use of the (poorly positioned) <b>Esc</b> key reduces typing efficiency.  Possible solutions involve i) pressing Ctrl-[ instead ii) re-mapping a more ergonomic key to be <b>Esc</b>.</p></li>
<li><p>
<a name="id46571815"></a>vim is linked against a lot of libraries: (<b>ldd /usr/bin/vim</b> to see the list) including some X libraries.  If this is a real concern, you may prefer vi.</p></li>
<li><p>
<a name="id46571831"></a>Some people really don't get on with the modal way of doing things.</p></li>
</ul></div>
<p>Probably the best way to learn the basics of vim is to follow the tutorial; start vimtutor and enjoy.  The <a href="http://www.linuxdoc.org/HOWTO/Vim-HOWTO.html" target="_top">vim-HOWTO</a> also has a lot of useful information.</p>
<p>For additional information on editing C source code with vim, see the <a href="http://www.linuxdoc.org/HOWTO/C-editing-with-VIM-HOWTO/index.html" target="_top">C-editing-with-Vim-HOWTO</a>
</p>
<p>For more general information on vim see <a href="http://www.vim.org" target="_top">the Vim Homepage</a>
</p>
</div>
<div class="sect2">
<a name="emacs"></a><div class="titlepage"><div><h3 class="title">
<a name="emacs"></a>emacs</h3></div></div>
<p><i>Most of the information in this section is also applicable to xemacs.</i></p>
<p>Like vi, emacs also has a long heritage and a large number of loyal users.</p>
<p>Reasons to use emacs for kernel programming:</p>
<div class="itemizedlist"><ul><li><p>
<a name="id46571896"></a>Large library of emacs lisp programs available to aid productivity.</p></li></ul></div>
<p>Other reasons to use emacs</p>
<div class="itemizedlist"><ul>
<li><p>
<a name="id46571905"></a>Good integration with etags.</p></li>
<li><p>
<a name="id46571915"></a>Also integrates with grep and cscope.</p></li>
<li><p>
<a name="id46571927"></a>gdb integration.</p></li>
<li><p>
<a name="id46571934"></a>The keystrokes may seem more intuitive (e.g. you can type into a document immediately without having to enter a mode), and therefore maybe preferred by those who don't get on with the modal way of doing things.</p></li>
</ul></div>
<p>Reasons not to use emacs</p>
<div class="itemizedlist"><ul>
<li><p>
<a name="id46571944"></a>Constant use of the <b>Ctrl</b> key makes RSI a real concern.  Re-mapping <b>Caps-Lock</b> to be another <b>Ctrl</b> key is recommended.</p></li>
<li><p>
<a name="id46571962"></a>It is a big package so may not be suitable for systems with limited hard disk space.</p></li>
<li><p>
<a name="id46571966"></a>Longer loading time on modest systems.</p></li>
<li><p>
<a name="id46571970"></a>Larger memory footprint, so less memory available for kernel recompiles.</p></li>
<li><p>
<a name="id46571975"></a>etags is considered unstable by some, dumping core frequently.</p></li>
</ul></div>
<p>One of the best ways to learn emacs is to work through the tutorial which can be accessed by loading emacs and issuing these keystrokes: Ctrl-h then <b>t</b>.</p>
<p>If you like the way that emacs works but don't like it's size, you could try jove which is a minimal clone.  The source can be downloaded from <a href="ftp://ftp.cs.toronto.edu/pub/moraes/jove/" target="_top">the jove FTP site.</a>
</p>
<p>For more information on emacs see <a href="http://www.gnu.org/software/emacs/" target="_top">the emacs home page.</a>
</p>
<p>In summary, if you like to do <i>everything</i> in one place (write code, debug code, review patches, email, news groups), emacs is probably for you.  If you like smaller, more application specific programs, a smaller editor (like vim) may suit you better.</p>
</div>
<div class="sect2">
<a name="development"></a><div class="titlepage"><div><h3 class="title">
<a name="development"></a>Development</h3></div></div>
<div class="sect3">
<a name="make"></a><div class="titlepage"><div><h4 class="title">
<a name="make"></a>make</h4></div></div>
<p>make is a program that is used to determine which parts of a multi-source-file project need to be rebuilt.  Only those source files which have been modified are rebuilt before the final linking step.  This is a big plus for the kernel programmer as once the &quot;stock&quot; kernel has been built, recompiles to include changes take seconds instead of minutes.  make operates on a <tt>Makefile</tt>, a file containing the relationships and dependencies between source files along with the commands used to build them.</p>
<p>Just about every directory in the kernel source tree has a makefile, including the top level directory.  When you invoke <b>make dep bzImage modules</b>, make operates on the top level makefile which recursively works through the makefiles in each of the subdirectories (depending on which options were included during the config step).</p>
</div>
<div class="sect3">
<a name="lclint"></a><div class="titlepage"><div><h4 class="title">
<a name="lclint"></a>lclint</h4></div></div>
<p>Some programming errors can be caught early on in the development cycle, saving time and effort.  You may not have bothered with formal code analysis before, but now would be a good time to start; bugs in kernel code are generally harder to track down and can have more serious implications than their user-space counterparts.  Generally speaking, a higher standard of programming is called for; while a user may be prepared to put up with an email client that occasionally core dumps, they certainly won't put up with a kernel that freezes or worse, causes data loss.</p>
<p>lclint is a program that can be used to statically check C code, that is to check it before it is even compiled or executed.  Like lint, lclint can be run on unmodified C source code and used to catch classic programming mistakes.  However, lclint can do a whole lot more for you, but you must give it &quot;clues&quot; by annotating your source code using comments in the appropriate way.</p>
<p>In short, lclint can give you some of the foresight that an experienced programmer has at their disposal.  While it may not be perfectly suited to kernel C code (which has some unusual attributes), it can still be used to prove fragments of code prior to inclusion in the kernel source.</p>
<p>More information on lclint can be found at <a href="http://lclint.cs.virginia.edu/" target="_top">the lclint home page.</a>
</p>
</div>
</div>
<div class="sect2">
<a name="srccodenav"></a><div class="titlepage"><div><h3 class="title">
<a name="srccodenav"></a>Source Code Navigation</h3></div></div>
<p>One of the most daunting activities that faces a new kernel programmer is navigating a very large volume of unfamiliar source code.  This section describes some invaluable tools to help.</p>
<div class="sect3">
<a name="grep"></a><div class="titlepage"><div><h4 class="title">
<a name="grep"></a>grep</h4></div></div>
<p>grep is used to find lines matching a given pattern; a useful tool for quickly locating variable or function definitions and use.  Example: Suppose you want to find all instances of <tt>task_struct</tt>:</p>
<p><b>$grep -r task_struct * | less</b></p>
<p>This command recursively (<b>-r</b>) scans all files in the source tree and prints lines containing <tt>task_struct</tt>, those lines are piped to less, which provides a scroll-able output.  <b>man grep</b> for more details!</p>
</div>
<div class="sect3">
<a name="lxr"></a><div class="titlepage"><div><h4 class="title">
<a name="lxr"></a>lxr</h4></div></div>
<p>lxr enables you to navigate source code via a web browser, where all variables and functions are links to their respective definitions.  Probably the best way to read and understand code.</p>
<p>You can browse the kernel source code online at <a href="http://lxr.linux.no/source/?v=2.4.16" target="_top">the Linux Cross Reference Page</a> or at <a href="http://innominate.org/cgi-bin/lksr/" target="_top">innominate.org</a>, or download lxr and set it up on your box, useful if you don't have a permanent Internet connection.  The setup process is quite involved but details are given in the README file that comes with the lxr source code.</p>
</div>
<div class="sect3">
<a name="cscope"></a><div class="titlepage"><div><h4 class="title">
<a name="cscope"></a>cscope</h4></div></div>
<p>cscope is useful for doing many of the things you could use grep for, but is more intelligent and provides a nicer interface to work with.  You can search for definitions, uses, strings etc.</p>
<p>Before you can use cscope you need to build an index file.  This can be done by issuing the command <b>cscope -b -R -k</b> in the top level source directory; <b>-b</b> to build the index, <b>-R</b> to search recursively through the source tree and <b>-k</b> to indicate kernel use; this ensures the appropriate include files are used when generating the index.</p>
<p>To start a cscope session, type <b>cscope -d</b>.  You will then get something that looks like this:</p>
<pre class="screen">
Cscope version 15.3                                    Press the ? key for help













Find this C symbol:
Find this global definition:
Find functions called by this function:
Find functions calling this function:
Find this text string:
Change this text string:
Find this egrep pattern:
Find this file:
Find files #including this file:
</pre>
<p>The top half of the screen is used to display search results, while the lower half is used to issue commands.  Example; suppose you want to find the definition of the file_system_type data structure.  Use the arrow keys to move the cursor to the Find this global definition: field and enter the name of the data structure, followed by enter.  If all is well, cscope will find just one instance and will open your favourite editor (set by the <b>EDITOR</b> environment variable) to display the appropriate section of the file.</p>
<p>Now suppose you want to find the definition of <tt>super_block</tt>.  Follow the procedure above, which should give you this output:</p>
<pre class="screen">
Global definition: super_block

  File          Line
0 vxfs_extern.h  44 struct super_block;
1 super.c       265 int (*test)(struct super_block *, struct buffer_head *);
2 udfdecl.h      52 struct super_block;
3 fs.h          688 struct super_block 
4 fs.h          936 struct super_block *(*read_super) (struct super_block *,
                    void *, int );
5 udf_fs_sb.h    71 __u32 (*s_partition_func)(struct super_block *, __u32,
                    __u16, __u32);



Find this C symbol:
Find this global definition:
Find functions called by this function:
Find functions calling this function:
Find this text string:
Change this text string:
Find this egrep pattern:
Find this file:
Find files #including this file:
</pre>
<p>This time, cscope has found multiple possible definitions.  You can view each definition in its context by pressing the numbers given next to the list of files, alternatively, you can use <b>Tab</b> to move to the top half of the screen and the arrow keys to select a definition.  Simply quit out of the editor to return to cscope.  Press <b>Tab</b> again to return to the command area.  Note that you can also move up and down using Ctrl-p and Ctrl-n, which saves moving your hands away from a typing position.  To exit cscope, press Ctrl-d.</p>
<p>cscope source code and documentation is available from <a href="http://cscope.sourceforge.net/" target="_top">the cscope home page</a>, I would advise using version 15.3 or later as this version includes support for recursive indexing and using kernel headers.</p>
</div>
<div class="sect3">
<a name="ctags"></a><div class="titlepage"><div><h4 class="title">
<a name="ctags"></a>ctags</h4></div></div>
<p>ctags provides similar functionality to cscope, but integrates closely with your editor, allowing look-ups with a few key strokes.  Like cscope, ctags builds an index file to speed up searches.  The easiest way to generate the index is to type <b>make tags</b> in the top level kernel source directory.</p>
<p>When using vim, moving the cursor to a use of a function/variable/data structure/type and pressing Ctrl-] should take you to the definition.  Ctrl-t takes you back to where you were.  Note that lookups can be nested, in which case, Ctrl-t takes you up one level.</p>
<p>Details for using ctags with emacs are welcome!</p>
<p>ctags can be obtained from <a href="http://ctags.sourceforge.net/" target="_top">the ctags home page</a>.  Debian users will want to install the exuberant-ctags package.</p>
</div>
<div class="sect3">
<a name="summary"></a><div class="titlepage"><div><h4 class="title">
<a name="summary"></a>Summary</h4></div></div>
<p>A brief summary of the tools presented:</p>
<div class="itemizedlist"><ul>
<li><p>
<a name="id46572491"></a>lxr is useful for browsing and understanding code, as opposed to editing.</p></li>
<li><p>
<a name="id46572499"></a>cscope is useful for finding a definition if you know the name of function/variable/data structure concerned and want quick access to the source file, perhaps to add a field to a data structure.</p></li>
<li><p>
<a name="id46572509"></a>ctags is useful for doing quick look-ups during an editing session, but isn't quite as smart as cscope is.</p></li>
</ul></div>
</div>
</div>
<div class="sect2">
<a name="sourcecodemanipulation"></a><div class="titlepage"><div><h3 class="title">
<a name="sourcecodemanipulation"></a>Source Code Manipulation</h3></div></div>
<div class="sect3">
<a name="diff"></a><div class="titlepage"><div><h4 class="title">
<a name="diff"></a>diff</h4></div></div>
<p>diff is used to compare two files and output any differences between them.  When used in unified mode (<b>-u</b> option) to compare two files (original and modified) a &quot;patch&quot; is produced:</p>
<p><b>diff -u linux-2.4.14/drivers/char/keyboard.c linux/drivers/char/keyboard.c &gt; my_keyboard_patch</b></p>
<p>Where the <tt>linux-2.4.14</tt> directory holds the original, unmodified source tree and <tt>linux</tt> directory holds the one you have hacked around with.  Distribution of ideas and modifications as patches is a lot more convenient and efficient than distributing complete files or source trees.</p>
<p>The procedure above can be used when just one file has been modified, but what if you need to modify a lot files and produce a patch?</p>
<p><b>diff -urN linux-2.4.14 linux &gt; my_hefty_kernel_patch</b></p>
<p>Note that the convention is to generate patches from the directory above the top level kernel source directory i.e. <tt>/usr/src</tt> if you keep your modified kernel source in <tt>/usr/src/linux</tt>.</p>
<p>Note that if you are generating a patch to post to the Linux Kernel Mailing List, be sure to follow the instructions given in the FAQ exactly.  The FAQ can be found at: <a href="http://www.tux.org/lkml/" target="_top">http://www.tux.org/lkml/</a>
</p>
<p>Of course, use of diff is not restricted to generating patches; it is a useful tool for finding out what has changed between two kernel releases.  Uncompressed patches are human readable to some extent; the format is fairly self explanatory.  You can even grep a patch if you know what you are looking for.</p>
</div>
<div class="sect3">
<a name="patch"></a><div class="titlepage"><div><h4 class="title">
<a name="patch"></a>patch</h4></div></div>
<p>patch is used to apply patches to a file or a source tree:</p>
<p>
<b>cd linux-2.4.13</b><b>patch -p1 patch-2.4.14</b>
</p>
<p>This procedure would update a 2.4.13 tree to 2.4.14.  The <b>-p1</b> option strips the top level directory off all filenames within the patch (as you are patching from inside the top level source directory).  Of course, you could apply the patch from the directory above, but you would need to have your directories named in the same way as when the patch was generated.  Note that patches are often distributed in compressed form, to save bandwidth.  You can save disk space (and typing) by uncompressing patches as you apply them:</p>
<p><b>bzip2 -dc /usr/src/patch-2.4.14.bz2 | patch -p1</b></p>
<p>Simply replace bzip2 with gzip if the patch was gzipped instead of bzipped.</p>
<p>A useful script is included in the kernel source tree to semi-automate the process of upgrading a source tree by applying successive patches: <tt>linux/scripts/patch-kernel</tt>.  Read the script to see what it does and how to use it, instructions are given in the comments at the top of the file.</p>
<p>It is often a good idea to do a &quot;dry run&quot; of applying a patch, especially if you are patching a heavily modified tree, or are attempting to apply an old patch against a newer tree.  Backing out a partially applied patch can be time consuming and generally is not much fun!</p>
<p><b>bzip2 -dc /usr/src/patch-2.4.14.bz2 | patch -p1 --dry-run</b></p>
<p>What if the patch does not apply cleanly?  If only a couple of files failed, you could apply the patch anyway and sort things out with a text editor afterwards, alternatively you could manually go through and apply the patch by reading it and making the changes by hand.  The manual approach is sometimes necessary to resolve conflicting patches and is a useful technique if you want to understand exactly what a patch changes.</p>
<p>What if you want to remove a previously applied patch?  Easy:</p>
<p><b>bzip2 -dc /usr/src/patch-2.4.14.bz2 | patch -R -p1</b></p>
<p>This would take your source tree back to 2.4.13.</p>
</div>
<div class="sect3">
<a name="RCS"></a><div class="titlepage"><div><h4 class="title">
<a name="RCS"></a>RCS</h4></div></div>
<p>Any development work is an incremental process, particularly so at the debugging stage. It always pays to keep a record of the process using some form of revision control system, so that a bad change can backed out with minimal effort.  A very basic revision control system can be implemented by just keeping a backup of a file before making major changes, however this approach tends to become cumbersome very quickly.</p>
<p>Enter RCS, the little brother of CVS.  CVS is great for large projects with many contributors, but is overkill for small personal projects.  One of the attractions of RCS is it's simplicity.</p>
<p>First create the <tt>RCS</tt> directory in the same directory as your source files:</p>
<p><b>mkdir RCS</b></p>
<p>Then &quot;check in&quot; a source file:</p>
<p><b>ci -u some-file.c</b></p>
<p>You will then be prompted to give a description.  By default, RCS deletes the working file upon check in, so you will want the <b>-u</b> option which automatically checks the file out again.  Check in all the files you are working on in this way.</p>
<p>Make some changes to one of your source files and check it in again.  You'll be prompted for a summary of the changes and the version number will be incremented.</p>
<p>Suppose you have made a mess of the working file and want to revert to a known good version (1.7), check it out using this command:</p>
<p><b>co -l -r1.7 some-file.c</b></p>
<p>The <b>-l</b> flag locks the file and gives you write access to it (otherwise you get read access only).</p>
<p>RCS stores the initial file and only differences between versions, saving disk space.  For more information on RCS, see the following man pages: rcs, ci, co, rcsintro, rcsdiff, rcsclean, rcsmerge, rlog, rcsfile and ident.</p>
</div>
<div class="sect3">
<a name="CVS"></a><div class="titlepage"><div><h4 class="title">
<a name="CVS"></a>CVS</h4></div></div>
<p>While RCS is good for basic projects involving (changes to) a limited number of files, it quickly becomes unwieldy for larger projects, particularly so with contributions from more than one developer. CVS is particularly good in this area.</p>
<div class="sect4">
<a name="cvscommands"></a><div class="titlepage"><div><h5 class="title">
<a name="cvscommands"></a>CVS Commands</h5></div></div>
<p>All cvs commands are specified as sub-commands of the <b>cvs</b> command.  Both the <b>cvs</b> command and the sub-command can be passed options, but their position in the command line should be as shown here.</p>
<p><b>$ cvs [cvs options] sub-command [sub-command options]</b></p>
<div class="itemizedlist"><ul>
<li><p>
<a name="id46572858"></a><b>add</b>: This command will add a new file to source control.  You must check in the file using <b>cvs ci</b> after this command to make the change take effect.</p></li>
<li>
<p>
<a name="id46572871"></a><b>ci</b> or <b>commit</b>: This command will check in the changes that you have made to the local copy of a file to make them permanent.  After this command, anyone updating or checking out the file from the repository will see the changes that you have made.  You can either specify the <b>-m</b> &quot;message&quot; option to provide a message describing the change, or this command will execute the editor for you to enter the message.</p>
<p>When you check in your changes and the local copy of the files are not up to date, cvs will print a message informing you of this.  In this case, you have to update the files and then check in your changes.</p>
<p>To check in the changes in all the modified files in the current working directory, execute the following command from the top of the working directory:</p>
<p><b>$ cvs -q ci -m &quot;blah blah ...&quot;</b></p>
</li>
<li><p>
<a name="id46572907"></a><b>co</b> or <b>checkout</b>: This command will make a local copy of all the files in a module.  First, it will create a subdirectory with the same name as the module, then it will copy the files into that subdirectory.</p></li>
<li>
<p>
<a name="id46572920"></a><b>diff</b>: This command will print the differences between the local copy of a file and the version in the repository.</p>
<p>To generate a patch for the changes in the current working directory, execute the following command from the top of the working directory.</p>
<p><b>$ cvs -q diff -u</b></p>
</li>
<li>
<p>
<a name="id46572936"></a><b>history</b>: This command will print information about the <b>cvs</b> repository.  By default, this command only prints information that pertains to you.  You can use the <b>-a</b> option to print information about all users.  The following are some useful history options.</p>
<p>
<b>$ cvs history -a -o   # Show checked out files</b><b>$ cvs history -a -T   # Show all tags</b><b>$ cvs history -a -e   # Show all information</b>
</p>
</li>
<li>
<p>
<a name="id46572964"></a><b>import</b> This command will put an existing project into the repository.</p>
<p><b>$ cvs import -m &quot;blah blah ...&quot; directory vendorTag releaseTag</b></p>
</li>
<li><p>
<a name="id46572976"></a><b>log</b>: This command will print the messages that were specified when each file was checked in.</p></li>
<li>
<p>
<a name="id46572983"></a><b>remove</b>: This command will remove a file from source control.  You must check in the file using cvs ci after this command to make the change take effect???</p>
<p>This command will remove a file from the current branch of the source tree.  If someone checks out the module, they will not get a copy of this file.  However, if they check out an older version of the module, they will still get the appropriate version of the file.</p>
</li>
<li>
<p>
<a name="id46572996"></a><b>tag</b>: To tag all the files in the current working directory, execute the following command from the top of the working directory.</p>
<p><b>$ cvs -q tag tagName</b></p>
</li>
<li>
<p>
<a name="id46573009"></a><b>update</b>: This command will update the local copy of the files in a module.  For any file that is updated, its name is printed preceded by a &quot;U&quot;.  It will also print the names of the files that you have modified (i.e., files that are different from the copy in the repository) and precede them with an &quot;M&quot;.</p>
<p>If there is a conflict between a file that needs to be updated and the local changes that you have made, the file name will be printed and it will be preceded with a &quot;C&quot;.  The file will be replaced and the conflicting code will be marked with &quot;&quot; and &quot;&gt;&gt;&gt;&gt;&quot;, and the original file will be saved as .#file.version.</p>
<p>You can always delete your local copy of a file and use the cvs update command to restore the up-to-date copy of the file from the repository.  In this case, CVS will print a message that the file was lost and replace the file.  The file name will be printed preceded by a &quot;U&quot;.</p>
<p>To list the files that have been modified in the current working directory, execute the following command from the top of the working directory.</p>
<p><b>$ cvs -q update</b></p>
</li>
</ul></div>
</div>
<div class="sect4">
<a name="repspec"></a><div class="titlepage"><div><h5 class="title">
<a name="repspec"></a>Repository Specification</h5></div></div>
<p> The cvs repository is specified using the <b>-d</b> option to the <b>cvs</b> command or the <b>CVSROOT</b> environment variable.  For example,</p>
<p><b>$ cvs -d pathName login</b></p>
<p>Or,</p>
<p>
<b>$ export CVSROOT=pathName</b><b>$ cvs login</b>
</p>
<p>If the repository is on the local system, the option is simply the path to the repository.  For example,</p>
<p><b>$ export CVSROOT=/usr/local/cvs</b></p>
<p>However, if the repository is on another system, the repository specification must also include the access method and the user name and server name where the repository is located.  Each of these items; the access method, user name and server name, and the path name of the repository on the server; must be separated by a colon.  The user name and the server name are connected with the at-sign (&quot;@&quot;).</p>
<p><b>$ export CVSROOT=:accessMethod:userName@serverName:pathName</b></p>
<p>Linux Top of Tree (2.4)</p>
<p> To get the Linux source code for Linux 2.4, use the following command.  This repository is a mirror that is updated every 30 minutes.</p>
<p>
<b>$ export CVSROOT=:pserver:cvs@vger.samba.org:/vger</b><b>$ cvs login</b><b>Password: cvs</b><b>$ cd some-directory	# For example, /usr/local/src</b><b>$ cvs -z3 co linux</b>
</p>
<p>To update the source code, use the following commands.</p>
<p>
<b>$ cd some-directory/linux</b><b>$ cvs -z3 update -d</b>
</p>
<p>Linux Branch (2.2)</p>
<p>Or, to get the Linux 2.2 source code, use the following command</p>
<p>
<b>$ export CVSROOT=:pserver:cvs@vger.samba.org:/vger</b><b>$ cvs login</b><b>Password: cvs</b><b>$ cd some-directory	# For example, /usr/local/src</b><b>$ cvs -z3 co -r linux_2_2 linux</b>
</p>
</div>
</div>
</div>
<div class="sect2">
<a name="toolsyourturn"></a><div class="titlepage"><div><h3 class="title">
<a name="toolsyourturn"></a>Your Turn</h3></div></div>
<p>Make sure you have installed all the tools mentioned in this chapter, practice using them and try to learn the most common commands and keystrokes.  Check out the appropriate <b>man</b> and <b>info</b> pages for more information.</p>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a href="indexs04.html">Prev</a> </td>
<td width="20%" align="center"><a href="index.html">Home</a></td>
<td width="40%" align="right"> <a href="indexs06.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left">Source Tour </td>
<td width="20%" align="center"><a href="index.html">Up</a></td>
<td width="40%" align="right"> Tasks</td>
</tr>
</table>
</div>
</body>
</html>

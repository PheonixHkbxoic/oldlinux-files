<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>Glossary</title>
<meta name="generator" content="DocBook XSL Stylesheets V1.40">
<link rel="home" href="index.html" title="Kernel Hacking HOWTO">
<link rel="up" href="index.html" title="Kernel Hacking HOWTO">
<link rel="previous" href="indexs16.html" title="To Do">
<link rel="next" href="indexs17.html#id46575701" title="Glossary">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Glossary</th></tr>
<tr>
<td width="20%" align="left">
<a href="indexs16.html">Prev</a> </td>
<th width="60%" align="center"> </th>
<td width="20%" align="right"> <a href="indexs17.html#id46575701">Next</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="sect1">
<a name="glossary"></a><div class="titlepage"><div><h2 class="title" style="clear: both">
<a name="glossary"></a>Glossary</h2></div></div>
<p>This part of the document will remain a random to-do list until I figure out how to do a glossary properly in SGML!</p>
<p>Please send suggestions.</p>
<div id="id46575701" class="glossary">
<div class="titlepage"><div><h2 class="title">
<a name="id46575701"></a>Glossary</h2></div></div>
<dl>
<dt><a name="id46575702">2Q algorithm</a></dt>
<dd><p>MM algorithm based on two areas, one managed as a FIFO queue, and one as an LRU list.</p></dd>
<dt><a name="id46575713">8259 PIC</a></dt>
<dd><p>Outdated Programmable Interrupt Controller present on Intel hardware.</p></dd>
<dt><a name="id46575722">ABI</a></dt>
<dd><p>Application Binary Interface; the interface of passed structures between the user processes (and libraries) and the kernel. For compatibility, it is important that these remain as static as possible (i.e. making sure that variables and structure members have the same bytesize as before, and in the same ordering). Occasionally breakage is necessary, requiring re-compilation of the user-space sources (note that this does not affect source-compatibility; that is a separate issue).</p></dd>
<dt><a name="id46575735">ACPI</a></dt>
<dd><p>Advanced Configuration and Power Interface - replacement for APM that has the advantage of allowing O/S control of power management facilities.</p></dd>
<dt><a name="id46575744">AGI</a></dt>
<dd><p>Address Generation Interlocking, on x86. When execution of an instruction requires an address resulting from a non-completed instruction, the CPU must wait - this is known as an AGI stall.</p></dd>
<dt><a name="id46575754">AGP</a></dt>
<dd><p>Accelerated Graphics Port, on x86 boxes.</p></dd>
<dt><a name="id46575763">anonymous</a></dt>
<dd><p>Generally, used for something which doesn't have the usual associated object. For example an anonymous address space is not interested in user address space (that is, no process context). Some common ones are:</p></dd>
<dt><a name="id46575773">Anonymous page</a></dt>
<dd><p>A page of memory that is not associated with a file on a file system. This can come from expanding the process's data segment with brk(), shared memory segments, or mmap() with a MAP_ANON or MAP_PRIVATE flag. MAP_PRIVATE, although it maps in data from a file, is considered anonymous because any changes do not get written back to the file (any dirty pages have to be moved to swap if the page is freed from main memory).</p></dd>
<dt><a name="id46575785">Anonymous buffer</a></dt>
<dd><p>The buffer cache contains buffers of data on their way to/from the disk. An anonymous buffer is not associated with a file. One example of this is data from a deleted file - it will not be written to any file, but is kept around until it is flushed.</p></dd>
<dt><a name="id46575796">APIC</a></dt>
<dd><p>See local APIC and IO-APIC.</p></dd>
<dt><a name="id46575804">APM</a></dt>
<dd><p>Advanced Power Management, power management standard superseded by ACPI. APM and SMP just don't mix.</p></dd>
<dt><a name="id46575813">ARP</a></dt>
<dd><p>This is an acronym for the Address Resolution Protocol and this is how a network machine associates an IP Address with a hardware address.</p></dd>
<dt><a name="id46575823">ASN.1</a></dt>
<dd><p>Abstract Syntax Notation, a protocol for structured data, used, for example, in the Q.3 management protocol.</p></dd>
<dt><a name="id46575832">ast</a></dt>
<dd><p>Professor Andrew S. Tanenbaum, writer of MINIX and several essential O/S books.</p></dd>
<dt><a name="id46575841">ATAPI</a></dt>
<dd><p>ATA Packet Interface, used by most CD-ROMs, and other devices.</p></dd>
<dt><a name="id46575850">balancing</a></dt>
<dd><p>Technique used in the VM code, referring to balancing various parameters such as the number of pages currently free, to avoid thrashing and other bad memory capacity artefacts. See zones, kswapd bug.</p></dd>
<dt><a name="id46575860">BAR</a></dt>
<dd><p>Base Address Registers, for PCI devices.</p></dd>
<dt><a name="id46575868">BCD</a></dt>
<dd><p>Binary-Coded Decimal - see a textbook.</p></dd>
<dt><a name="id46575877">bigmem</a></dt>
<dd><p>See highmem.</p></dd>
<dt><a name="id46575885">big lock</a></dt>
<dd><p>kernel_lock, which locks the entire kernel from entry (no other task may run in the kernel code). It is recursive per process and dropped automatically when a process gives up the CPU, then regained on wake-up, in contrast to other spinlocks.</p></dd>
<dt><a name="id46575896">bit error</a></dt>
<dd><p>Used colloquially to mean a single bit error in some memory address. Often due to faulty memory (ECC memory can correct single bit errors). Often results in fake Oopsen, with addresses like 0x0008000. Also seen are values some small offset from zero, plus a bit error, which is where the value passed a NULL check due to the bit error, and then the kernel tried to access a structure member by means of the pointer, leading to the offset.</p></dd>
<dt><a name="id46575908">block bitmap</a></dt>
<dd><p>In UNIX-like filesystems, the usage of disks blocks is recorded in the block bitmap, where each set bit indicates a specific allocated block.</p></dd>
<dt><a name="id46575918">bottom-half handler</a></dt>
<dd><p>A set of standard kernel threads that execute tasks on a queue that have been registered with that type of bottom-half handler for execution. The code is run on return to user space or at the end of a hardware interrupt. In 2.3.43 a more general solution with softirqs and tasklets was implemented. Sometimes abbreviated to &quot;bh&quot;, which should not be confused with buffer head, which is also abbreviated to &quot;bh&quot;.</p></dd>
<dt><a name="id46575930">bounce buffer</a></dt>
<dd><p>An intermediate buffer. Used for example, in &quot;faking&quot; alignment to a client from non-aligned resources.</p></dd>
<dt><a name="id46575939">brlocks</a></dt>
<dd><p>Big-reader locks, used when there are many contending for read access to a resource, and very few contending for writes (thus the balance is towards very fast read locking, and very slow write locking).</p></dd>
<dt><a name="id46575949">BSP</a></dt>
<dd><p>BootStrap Processor, or the CPU which enables the other CPUs in an SMP system.</p></dd>
<dt><a name="id46575958">bss</a></dt>
<dd><p>Block storage segment. This is the memory mapping section containing the data allocated for a binary image at execution time. Also known as &quot;Block Started by Symbol&quot; and &quot;Bull-Shit Storage&quot;.</p></dd>
<dt><a name="id46575968">BTB</a></dt>
<dd><p>Branch Target Buffer - on x86 processors, the cache of recent conditional jump results.</p></dd>
<dt><a name="id46575977">buddy allocator</a></dt>
<dd><p>The memory allocation scheme used in the kernel. A vector of lists of free pages is kept, ordered by the size of the chunk (in powers of two). When a chunk is allocated, it is removed from the relevant list. When a chunk is freed back to the free pages pool, it is placed in the relevant list, starting from the top. If it is physically contiguous with a present chunk, they are merged and placed in the list above (i.e. where the chunks are twice the size), and this operation percolates up the vector. As regions are merged whenever possible, this design helps to reduce memory fragmentation. FIXME</p></dd>
<dt><a name="id46575991">buffer cache</a></dt>
<dd><p>The buffer cache is a hash table of buffers, indexed by device and block number. LRU lists are maintained for the buffers in the various states, with separate lists for buffers of different sizes. With 2.3's unification of the buffer and page caches, each buffer head points to part or all of a page structure, through which the buffer's actual contents are available. FIXME</p></dd>
<dt><a name="id46576006">buffer head</a></dt>
<dd><p>A structure containing information on I/O for some page in real memory. A buffer can be locked during I/O, or in several other states depending on its usage or whether it is free. Each buffer is associated with one page, but every page may have several buffers (consider the floppy on x86, where the I/O block size is 512 bytes, but each page is commonly 4096 bytes).</p></dd>
<dt><a name="id46576018">BUG()</a></dt>
<dd><p>Used in kernel code in tests for &quot;impossible&quot; conditions. Signify a kernel bug or faulty hardware.</p></dd>
<dt><a name="id46576027">bus mastering</a></dt>
<dd><p>Giving a card on a bus (e.g. ISA,PCI) the ability to read/write directly to main memory. This is how DMA is performed on PCI busses.</p></dd>
<dt><a name="id46576036">byte sex</a></dt>
<dd><p>Endianness.</p></dd>
<dt><a name="id46576044">cache affinity</a></dt>
<dd><p>Where the cache of a CPU represents the current memory set used by a task, there is said to be cache affinity with that task. A good thing if the task is regularly scheduled on that CPU. See processor affinity.</p></dd>
<dt><a name="id46576055">cache coherency</a></dt>
<dd><p>On an SMP system, ensuring that the local memory cache of each CPU is consistent with respect to the values which may be stored in other CPUs' caches, avoiding coherency problems such as the &quot;lost update&quot;. This is achieved by the hardware in concert with the operating system.</p></dd>
<dt><a name="id46576066">cache line</a></dt>
<dd><p>A section of the hardware cache, around 32 bytes large. Kernel structures are often designed such that the commonly-accessed members all fit into one cache-line, which reduces cache pollution. Structures such as this are cache line aligned.</p></dd>
<dt><a name="id46576076">cache ping-pong</a></dt>
<dd><p>A hardware phenomenon in an SMP system, where two tasks on different CPUs are both accessing the same physical memory in a cache line. This means as each task runs, when it changes the memory, it must invalidate the other CPU's relevant cache line (to ensure cache coherency). Then, when the task on the other CPU runs, it must reload the cache line (as it's set invalid), before changing it. Repeat ad jocularum. A bad thing (TM). A common reason for putting a lock on a different cache line than the data mutexed by the lock : then the &quot;other&quot; task can grab and drop the lock without having to necessarily invalidate the cache line on the first CPU. FIXME</p></dd>
<dt><a name="id46576090">cache pollution</a></dt>
<dd><p>Where during execution of a task, another task is scheduled onto that CPU which disrupts useful lines of the current cache contents, which will be used soon. That is, cache pollution is a non-optimal situation where the other process would have been bettered scheduled on a different CPU or at a different time. The aim is to minimise the need to replace cache lines, obviously increasing efficiency.</p></dd>
<dt><a name="id46576102">call gate</a></dt>
<dd><p>x86 hardware support for mode switch to kernel (i.e. system call). In Linux, int 0x80 will trigger the call gate.</p></dd>
<dt><a name="id46576112">CAP_</a></dt>
<dd><p>These are defined names of capabilities for specific tasks provided by the kernel, e.g. CAP_SYS_NICE.*</p></dd>
<dt><a name="id46576121">chroot jail</a></dt>
<dd><p>A process under the aegis of a chroot() syscall is in a chroot jail, and cannot access the file system above its notion of root directory /.</p></dd>
<dt><a name="id46576130">cli/sti</a></dt>
<dd><p>x86 assembler instructions for disabling and enabling interrupts, respectively. There are CPU-local and global variants of these. Code running with interrupts disabled must be fast, for obvious reasons (this is called interrupt latency).</p></dd>
<dt><a name="id46576141">CML2</a></dt>
<dd><p>Eric Raymond's proposal for a replacement to the current kernel build system. See http://www.tuxedo.org/~esr/kbuild.</p></dd>
<dt><a name="id46576150">cold cache</a></dt>
<dd><p>A cache whose content is invalid or irrelevant with respect to some task to be run.</p></dd>
<dt><a name="id46576159">completion ports</a></dt>
<dd><p>I/O interface used in O/S's such as Windows NT. Userspace notifies the kernel of each file descriptor the program is interested. The O/S uses a callback for each fd to indicate that I/O is ready.</p></dd>
<dt><a name="id46576169">contention</a></dt>
<dd><p>Where two tasks each want an exclusive resource. You may hear talk of, for example, spinlock contention, which is where one or more tasks is commonly busy-waiting for a spinlock to become unlocked, as it is being taken by other tasks.</p></dd>
<dt><a name="id46576179">context switch</a></dt>
<dd><p>Refers to the changes necessary in the CPU when the scheduler schedules a different process to run on the CPU. This involves invalidating the TLB, loading the registers with the saved values, etc. There is an associated cost with such a switch, so it is best to avoid unnecessary context switch when possible. Note that the division of kernel-mode and user-mode means a similar, but simpler, operation is necessary when a syscall moves into kernel mode. However this is not called a context switch, as the mode switch doesn't change the current process. See lazy TLB. One good of feature of Linux is its extremely low context and mode switch cost, compared to an operating system like Solaris.</p></dd>
<dt><a name="id46576194">COW</a></dt>
<dd><p>Copy-On-Write, efficiency method where a page or other resource is shared until an attempt to write is made. In that case a copy is made, and the write is done to the copy.</p></dd>
<dt><a name="id46576204">CPL</a></dt>
<dd><p>Current Privilege Level. FIXME</p></dd>
<dt><a name="id46576212">critical path</a></dt>
<dd><p>A vital code path which should be optimised for the common case. Critical paths are executed frequently and form the important trunk routes of various kernel operations. An example would be buffer head manipulation during file I/O.</p></dd>
<dt><a name="id46576223">css</a></dt>
<dd><p>Code storage segment, aka text section. This is the memory mapping containing the executable code (text) for a binary image.</p></dd>
<dt><a name="id46576232">Directed Acyclic Graph</a></dt>
<dd><p>FIXME</p></dd>
<dt><a name="id46576240">dancing makefiles</a></dt>
<dd><p>An experimental new Makefile set up for configuring and compiling the kernel, written by Michael Elizabeth Chastain.</p></dd>
<dt><a name="id46576250">dcache</a></dt>
<dd><p>The cache of dentry structures. Under UNIX an entry in a particular directory must be searched for linearly, so even if the disk block containing the directory entry list is in-core, there is an associated cost. The dcache stores recent results of these searches which in general speeds up these disk searches by a large factor. Recent 2.3 work uses the dentries to allow multiple mounting, union mount, and more. The hardware data cache is usually referred to as the D-cache.</p></dd>
<dt><a name="id46576262">deadlock</a></dt>
<dd><p>Any of a number of situations where two or more processes cannot proceed because they are both waiting for the other to release some resource. FIXME(give good references).</p></dd>
<dt><a name="id46576272">delayed write</a></dt>
<dd><p>See write behind.</p></dd>
<dt><a name="id46576280">demand zero</a></dt>
<dd><p>In demand paging, where the page is to be zeroed when actually created (common case: bss segment of an executable image, which is uninitialised heap data for the executable). Also called ZFOD.</p></dd>
<dt><a name="id46576291">dentry</a></dt>
<dd><p>Directory entry, in-core structure defining a file's details: inode, parent dentry etc. Cached in a hash table indexed by hashed filename (see dcache).</p></dd>
<dt><a name="id46576300">DF</a></dt>
<dd><p>IP packet bit indicating it should not be fragmented. The remote host will return ICMP notifications if the packet had to be split anyway, and these are used in MTU discovery.</p></dd>
<dt><a name="id46576310">directory notification</a></dt>
<dd><p>Provides hooks for notifying tasks when the contents of a directory has changed. Note &quot;contents&quot; can refer to dentries, the file inodes, or even the file contents themselves (file notification).</p></dd>
<dt><a name="id46576320">DOD</a></dt>
<dd><p>Dial-On-Demand for PPP connections over a standard telephone line. </p></dd>
<dt><a name="id46576329">drop behind</a></dt>
<dd><p>In stream I/O conditions, data that has already been read and processed is not needed again. The VM ideally should recognise this and mark the used pages as unneeded, so they can be discarded first. This technique is called &quot;drop behind&quot;.</p></dd>
<dt><a name="id46576339">dss</a></dt>
<dd><p>Data storage segment, aka data section. This is the memory mapping containing the initialised data for a binary image.</p></dd>
<dt><a name="id46576348">dual-issue</a></dt>
<dd><p>Processors such as the Pentium Pro, that can decode and execute two instructions simultaneously.</p></dd>
<dt><a name="id46576358">dupe</a></dt>
<dd><p>Abbrev. fr. duplication.</p></dd>
<dt><a name="id46576366">dword</a></dt>
<dd><p>Double word, i.e. 4 bytes on x86.</p></dd>
<dt><a name="id46576374">EA</a></dt>
<dd><p>See extended attributes.</p></dd>
<dt><a name="id46576383">eager coalescing</a></dt>
<dd><p>What the buddy allocator currently does, i.e. merge adjacent blocks as soon as possible.</p></dd>
<dt><a name="id46576392">edge-triggered interrupt</a></dt>
<dd><p>The interrupt is triggered by the rising or falling edge of the interrupt line. This makes IRQ line sharing difficult, as an edge may occur while an ISR is running, and it could be easily missed; to allow sharing level-triggered interrupts are usually used.</p></dd>
<dt><a name="id46576403">EIP</a></dt>
<dd><p>Extended Instruction Pointer. This register contains the PC value of a task, that is, it points to the next instruction to be fetched, decoded etc.</p></dd>
<dt><a name="id46576412">elevator algorithm</a></dt>
<dd><p>This algorithm, often used in disk accesses, keeps an ordered list of requests. When the current request on the disk (e.g. the disk block) has been satisfied, the next strictly greater request on the list is dealt with. When a new request arrives, it is inserted into the ordered list in position (e.g. if the new requested block number is less than the current handled request, it goes before it in the list). When reaching the end of the list, the elevator changes direction, and the situation is reversed.</p></dd>
<dt><a name="id46576430">EPIC</a></dt>
<dd><p>Explicitly-Parallel Instruction set Computing, an instruction set architecture where every dependency for an instruction is encoded into the instruction itself. This has the potential to be faster as the compiler can encode the data dependencies in the instructions.</p></dd>
<dt><a name="id46576441">exponential back-off</a></dt>
<dd><p>A general algorithm for dealing with contention cases; for example, collisions on a network bus, or contention for a spinlock.</p></dd>
<dt><a name="id46576450">extended attributes</a></dt>
<dd><p>Also known as multi-part or multi-stream files, files with extended attributes deviate from the principle of files being a simple single data stream. An example of extended attributes is the Macintosh's &quot;resource fork&quot;, which is associated with a specific file (known as the &quot;data fork&quot;).</p></dd>
<dt><a name="id46576461">fair scheduler</a></dt>
<dd><p>A scheduler which ensures fairness between users, such that a user's process count and associated cost only impacts that user, rather than the whole system as currently. Rik van Riel and Borislav Deianov have both produced different patches to implement this.</p></dd>
<dt><a name="id46576472">false sharing</a></dt>
<dd><p>On SMP caches, when two parts of single block are accessed, neither of which collide with the other, the cache coherency protocol may not be able to detect this, and mark the block as &quot;shared&quot; even when it isn't. This is known as false sharing.</p></dd>
<dt><a name="id46576482">fastpath</a></dt>
<dd><p>The code path most commonly taken, often optimised heavily at the expense of less frequently-taken blocks of code. This is the reason you see so many gotos in core functions - it produces common-path code far more efficient than an optimising compiler can manage.</p></dd>
<dt><a name="id46576493">fd</a></dt>
<dd><p>file descriptor.</p></dd>
<dt><a name="id46576501">filemap</a></dt>
<dd><p>The mapping of a file's contents into memory.</p></dd>
<dt><a name="id46576510">fixed mmap</a></dt>
<dd><p>A user-space request for a mmap starting at a fixed virtual address. Generally not useful or guaranteed to work; a notable exception is overlayed mmaps, where a mmaped area has further mmaps of different types at fixed positions in the map.</p></dd>
<dt><a name="id46576520">FQDN</a></dt>
<dd><p>Fully-Qualified Domain Name, e.g. martyr.darrenemerson.co.uk.</p></dd>
<dt><a name="id46576529">GART</a></dt>
<dd><p>For AGP setups, Graphics Aperture Relocation Table.</p></dd>
<dt><a name="id46576538">gdoc</a></dt>
<dd><p>GNOME's source documentation system (similar to javadoc). Available by CVS from gnome. Kernel driver interface descriptions, built from source using gdoc, are currently being written in 2.3.</p></dd>
<dt><a name="id46576548">gdt</a></dt>
<dd><p>Global Descriptor Table. Something to do with x86 memory segmentation I think (FIXME). See ldt.</p></dd>
<dt><a name="id46576557">get</a></dt>
<dd><p>In the kernel, often means &quot;get a reference to&quot;. This may be as simple as incrementing a usage count, or it may imply attempting to retrieve an object from a cache of some sort, or allocating kernel memory. See put.</p></dd>
<dt><a name="id46576567">GKHI</a></dt>
<dd><p>Generalised Kernel Hook Infrastructure, an IBM patch to implement hooks into the kernel code.</p></dd>
<dt><a name="id46576576">group descriptor</a></dt>
<dd><p>On-disk filesystem structure, containing information for a block group, such as the inode bitmap and block bitmap.</p></dd>
<dt><a name="id46576585">HID</a></dt>
<dd><p>Human Interface Device (for USB).</p></dd>
<dt><a name="id46576594">highmem</a></dt>
<dd><p>On the x86 platform, memory addresses accessed using Intel's Physical Address Extension, which allows real memory of up to 64Gb on IA32. Only certain things can be stored in this space (FIXME: only userspace ? or what ? no bh or irqhandler can use it ...)</p></dd>
<dt><a name="id46576604">hton</a></dt>
<dd><p>Possibly byte-swapping conversion from host-endian to network-endian format. The network is big-endian.</p></dd>
<dt><a name="id46576614">IBCS</a></dt>
<dd><p>A standard for executable image interfacing (syscalls etc.). This is orthogonal to binary image file format standards such as ELF.</p></dd>
<dt><a name="id46576623">icache</a></dt>
<dd><p>On lkml, this almost always refers to the inode cache, rather than the hardware instruction cache (I-cache).</p></dd>
<dt><a name="id46576632">IETF</a></dt>
<dd><p>Internet Engineering Task Force, a standards organisation for protocols used on the Internet.</p></dd>
<dt><a name="id46576641">IKD</a></dt>
<dd><p>Integrated Kernel Debugger. A patched version of the kernel containing additional facilities for debugging the kernel.</p></dd>
<dt><a name="id46576650">ILP</a></dt>
<dd><p>Instruction-Level Parallelism, i.e. executing more than one instruction at once. See dual-issue.</p></dd>
<dt><a name="id46576660">incestuous</a></dt>
<dd><p>What you might expect: code with knowledge of used code's internals beyond the API. This breaks modularity, increases complexity and causes bugs, and a design goal is to minimise this behaviour.</p></dd>
<dt><a name="id46576670">inode</a></dt>
<dd><p>As per UNIX, the structure defining a file (except for the filename which is stored in the directory entry). The inode cache is a closed hash table indexed by superblock and inode number, and is only hit when the dentry lookup failed.</p></dd>
<dt><a name="id46576680">inode bitmap</a></dt>
<dd><p>In UNIX-like filesystems, the usage of on-disk inodes is recorded in the inode bitmap, where each set bit indicates a specific allocated inode.</p></dd>
<dt><a name="id46576690">insn</a></dt>
<dd><p>Abbrev. fr. &quot;instruction&quot;.</p></dd>
<dt><a name="id46576698">interrupt context</a></dt>
<dd><p>This is code executing in the kernel in response to a generated interrupt, without a process context. For more time-consuming work, a bottom-half handler task can be added to be executed at some later time.</p></dd>
<dt><a name="id46576708">interrupt gate</a></dt>
<dd><p>x86 hardware support for hardware interrupts. Interrupt gate facilities are provided to allow a known entry path from untrusted privilege levels to the interrupt routines.</p></dd>
<dt><a name="id46576718">IO-APIC</a></dt>
<dd><p>Receives interrupts external to a CPU (e.g. from a device) and routes them through the local APIC to the CPU.</p></dd>
<dt><a name="id46576727">iopl</a></dt>
<dd><p>I/O privilege level system call and bit in x86 EFLAGS register.</p></dd>
<dt><a name="id46576736">IPI</a></dt>
<dd><p>Inter-processor Interrupt. On SMP machines this refers to an interrupt sent between CPUs, indicating some event that the other CPU needs to be aware of, for example smp_invalidate_interrupt, which invalidates a CPU's TLB.</p></dd>
<dt><a name="id46576746">ISO9660</a></dt>
<dd><p>On-disk format often used for CDs. See also Joliet.</p></dd>
<dt><a name="id46576755">ISR</a></dt>
<dd><p>Interrupt Service Routine, or interrupt handler. Also, on x86 APICs, In-Service Register, confusingly enough.</p></dd>
<dt><a name="id46576764">jiffy</a></dt>
<dd><p>Basic packet of kernel time, around 10ms on x86. Related to HZ, the basic resolution of the operating system. The timer interrupt is raised each 10ms, which then performs some h/w timer related stuff, and marks a couple of bh's ready to run if applicable.</p></dd>
<dt><a name="id46576775">Joliet</a></dt>
<dd><p>Microsoft extension to ISO9660, commonly used.</p></dd>
<dt><a name="id46576783">journalling</a></dt>
<dd><p>A filesystem that writes all changes to some log file, to preserve filesystem consistency (for example, an inode's link count should equal the number of directory entries pointing to that inode). There are two types; FIXME log only metadata such as link count, whereas FIXME logs both meta-data and data, effectively writing all data twice. ext3, ReiserFS and XFS are all meta-data loggers, the second type are rare as the same effect can be achieved using RAID.</p></dd>
<dt><a name="id46576796">kiobuf</a></dt>
<dd><p>FIXME</p></dd>
<dt><a name="id46576804">kiovec</a></dt>
<dd><p>This allows user-space memory access from other contexts, such as in a bh. This also allows kernel drivers to set up DMA from a device directly to user-space pages.</p></dd>
<dt><a name="id46576814">kmalloc</a></dt>
<dd><p>Kernel memory allocation routine. See vmalloc. kmalloc() ensures physical address contiguity.</p></dd>
<dt><a name="id46576823">kswapd bug</a></dt>
<dd><p>Problems with VM balancing in late 2.3 kernels. People in a variety of situations found that the VM subsystem was far from optimal, leading to the kernel swapping daemon kswapd taking an inordinate amount of CPU resources; thrashing was also a common problem. Work is undergoing to fix these scenarios.</p></dd>
<dt><a name="id46576834">L1</a></dt>
<dd><p>See L2.</p></dd>
<dt><a name="id46576842">L2</a></dt>
<dd><p>The L2 (level 2) cache is a memory cache in the order of half a megabyte wide, located on the motherboard. The much faster L1 cache is in-CPU, but correspondingly smaller. x86 has a two-level cache, while some architectures such as Alpha AXP have an additional L3 cache. Often referred to is the memory hierarchy, which goes something like (with increasing latency and capacity, decreasing cost) registers, L1 cache, L2 cache, L3 cache, main memory, local mass storage device, network.</p></dd>
<dt><a name="id46576855">lazy TLB</a></dt>
<dd><p>Some tasks, such as kernel threads like kswapd, don't have a process context, which renders the costly invalidation of the TLB unnecessary (as the user-level page tables are not used). The task structure member mm indicates the user-level address space, which will be NULL for kernel threads. In this case active_mm indicates the used address space (kernel). These address spaces are known as anonymous.  Note also that certain tasks may occasionally temporarily drop the user-level address space and have an anonymous address space for a short while.</p></dd>
<dt><a name="id46576869">ldt</a></dt>
<dd><p>Local Descriptor Table. The ldt is a per-process memory management table used on x86. See gdt.</p></dd>
<dt><a name="id46576878">lease</a></dt>
<dd><p>General term used in unreliably-connected components. A resource is given a lease which eventually expires. This means the connection can break, without leaving state hanging. NFS, being stateless, does not have the concept of leases.</p></dd>
<dt><a name="id46576888">level-triggered interrupt</a></dt>
<dd><p>Also level-sensitive. As used on PCI. PCI's ability to have multiple devices sharing a single interrupt line is made possible by its use of level-triggered interrupts. If interrupts were edge-triggered, it is possible that some of the incoming interrupts might be lost, for example if a second interrupt were to come in while the processor was still in the midst of processing a previous one, the processor would return from servicing the first interrupt but not be aware that a second interrupt had been asserted. With level-triggered interrupts, by contrast, the interrupt line remains active until specifically deactivated by an ISR. This does mean, however, that if a buggy routine forgets to reset the interrupt line after agreeing to deal with the interrupt, then the machine may hang in a loop of constant interrupts.</p></dd>
<dt><a name="id46576904">LFS</a></dt>
<dd><p>Large File Support, specifically files larger than 2Gb on 32-bit systems.</p></dd>
<dt><a name="id46576913">LFU</a></dt>
<dd><p>Least Frequently Used, another MM technique. The tension between recency of access and frequency of access of a an area of memory is one of the crucial parts of any memory management system.</p></dd>
<dt><a name="id46576923">libc</a></dt>
<dd><p>The standard C libraries.  Remember that the kernel build makes no use of libc !</p></dd>
<dt><a name="id46576932">LIP</a></dt>
<dd><p>Loop Initialization Primitive, related to target IDs on SCSI busses.</p></dd>
<dt><a name="id46576941">livelock</a></dt>
<dd><p>When tasks are fighting for an exclusive resource, but are also ready to run. For example both tasks may be in a loop checking for a resource's availability.</p></dd>
<dt><a name="id46576951">lkml</a></dt>
<dd><p>The Linux-Kernel Mailing List.  See <a href="http://www.tux.org/lkml/" target="_top">the FAQ</a> for details.</p></dd>
<dt><a name="id46576961">local APIC</a></dt>
<dd><p>On-chip interrupt controller provided on P6 and above Intel CPUs. Linux uses the timer interrupt register if a local APIC is available to provide its timer interrupt (is this true ?). The local APIC is part of a replacement for the old-style 8259 PIC, and receives external interrupts through an IO-APIC if there is one.</p></dd>
<dt><a name="id46576980">loopback device</a></dt>
<dd><p>The fake net device representing the local host net interface, lo. This can also refer to file loopback mounts.</p></dd>
<dt><a name="id46576988">loopback mount</a></dt>
<dd><p>There are two types of mount called loopback mounting. First is the file loopback mount, where a single file on a filesystem itself containing a filesystem is mounted (useful in constructing ISO9660 images for one).  The other type, which is possible in 2.4, is &quot;true&quot; loopback mount, where you can do something like mount -t bind /safebin /chrootjail/bin.</p></dd>
<dt><a name="id46576998">LRU</a></dt>
<dd><p>As per the CS literature, Least Recently Used. A selection algorithm where a list is kept, ordered by last usage of each element. Often used in page replacement algorithms. Also Most Recently Used and LFU.</p></dd>
<dt><a name="id46577008">LUN blacklist</a></dt>
<dd><p>This is a blacklist of SCSI devices that do not properly handle probes with a Logical UNit number other than zero. Some mischievous devices respond to all LUNs, while others can hang with a LUN more than zero. LUNs are used in CD changers amongst other devices.</p></dd>
<dt><a name="id46577019">LVM</a></dt>
<dd><p>Logical Volume Manager. This allows several physical partitions to be represented as a single block device, amongst other things.</p></dd>
<dt><a name="id46577028">major fault</a></dt>
<dd><p>A major page fault occurs when an attempt to access a page not currently present in physical memory was made. The page must be swapped in to physical memory by the fault fixup code.</p></dd>
<dt><a name="id46577038">mb</a></dt>
<dd><p>Memory barrier; ensures on SMP systems that each CPU's view of memory is the same, i.e. enforces order. rmb() ensures reads are done in order, and wmb() ensures writes are done in order. Placing a barrier after some code basically makes sure that all previous memory reads or writes are done (as CPUs can re-order usually to increase performance). (FIXME: this needs to be more clear).</p></dd>
<dt><a name="id46577050">medium-often race</a></dt>
<dd><p>A race condition scenario. FIXME</p></dd>
<dt><a name="id46577058">memory rusting</a></dt>
<dd><p>Name for problems with mm code in v2.1, where pages got rusted and stuck in memory when they should really have been swapped out. Was a problem on small-memory machines. Now fixed (right ?)</p></dd>
<dt><a name="id46577068">MOESI</a></dt>
<dd>
<p>The name for a superset of cache coherency protocols. There are five possible states for a cacheline to be in:</p>
<div class="itemizedlist"><ul>
<li><p>
<a name="id46577080"></a>Modified: The data in the cacheline has been changed.</p></li>
<li><p>
<a name="id46577085"></a>Owned: The cache owner has exclusive rights to the contents of this data.</p></li>
<li><p>
<a name="id46577090"></a>Exclusive: The cacheline is not present on any other caches.</p></li>
<li><p>
<a name="id46577095"></a>Shared: The cacheline is shared with another cache, but does not need writing back to memory.</p></li>
<li><p>
<a name="id46577100"></a>Invalid: The cacheline is invalid and does not contain useful data.</p></li>
</ul></div>
<p>This protocol is described in more detail in the Schimmel book.</p>
</dd>
<dt><a name="id46577106">metadata</a></dt>
<dd><p>Information about a file, such as permissions, in contrast to the actual data in the file.</p></dd>
<dt><a name="id46577115">minor fault</a></dt>
<dd><p>A minor page fault occurs when an attempt to access a page present in physical memory, but without the correct permissions. An example is the first write to a second reference to a shared page, when the kernel must perform the copy-on-write and allow the task to update the copied page.</p></dd>
<dt><a name="id46577126">MMIO</a></dt>
<dd><p>Memory-mapped I/O, that is I/O memory (memory on hardware devices) accessible through a memory mapping. Also known as an I/O region.</p></dd>
<dt><a name="id46577135">monotonic</a></dt>
<dd><p>Technical term, meaning very roughly &quot;new data doesn't affect existing data&quot;. Used to mean a wide range of different things. For example, a monotonic clock is one which never gives a time prior to the time given previously (that is, sequential reads of the clock always increase).</p></dd>
<dt><a name="id46577146">MSR</a></dt>
<dd><p>Model-Specific Register. For the x86 platform, registers that are not guaranteed as part of the Intel Architecture (i.e. could be not present in future CPU models).</p></dd>
<dt><a name="id46577156">MSS</a></dt>
<dd><p>The Maximum Segment Size is the largest quantity of data that can be transmitted at one time over a net interface.</p></dd>
<dt><a name="id46577165">mtrr</a></dt>
<dd><p>Memory Type Range Registers.FIXME: explain what they do.</p></dd>
<dt><a name="id46577174">MTU</a></dt>
<dd><p>The Maximum Transmission Unit is a parameter that determines the largest datagram than can be transmitted by an IP interface without it needing to be broken down into smaller units. Typical values are 1500 bytes for an ethernet interface, or 576 bytes for a SLIP interface.</p></dd>
<dt><a name="id46577185">MTU discovery</a></dt>
<dd><p>The process of discovering the MTU of a remote site that can be used without causing expensive fragmentation. See DF.</p></dd>
<dt><a name="id46577194">n/w</a></dt>
<dd><p>Used occasionally for &quot;network&quot;.</p></dd>
<dt><a name="id46577202">Nagle's Algorithm</a></dt>
<dd><p>TCP algorithm for reducing network traffic in a connection. The local machine will accumulate outgoing data into packets until receiving a packet from the machine, and then the packets are sent. This way small amounts of outgoing data are amalgamated into the packet's larger payloads. Setting the TCP option NODELAY disables this behaviour. FIXME</p></dd>
<dt><a name="id46577214">nbd</a></dt>
<dd><p>Network Block Device - presents a local block device to a remote device.</p></dd>
<dt><a name="id46577223">negative entry</a></dt>
<dd><p>Meaning an error return rather than the expected entry from some vector or cache. A negative dentry is used when an NFS client tries to operate on a stale file, and with other situations. Without the negative dentry, a lookup is done on each request. This would allow a DoS attack by stealing CPU time doing lookups which will fail. So the dentry is kept around to provide a near-immediate &quot;stale file&quot; response to the client. See fs/dcache.c:d_delete(). Apparently positive dentries are not allowed to become negative. A negative dentry is one with a NULL d_inode field.</p></dd>
<dt><a name="id46577236">NMI</a></dt>
<dd><p>Non-maskable interrupt - highest-priority interrupt that can even interrupt standard h/w interrupt ISRs. The NMI watchdog is a kernel facility, running off NMIs, which checks CPUs for recent activity (in the last five minutes), to detect permanently stalled CPUs. NMIs are also delivered by motherboards in the case of serious hardware problems (like bad RAM).</p></dd>
<dt><a name="id46577248">nopage</a></dt>
<dd><p>A routine executed when a virtual address has been accessed when the page is for some reason not available in real memory. An example would be a swapped out page, hence the nopage operation would need to bring the page into real memory from the swap file.</p></dd>
<dt><a name="id46577259">nr_</a></dt>
<dd><p>&quot;Number of&quot;, e.g. nr_free_pages(). Preferred to the &quot;no_&quot; form as it's not ambiguous with the negative case (compare no_free_pages()).*</p></dd>
<dt><a name="id46577268">ntoh</a></dt>
<dd><p>Possibly byte-swapping conversion from network-endian to host-endian format. The network is big-endian.</p></dd>
<dt><a name="id46577277">NUMA</a></dt>
<dd><p>Non-Uniform Memory Architecture. Usually on an SMP system, all memory beyond the caches costs an equal amount to reach for each CPU. In NUMA systems, some memory can be accessed more quickly than other parts. Later kernels have some NUMA support for preferring to use memory &quot;nearer&quot; to the CPU, rather than higher-latency distant memory. See Documentation/vm/numa for details.</p></dd>
<dt><a name="id46577289">NVidia</a></dt>
<dd><p>A graphics card manufacturer that produce proprietary, non-open-source/binary kernel module drivers. Complaints about this module go to NVidia; such complaints are not welcome on linux-kernel. Also check #nvidia on irc.openprojects.net.</p></dd>
<dt><a name="id46577300">O()</a></dt>
<dd><p>Notation from Computer Science literature for complexity of algorithms. An O(1) algorithm takes constant time; an O(n) algorithm takes time proportional to N, the number of data, and so on. Also used for space complexity, the number of memory &quot;units&quot; used in the algorithm.</p></dd>
<dt><a name="id46577310">OHCI</a></dt>
<dd><p>Compaq standard for USB controllers.</p></dd>
<dt><a name="id46577319">one-hand algorithm</a></dt>
<dd><p>VM algorithm. A one-handed clock algorithm has one &quot;clock hand&quot; sweeping through pages, performing ageing and other activities.</p></dd>
<dt><a name="id46577328">oob</a></dt>
<dd><p>In networking Out-Of-Band data. FIXME</p></dd>
<dt><a name="id46577337">oops</a></dt>
<dd><p>An oops is generated on some kernel errors. This may be due to kernel bugs or faulty hardware (especially bad RAM). Often the kernel can continue to operate mostly correctly after an oops. More serious or potentially dangerous errors can cause a kernel panic (the O/S freezes). This is sometimes done to protect a filesystem from incurring further harm.  An oops report will appear in the kernel logs, but is only useful to developers after decoding it with ksymoops (see Documentation/oops-tracing.txt). Note also that klogd can corrupt oops reports by incorrectly decoding it automatically. It is recommended to pass the -x option to klogd on startup to prevent this from happening.  The plural form is oopsen.</p></dd>
<dt><a name="id46577352">out-of-order execution</a></dt>
<dd><p>Some processors (such as Intel Pentium Pro and above) can decode and execute more than one instruction at a time in parallel. This means a sequence of instructions is not necessarily the order in which those instructions are completed. See mb().</p></dd>
<dt><a name="id46577362">PAE36</a></dt>
<dd><p>Physical Address Extension - Intel's 36-bit physical address extensions for highmem.</p></dd>
<dt><a name="id46577371">page ageing</a></dt>
<dd><p>Marking a page as &quot;old&quot; in some way, that is, it hasn't been used for some time. Old pages are preferred for swapping out (although this is a simplification of the page swap selection algorithm), and are aged by kernel threads via a clock algorithm. Confusingly, page-&gt;age==0 indicates an infinitely old page (FIXME: true ?).  The pte's are also aged for selection for flushing from the page table to the page or swap cache.</p></dd>
<dt><a name="id46577383">page cache</a></dt>
<dd><p>The page cache caches pages mapped from files (e.g. mapping in an executable image).</p></dd>
<dt><a name="id46577392">page colouring</a></dt>
<dd><p>A system to ensure that virtually-contiguous pages are not mapped to the same cache lines, improving performance. FreeBSD does this, but Linux, after some discussion, doesn't (yet).</p></dd>
<dt><a name="id46577402">page stealer</a></dt>
<dd><p>A task which steals from a process's vm, taking pages for itself. An example is kswapd, which runs through the pages of the system swapping out pages to keep freepages.min number of free pages.</p></dd>
<dt><a name="id46577412">pessimal</a></dt>
<dd><p>By analogy with optimal, the worst situation possible in some context.</p></dd>
<dt><a name="id46577421">PFF</a></dt>
<dd><p>FIXME</p></dd>
<dt><a name="id46577429">pgd</a></dt>
<dd><p>Page Global Directory, or the abstracted top level of the multi-level page tables. See pmd, pte. On x86, there are only two real levels of page tables; this fact is abstracted away by macros in the source. Each level of page table deals with different sizes of memory. For example, this global directory may deal with areas 4Mb in size. Each entry will be a pointer to a lower table of a smaller-sized directory. On x86, the next level (middle) is non present in hardware, and is folded in to the pgd in the kernel code. The bottom level deals in pages directly (PAGE_SIZE). So the pgd is a directory of page tables. Code which traverses this structure (such as the bttv driver) is said to walk the page tables.</p></dd>
<dt><a name="id46577444">PGE</a></dt>
<dd><p>FIXME</p></dd>
<dt><a name="id46577452">PIC</a></dt>
<dd><p>Programmable Interrupt Controller. See 8259 PIC, local APIC, IO-APIC.</p></dd>
<dt><a name="id46577461">PIO</a></dt>
<dd><p>The old-fashioned transfer protocol for devices on an IDE bus. Now mostly used is DMA, and standards like UDMA.</p></dd>
<dt><a name="id46577470">pinning</a></dt>
<dd><p>A pinned page cannot be swapped out of main memory.</p></dd>
<dt><a name="id46577479">pmd</a></dt>
<dd><p>Page Middle Directory. The middle level of page tables.</p></dd>
<dt><a name="id46577488">poisoning</a></dt>
<dd><p>Used in the slab cache for debugging purposes. Slabs are filled with a special value after they have been freed in order to catch double frees.</p></dd>
<dt><a name="id46577497">POSIX</a></dt>
<dd><p>A standard specifying semantics and interfaces for a UNIX-like kernel interface, along with standards for user-space facilities. There is a core POSIX definition which must be supported by all POSIX-conforming OSes, and several optional standards for specific facilities; so you may see references to &quot;POSIX shm&quot; or &quot;POSIX real-time signals&quot;.</p></dd>
<dt><a name="id46577509">PPPoE</a></dt>
<dd><p>PPP (point-to-point protocol, often used in modem up-links) running over Ethernet.</p></dd>
<dt><a name="id46577518">pre-emption</a></dt>
<dd>
<p>Involuntary switching of a CPU from one task to another. User-space is pre-empted by interrupts, which can then either return to the process, or schedule another process (a process switch will also occur when the process &quot;voluntarily&quot; gives up the CPU by e.g. waiting for a disk block in kernel mode).</p>
<p>Kernel mode tasks are never pre-empted (except by interrupts) - they are guaranteed use of the CPU until they sleep or yield the CPU. Some kernel code runs with interrupts disabled, meaning nothing except an NMI can interrupt the execution of the code.</p>
</dd>
<dt><a name="id46577534">pre-zeroing</a></dt>
<dd><p>Many pages (such as those for a process's BSS segment) need to be zeroed when accessed. As the kernel only takes the page on the page fault for these areas, it is possible to pre-zero some amount of pages before the page faults occur. FreeBSD does this, and there has been some inconclusive talk of including this feature in Linux. See demand zero.</p></dd>
<dt><a name="id46577545">printk</a></dt>
<dd><p> Obviously, the equivalent of printf for kernel code (remember, you can't use libc functions in the kernel). Can be called from interrupt context (although it does take the console spinlock) but floating-point cannot be used, as throughout the kernel.</p></dd>
<dt><a name="id46577556">priority inheritance</a></dt>
<dd><p>See priority inversion.</p></dd>
<dt><a name="id46577564">priority inversion</a></dt>
<dd><p>A situation where a low-priority task holds a resource which a higher-priority task is waiting for. This can occur with tasks scheduled with SCHED_OTHER or SCHED_IDLE, where a task with a higher scheduling priority will always be scheduled before in preference. This leads to deadlock as the low-priority task cannot be scheduled in order to release the lock, and the high-priority task can't continue without the lock on the resource. Priority inheritance is a putative solution, where the low-priority task temporarily takes on the priority of the other task, enabling its scheduling and release of the lock. However this approach can itself lead to deadlock (FIXME: is this really true ?).</p></dd>
<dt><a name="id46577579">processor affinity</a></dt>
<dd><p>Some OS's have system calls for binding a process to a particular CPU. The kernel ensures that when the process is re-scheduled it will be run on that processor. Linux currently doesn't support this and its relative merits are debatable.</p></dd>
<dt><a name="id46577589">processor ordering</a></dt>
<dd><p>The ordering of memory read and writes as seen from the CPU's point of view.</p></dd>
<dt><a name="id46577598">process context</a></dt>
<dd><p>Code executing in the kernel on behalf of a user process (from a syscall), is said to have a process context. Code not in a process context is not allowed to sleep or wait (see interrupt context).</p></dd>
<dt><a name="id46577608">process group</a></dt>
<dd><p>A set of user processes sharing the same group pid. One of these processes will be the group leader (same pid as pgid).</p></dd>
<dt><a name="id46577618">process suspension</a></dt>
<dd><p>When a VM is capable of completely suspending processes for a while. Also known as process swapping.</p></dd>
<dt><a name="id46577627">promiscuous</a></dt>
<dd><p>Of a network device, sucks all packets regardless of destination.</p></dd>
<dt><a name="id46577635">pte</a></dt>
<dd><p>Page Table Entry, or a value containing the physical address of a page along with associated bits indicating, for example, that the entry is valid and the related page is present in real memory.</p></dd>
<dt><a name="id46577645">put</a></dt>
<dd><p>In the kernel, means &quot;drop a reference to&quot;. This indicates that whatever task was using the object previously is no longer interested. This may just decrement a usage count, or perform a more complicated reaping routine.</p></dd>
<dt><a name="id46577656">QOS</a></dt>
<dd><p>Quality of Service.</p></dd>
<dt><a name="id46577664">race condition</a></dt>
<dd><p>Generally, where the ordering of events can affect the outcome of a situation. These bugs are caused by incomplete mutual exclusion, so a task or interrupt can come in and change something vital under the feet of another task. They are notoriously hard to debug as they are often marginal (often only occur in pathological==&quot;very unlikely&quot; situations).</p></dd>
<dt><a name="id46577676">RAID</a></dt>
<dd><p>Redundant Array of Independent/Inexpensive Disks. See the standard literature.</p></dd>
<dt><a name="id46577684">RAS</a></dt>
<dd><p>Reliability, Availability &amp; Serviceability.</p></dd>
<dt><a name="id46577693">rate limit</a></dt>
<dd><p>To avoid DoS attacks, some facilities have upper limits on how often they can trigger. Most trite example is logging.</p></dd>
<dt><a name="id46577702">raw I/O</a></dt>
<dd><p>I/O that does not go through the caches that Linux provides as standard to all block devices. This feature can be useful to database systems, where the database back-end has a better idea of the data access pattern than the kernel can, hence increasing performance.</p></dd>
<dt><a name="id46577713">read-ahead</a></dt>
<dd><p>Where I/O is performed before strictly required in an attempt to improve performance. This is performed by the Linux kernel, and often by hardware as well.</p></dd>
<dt><a name="id46577723">Readiness Event Queues</a></dt>
<dd><p>See completion ports.</p></dd>
<dt><a name="id46577731">red zone</a></dt>
<dd><p>Adding protection (e.g. read or write) to kernel pages, for use in detecting stack overflow and other situations. This often works by adding a guard area at the end of each buffer in the slab allocator, which is checked to make sure it hasn't been overwritten.</p></dd>
<dt><a name="id46577742">register spilling</a></dt>
<dd><p>FIXME</p></dd>
<dt><a name="id46577750">retired</a></dt>
<dd><p>On out-of-order processors, a retired instruction is one that has been executed and completed.</p></dd>
<dt><a name="id46577759">ring 0</a></dt>
<dd><p>ring 0 is the protection level provided by x86 hardware for kernel mode. Ring 3 is used in Linux for user mode, and rings 1 and 2 are unused. Ring transition to a higher protection level is only possible through gates. Interrupt gates are set up for transitions due to interrupts, and call gates are used for system calls.</p></dd>
<dt><a name="id46577770">ring buffer</a></dt>
<dd><p>A buffer of data which is of fixed size; when it fills, further data is placed back at the start of the buffer, overwriting the old data, in a &quot;ring&quot;. Commonly used in device drivers.</p></dd>
<dt><a name="id46577780">root squashing</a></dt>
<dd><p>An NFS option whereby any actions performed by a remote client's root account are actually attempted by the user &quot;nobody&quot; on the server.</p></dd>
<dt><a name="id46577790">RX</a></dt>
<dd><p>Common abbreviation used in net code for &quot;receive&quot;.</p></dd>
<dt><a name="id46577798">scatter-gather</a></dt>
<dd><p>An I/O mechanism, whereby devices can write to memory at several physically non-contiguous addresses (scatter), and compose reads from physically non-contiguous addresses in memory (gather).</p></dd>
<dt><a name="id46577808">semaphore</a></dt>
<dd><p>As per the literature, a mutual exclusion or resource management method where tasks sleep waiting for a semaphore to be granted to them. Later versions of the Linux kernel also provide a more complicated type, the read-write semaphore, which allows a task to specify its intentions with regard to the resource. Hence several readers are allowed for the resource, but a writer will have mutual exclusion.</p></dd>
<dt><a name="id46577820">session</a></dt>
<dd><p>Sessions are related to terminal handling. Sessions can have a controlling terminal; by becoming a session group leader, a daemon process can detach itself from any controlling terminal. A session group is a set of processes created by the session leader. FIXME</p></dd>
<dt><a name="id46577831">set_fs</a></dt>
<dd><p>The set_fs() facility enables the copy_*_user routines to access kernel (KERNEL_DS) or user (KERNEL_FS) memory. This is required in kernel code that uses functions that expect to copy data from user-space, so that the correct segment is used (i.e. copying from kernel memory rather than user space memory).</p></dd>
<dt><a name="id46577842">shm</a></dt>
<dd><p>Shared memory. This is memory accessible through more than one processes' virtual address map. There are standardised shm interfaces derived from System V, as well as POSIX.</p></dd>
<dt><a name="id46577852">silly delete</a></dt>
<dd><p>Silly-deleting in NFS is used when somebody tries to delete a file that is held open by some other process. The deletion is delayed, and the file is instead renamed to something along the lines of .nfsxxxxxxxxx. The last process to close the file will then attempt to delete it.</p></dd>
<dt><a name="id46577863">slab allocator</a></dt>
<dd><p>Cache-based kernel memory allocation scheme used by kmalloc(). Bonwick's paper can be found at ftp://ftp.bitmover.com/pub/slab.ps. When actually requiring new pages, __get_free_pages() is called which uses alloc_pages(), with the standard buddy allocator.</p></dd>
<dt><a name="id46577873">softirq</a></dt>
<dd><p>Interrupts run on return to user space or after a hardware interrupt, and there is a fixed number available. See tasklet, bottom-half handler. These methods are usually used to run kernel code resulting from a hardware interrupt of some kind, where the necessary operations take too long to execute in hardirq context. A notable case is routines queuing on TIMER_BH which are executed depending on the hardware timer tick.  These are different from DOS soft interrupts as they don't make use of hardware soft interrupt support (int instruction), although these types of soft interrupt are used in kernel code, for example kernel_thread().</p></dd>
<dt><a name="id46577888">SO_LINGER</a></dt>
<dd><p>FIXME</p></dd>
<dt><a name="id46577896">spinlock</a></dt>
<dd><p>A busy-wait method of ensuring mutual exclusion for a resource. Tasks waiting on a spin-lock sit in a busy loop until the spinlock becomes available. On a UP (single processor) system, spinlocks are not used and are optimised out of the kernel. There are also read-write spinlocks, where multiple readers are allowed, but only one writer. See Documentation/spinlocks.txt in the kernel source for details.</p></dd>
<dt><a name="id46577908">sti</a></dt>
<dd><p>See cli/sti.</p></dd>
<dt><a name="id46577916">superblock</a></dt>
<dd><p>An fs-specific data structure, stored on disk, that holds various bits of information about the fs on the disk, such as a pointer to the free blocks structure, the number of free inodes, etc. In the code, the inode manipulation routines are entered in super_operations vector of function pointers. Often abbreviated to sb.</p></dd>
<dt><a name="id46577927">SuS</a></dt>
<dd><p>The Single Unix Specification, a standard defined with the aim of standardisation of Unix-like OS semantics and APIs. There is also a second version of this standard, referred to as SuS v2.</p></dd>
<dt><a name="id46577937">SVR4</a></dt>
<dd><p>System V Release 4, as in the UNIX source that POSIX is mostly based on.</p></dd>
<dt><a name="id46577946">SYN cookies</a></dt>
<dd><p>Protection against TCP/IP SYN flooding DoS attack by storing state information about SYN packets from hosts. See ftp://koobera.math.uic.edu/syncookies.html.</p></dd>
<dt><a name="id46577956">system calls</a></dt>
<dd><p>The method by which a user process requests facilities provided by the kernel. Examples are wait4(2), open(2), and sched_setscheduler(2). By an architecture-specific method, the kernel is executed on behalf of the process in kernel mode at the entry point of the system call. Generally there is a convention in the source that syscall entry points are prefixed with sys_, for example, the entry point to open(2) is the function sys_open in the file fs/open.c. Code executing in kernel mode (that is, with access to the kernel's memory) from a syscall entry point is said to have a process context.  On x86, all system calls executed from user mode use int 0x80 and came through the syscall call gate in arch/i386/kernel/entry.S.</p></dd>
<dt><a name="id46577978">tail merging</a></dt>
<dd><p>Tail merging is a technique which collects tails of multiple files together in one block to save space, reducing internal fragmentation, especially at larger block sizes.</p></dd>
<dt><a name="id46577988">task</a></dt>
<dd><p>The kernel abstraction for every user process, user thread, and kernel thread. All of these are handled as tasks in the kernel. Every task is described by its task_struct. User processes/threads have an associated user_struct. When in process context, the process's task_struct is accessible through the routine get_current, which does assembly magic to access the struct, which is stored at the bottom of the kernel stack. When running in kernel mode without process context, the struct at the bottom of the kernel stack refers to the idle task.</p></dd>
<dt><a name="id46578001">tasklet</a></dt>
<dd><p>&quot;Software interrupt&quot; routines running when the software interrupt is received at a return to user space or after a hardware interrupt. They do not run concurrently on multiple CPUs, but are dynamically allocatable. See softirq and bottom-half handler.</p></dd>
<dt><a name="id46578012">task queue</a></dt>
<dd><p>A linked list of processes or threads. Tasks, for example, can queue on bottom-half handlers waiting to be executed. See wait queue.</p></dd>
<dt><a name="id46578021">TC</a></dt>
<dd><p>FIXME</p></dd>
<dt><a name="id46578029">TCQ</a></dt>
<dd><p>Tagged Command Queuing. This facility allows the kernel to send several asynchronous requests at once to a block device. The device can service the requests as it sees fit; the advantage being that the device can arrange the transfers as best suits the device hardware. TCQ works for both reads and writes.</p></dd>
<dt><a name="id46578041">thundering herd</a></dt>
<dd><p>Consider a set of tasks on a wait queue, waiting for some condition. When the event occurs, it is often the case that only some of the tasks has real work to do. Older kernels always woke up all tasks on the wait queue - this meant that each task immediately vied for scheduling - the &quot;thundering herd&quot;. More recent kernels have added the TASK_EXCLUSIVE flag to tasks in the wait queue. This ensures that one of the tasks with this flag set will be the only one to be woken up.</p></dd>
<dt><a name="id46578054">TLB flushing</a></dt>
<dd><p>Flagging part or all of a CPU's translation lookaside buffer (which is a virtual-address-indexed cache of physical addresses) as invalid. Depending on hardware, the whole TLB may be flushed at any one time, or just a part.</p></dd>
<dt><a name="id46578064">tmpfs</a></dt>
<dd><p>One of those cyclical lkml threads. O/S's such as Solaris have a &quot;tmpfs&quot; filesystem, providing a fs interface using main memory as storage. This differs from the usual ram disk in that it is swappable. The fs is often used for /tmp, which provides performance gains. Under Linux, ext2fs is already faster than Solaris' tmpfs, so no-one has ever implemented this.</p></dd>
<dt><a name="id46578076">trampoline</a></dt>
<dd><p>The process by which a compiler has special code to deal with code presented as data within a binary's segment, which is to be executed, amongst other scenarios. A short routine is called before the real procedure which sets up the stack environment correctly. This facility is used in languages such as Ada, and complicates provision of non-executable stack support at kernel level (useful for preventing simplistic buffer over-runs). FIXME </p></dd>
<dt><a name="id46578088">TSC</a></dt>
<dd><p>Time Stamp Counter, a very high resolution counter on the Intel platform.</p></dd>
<dt><a name="id46578097">two-hand algorithm</a></dt>
<dd><p>VM algorithm. A two-handed clock algorithm has two &quot;clock hands&quot; sweeping through pages, performing ageing and other activities. Imagine one hand ageing pages, whereas the later one decides to mark pages as unused.</p></dd>
<dt><a name="id46578107">TX</a></dt>
<dd><p>Common abbreviation used in net code for &quot;transmit&quot;.</p></dd>
<dt><a name="id46578116">UART</a></dt>
<dd><p>Universal Asynchronous Receiver/Transmitter. UARTs are hardware devices that convert byte-wide data streams in to serial (bit-wide) data streams.</p></dd>
<dt><a name="id46578125">UBC</a></dt>
<dd><p>Unified Buffer Cache - the combination of the buffer and page caches to use the same memory pool (disk I/O and VM use the same pool), and data I/O utilises the page cache.</p></dd>
<dt><a name="id46578135">UHCI</a></dt>
<dd><p>Intel standard for USB controllers.</p></dd>
<dt><a name="id46578144">union mount</a></dt>
<dd><p>Each mount structure is represented in the kernel by a dentry tree. Sharing of a tree allows union mount, where two separate mounts are accessible under one mount point.</p></dd>
<dt><a name="id46578153">uop</a></dt>
<dd><p>For micro-operation, or the basic set of CPU operations which are generated from machine code in microcode processors. Intel P6 processors and above have the facility for upgrading the microcode (stepping of the processor).</p></dd>
<dt><a name="id46578164">URB</a></dt>
<dd><p>USB Request Block, or the message struct for Universal Serial Bus.</p></dd>
<dt><a name="id46578172">user-mode port</a></dt>
<dd><p>A patched version of the kernel modified to run on top of user-space. This is intended to be used for testing, experimentation and debugging. See http://user-mode-linux.sf.net.</p></dd>
<dt><a name="id46578182">UTSL</a></dt>
<dd><p>Use The Source, Luke!</p></dd>
<dt><a name="id46578190">V4L</a></dt>
<dd><p>Video 4 Linux</p></dd>
<dt><a name="id46578199">versioned filesystem</a></dt>
<dd><p>A filesystem that tracks changes to files, for example by storing the entire previous file on a change in data.</p></dd>
<dt><a name="id46578208">VFS</a></dt>
<dd><p>VFS is the filesystem-independent in-kernel interface used to access each particular filesystem supported by Linux.</p></dd>
<dt><a name="id46578217">VLIW</a></dt>
<dd><p>Very Long Instruction Word, instruction sets with large-sized complex instructions encoded into one instruction.</p></dd>
<dt><a name="id46578227">vmalloc</a></dt>
<dd><p>Allocates a virtual address space. Can be slow for some purposes as it requires a TLB flush on all processors. Does not ensure physical address contiguity, but can allocate arbitrary sized areas. Also requires (along with related vfree()) the big kernel lock.</p></dd>
<dt><a name="id46578237">VMWare</a></dt>
<dd><p>Commercial virtual O/S software. If the modules won't compile for you, DO NOT complain to linux-kernel ! And see FreeMWare/Plex86.</p></dd>
<dt><a name="id46578247">volatile</a></dt>
<dd><p>From the C keyword. Used throughout the source and in discussion, signifying a variable or inline asm that cannot be optimised as usual by the compiler. This usually means the compiler shouldn't store the variable in a register, as another task can alter the value of the real memory contents at the time. For example, this is necessary with I/O address spaces, where the hardware device can fill up a buffer asynchronously to a reading task. Variables which are changed from both interrupts and other contexts are also volatile.</p></dd>
<dt><a name="id46578265">wait queue</a></dt>
<dd><p>A linked list of tasks (processes or threads) waiting on some specific condition. For example, a locked page may have a wait queue of tasks waiting for I/O on that page to complete (that is, !PageLocked(page)).</p></dd>
<dt><a name="id46578275">wall time</a></dt>
<dd><p>Real time, that is, the sort you would expect to find on a clock on your wall...</p></dd>
<dt><a name="id46578284">wandering logs</a></dt>
<dd><p>On journalling filesystems, the metadata must be logged. A wandering log system spreads log blocks throughout the filesystem for performance, rather than using a static log area on the disk.</p></dd>
<dt><a name="id46578294">warm cache</a></dt>
<dd><p>A cache whose contents are not invalid and are useful to the task to be run next. It is important to benchmark code in both cold-cache and warm-cache circumstances.</p></dd>
<dt><a name="id46578304">write bomb logic</a></dt>
<dd><p>Code to protect interactivity from being harmed by large writes. FIXME</p></dd>
<dt><a name="id46578312">write behind</a></dt>
<dd><p>A.K.A. delayed write, asynchronously writing after the write request was made.</p></dd>
<dt><a name="id46578321">WS</a></dt>
<dd><p>FIXME</p></dd>
<dt><a name="id46578329">XDR</a></dt>
<dd><p>External Data Representation, the marshalled form of RPC communications. XDR deals with sizing and endianness issues.</p></dd>
<dt><a name="id46578339">XIP</a></dt>
<dd><p>&quot;Execute in-place&quot;. For normal storage devices, executables are loaded into main memory before execution. For devices like a ram disk or flash system, it is possible to execute the program straight from the device, without duplication.</p></dd>
<dt><a name="id46578349">zero-copy</a></dt>
<dd><p>Networking where no data is copied to/from userspace during network transmit or receive. This is often touted as a universally good thing, but in fact it is a trade-off between the cost of the copy, and the cost of setting up page tables etc. such that user-space can read the data.</p></dd>
<dt><a name="id46578360">ZFOD</a></dt>
<dd><p>Zero-fill-on-demand, a page filled with zeros for which no space has yet been allocated.</p></dd>
<dt><a name="id46578369">zombie</a></dt>
<dd><p>A completed process whose parent has not waited for it. When a child exits, the return status must remain available to the parent, as it may later do a wait4(). A zombie holds its place in the process table until the parent waits for it.</p></dd>
<dt><a name="id46578380">zone</a></dt>
<dd><p>A particular area of free memory. Zoned allocators differentiate between intended uses, and are generally used to model different characteristics of the memory. For example, on the x86 there is only 16Mb of DMA-able memory; the zoned allocator will try to save DMA pages for processes specifically requesting ZONE_DMA memory. There are currently three zone types: ZONE_DMA, ZONE_NORMAL, and ZONE_HIGHMEM (see highmem).</p></dd>
</dl>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a href="indexs16.html">Prev</a> </td>
<td width="20%" align="center"><a href="index.html">Home</a></td>
<td width="40%" align="right"> <a href="indexs17.html#id46575701">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left">To Do </td>
<td width="20%" align="center"><a href="index.html">Up</a></td>
<td width="40%" align="right"> Glossary</td>
</tr>
</table>
</div>
</body>
</html>

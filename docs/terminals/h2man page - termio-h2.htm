<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0041)http://campuscgi.princeton.edu/man?termio -->
<HTML><HEAD><TITLE><h2>man page - termio</h2></TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type>
<META content="MSHTML 5.00.3502.5390" name=GENERATOR></HEAD>
<BODY>
<H1>
<H2>man page - termio</H2></H1><A 
href="http://campuscgi.princeton.edu/index.html"><B>Princeton University Campus 
CGI Facility<B></A><BR><A href="http://campuscgi.princeton.edu/man"><B>Return to 
man page access form<B></A>
<HR>
 <!-- manual page source format generated by RosettaMan, --><!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z --><HEADER></HEADER><A 
href="http://campuscgi.princeton.edu/man?termio#toc">Table of Contents</A>
<P><A href="http://campuscgi.princeton.edu/man?termio#toc0" name=sect0>
<H2>NAME</H2></A>termio - general terminal interface
<P><A href="http://campuscgi.princeton.edu/man?termio#toc1" name=sect1>
<H2>SYNOPSIS</H2></A>#include &lt;termio.h&gt;<BR>ioctl(int <I>fildes</I>, int 
<I>request</I>, struct termio *<I>arg</I>); ioctl(int <I>fildes</I>, int 
<I>request</I>, int <I>arg</I>); #include &lt;termios.h&gt;<BR>ioctl(int 
<I>fildes</I>, int <I>request</I>, struct termios *<I>arg</I>);
<P><A href="http://campuscgi.princeton.edu/man?termio#toc2" name=sect2>
<H2>DESCRIPTION</H2></A>This release supports a general interface for 
asynchronous communications ports that is hardware-independent. The user 
interface to this functionality is using function calls (the preferred 
interface) described in <A 
href="http://campuscgi.princeton.edu/man?termios">termios(3)</A> or ioctl 
commands described in this section. This section also discusses the common 
features of the terminal subsystem which are relevant with both user interfaces.
<P>When a terminal file is opened, it normally causes the process to wait until 
a connection is established. In practice, users' programs seldom open terminal 
files; they are opened by the system and become a user's standard input, output, 
and error files. The first terminal file opened by the session leader that is 
not already associated with a session becomes the controlling terminal for that 
session. The controlling terminal plays a special role in handling quit and 
interrupt signals, as discussed below. The controlling terminal is inherited by 
a child process during a <A 
href="http://campuscgi.princeton.edu/man?fork">fork(2)</A>. A process can break 
this association by changing its session using setsid() (see <A 
href="http://campuscgi.princeton.edu/man?getsid">getsid(2)</A>).
<P>A terminal associated with one of these files ordinarily operates in 
full-duplex mode. Characters may be typed at any time, even while output is 
occurring, and are only lost when the character input buffers of the system 
become completely full, which is rare. For example, the number of characters in 
the line discipline buffer may exceed {MAX_CANON} and IMAXBEL (see below) is not 
set, or the user may accumulate {MAX_INPUT} number of input characters that have 
not yet been read by some program. When the input limit is reached, all the 
characters saved in the buffer up to that point are thrown away without notice.
<P>Session Management (Job Control)<BR>A control terminal will distinguish one 
of the process groups in the session associated with it to be the foreground 
process group. All other process groups in the session are designated as 
background process groups. This foreground process group plays a special role in 
handling signal-generating input characters, as discussed below. By default, 
when a controlling terminal is allocated, the controlling process's process 
group is assigned as foreground process group.
<P>Background process groups in the controlling process's session are subject to 
a job control line discipline when they attempt to access their controlling 
terminal. Process groups can be sent signals that will cause them to stop, 
unless they have made other arrangements. An exception is made for members of 
orphaned process groups.
<P>The operating system will not normally send SIGTSTP, SIGTTIN, or SIGTTOU 
signals to a process that is a member of an orphaned process group.
<P>These are process groups which do not have a member with a parent in another 
process group that is in the same session and therefore shares the same 
controlling terminal. When a member's orphaned process group attempts to access 
its controlling terminal, errors will be returned. since there is no process to 
continue it if it should stop.
<P>If a member of a background process group attempts to read its controlling 
terminal, its process group will be sent a SIGTTIN signal, which will normally 
cause the members of that process group to stop. If, however, the process is 
ignoring or holding SIGTTIN, or is a member of an orphaned process group, the 
read will fail with errno set to EIO, and no signal will be sent.
<P>If a member of a background process group attempts to write its controlling 
terminal and the TOSTOP bit is set in the c_lflag field, its process group will 
be sent a SIGTTOU signal, which will normally cause the members of that process 
group to stop. If, however, the process is ignoring or holding SIGTTOU, the 
write will succeed. If the process is not ignoring or holding SIGTTOU and is a 
member of an orphaned process group, the write will fail with errno set to EIO, 
and no signal will be sent.
<P>If TOSTOP is set and a member of a background process group attempts to ioctl 
its controlling terminal, and that ioctl will modify terminal parameters (for 
example, TCSETA, TCSETAW, TCSETAF, or TIOCSPGRP), its process group will be sent 
a SIGTTOU signal, which will normally cause the members of that process group to 
stop. If, however, the process is ignoring or holding SIGTTOU, the ioctl will 
succeed. If the process is not ignoring or holding SIGTTOU and is a member of an 
orphaned process group, the write will fail with errno set to EIO, and no signal 
will be sent.
<P>Canonical Mode Input Processing<BR>
<DL>
  <DT>Normally, terminal input is processed in units of lines.
  <DD>A
  <P></P></DD></DL>line is delimited by a newline (ASCII LF) character, an 
end-of-file (ASCII EOT) character, or an end-of-line character. This means that 
a program attempting to read will be suspended until an entire line has been 
typed. Also, no matter how many characters are requested in the read call, at 
most one line will be returned. It is not necessary, however, to read a whole 
line at once; any number of characters may be requested in a read, even one, 
without losing information.
<P>During input, erase and kill processing is normally done. The ERASE character 
(by default, the character DEL) erases the last character typed. The WERASE 
character (the character Control-w) erases the last "word" typed in the current 
input line (but not any preceding spaces or tabs). A "word" is defined as a 
sequence of non-blank characters, with tabs counted as blanks. Neither ERASE nor 
WERASE will erase beyond the beginning of the line. The KILL character (by 
default, the character NAK) kills (deletes) the entire input line, and 
optionally outputs a newline character. All these characters operate on a key 
stroke basis, independent of any backspacing or tabbing that may have been done. 
The REPRINT character (the character Control-r) prints a newline followed by all 
characters that have not been read. Reprinting also occurs automatically if 
characters that would normally be erased from the screen are fouled by program 
output. The characters are reprinted as if they were being echoed; 
consequencely, if ECHO is not set, they are not printed.
<P>The ERASE and KILL characters may be entered literally by preceding them with 
the `\' (escape) character. In this case, the escape character is not read. The 
erase and kill characters may be changed.
<P>Non-canonical Mode Input Processing<BR>In non-canonical mode input 
processing, input characters are not assembled into lines, and erase and kill 
processing does not occur. The MIN and TIME values are used to determine how to 
process the characters received.
<P>MIN represents the minimum number of characters that should be received when 
the read is satisfied (that is, when the characters are returned to the user). 
TIME is a timer of 0.10-second granularity that is used to timeout bursty and 
short-term data transmissions. The four possible values for MIN and TIME and 
their interactions are described below.
<P>Case A: MIN &gt; 0, TIME &gt; 0<BR>In this case, TIME serves as an 
intercharacter timer and is activated after the first character is received. 
Since it is an intercharacter timer, it is reset after a character is received. 
The interaction between MIN and TIME is as follows: as soon as one character is 
received, the intercharacter timer is started. If MIN characters are received 
before the intercharacter timer expires (note that the timer is reset upon 
receipt of each character), the read is satisfied. If the timer expires before 
MIN characters are received, the characters received to that point are returned 
to the user. Note that if TIME expires, at least one character will be returned 
because the timer would not have been enabled unless a character was received. 
In this case (MIN &gt; 0, TIME &gt; 0), the read sleeps until the MIN and TIME 
mechanisms are activated by the receipt of the first character. If the number of 
characters read is less than the number of characters available, the timer is 
not reactivated and the subsequent read is satisfied immediately.
<P>Case B: MIN &gt; 0, TIME = 0<BR>In this case, since the value of TIME is 
zero, the timer plays no role and only MIN is significant. A pending read is not 
satisfied until MIN characters are received (the pending read sleeps until MIN 
characters are received). A program that uses this case to read record based 
terminal I/O may block indefinitely in the read operation.
<P>Case C: MIN = 0, TIME &gt; 0<BR>In this case, since MIN = 0, TIME no longer 
represents an intercharacter timer: it now serves as a read timer that is 
activated as soon as a read is done. A read is satisfied as soon as a single 
character is received or the read timer expires. Note that, in this case, if the 
timer expires, no character is returned. If the timer does not expire, the only 
way the read can be satisfied is if a character is received. In this case, the 
read will not block indefinitely waiting for a character; if no character is 
received within TIME*.10 seconds after the read is initiated, the read returns 
with zero characters.
<P>Case D: MIN = 0, TIME = 0<BR>In this case, return is immediate. The minimum 
of either the number of characters requested or the number of characters 
currently available is returned without waiting for more characters to be input.
<P>Comparing Different Cases of MIN, TIME Interaction Some points to note about 
MIN and TIME:
<P>o In the following explanations, note that the interactions of MIN and TIME 
are not symmetric. For example, when MIN &gt; 0 and TIME = 0, TIME has no 
effect. However, in the opposite case, where MIN = 0 and TIME &gt; 0, both MIN 
and TIME play a role in that MIN is satisfied with the receipt of a single 
character.
<P>o Also note that in case A (MIN &gt; 0, TIME &gt; 0), TIME represents an 
intercharacter timer, whereas in case C (MIN = 0, TIME &gt; 0), TIME represents 
a read timer.
<P>These two points highlight the dual purpose of the MIN/TIME feature. Cases A 
and B, where MIN &gt; 0, exist to handle burst mode activity (for example, file 
transfer programs), where a program would like to process at least MIN 
characters at a time. In case A, the intercharacter timer is activated by a user 
as a safety measure; in case B, the timer is turned off.
<P>Cases C and D exist to handle single character, timed transfers. These cases 
are readily adaptable to screenbased applications that need to know if a 
character is present in the input queue before refreshing the screen. In case C, 
the read is timed, whereas in case D, it is not.
<P>Another important note is that MIN is always just a minimum. It does not 
denote a record length. For example, if a program does a read of 20 bytes, MIN 
is 10, and 25 characters are present, then 20 characters will be returned to the 
user.
<P>Writing Characters<BR>When one or more characters are written, they are 
transmitted to the terminal as soon as previously written characters have 
finished typing. Input characters are echoed as they are typed if echoing has 
been enabled. If a process produces characters more rapidly than they can be 
typed, it will be suspended when its output queue exceeds some limit. When the 
queue is drained down to some threshold, the program is resumed.
<P>Special Characters<BR>Certain characters have special functions on input. 
These functions and their default character values are summarized as follows:
<P>
<DL>
  <DT>INTR
  <DD>(Control-c or ASCII ETX) generates a SIGINT signal. SIGINT is sent to all 
  frequent processes associated with the controlling terminal. Normally, each 
  such process is forced to terminate, but arrangements may be made either to 
  ignore the signal or to receive a trap to an agreed upon location. (See <A 
  href="http://campuscgi.princeton.edu/man?signal">signal(5)</A>).
  <P></P></DD></DL>
<DL>
  <DT>QUIT
  <DD>(Control-| or ASCII FS) generates a SIGQUIT signal.
  <P></P></DD></DL>Its treatment is identical to the interrupt signal except that, 
unless a receiving process has made other arrangements, it will not only be 
terminated but a core image file (called core) will be created in the current 
working directory.
<P>
<DL>
  <DT>ERASE
  <DD>(DEL) erases the preceding character. It does not erase beyond the start 
  of a line, as delimited by a NL, EOF, EOL, or EOL2 character.
  <P></P></DD></DL>WERASE (Control-w or ASCII ETX) erases the preceding "word". It 
does not erase beyond the start of a line, as delimited by a NL, EOF, EOL, or 
EOL2 character.
<P>
<DL>
  <DT>KILL
  <DD>(Control-u or ASCII NAK) deletes the entire line, as delimited by a NL, 
  EOF, EOL, or EOL2 character.
  <P></P></DD></DL>REPRINT (Control-r or ASCII DC2) reprints all characters, 
preceded by a newline, that have not been read.
<P>
<DL>
  <DT>EOF
  <DD>(Control-d or ASCII EOT) may be used to generate an end-of-file from a 
  terminal. When received, all the characters waiting to be read are immediately 
  passed to the program, without waiting for a newline, and the EOF is 
  discarded. Thus, if no characters are waiting (that is, the EOF occurred at 
  the beginning of a line) zero characters are passed back, which is the 
  standard end-of-file indication. Unless escaped, the EOF character is not 
  echoed. Because EOT is the default EOF character, this prevents terminals that 
  respond to EOT from hanging up.
  <P></P></DD></DL>
<DL>
  <DT>NL
  <DD>(ASCII LF) is the normal line delimiter. It cannot be changed or escaped.
  <P></P></DD></DL>
<DL>
  <DT>EOL
  <DD>(ASCII NULL) is an additional line delimiter, like NL. It is not normally 
  used.
  <P></P></DD></DL>
<DL>
  <DT>EOL2
  <DD>is another additional line delimiter.
  <P></P></DD></DL>
<DL>
  <DT>SWTCH
  <DD>(Control-z or ASCII EM) is used only when shl layers is invoked.
  <P></P></DD></DL>
<DL>
  <DT>SUSP
  <DD>(Control-z or ASCII SUB) generates a SIGTSTP signal. SIGTSTP stops all 
  processes in the foreground process group for that terminal.
  <P></P></DD></DL>
<DL>
  <DT>DSUSP
  <DD>(Control-y or ASCII EM) It generates a SIGTSTP signal as SUSP does, but 
  the signal is sent when a process in the foreground process group attempts to 
  read the DSUSP character, rather than when it is typed.
  <P></P></DD></DL>
<DL>
  <DT>STOP
  <DD>(Control-s or ASCII DC3) can be used to suspend output temporarily. It is 
  useful with CRT terminals to prevent output from disappearing before it can be 
  read. While output is suspended, STOP characters are ignored and not read.
  <P></P></DD></DL>
<DL>
  <DT>START
  <DD>(Control-q or ASCII DC1) is used to resume output. Output has been 
  suspended by a STOP character. While output is not suspended, START characters 
  are ignored and not read.
  <P></P></DD></DL>DISCARD (Control-o or ASCII SI) causes subsequent output to be 
discarded. Output is discarded until another DISCARD character is typed, more 
input arrives, or the condition is cleared by a program.
<P>
<DL>
  <DT>LNEXT
  <DD>(Control-v or ASCII SYN) causes the special meaning of the next character 
  to be ignored. This works for all the special characters mentioned above. It 
  allows characters to be input that would otherwise be interpreted by the 
  system (for example KILL, QUIT). .PP The character values for INTR, QUIT, 
  ERASE, WERASE, KILL, REPRINT, EOF, EOL, EOL2, SWTCH, SUSP, DSUSP, STOP, START, 
  DISCARD, and LNEXT may be changed to suit individual tastes. If the value of a 
  special control character is _POSIX_VDISABLE (0), the function of that special 
  control character is disabled. The ERASE, KILL, and EOF characters may be 
  escaped by a preceding `\' character, in which case no special function is 
  done. Any of the special characters may be preceded by the LNEXT character, in 
  which case no special function is done.
  <P></P></DD></DL>Modem Disconnect<BR>When a modem disconnect is detected, a 
SIGHUP signal is sent to the terminal's controlling process. Unless other 
arrangements have been made, these signals cause the process to terminate. If 
SIGHUP is ignored or caught, any subsequent read returns with an end-of-file 
indication until the terminal is closed.
<P>If the controlling process is not in the foreground process group of the 
terminal, a SIGTSTP is sent to the terminal's foreground process group. Unless 
other arrangements have been made, these signals cause the processes to stop.
<P>Processes in background process groups that attempt to access the controlling 
terminal after modem disconnect while the terminal is still allocated to the 
session will receive appropriate SIGTTOU and SIGTTIN signals. Unless other 
arrangements have been made, this signal causes the processes to stop.
<P>The controlling terminal will remain in this state until it is reinitialized 
with a successful open by the controlling process, or deallocated by the 
controlling process.
<P>Terminal Parameters<BR>The parameters that control the behavior of devices 
and modules providing the termios interface are specified by the termios 
structure defined by termios.h. Several <A 
href="http://campuscgi.princeton.edu/man?ioctl">ioctl(2)</A> system calls that 
fetch or change these parameters use this structure that contains the following 
members: tcflag_t c_iflag; /* input modes */ tcflag_t c_oflag; /* output modes 
*/ tcflag_t c_cflag; /* control modes */ tcflag_t c_lflag; /* local modes */ 
<DL>
  <DT>cc_t
  <DD>c_cc[NCCS]; /* control chars */
  <P></P></DD></DL>The special control characters are defined by the array c_cc. 
The symbolic name NCCS is the size of the Controlcharacter array and is also 
defined by &lt;termios.h&gt;. The relative positions, subscript names, and 
typical default values for each function are as follows: 0 VINTR ETX<BR>1 VQUIT 
FS<BR>2 VERASE DEL<BR>3 VKILL NAK<BR>4 VEOF EOT<BR>5 VEOL NUL<BR>6 VEOL2 
NUL<BR>7 VSWTCH NUL<BR>8 VSTART DC1<BR>9 VSTOP DC3<BR>10 VSUSP SUB<BR>11 VDSUSP 
EM<BR>12 VREPRINT DC2<BR>13 VDISCARD SI<BR>14 VWERASE ETB<BR>15 VLNEXT 
SYN<BR>16-19 reserved
<P>Input Modes<BR>The c_iflag field describes the basic terminal input control:
<P>
<DL>
  <DT>IGNBRK
  <DD>Ignore break condition. </DD></DL>
<DL>
  <DT>BRKINT
  <DD>Signal interrupt on break. </DD></DL>
<DL>
  <DT>IGNPAR
  <DD>Ignore characters with parity errors. </DD></DL>
<DL>
  <DT>PARMRK
  <DD>Mark parity errors.
  <P></P></DD></DL>
<DL>
  <DT>INPCK
  <DD>Enable input parity check. </DD></DL>
<DL>
  <DT>ISTRIP
  <DD>Strip character. </DD></DL>
<DL>
  <DT>INLCR
  <DD>Map NL to CR on input. </DD></DL>
<DL>
  <DT>IGNCR
  <DD>Ignore CR. </DD></DL>
<DL>
  <DT>ICRNL
  <DD>Map CR to NL on input. </DD></DL>
<DL>
  <DT>IUCLC
  <DD>Map upper-case to lower-case on input. </DD></DL>
<DL>
  <DT>IXON
  <DD>Enable start/stop output control. </DD></DL>
<DL>
  <DT>IXANY
  <DD>Enable any character to restart output. </DD></DL>
<DL>
  <DT>IXOFF
  <DD>Enable start/stop input control. </DD></DL>
<DL>
  <DT>IMAXBEL
  <DD>Echo BEL on input line too long.
  <P></P></DD></DL>If IGNBRK is set, a break condition (a character framing error 
with data all zeros) detected on input is ignored, that is, not put on the input 
queue and therefore not read by any process. If IGNBRK is not set and BRKINT is 
set, the break condition shall flush the input and output queues and if the 
terminal is the controlling terminal of a foreground process group, the break 
condition generates a single SIGINT signal to that foreground process group. If 
neither IGNBRK nor BRKINT is set, a break condition is read as a single \0 
(ASCII NULL) character, or if PARMRK is set, as \377, \0, \0.
<P>If IGNPAR is set, a byte with framing or parity errors (other than break) is 
ignored.
<P>If PARMRK is set, and IGNPAR is not set, a byte with a framing or parity 
error (other than break) is given to the application as the three-character 
sequence: \377, \0, <I>X</I>, where <I>X</I> is the data of the byte received in 
error. To avoid ambiguity in this case, if ISTRIP is not set, a valid character 
of \377 is given to the application as \377, \377. If neither IGNPAR nor PARMRK 
is set, a framing or parity error (other than break) is given to the application 
as a single \0 (ASCII NULL) character.
<P>If INPCK is set, input parity checking is enabled. If I NPCK is not set, 
input parity checking is disabled. This allows output parity generation without 
input parity errors. Note that whether input parity checking is enabled or 
disabled is independent of whether parity detection is enabled or disabled. If 
parity detection is enabled but input parity checking is disabled, the hardware 
to which the terminal is connected will recognize the parity bit, but the 
terminal special file will not check whether this is set correctly or not.
<P>If ISTRIP is set, valid input characters are first stripped to seven bits, 
otherwise all eight bits are processed.
<P>If INLCR is set, a received NL character is translated into a CR character. 
If IGNCR is set, a received CR character is ignored (not read). Otherwise, if 
ICRNL is set, a received CR character is translated into a NL character.
<P>If IUCLC is set, a received upper case, alphabetic character is translated 
into the corresponding lower case character.
<P>If IXON is set, start/stop output control is enabled. A received STOP 
character suspends output and a received START character restarts output. The 
STOP and START characters will not be read, but will merely perform flow control 
functions. If IXANY is set, any input character restarts output that has been 
suspended.
<P>If IXOFF is set, the system transmits a STOP character when the input queue 
is nearly full, and a START character when enough input has been read so that 
the input queue is nearly empty again.
<P>If IMAXBEL is set, the ASCII BEL character is echoed if the input stream 
overflows. Further input is not stored, but any input already present in the 
input stream is not disturbed. If IMAXBEL is not set, no BEL character is 
echoed, and all input present in the input queue is discarded if the input 
stream overflows.
<P>Output Modes<BR>The c_oflag field specifies the system treatment of output:
<P>
<DL>
  <DT>OPOST
  <DD>Post-process output. </DD></DL>
<DL>
  <DT>OLCUC
  <DD>Map lower case to upper on output. </DD></DL>
<DL>
  <DT>ONLCR
  <DD>Map NL to CR-NL on output. </DD></DL>
<DL>
  <DT>OCRNL
  <DD>Map CR to NL on output. </DD></DL>
<DL>
  <DT>ONOCR
  <DD>No CR output at column 0. </DD></DL>
<DL>
  <DT>ONLRET
  <DD>NL performs CR function. </DD></DL>
<DL>
  <DT>OFILL
  <DD>Use fill characters for delay. </DD></DL>
<DL>
  <DT>OFDEL
  <DD>Fill is DEL, else NULL. </DD></DL>
<DL>
  <DT>NLDLY
  <DD>Select newline delays: NL0 NL1 </DD></DL>
<DL>
  <DT>CRDLY
  <DD>Select carriage-return delays: CR0 CR1 CR2 CR3 </DD></DL>
<DL>
  <DT>TABDLY
  <DD>Select horizontal tab delays: </DD></DL>
<DL>
  <DT>TAB0
  <DD>or tab expansion: TAB1 TAB2 </DD></DL>
<DL>
  <DT>TAB3
  <DD>Expand tabs to spaces. </DD></DL>
<DL>
  <DT>XTABS
  <DD>Expand tabs to spaces. </DD></DL>
<DL>
  <DT>BSDLY
  <DD>Select backspace delays: BS0
  <P></P></DD></DL>BS1<BR>
<DL>
  <DT>VTDLY
  <DD>Select vertical tab delays: VT0 VT1 </DD></DL>
<DL>
  <DT>FFDLY
  <DD>Select form feed delays: FF0 FF1
  <P></P></DD></DL>If OPOST is set, output characters are post-processed as 
indicated by the remaining flags; otherwise, characters are transmitted without 
change.
<P>If OLCUC is set, a lower case alphabetic character is transmitted as the 
corresponding upper case character. This function is often used in conjunction 
with IUCLC.
<P>If ONLCR is set, the NL character is transmitted as the CRNL character pair. 
If OCRNL is set, the CR character is transmitted as the NL character. If ONOCR 
is set, no CR character is transmitted when at column 0 (first position). If 
ONRET is set, the NL character is assumed to do the carriage-return function; 
the column pointer is set to 0 and the delays specified for CR are used. 
Otherwise, the NL character is assumed to do just the line-feed function; the 
column pointer remains unchanged. The column pointer is also set to 0 if the CR 
character is actually transmitted.
<P>The delay bits specify how long transmission stops to allow for mechanical or 
other movement when certain characters are sent to the terminal. In all cases, a 
value of 0 indicates no delay. If OFILL is set, fill characters are transmitted 
for delay instead of a timed delay. This is useful for high baud rate terminals 
that need only a minimal delay. If OFDEL is set, the fill character is DEL; 
otherwise it is NULL.
<P>If a form-feed or vertical-tab delay is specified, it lasts for about 2 
seconds.
<P>Newline delay lasts about 0.10 seconds. If ONLRET is set, the carriage-return 
delays are used instead of the newline delays. If OFILL is set, two fill 
characters are transmitted.
<P>Carriage-return delay type 1 is dependent on the current column position, 
type 2 is about 0.10 seconds, and type 3 is about 0.15 seconds. If OFILL is set, 
delay type 1 transmits two fill characters, and type 2 transmits four fill 
characters.
<P>Horizontal-tab delay type 1 is dependent on the current column position. Type 
2 is about 0.10 seconds. Type 3 specifies that tabs are to be expanded into 
spaces. If
<P>OFILL is set, two fill characters are transmitted for any delay.
<P>Backspace delay lasts about 0.05 seconds. If OFILL is set, one fill character 
is transmitted.
<P>The actual delays depend on line speed and system load.
<P>Control Modes<BR>The c_cflag field describes the hardware control of the 
terminal:
<P>
<DL>
  <DT>CBAUD
  <DD>Baud rate: </DD></DL>
<DL>
  <DT>B0
  <DD>Hang up </DD></DL>
<DL>
  <DT>B50
  <DD>50 baud </DD></DL>
<DL>
  <DT>B75
  <DD>75 baud </DD></DL>
<DL>
  <DT>B110
  <DD>110 baud </DD></DL>
<DL>
  <DT>B134
  <DD>134 baud </DD></DL>
<DL>
  <DT>B150
  <DD>150 baud </DD></DL>
<DL>
  <DT>B200
  <DD>200 baud </DD></DL>
<DL>
  <DT>B300
  <DD>300 baud </DD></DL>
<DL>
  <DT>B600
  <DD>600 baud </DD></DL>
<DL>
  <DT>B1200
  <DD>1200 baud </DD></DL>
<DL>
  <DT>B1800
  <DD>1800 baud </DD></DL>
<DL>
  <DT>B2400
  <DD>2400 baud </DD></DL>
<DL>
  <DT>B4800
  <DD>4800 baud </DD></DL>
<DL>
  <DT>B9600
  <DD>9600 baud </DD></DL>
<DL>
  <DT>B19200
  <DD>19200 baud </DD></DL>
<DL>
  <DT>EXTA
  <DD>External A </DD></DL>
<DL>
  <DT>B38400
  <DD>38400 baud </DD></DL>
<DL>
  <DT>EXTB
  <DD>External B </DD></DL>
<DL>
  <DT>B57600
  <DD>57600 baud </DD></DL>
<DL>
  <DT>B76800
  <DD>76800 baud </DD></DL>
<DL>
  <DT>B115200
  <DD>115200 baud </DD></DL>
<DL>
  <DT>B153600
  <DD>153600 baud </DD></DL>
<DL>
  <DT>B230400
  <DD>230400 baud </DD></DL>
<DL>
  <DT>B307200
  <DD>307200 baud </DD></DL>
<DL>
  <DT>B460800
  <DD>460800 baud
  <P></P></DD></DL>
<DL>
  <DT>CSIZE
  <DD>Character size: </DD></DL>
<DL>
  <DT>CS5
  <DD>5 bits </DD></DL>
<DL>
  <DT>CS6
  <DD>6 bits </DD></DL>
<DL>
  <DT>CS7
  <DD>7 bits </DD></DL>
<DL>
  <DT>CS8
  <DD>8 bits
  <P></P></DD></DL>
<DL>
  <DT>CSTOPB
  <DD>Send two stop bits, else one </DD></DL>
<DL>
  <DT>CREAD
  <DD>Enable receiver </DD></DL>
<DL>
  <DT>PARENB
  <DD>Parity enable </DD></DL>
<DL>
  <DT>PARODD
  <DD>Odd parity, else even </DD></DL>
<DL>
  <DT>HUPCL
  <DD>Hang up on last close </DD></DL>
<DL>
  <DT>CLOCAL
  <DD>Local line, else dial-up </DD></DL>
<DL>
  <DT>CIBAUD
  <DD>Input baud rate, if different from output rate </DD></DL>
<DL>
  <DT>PAREXT
  <DD>Extended parity for mark and space parity </DD></DL>
<DL>
  <DT>CRTSXOFF
  <DD>Enable inbound hardware flow control </DD></DL>
<DL>
  <DT>CRTSCTS
  <DD>Enable outbound hardware flow control </DD></DL>
<DL>
  <DT>CBAUDEXT
  <DD>Bit to indicate output speed &gt; B38400 </DD></DL>
<DL>
  <DT>CIBAUDEXT
  <DD>Bit to indicate input speed &gt; B38400
  <P></P></DD></DL>The CBAUD bits together with the CBAUDEXT bit specify the 
output baud rate. To retrieve the output speed from the termios structure 
pointed to by termios_p see the following code segment.
<P>speed_t ospeed;
<P>if (termios_p-&gt;c_cflag &amp; CBAUDEXT)<BR>ospeed = (termios_p-&gt;c_cflag 
&amp; CBAUD) + CBAUD + 1; else<BR>ospeed = termios_p-&gt;c_cflag &amp; CBAUD;
<P>To store the output speed in the termios structure pointed to by termios_p 
see the following code segment.
<P>speed_t ospeed;
<P>if (ospeed &gt; CBAUD) {<BR>termios_p-&gt;c_cflag |= CBAUDEXT;<BR>ospeed -= 
(CBAUD + 1);<BR>} else<BR>termios_p-&gt;c_cflag &amp;= ~CBAUDEXT;
<P>termios_p-&gt;c_cflag =<BR>(termios_p-&gt;c_cflag &amp; ~CBAUD) | (ospeed 
&amp; CBAUD);
<P>The zero baud rate, B0, is used to hang up the connection. If B0 is 
specified, the data-terminal-ready signal is not asserted. Normally, this 
disconnects the line.
<P>If the CIBAUDEXT or CIBAUD bits are not zero, they specify the input baud 
rate, with the CBAUDEXT and CBAUD bits specifying the output baud rate; 
otherwise, the output and input baud rates are both specified by the CBAUDEXT 
and CBAUD bits. The values for the CIBAUD bits are the same as the values for 
the CBAUD bits, shifted left IBSHIFT bits. For any particular hardware, 
impossible speed changes are ignored. To retrieve the input speed in the termios 
structure pointed to by termios_p see the following code segment.
<P>speed_t ispeed;
<P>if (termios_p-&gt;c_cflag &amp; CIBAUDEXT)
<P>ispeed = ((termios_p-&gt;c_cflag &amp; CIBAUD) &gt;&gt; IBSHIFT) + (CIBAUD 
&gt;&gt; IBSHIFT) + 1; else<BR>ispeed = (termios_p-&gt;c_cflag &amp; CIBAUD) 
&gt;&gt; IBSHIFT;
<P>To store the input speed in the termios structure pointed to by termios_p see 
the following code segment.
<P>speed_t ispeed;
<P>if (ispeed == 0) {<BR>ispeed = termios_p-&gt;c_cflag &amp; CBAUD; if 
(termios_p-&gt;c_cflag &amp; CBAUDEXT) ispeed += (CBAUD + 1); }
<P>if ((ispeed &lt;&lt; IBSHIFT) &gt; CIBAUD) { termios_p-&gt;c_cflag |= 
CIBAUDEXT; ispeed -= ((CIBAUD &gt;&gt; IBSHIFT) + 1); } 
else<BR>termios_p-&gt;c_cflag &amp;= ~CIBAUDEXT; termios_p-&gt;c_cflag 
=<BR>(termios_p-&gt;c_cflag &amp; ~CIBAUD)<BR>((ispeed &lt;&lt; IBSHIFT) &amp; 
CIBAUD);
<P>The CSIZE bits specify the character size in bits for both transmission and 
reception. This size does not include the parity bit, if any. If CSTOPB is set, 
two stop bits are used; otherwise, one stop bit is used. For example, at 110 
baud, two stops bits are required.
<P>If PARENB is set, parity generation and detection is enabled, and a parity 
bit is added to each character. If parity is enabled, the PARODD flag specifies 
odd parity if set; otherwise, even parity is used.
<P>If CREAD is set, the receiver is enabled. Otherwise, no characters are 
received.
<P>If HUPCL is set, the line is disconnected when the last process with the line 
open closes it or terminates. That is, the data-terminal-ready signal is not 
asserted.
<P>If CLOCAL is set, the line is assumed to be a local, direct connection with 
no modem control; otherwise, modem control is assumed.
<P>If CRTSCTS is set, inbound hardware flow control is enabled.
<P>If CRTSCTS is set, outbound hardware flow control is enabled.
<P>The four possible combinations for the state of CRTSCTS and CRTSXOFF bits and 
their interactions are described below.
<P>Case A: CRTSCTS off, CRTSXOFF off. In this case the hardware flow control is 
disabled.
<P>Case B: CRTSCTS on, CRTSXOFF off. In this case only outbound hardware flow 
control is enabled. The state of CTS signal is used to do outbound flow control. 
It is expected that output will be suspended if CTS is low and resumed when CTS 
is high.
<P>Case C: CRTSCTS off, CRTSXOFF on. In this case only inbound hardware flow 
control is enabled. The state of RTS signal is used to do inbound flow con
<DL>
  <DT>trol.
  <DD>It is expected that input will be suspended if RTS is low and resumed when 
  RTS is high.
  <P></P></DD></DL>Case D: CRTSCTS on, CRTSXOFF on. In this case both inbound and 
outbound hardware flow control are enabled. Uses the state of CTS signal to do 
outbound flow control and RTS signal to do inbound flow control.
<P>Local Modes<BR>The c_lflag field of the argument structure is used by the 
line discipline to control terminal functions. The basic line discipline 
provides the following:
<P>
<DL>
  <DT>ISIG
  <DD>Enable signals. </DD></DL>
<DL>
  <DT>ICANON
  <DD>Canonical input (erase and kill processing). </DD></DL>
<DL>
  <DT>XCASE
  <DD>Canonical upper/lower presentation. </DD></DL>
<DL>
  <DT>ECHO
  <DD>Enable echo. </DD></DL>
<DL>
  <DT>ECHOE
  <DD>Echo erase character as BS-SP-BS&amp;. </DD></DL>
<DL>
  <DT>ECHOK
  <DD>Echo NL after kill character. </DD></DL>
<DL>
  <DT>ECHONL
  <DD>Echo NL. </DD></DL>
<DL>
  <DT>NOFLSH
  <DD>Disable flush after interrupt or quit. </DD></DL>
<DL>
  <DT>TOSTOP
  <DD>Send SIGTTOU for background output. </DD></DL>
<DL>
  <DT>ECHOCTL
  <DD>Echo control characters as <I>char</I>, delete as ^?. </DD></DL>
<DL>
  <DT>ECHOPRT
  <DD>Echo erase character as character erased. </DD></DL>
<DL>
  <DT>ECHOKE
  <DD>BS-SP-BS erase entire line on line kill. </DD></DL>
<DL>
  <DT>FLUSHO
  <DD>Output is being flushed. </DD></DL>
<DL>
  <DT>PENDIN
  <DD>Retype pending input at next read or input character. </DD></DL>
<DL>
  <DT>IEXTEN
  <DD>Enable extended (implementation-defined) functions.
  <P></P></DD></DL>If ISIG is set, each input character is checked against the 
special control characters INTR, QUIT, SWTCH, SUSP, STATUS, and DSUSP. If an 
input character matches one of these control characters, the function associated 
with that character is performed. If ISIG is not set, no checking is done. Thus, 
these special input functions are possible only if ISIG is set.
<P>If ICANON is set, canonical processing is enabled. This enables the erase and 
kill edit functions, and the assembly of input characters into lines delimited 
by NL-c , EOF, EOL, and EOL. If ICANON is not set, read requests are satisfied 
directly from the input queue. A read is not satisfied until at least MIN 
characters have been received or the timeout value TIME has expired between 
characters. This allows fast bursts of input to be read efficiently while still 
allowing single character input. The time value represents tenths of seconds.
<P>If XCASE is set, and if ICANON is set, an upper case letter is accepted on 
input by preceding it with a `\' character, and is output preceded by a `\' 
character. In this mode, the following escape sequences are generated on output 
and accepted on input:
<P>For: Use:<BR>
<DL>
  <DT>`
  <DD>\' </DD></DL>
<DL>
  <DT>|
  <DD>\! </DD></DL>
<DL>
  <DT>~
  <DD>\^ </DD></DL>
<DL>
  <DT>{
  <DD>\( </DD></DL>
<DL>
  <DT>}
  <DD>\) </DD></DL>
<DL>
  <DT>\
  <DD>\\
  <P></P></DD></DL>For example, A is input as \a, \n as \\n, and \N as \\\n.
<P>If ECHO is set, characters are echoed as received.
<P>When ICANON is set, the following echo functions are possible.
<P>o If ECHO and ECHOE are set, and ECHOPRT is not set, the ERASE and WERASE 
characters are echoed as one or more ASCII BS SP BS, which clears the last 
character(s) from a CRT screen.
<P>o If ECHO, ECHOPRT, and IEXTEN are set, the first ERASE and WERASE character 
in a sequence echoes as a `\' (backslash), followed by the characters being 
erased. Subsequent ERASE and WERASE characters echo the characters being erased, 
in reverse order. The next non-erase character causes a `/' (slash) to be typed 
before it is echoed. ECHOPRT should be used for hard copy terminals.
<P>o If ECHOKE and IEXTEN are set, the kill character is echoed by erasing each 
character on the line from the screen (using the mechanism selected by ECHOE and 
ECHOPRa).
<P>o If ECHOK is set, and ECHOKE is not set, the NL character is echoed after 
the kill character to emphasize that the line is deleted. Note that a `\' 
(escape) character or an LNEXT character preceding the erase or kill character 
removes any special function.
<P>o If ECHONL is set, the NL character is echoed even if ECHO is not set. This 
is useful for terminals set to local echo (so called half-duplex).
<P>If ECHOCTL and IEXTEN are set, all control characters (characters with codes 
between 0 and 37 octal) other than ASCII TAB, ASCII NL, the START character, and 
the STOP character, ASCII CR, and ASCII BS are echoed as ^X, where X is the 
character given by adding 100 octal to the code of the control character (so 
that the character with octal code 1 is echoed as ^A), and the ASCII DEL 
character, with code 177 octal, is echoed as ^?.
<P>If NOFLSH is set, the normal flush of the input and output queues associated 
with the INTR, QUIT, and SUSP characters is not done. This bit should be set 
when restarting system calls that read from or write to a terminal (see sigac<A 
href="http://campuscgi.princeton.edu/man?tion">tion(2)</A>).
<P>If TOSTOP and IEXTEN are set, the signal SIGTTOU is sent to a process that 
tries to write to its controlling terminal if it is not in the foreground 
process group for that terminal. This signal normally stops the process. 
Otherwise, the output generated by that process is output to the current output 
stream. Processes that are blocking or ignoring SIGTTOU signals are excepted and 
allowed to produce output, if any.
<P>If FLUSHO and IEXTEN are set, data written to the terminal is discarded. This 
bit is set when the FLUSH character is typed. A program can cancel the effect of 
typing the FLUSH character by clearing FLUSHO.
<P>If PENDIN and IEXTEN are set, any input that has not yet been read is 
reprinted when the next character arrives as input. PENDIN is then automatically 
cleared.
<P>If IEXTEN is set, the following implementation-defined functions are enabled: 
special characters (WERASE, REPRINT, DISCARD, and LNEXT) and local flags 
(TOSTOP, ECHOCTL, ECHOPRT, ECHOKE, FLUSHO, and PENDIN).
<P>Minimum and Timeout<BR>The MIN and TIME values were described previously, in 
the subsection, Non-canonical Mode Input Processing. The initial value of MIN is 
1, and the initial value of TIME is 0.
<P>Terminal Size<BR>The number of lines and columns on the terminal's display is 
specified in the winsize structure defined by sys/termios.h and includes the 
following members:
<P>unsigned short ws_row; /* rows, in characters */ unsigned short ws_col; /* 
columns, in characters */ 
<DL>
  <DT>unsigned
  <DD>short ws_xpixel; /* horizontal size, in pixels */ </DD></DL>
<DL>
  <DT>unsigned
  <DD>short ws_ypixel; /* vertical size, in pixels */
  <P></P></DD></DL>Termio Structure<BR>The SunOS/SVR4 termio structure is used by 
some ioctls; it is defined by sys/termio.h and includes the following members:
<P>unsigned short c_iflag; /* input modes */ unsigned short c_oflag; /* output 
modes */ unsigned short c_cflag; /* control modes */ unsigned short c_lflag; /* 
local modes */ 
<DL>
  <DT>char
  <DD>c_line; /* line discipline */ unsigned char c_cc[NCC]; /* control chars */
  <P></P></DD></DL>The special control characters are defined by the array c_cc. 
The symbolic name NCC is the size of the Controlcharacter array and is also 
defined by termio.h. The relative positions, subscript names, and typical 
default values for each function are as follows:
<P>0 VINTR EXT<BR>1 VQUIT FS<BR>2 VERASE DEL<BR>3 VKILL NAK<BR>4 VEOF EOT<BR>5 
VEOL NUL<BR>6 VEOL2 NUL<BR>
<DL>
  <DT>7
  <DD>reserved
  <P></P></DD></DL>The MIN values is stored in the VMIN element of the c_cc array; 
the TIME value is stored in the VTIME element of the c_cc array. The VMIN 
element is the same element as the VEOF element; the VTIME element is the same 
element as the VEOL element.
<P>The calls that use the termio structure only affect the flags and control 
characters that can be stored in the termio structure; all other flags and 
control characters are unaffected.
<P>Modem Lines<BR>On special files representing serial ports, the modem control 
lines supported by the hardware can be read, and the modem status lines 
supported by the hardware can be changed. The following modem control and status 
lines may be supported by a device; they are defined by sys/termios.h:
<P>
<DL>
  <DT>TIOCM_LE
  <DD>line enable </DD></DL>
<DL>
  <DT>TIOCM_DTR
  <DD>data terminal ready </DD></DL>
<DL>
  <DT>TIOCM_RTS
  <DD>request to send </DD></DL>
<DL>
  <DT>TIOCM_ST
  <DD>secondary transmit </DD></DL>
<DL>
  <DT>TIOCM_SR
  <DD>secondary receive </DD></DL>
<DL>
  <DT>TIOCM_CTS
  <DD>clear to send </DD></DL>
<DL>
  <DT>TIOCM_CAR
  <DD>carrier detect </DD></DL>
<DL>
  <DT>TIOCM_RNG
  <DD>ring </DD></DL>
<DL>
  <DT>TIOCM_DSR
  <DD>data set ready
  <P></P></DD></DL>TIOCM_CD is a synonym for TIOCM_CAR, and TIOCM_RI is a synonym 
for TIOCM_RNG. Not all of these are necessarily supported by any particular 
device; check the manual page for the device in question.
<P>The software carrier mode can be enabled or disabled using the TIOCSSOFTCAR 
ioctl. If the software carrier flag for a line is off, the line pays attention 
to the hardware carrier detect (DCD) signal. The tty device associated with the 
line cannot be opened until DCD is asserted. If the software carrier flag is on, 
the line behaves as if DCD is always asserted.
<P>The software carrier flag is usually turned on for locally connected 
terminals or other devices, and is off for lines with modems.
<P>To be able to issue the TIOCGSOFTCAR and TIOCSSOFTCAR ioctl calls, the tty 
line should be opened with O_NDELAY so that the <A 
href="http://campuscgi.princeton.edu/man?open">open(2V)</A> will not wait for 
the carrier.
<P>Default Values<BR>The initial termios values upon driver open is 
configurable. This is accomplished by setting the "ttymodes" property in the 
file /kernel/drv/options.conf. Note: This property is assigned during system 
initialization, therefore any change to the "ttymodes" property will not take 
effect until the next reboot. The string value assigned to this property should 
be in the same format as the output of the <A 
href="http://campuscgi.princeton.edu/man?stty">stty(1)</A> command with the -g 
option.
<P>If this property is undefined, the following termios modes are in effect. The 
initial input control value is BRKINT, ICRNL, IXON, IMAXBEL. The initial output 
control value is OPOST, ONLCR, TAB3. The initial hardware control value is
<P>B9600, CS8, CREAD. The initial line-discipline control value is ISIG, ICANON, 
IEXTEN, ECHO, ECHOK, ECHOE, ECHOKE, ECHOCTL.
<P><A href="http://campuscgi.princeton.edu/man?termio#toc3" name=sect3>
<H2>IOCTLS</H2></A>The ioctls supported by devices and STREAMS modules providing 
the <A href="http://campuscgi.princeton.edu/man?termios">termios(3)</A> 
interface are listed below. Some calls may not be supported by all devices or 
modules. The functionality provided by these calls is also available through the 
preferred function call interface specified on termios.
<P>
<DL>
  <DT>TCGETS
  <DD>The argument is a pointer to a termios structure. The current terminal 
  parameters are fetched and stored into that structure.
  <P></P></DD></DL>
<DL>
  <DT>TCSETS
  <DD>The argument is a pointer to a termios structure. The current terminal 
  parameters are set from the values stored in that structure. The change is 
  immediate.
  <P></P></DD></DL>
<DL>
  <DT>TCSETSW
  <DD>The argument is a pointer to a termios structure. The current terminal 
  parameters are set from the values stored in that structure. The change occurs 
  after all characters queued for output have been transmitted. This form should 
  be used when changing parameters that affect output.
  <P></P></DD></DL>
<DL>
  <DT>TCSETSF
  <DD>The argument is a pointer to a termios structure. The current terminal 
  parameters are set from the values stored in that structure. The change occurs 
  after all characters queued for output have been transmitted; all characters 
  queued for input are discarded and then the change occurs.
  <P></P></DD></DL>
<DL>
  <DT>TCGETA
  <DD>The argument is a pointer to a termio structure. The current terminal 
  parameters are fetched, and those parameters that can be stored in a termio 
  structure are stored into that structure.
  <P></P></DD></DL>
<DL>
  <DT>TCSETA
  <DD>The argument is a pointer to a termio struc </DD></DL>
<DL>
  <DT>ture.
  <DD>Those terminal parameters that can be stored in a termio structure are set 
  from the values stored in that structure. The change is immediate.
  <P></P></DD></DL>
<DL>
  <DT>TCSETAW
  <DD>The argument is a pointer to a termio struc </DD></DL>
<DL>
  <DT>ture.
  <DD>Those terminal parameters that can be stored in a termio structure are set 
  from the values stored in that structure. The change occurs after all 
  characters queued for output have been transmitted. This form should be used 
  when changing parameters that affect output.
  <P></P></DD></DL>
<DL>
  <DT>TCSETAF
  <DD>The argument is a pointer to a termio structure. Those terminal parameters 
  that can be stored in a termio structure are set from the values stored in 
  that structure. The change occurs after all characters queued for output have 
  been transmitted; all characters queued for input are discarded and then the 
  change occurs.
  <P></P></DD></DL>
<DL>
  <DT>TCSBRK
  <DD>The argument is an int value. Wait for the output to drain. If the 
  argument is 0, then send a break (zero valued bits for 0.25 seconds).
  <P></P></DD></DL>
<DL>
  <DT>TCXONC
  <DD>Start/stop control. The argument is an int value. If the argument is 0, 
  suspend output; if 1, restart suspended output; if 2, suspend input; if 3, 
  restart suspended input.
  <P></P></DD></DL>
<DL>
  <DT>TCFLSH
  <DD>The argument is an int value. If the argument is 0, flush the input queue; 
  if 1, flush the output queue; if 2, flush both the input and output queues.
  <P></P></DD></DL>
<DL>
  <DT>TIOCGPGRP
  <DD>The argument is a pointer to a pid_t. Set the value of that pid_t to the 
  process group ID of the foreground process group associated with the terminal. 
  See <A href="http://campuscgi.princeton.edu/man?termios">termios(3)</A> for a 
  description of TCGETPGRP.
  <P></P></DD></DL>
<DL>
  <DT>TIOCSPGRP
  <DD>The argument is a pointer to a pid_t. Associate the process group whose 
  process group ID is specified by the value of that pid_t with the terminal. 
  The new process group value must be in the range of valid process group ID 
  values. Otherwise, the error EPERM is returned. See <A 
  href="http://campuscgi.princeton.edu/man?termios">termios(3)</A> for a 
  description of TCSETPGRP.
  <P></P></DD></DL>
<DL>
  <DT>TIOCGSID
  <DD>The argument is a pointer to a pid_t. The session ID of the terminal is 
  fetched and stored in the pid_t.
  <P></P></DD></DL>
<DL>
  <DT>TIOCGWINSZ
  <DD>The argument is a pointer to a winsize structure. The terminal driver's 
  notion of the terminal size is stored into that structure.
  <P></P></DD></DL>
<DL>
  <DT>TIOCSWINSZ
  <DD>The argument is a pointer to a winsize structure. The terminal driver's 
  notion of the terminal size is set from the values specified in that 
  structure. If the new sizes are different from the old sizes, a SIGWINCH 
  signal is set to the process group of the terminal.
  <P></P></DD></DL>
<DL>
  <DT>TIOCMBIS
  <DD>The argument is a pointer to an int whose value is a mask containing modem 
  control lines to be turned on. The control lines whose bits are set in the 
  argument are turned on; no other control lines are affected.
  <P></P></DD></DL>
<DL>
  <DT>TIOCMBIC
  <DD>The argument is a pointer to an int whose value is a mask containing modem 
  control lines to be turned off. The control lines whose bits are set in the 
  argument are turned off; no other control lines are affected.
  <P></P></DD></DL>
<DL>
  <DT>TIOCMGET
  <DD>The argument is a pointer to an int. The current state of the modem status 
  lines is fetched and stored in the int pointed to by the argument.
  <P></P></DD></DL>
<DL>
  <DT>TIOCMSET
  <DD>The argument is a pointer to an int containing a new set of modem control 
  lines. The modem control lines are turned on or off, depending on whether the 
  bit for that mode is set or clear.
  <P></P></DD></DL>
<DL>
  <DT>TIOCSPPS
  <DD>The argument is a pointer to an int that determines whether 
  pulse-per-second event handling is to be enabled (non-zero) or disabled 
  (zero). If a one-pulse-per-second reference clock is attached to the serial 
  line's data carrier detect input, the local system clock will be calibrated to 
  it. A clock with a high error, that is, a deviation of more than 25 
  microseconds per tick, is ignored.
  <P></P></DD></DL>
<DL>
  <DT>TIOCGPPS
  <DD>The argument is a pointer to an int, in which the state of the even 
  handling is returned. The int is set to a non-zero value if pulseper-second 
  (PPS) handling has been enabled. Otherwise, it is set to zero.
  <P></P></DD></DL>
<DL>
  <DT>TIOCGPPSEV
  <DD>The argument is a pointer to a struct ppsclockev. This structure contains 
  the following members:
  <P></P></DD></DL>struct timeval tv;<BR>uint32_t serial;
<P>"tv" is the system clock timestamp when the event (pulse on the DCD pin) 
occurred. "serial" is the ordinal of the event, which each consecutive event 
being assigned the next ordinal. The first event registered gets a "serial" 
value of 1. The TIOCGPPSEV returns the last event registered; multiple calls 
will persistently return the same event until a new one is registered. In 
addition to time stamping and saving the event, if it is of one-second period 
and of consistently high accuracy, the local system clock will automatically 
calibrate to it.
<P>TIOCGSOFTCAR The argument is a pointer to an int whose value is 1 or 0, 
depending on whether the software carrier detect is turned on or off.
<P>TIOCSSOFTCAR The argument is a pointer to an int whose value is 1 or 0. The 
value of the integer should be 0 to turn off software carrier, or 1 to turn it 
on.
<P><A href="http://campuscgi.princeton.edu/man?termio#toc4" name=sect4>
<H2>FILES</H2></A>files in or under /dev
<P><A href="http://campuscgi.princeton.edu/man?termio#toc5" name=sect5>
<H2>SEE ALSO</H2></A><A 
href="http://campuscgi.princeton.edu/man?stty">stty(1)</A>, <A 
href="http://campuscgi.princeton.edu/man?fork">fork(2)</A>, <A 
href="http://campuscgi.princeton.edu/man?getsid">getsid(2)</A>, <A 
href="http://campuscgi.princeton.edu/man?ioctl">ioctl(2)</A>, <A 
href="http://campuscgi.princeton.edu/man?setsid">setsid(2)</A>, sigac<A 
href="http://campuscgi.princeton.edu/man?tion">tion(2)</A>, <A 
href="http://campuscgi.princeton.edu/man?signal">signal(3C)</A>, <A 
href="http://campuscgi.princeton.edu/man?termios">termios(3)</A>, <A 
href="http://campuscgi.princeton.edu/man?signal">signal(5)</A>, <A 
href="http://campuscgi.princeton.edu/man?streamio">streamio(7I)</A>
<P>
<HR>
<A name=toc><B>Table of Contents</B></A>
<P>
<UL>
  <LI><A href="http://campuscgi.princeton.edu/man?termio#sect0" 
  name=toc0>NAME</A> 
  <LI><A href="http://campuscgi.princeton.edu/man?termio#sect1" 
  name=toc1>SYNOPSIS</A> 
  <LI><A href="http://campuscgi.princeton.edu/man?termio#sect2" 
  name=toc2>DESCRIPTION</A> 
  <LI><A href="http://campuscgi.princeton.edu/man?termio#sect3" 
  name=toc3>IOCTLS</A> 
  <LI><A href="http://campuscgi.princeton.edu/man?termio#sect4" 
  name=toc4>FILES</A> 
  <LI><A href="http://campuscgi.princeton.edu/man?termio#sect5" name=toc5>SEE 
  ALSO</A> </LI></UL>
<HR>
<A href="http://campuscgi.princeton.edu/index.html"><B>Princeton University 
Campus CGI Facility<B></A><BR><A 
href="http://campuscgi.princeton.edu/man"><B>Return to man page access 
form<B></A> </B></B></B></B></B></B></B></B></BODY></HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0051)http://conx.bu.edu/cgi-bin/perl/manscript?termio(7) -->
<HTML><HEAD><TITLE>Tonka - SuperMan Pages</TITLE>
<META content="text/html; charset=gb2312" http-equiv=Content-Type>
<META content="MSHTML 5.00.3502.5390" name=GENERATOR></HEAD>
<BODY>
<P><!-- Formatted with RosettaMan v2.5a6 of $Date: 1996/07/17 01:18:19 $ (Tom A. Phelps [phelps@CS.Berkeley.EDU]) --><!-- Gatewayed with man2html v0.4 (Brooks Cutter [bcutter@paradyne.com]) --><!-- Page was /bin/pcat /usr/share/catman/a_man/cat7/termio.z| /usr/local/web/Aux/Pub/rman -f html -r 'http://tonka.bu.edu/cgi-bin/perl/manscript?%s(%s) --><!-- manual page source format generated by RosettaMan v2.5a6, --><!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z --><A 
href="http://conx.bu.edu/cgi-bin/perl/manscript?termio(7)#toc">Table of 
Contents</A>
<P>
<H2><A href="http://conx.bu.edu/cgi-bin/perl/manscript?termio(7)#toc1" 
name=sect1>NAME</A></H2>termio, termios - general terminal interfaces 
<P>
<H2><A href="http://conx.bu.edu/cgi-bin/perl/manscript?termio(7)#toc2" 
name=sect2><B>SYNOPSIS</B></A></H2><B>#include</B> <B>&lt;termios.h&gt;</B> 
<P><B>ioctl</B> <B>(int</B> <B>fildes,</B> <B>int</B> <B>request,</B> 
<B>struct</B> <B>termios</B> <B>*arg);</B> 
<P><B>ioctl</B> <B>(int</B> <B>fildes,</B> <B>int</B> <B>request,</B> <B>int</B> 
<B>arg);</B> 
<P><B>#include</B> <B>&lt;termio.h&gt;</B> 
<P><B>ioctl</B> <B>(int</B> <B>fildes,</B> <B>int</B> <B>request,</B> 
<B>struct</B> <B>termio</B> <B>*arg);</B> 
<P>
<H2><A href="http://conx.bu.edu/cgi-bin/perl/manscript?termio(7)#toc3" 
name=sect3><B>DESCRIPTION</B></A></H2>All of the asynchronous communications 
ports use the same general interface, no matter what hardware is involved. The 
user interface to this functionality is via the <I>ioctl</I> calls described 
below, or the POSIX <I>termios</I> interface described in <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?termios(3t)">termios(3t)</A>. 
The remainder of this section discusses the common features of the terminal 
subsystem which are relevant to both of these interfaces. 
<P><B>Recent</B> <B>changes</B><BR>The <B>termio</B> and <B>termios</B> 
structures have been changed to support bit rates of greater than 38400 bps. 
Each of these structures has two new members <I>c</I>_<I>ospeed</I> and 
<I>c</I>_<I>ispeed</I> which store the output and input bit rates, respectively. 
They replace the <B>CBAUD</B> and <B>CIBAUD</B> fields of the 
<I>c</I>_<I>cflag</I> member. <B>CBAUD</B> and <B>CIBAUD</B> should no longer be 
modified or examined by applications. (Because no current SGI hardware supports 
setting input and output to different rates, <I>c</I>_<I>ispeed</I> is currently 
unsupported. Applications should either not modify it, or should set it to the 
same value as <I>c</I>_<I>ospeed</I>.) 
<P>Unlike <B>CBAUD</B> and <B>CIBAUD</B>, <I>c</I>_<I>ospeed</I> and 
<I>c</I>_<I>ispeed</I> encode bit rates as plain integers. To set a bit rate of 
38400 bits per second, an application would set <I>c</I>_<I>ospeed</I> to the 
integer value 38400. For convenience, macros such as <B>B38400</B> have been 
provided for several common bit rates. 
<P>Note that the capabilities of various serial port hardware differ; many still 
do not support rates greater than 38400 bps (see <I>serial</I>(<I>7</I>) for 
more information on different serial port types.) Applications therefore need to 
check the return values of library calls that attempt to set bit rates (such as 
<B>ioctl</B> described here) , because the calls may now fail in more situations 
than before. 
<P><B>Controlling</B> <B>Terminal</B><BR>When a terminal file is opened, it 
normally causes the process to wait until a connection is established. In 
practice, users' programs seldom open terminal files; they are opened by the 
system and become a user's standard input, output and error files. The very 
first terminal file opened by the session leader which is not already associated 
with a session becomes the controlling terminal for the session. 
<P>If a process does not wish to acquire the terminal as a controlling terminal 
(as is the case with many daemons that open <B>/dev/console</B>), the process 
should add the <B>O_NOCTTY</B> flag into the second argument bitmask to <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?open(2)">open(2)</A>. 
<P>The controlling terminal is inherited by the child process during a <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?fork(2)">fork(2)</A>. A process 
can break this association by changing its session using <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?setsid(2)">setsid(2)</A>. 
(Currently, this also happens if a process issues a System V <I>setpgrp</I>() or 
<I>BSDsetpgrp</I>(mypid, 0). This provides backward compatibility with SVR3 and 
BSD4.3). 
<P>When a session leader that has a controlling terminal exits, the 
<B>SIGHUP</B> signal will be sent to each process in the foreground process 
group of the controlling terminal and the controlling terminal will be 
disassociated from the current session. This allows the terminal to be acquired 
by a new session leader. Subsequent access to the terminal by other processes in 
the earlier session will fail, returning the error code <B>EIO</B>. 
<P><B>Session</B> <B>Management</B> <B>(Job</B> <B>Control)</B><BR>A controlling 
terminal will designate one of the process groups in the session associated with 
it as the <B>foreground</B> process group. All other process groups in the 
session are designated as <B>background</B> process groups. The foreground 
process group plays a special role in handling signal-generating input 
characters, as discussed below. By default, when a controlling terminal is 
allocated, the controlling process's process group is assigned as the foreground 
process group. 
<P>Background process groups in the controlling process's session are subject to 
a job control line discipline when they attempt to access their controlling 
terminal. Typically, they will be sent signals that will cause them to stop, 
unless they have made other arrangements. An exception is made for members of 
orphaned process groups. When a member of an orphaned process group attempts to 
access its controlling terminal, an error is returned since there is no process 
to continue it should it stop. 
<P>If a member of a background process group attempts to <I>read</I> its 
controlling terminal, its process group will be sent a <B>SIGTTIN</B> signal, 
which will normally cause the members of that process group to stop. If, 
however, the process is ignoring or holding <B>SIGTTIN</B>, or is a member of an 
orphaned process group, the <I>read</I> will fail with <B>errno</B> set to 
<B>EIO</B>, and no signal will be sent. 
<P>If a member of a background process group attempts to <I>write</I> to its 
controlling terminal and the <B>TOSTOP</B> bit is set in the 
<I>c</I>_<I>lflag</I> field (see below), its process group will be sent a 
<B>SIGTTOU</B> signal, which will normally cause the members of that process 
group to stop. If, however, the process is ignoring or holding <B>SIGTTOU</B>, 
the <I>write</I> will succeed. If the process is not ignoring or holding 
<B>SIGTTOU</B> and is a member of an orphaned process group, the <I>write</I> 
will fail with <B>errno</B> set to <B>EIO</B>, and no signal will be sent. 
<P>If a member of a background process group attempts to invoke an 
<I>ioctl</I>() on its controlling terminal, and that <I>ioctl</I>() will modify 
terminal parameters (e.g. <B>TCSETA,</B> <B>TCSETAW,</B> <B>TCSETAF</B>, or 
<B>TIOCSPGRP</B>), and the <B>TOSTOP</B> bit is set in the <I>c</I>_<I>lflag</I> 
field, its process group will be sent a <B>SIGTTOU</B> signal, which will 
normally cause the members of that process group to stop. If, however, the 
process is ignoring or holding <B>SIGTTOU</B>, the <I>ioctl</I>() will succeed. 
If the process is not ignoring or holding <B>SIGTTOU</B> and is a member of an 
orphaned process group, the <I>ioctl</I>() will fail with <B>errno</B> set to 
<B>EIO</B>, and no signal will be sent. 
<P><B>Input</B> <B>Processing</B> <B>and</B> <B>Reading</B> 
<B>Characters</B><BR>A terminal associated with one of these files ordinarily 
operates in full-duplex mode. Characters may be typed at any time, even while 
output is occurring, and are only lost when the system's character input buffers 
become completely full (which is rare) or when the user has accumulated the 
maximum allowed number of input characters that have not yet been read by some 
program. Currently, this limit is {MAX_CANON} characters (see 
<I>pathconf</I>(<I>2</I>)). When the input limit is reached, the buffer is 
flushed and all the saved characters are thrown away without notice. 
<P><B>Canonical</B> <B>Mode</B> <B>Input</B> <B>Processing</B><BR>Normally, 
terminal input is processed in units of lines. A line is delimited by a new-line 
(ASCII <B>LF)</B> character, an end-of-file (ASCII <B>EOT)</B> character, or an 
end-of-line character. This means that a program attempting to <I>read</I> will 
be suspended until an entire line has been typed. Also, no matter how many 
characters are requested in the <I>read</I> call, at most one line will be 
returned. It is not, however, necessary to <I>read</I> a whole line at once; any 
number of characters may be requested in a <I>read</I>, even one, without losing 
information. 
<P>During input, erase and kill processing is normally done. The <B>ERASE</B> 
character (Control-H) erases the last character typed. The <B>WERASE</B> 
character (Control-W) erases the last ``word'' typed in the current input line 
(but not any preceding spaces or tabs). A ``word'' is defined as a sequence of 
non-blank characters, with tabs counted as blanks. Neither <B>ERASE</B> or 
<B>WERASE</B> will erase beyond the beginning of the line. The <B>KILL</B> 
character (Control-U) kills (deletes) the entire input line, and optionally 
outputs a new-line character. All these characters operate on a key-stroke 
basis, independently of any backspacing or tabbing that may have been done. The 
<B>REPRINT</B> character (Control-R) prints a newline followed by all unread 
characters. The characters are reprinted as if they were being echoed; 
consequently if the <B>ECHO</B> flag is not set (see below), they are not 
printed. The <B>ERASE</B>, <B>WERASE</B>, <B>KILL</B> and <B>REPRINT</B> 
characters may be changed. 
<P><B>Non-canonical</B> <B>Mode</B> <B>Input</B> <B>Processing</B><BR>In 
non-canonical mode input processing, input characters are not assembled into 
lines, and erase and kill processing does not occur. The 
<P><CODE>MIN</CODE> and <CODE>TIME</CODE> values are used to determine how to 
process the characters received. 
<P><CODE>MIN</CODE> represents the minimum number of characters that should be 
received when the read is satisfied (i.e., when the characters are returned to 
the user). <CODE>TIME</CODE> is a timer of 0.10-second granularity that is used 
to timeout bursty and short-term data transmissions. The four possible values 
for <CODE>MIN</CODE> and <CODE>TIME</CODE> and their interactions are described 
below. 
<P>Case A: <CODE>MIN</CODE> &gt; 0, <CODE>TIME</CODE> &gt; 0<BR>In this case, 
<CODE>TIME</CODE> serves as an intercharacter timer and is activated after the 
first character is received. Since it is an intercharacter timer, it is reset 
after a character is received. The interaction between <CODE>MIN</CODE> and 
<CODE>TIME</CODE> is as follows: as soon as one character is received, the 
intercharacter timer is started. If <CODE>MIN</CODE> characters are received 
before the intercharacter timer expires (note that the timer is reset upon 
receipt of each character), the read is satisfied. If the timer expires before 
<CODE>MIN</CODE> characters are received, the characters received to that point 
are returned to the user. Note that if <CODE>TIME</CODE> expires, at least one 
character will be returned because the timer would not have been enabled unless 
a character was received. In this case (<CODE>MIN</CODE> &gt; 0, 
<CODE>TIME</CODE> &gt; 0), the read sleeps until the <CODE>MIN</CODE> and 
<CODE>TIME</CODE> mechanisms are activated by the receipt of the first 
character. If the number of characters read is less than the number of 
characters available, the timer is not reactivated and the subsequent read is 
satisfied immediately. 
<P>Case B: <CODE>MIN</CODE> &gt; 0, <CODE>TIME</CODE> = 0<BR>In this case, since 
the value of <CODE>TIME</CODE> is zero, the timer plays no role and only 
<CODE>MIN</CODE> is significant. A pending read is not satisfied until 
<CODE>MIN</CODE> characters are received (the pending read sleeps until 
<CODE>MIN</CODE> characters are received). A program that uses this case to read 
record based terminal I/O may block indefinitely in the read operation. 
<P>Case C: <CODE>MIN</CODE> = 0, <CODE>TIME</CODE> &gt; 0<BR>In this case, since 
<CODE>MIN</CODE> = 0, <CODE>TIME</CODE> no longer represents an intercharacter 
timer: it now serves as a read timer that is activated as soon as a read is 
done. A read is satisfied as soon as a single character is received or the read 
timer expires. Note that, in this case, if the timer expires, no character is 
returned. If the timer does not expire, the only way the read can be satisfied 
is if a character is received. In this case, the read will not block 
indefinitely waiting for a character; if no character is received within 
<CODE>TIME</CODE>*.10 seconds after the read is initiated, the read returns with 
zero characters. 
<P>Case D: <CODE>MIN</CODE> = 0, <CODE>TIME</CODE> = 0<BR>In this case, return 
is immediate. The minimum of either the number of characters requested or the 
number of characters currently available is returned without waiting for more 
characters to be input. 
<P><B>Writing</B> <B>Characters</B><BR>When one or more characters are written, 
they are transmitted to the terminal as soon as previously-written characters 
have finished typing. Input characters are echoed by putting them in the output 
queue as they arrive. If a process produces characters more rapidly than they 
can be typed, it will be suspended when its output queue exceeds some limit. 
When the queue has drained down to some threshold, the program is resumed. 
<P><B>Special</B> <B>Characters</B><BR>Certain characters have special functions 
on input. These functions and their default character values are summarized as 
follows: 
<P>
<DL>
  <DT><B>INTR</B> 
  <DD>(Typically, rubout or ASCII <B>DEL)</B> generates an <I>interrupt</I> 
  signal <B>SIGINT</B> which is sent to all foreground processes with the 
  associated controlling terminal. Normally, each such process is forced to 
  terminate, but arrangements may be made either to ignore the signal or to 
  receive a trap to an agreed-upon location; see <A 
  href="http://tonka.bu.edu/cgi-bin/perl/manscript?signal(2)">signal(2)</A>. 
  <P></P></DD></DL>
<DL>
  <DT><B>QUIT</B> 
  <DD>(Typically, control-\ or ASCII <B>FS)</B> generates a <I>quit</I> signal 
  <B>SIGQUIT</B>. Its treatment is identical to the interrupt signal except 
  that, unless a receiving process has made other arrangements, it will not only 
  be terminated, but a core image file (called <B>core</B>) will be created in 
  the current working directory. 
  <P></P></DD></DL>
<DL>
  <DT><B>ERASE</B> 
  <DD>(Typically, control-H or backspace) erases the preceding character. It 
  will not erase beyond the start of a line, as delimited by a <B>NL,</B> 
  <B>EOF,</B> <B>EOL,</B> or <B>EOL2</B> character. 
  <P></P></DD></DL>
<DL>
  <DT><B>KILL</B> 
  <DD>(Typically, control-U) deletes the entire line, as delimited by a 
  <B>NL,</B> <B>EOF,</B> <B>EOL,</B> or <B>EOL2</B> character. 
  <P></P></DD></DL>
<DL>
  <DT><B>EOF</B> 
  <DD>(Typically, control-D or ASCII <B>EOT)</B> may be used to generate an 
  end-of-file from a terminal. When received, all the characters waiting to be 
  read are immediately passed to the program, without waiting for a new-line, 
  and the <B>EOF</B> is discarded. Thus, if there are no characters waiting, 
  which is to say the <B>EOF</B> occurred at the beginning of a line, zero 
  characters will be passed back, which is the standard endof-file indication. 
  <P></P></DD></DL>
<DL>
  <DT><B>NL</B> 
  <DD>(ASCII <B>LF)</B> is the normal line delimiter. It can not be changed or 
  escaped. 
  <P></P></DD></DL>
<DL>
  <DT><B>EOL</B> 
  <DD>(Typically, ASCII <B>NUL)</B> is an additional line delimiter, like 
  <B>NL.</B> It is not normally used. 
  <P></P></DD></DL>
<DL>
  <DT><B>EOL2</B> 
  <DD>is another additional line delimiter. 
  <P></P></DD></DL>
<DL>
  <DT><B>STOP</B> 
  <DD>(Typically, control-S or ASCII <B>DC3)</B> can be used to temporarily 
  suspend output. It is useful with <B>CRT</B> terminals to prevent output from 
  disappearing before it can be read. While output is suspended, <B>STOP</B> 
  characters are ignored and not read. 
  <P></P></DD></DL>
<DL>
  <DT><B>START</B> 
  <DD>(Typically, control-Q or ASCII <B>DC1)</B> is used to resume output which 
  has been suspended by a <B>STOP</B> character. While output is not suspended, 
  <B>START</B> characters are ignored and not read. The <B>START/STOP</B> 
  characters can not be changed or escaped in <B>LDISC0</B> (see ``Termio 
  Structure'' below). 
  <P></P></DD></DL>The following characters have special functions on input when 
the POSIX <I>termios</I> interface is used or when the System V <I>termio</I> 
interface is used and the line discipline is set to the default of <B>LDISC1</B> 
(see ``Termio Structure'' below). These functions and their default character 
values are summarized as follows: 
<P>
<DL>
  <DT><B>SUSP</B> 
  <DD>(Control-Z or ASCII <B>SUB)</B> generates a <B>SIGTSTP</B> signal which 
  stops all processes in the foreground process group for that terminal. 
  <P></P></DD></DL>
<DL>
  <DT><B>DSUSP</B> 
  <DD>(Control-Y or ASCII <B>EM</B>) generates a <B>SIGTSTP</B> signal as 
  <B>SUSP</B> does, but the signal is sent when a process in the foreground 
  process group attempts to read the <B>DSUSP</B> character, rather than when it 
  is typed. 
  <P></P></DD></DL>
<DL>
  <DT><B>LNEXT</B> 
  <DD>(Control-V or ASCII <B>SYN</B>) causes the next character input to treated 
  literally. 
  <P></P></DD></DL>
<DL>
  <DT><B>WERASE</B> 
  <DD>(Control-W or ASCII <B>ETB</B>) erases the preceding white spacedelimited 
  word. It will not erase beyond the start of a line, as delimited by a 
  <B>NL,</B> <B>EOF,</B> <B>EOL,</B> or <B>EOL2</B> character. 
  <P></P></DD></DL>
<DL>
  <DT><B>REPRINT</B> 
  <DD>(Control-R or ASCII <B>DC2</B>) reprints all characters, preceded by a 
  newline, that have not been read. 
  <P></P></DD></DL>
<DL>
  <DT><B>FLUSH</B> 
  <DD>(Control-O or ASCII <B>SI</B>) when typed during output causes all 
  subsequent output to be discarded. Typing any character reenables output. This 
  character is also known by the POSIX name <B>DISCARD</B> 
  <P></P></DD></DL>The character values for <B>INTR,</B> <B>QUIT,</B> 
<B>ERASE,</B> <B>WERASE,</B> <B>KILL,</B> <B>REPRINT,</B> <B>EOF,</B> 
<B>EOL,</B> <B>EOL2,</B> <B>SUSP,</B> <B>DSUSP,</B> <B>STOP,</B> <B>START,</B> 
<B>FLUSH/DISCARD,</B> and <B>LNEXT</B> may be changed to suit individual tastes 
(see <A href="http://tonka.bu.edu/cgi-bin/perl/manscript?stty(1)">stty(1)</A>). 
If the value of a special control character is <B>CNUL</B> or 
<B>_POSIX_VDISABLE</B>, the function of that special control character is 
disabled. The <B>ERASE,</B> <B>KILL,</B> and <B>EOF</B> characters may be 
entered literally in <B>LDISC0</B> (see ``Termio Structure'' below), by 
preceding them with the escape character (<B>\</B>), in which case no special 
function is done and the escape character is not read. Any of the special 
characters may be entered literally in the <I>termios</I> interface or if the 
<I>termio</I> interface line discipline is set to <B>LDISC1</B> (see ``Termio 
<P>Structure'' below), by preceding them with the <B>LNEXT</B> character, in 
which case no special function is done and the <B>LNEXT</B> character is not 
read. 
<P><B>Modem</B> <B>Disconnect</B><BR>When a modem disconnect is detected, and if 
<B>CLOCAL</B> is not set in the line discipline mode (see the discussion of the 
<I>c</I>_<I>cflag</I> field below), a <B>SIGHUP</B> signal is sent to the 
terminal's controlling process. Unless other arrangements have been made, this 
signal causes the process to terminate. If <B>SIGHUP</B> is ignored or caught, 
any subsequent read returns with an end-of-file indication until the terminal is 
closed. Thus, programs that read a terminal and test for end-of-file can 
terminate appropriately after a disconnect. Any subsequent write will return -1 
and set <B>errno</B> to <B>EIO</B> until the device is closed. 
<P>If the controlling process is not in the foreground process group of the 
terminal, a <B>SIGTSTP</B> is sent to the terminal's foreground process group. 
Unless other arrangements have been made, this signal causes the processes to 
stop. 
<P>Processes in background process groups that attempt to access the controlling 
terminal after modem disconnect, while the terminal is still allocated to the 
session, will receive appropriate <B>SIGTTOU</B> and <B>SIGTTIN</B> signals. 
Unless other arrangements have been made, this signal causes the processes to 
stop. 
<P>The controlling terminal will remain in this state until it is reinitialized 
with a successful open by the controlling process, or deallocated by the 
controlling process. 
<P><B>Terminal</B> <B>Parameters</B><BR>The parameters that control the behavior 
of devices and modules providing the <B>termios</B> interface are specified by 
the <B>termios</B> structure defined by <B>&lt;termios.h&gt;</B>. Several <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?ioctl(2)">ioctl(2)</A> system 
calls that fetch or change these parameters use this structure, which contains 
the following members: 
<P>
<DL>
  <DT>struct 
  <DD>termios { </DD></DL>
<DL>
  <DT>tcflag_t 
  <DD>c_iflag; /* input modes */ </DD></DL>
<DL>
  <DT>tcflag_t 
  <DD>c_oflag; /* output modes */ </DD></DL>
<DL>
  <DT>tcflag_t 
  <DD>c_cflag; /* control modes */ </DD></DL>
<DL>
  <DT>tcflag_t 
  <DD>c_lflag; /* local modes */ </DD></DL>
<DL>
  <DT>speed_t 
  <DD>c_ospeed; /* output speed */ </DD></DL>
<DL>
  <DT>speed_t 
  <DD>c_ispeed; /* input speed; not supported */ </DD></DL>
<DL>
  <DT>cc_t 
  <DD>c_cc[NCCS]; /* control chars */ }; 
  <P></P></DD></DL>The special control characters are defined by the array 
<CODE>c_cc</CODE>. The symbolic name <B>NCCS</B> is the size of the 
control-character array and is also defined by <B>&lt;termios.h&gt;</B>. All 
space in the array is reserved or used as described below. The relative 
positions, subscript names, and normal default values for each function are as 
follows: 
<P>0 VINTR CINTR (DEL)<BR>1 VQUIT CQUIT (Control-\) 2 VERASE CERASE (Control-H 
(Backspace)) 3 VKILL CKILL (Control-U) 4 VEOF CEOF (Control-D) 4 VMIN<BR>5 VEOL 
CEOL (NUL) 5 VTIME<BR>6 VEOL2 CEOL2 (NUL)<BR>7 VSWTCH CNSWTCH (NUL)<BR>8 VSTART 
CSTART (Control-Q) 9 VSTOP CSTOP (Control-S) 10 VSUSP CNSWTCH (NUL)<BR>11 VDSUSP 
CNUL (NUL)<BR>12 VREPRINT CRPRNT (Control-R)<BR>13 VFLUSH CFLUSH (Control-O) 14 
VWERASE CWERASE (Control-W)<BR>15 VLNEXT CLNEXT (Control-V) 
<P><B>Input</B> <B>Modes</B> 
<P>The <I>c</I>_<I>iflag</I> field describes the basic terminal input control. 
The values, functions, and symbolic names of the bits in the 
<I>c</I>_<I>iflag</I> field are as follows: 
<P>IGNBRK 0000001 Ignore break condition. BRKINT 0000002 Signal interrupt on 
break. IGNPAR 0000004 Ignore characters with parity errors. PARMRK 0000010 Mark 
parity errors. 
<DL>
  <DT>INPCK 
  <DD>0000020 Enable input parity check. ISTRIP 0000040 Strip character. 
</DD></DL>
<DL>
  <DT>INLCR 
  <DD>0000100 Map NL to CR on input. </DD></DL>
<DL>
  <DT>IGNCR 
  <DD>0000200 Ignore CR. </DD></DL>
<DL>
  <DT>ICRNL 
  <DD>0000400 Map CR to NL on input. </DD></DL>
<DL>
  <DT>IUCLC 
  <DD>0001000 Map upper-case to lower-case on input. </DD></DL>
<DL>
  <DT>IXON 
  <DD>0002000 Enable start/stop output control. </DD></DL>
<DL>
  <DT>IXANY 
  <DD>0004000 Enable any character to restart output. </DD></DL>
<DL>
  <DT>IXOFF 
  <DD>0010000 Enable start/stop input control. IMAXBEL 0020000 Echo BEL on input 
  line too long. 
  <P></P></DD></DL>
<DL>
  <DT><B>IGNBRK</B> 
  <DD>If <B>IGNBRK</B> is set, a break condition (a character framing error with 
  data all zeros) detected on input is ignored, that is, not put on the input 
  queue and therefore not read by any process. 
  <P></P></DD></DL>
<DL>
  <DT><B>BRKINT</B> 
  <DD>If <B>IGNBRK</B> is not set and <B>BRKINT</B> is set, the break condition 
  will flush the input and output queues and if the terminal is the controlling 
  terminal of a foreground process group, the break condition will generate a 
  single <B>SIGINT</B> signal to that foreground process group. If neither 
  <B>IGNBRK</B> nor <B>BRKINT</B> is set, a break condition is read as a single 
  ASCII <B>NUL</B> character, or if <B>PARMRK</B> is set, as: `0377', `0', `0'. 
  <P></P></DD></DL>
<DL>
  <DT><B>IGNPAR</B> 
  <DD>If <B>IGNPAR</B> is set, a byte with framing or parity errors (other than 
  break) is ignored. 
  <P></P></DD></DL>
<DL>
  <DT><B>PARMRK</B> 
  <DD>If <B>PARMRK</B> is set, and <B>IGNPAR</B> is not set, a character with a 
  framing or parity error (other than break) is read as the three-character 
  sequence: `0377', `0', `X', where X is the data of the character received in 
  error. To avoid ambiguity in this case, if <B>ISTRIP</B> is not set, a valid 
  character of `0377' is read as `0377', `0377'. If neither <B>PARMRK</B> nor 
  <B>IGNPAR</B> is set, a framing or parity error (other than break) is read as 
  the single ASCII <B>NUL</B> character. 
  <P></P></DD></DL>
<DL>
  <DT><B>INPCK</B> 
  <DD>If <B>INPCK</B> is set, input parity checking is enabled. If <B>INPCK</B> 
  is not set, input parity checking is disabled. This allows output parity 
  generation without input parity errors. 
  <P></P></DD></DL>
<DL>
  <DT><B>ISTRIP</B> 
  <DD>If <B>ISTRIP</B> is set, valid input characters are first stripped to 
  7-bits, otherwise all 8-bits are processed. 
  <P></P></DD></DL>
<DL>
  <DT><B>INLCR</B> 
  <DD>If <B>INLCR</B> is set, a received <B>NL</B> character is translated into 
  a <B>CR</B> character. 
  <P></P></DD></DL>
<DL>
  <DT><B>IGNCR</B> 
  <DD>If <B>IGNCR</B> is set, a received <B>CR</B> character is ignored (not 
  read). 
  <P></P></DD></DL>
<DL>
  <DT><B>ICRNL</B> 
  <DD>If <B>ICRNL</B> is set, a received <B>CR</B> character is translated into 
  a <B>NL</B> character. 
  <P></P></DD></DL>
<DL>
  <DT><B>IUCLC</B> 
  <DD>If <B>IUCLC</B> is set, a received upper-case alphabetic character is 
  translated into the corresponding lower-case character. 
  <P></P></DD></DL>
<DL>
  <DT><B>IXON</B> 
  <DD>If <B>IXON</B> is set, start/stop output control is enabled. A received 
  <B>STOP</B> character will suspend output and a received <B>START</B> 
  character will restart output. The <B>STOP</B> and <B>START</B> characters 
  will not be read, but will mearly perform flow control functions. 
  <P></P></DD></DL>
<DL>
  <DT><B>IXANY</B> 
  <DD>If <B>IXANY</B> is set, any input character will restart output that has 
  been suspended. 
  <P></P></DD></DL>
<DL>
  <DT><B>IXOFF</B> 
  <DD>If <B>IXOFF</B> is set, the system will transmit <B>START/STOP</B> 
  characters when the input queue is nearly empty/full. 
  <P></P></DD></DL>
<DL>
  <DT><B>IMAXBEL</B> 
  <DD>If <B>IMAXBEL</B> is set, the ASCII <B>BEL</B> character is echoed if the 
  input stream overflows. Further input is discarded, but any input already 
  present in the input stream is preserved. 
  <P></P></DD></DL><B>Output</B> <B>Modes</B> 
<P>The <I>c</I>_<I>oflag</I> field specifies the system treatment of output. The 
values, functions, and symbolic names of the bits and subfields in the 
<I>c</I>_<I>oflag</I> field are as follows: 
<P>OPOST 0000001 Postprocess output. OLCUC 0000002 Map lower case to upper on 
output. ONLCR 0000004 Map NL to CR-NL on output. OCRNL 0000010 Map CR to NL on 
output. ONOCR 0000020 No CR output at column 0. ONLRET 0000040 NL performs CR 
function. OFILL 0000100 Use fill characters for delay. OFDEL 0000200 Fill is 
DEL, else NUL. NLDLY 0000400 Select new-line delays: 
<DL>
  <DT>NL0 
  <DD>0 </DD></DL>
<DL>
  <DT>NL1 
  <DD>0000400 CRDLY 0003000 Select carriage-return delays: </DD></DL>
<DL>
  <DT>CR0 
  <DD>0 </DD></DL>
<DL>
  <DT>CR1 
  <DD>0001000 </DD></DL>
<DL>
  <DT>CR2 
  <DD>0002000 </DD></DL>
<DL>
  <DT>CR3 
  <DD>0003000 TABDLY 0014000 Select horizontal-tab delays: </DD></DL>
<DL>
  <DT>TAB0 
  <DD>0 </DD></DL>
<DL>
  <DT>TAB1 
  <DD>0004000 </DD></DL>
<DL>
  <DT>TAB2 
  <DD>0010000 </DD></DL>
<DL>
  <DT>TAB3 
  <DD>0014000 Expand tabs to spaces. BSDLY 0020000 Select backspace delays: 
</DD></DL>
<DL>
  <DT>BS0 
  <DD>0 </DD></DL>
<DL>
  <DT>BS1 
  <DD>0020000 VTDLY 0040000 Select vertical-tab delays: </DD></DL>
<DL>
  <DT>VT0 
  <DD>0 </DD></DL>
<DL>
  <DT>VT1 
  <DD>0040000 FFDLY 0100000 Select form-feed delays: </DD></DL>
<DL>
  <DT>FF0 
  <DD>0 </DD></DL>
<DL>
  <DT>FF1 
  <DD>0100000 
  <P></P></DD></DL>
<DL>
  <DT><B>OPOST</B> 
  <DD>If <B>OPOST</B> is set, output characters are post-processed as indicated 
  by the remaining flags, otherwise characters are transmitted without change. 
  <P></P></DD></DL>
<DL>
  <DT><B>OLCUC</B> 
  <DD>If <B>OLCUC</B> is set, a lower-case alphabetic character is transmitted 
  as the corresponding upper-case character. This function is often used in 
  conjunction with <B>IUCLC.</B> 
  <P></P></DD></DL>
<DL>
  <DT><B>ONLCR</B> 
  <DD>If <B>ONLCR</B> is set, the <B>NL</B> character is transmitted as the 
  <B>CR-NL</B> character pair. 
  <P></P></DD></DL>
<DL>
  <DT><B>OCRNL</B> 
  <DD>If <B>OCRNL</B> is set, the <B>CR</B> character is transmitted as the 
  <B>NL</B> character. 
  <P></P></DD></DL>
<DL>
  <DT><B>ONOCR</B> 
  <DD>If <B>ONOCR</B> is set, no <B>CR</B> character is transmitted when at 
  column 0 (first position). 
  <P></P></DD></DL>
<DL>
  <DT><B>ONLRET</B> 
  <DD>If <B>ONLRET</B> is set, the <B>NL</B> character is assumed to do the 
  carriage-return function; the column pointer will be set to 0 and the delays 
  specified for <B>CR</B> will be used. Otherwise the <B>NL</B> character is 
  assumed to do just the line-feed function; the column pointer will remain 
  unchanged. The column pointer is also set to 0 if the <B>CR</B> character is 
  actually transmitted. 
  <P></P></DD></DL>
<DL>
  <DT><B>OFILL</B> 
  <DD>If <B>OFILL</B> is set, fill characters will be transmitted for delay 
  instead of a timed delay. This is useful for high baud rate terminals which 
  need only a minimal delay. 
  <P></P></DD></DL>
<DL>
  <DT><B>OFDEL</B> 
  <DD>If <B>OFDEL</B> is set, the fill character is <B>DEL,</B> otherwise 
  <B>NUL.</B> 
  <P></P></DD></DL>The delay bits specify how long transmission stops to allow for 
mechanical or other movement when certain characters are sent to the terminal. 
In all cases a value of 0 indicates no delay. 
<P>The actual delays depend on line speed and system load. 
<P>
<DL>
  <DT><B>NLDLY</B> 
  <DD>Newline delay type 0 (<B>NL0</B>) selects no delay. Newline delay type 1 
  (<B>NL1</B>) lasts about 0.10 seconds. If <B>ONLRET</B> is set, the 
  carriage-return delays are used instead of the new-line delays. If 
  <B>OFILL</B> is set, two fill characters will be transmitted. 
  <P></P></DD></DL>
<DL>
  <DT><B>CRDLY</B> 
  <DD>Carriage-return delay type 0 (<B>CR0</B>) selects no delay. 
  Carriage-return delay type 1 (<B>CR1</B>) is dependent on the current column 
  position, type 2 (<B>CR2</B>) is about 0.10 seconds, and type 3 (<B>CR3</B>) 
  is about 0.15 seconds. If <B>OFILL</B> is set, delay type 1 transmits two fill 
  characters, and type 2, four fill characters. 
  <P></P></DD></DL>
<DL>
  <DT><B>TABDLY</B> 
  <DD>Horizontal-tab delay type 0 (<B>TAB0</B>) selects no delay. Horizontal-tab 
  delay type 1 (<B>TAB1</B>) is dependent on the current column position. Type 2 
  (<B>TAB2</B>) is about 0.10 seconds. Type 3 (<B>TAB3</B>) specifies that tabs 
  are to be expanded into spaces. If <B>OFILL</B> is set, two fill characters 
  will be transmitted for any delay. 
  <P></P></DD></DL>
<DL>
  <DT><B>BSDLY</B> 
  <DD>Backspace delay type 0 (<B>BS0</B>) selects no delay. Backspace delay type 
  1 (<B>BS1</B>) lasts about 0.05 seconds. If <B>OFILL</B> is set, one fill 
  character will be transmitted. 
  <P></P></DD></DL>
<DL>
  <DT><B>VTDLY</B> 
  <DD>Vertical-tab delay type 0 (<B>VT0</B>) selects no delay. Verticaltab delay 
  type 1 (<B>VT1</B>) lasts about 2.0 seconds. 
  <P></P></DD></DL>
<DL>
  <DT><B>FFDLY</B> 
  <DD>Form-feed delay type 0 (<B>FF0</B>) selects no delay. Form-feed delay type 
  0 (<B>FF0</B>) lasts about 2.0 seconds. 
  <P></P></DD></DL><B>Control</B> <B>Modes</B> 
<P>The <I>c</I>_<I>cflag</I> field describes the hardware control of the 
terminal. The values, functions, and symbolic names of the bits and subfields in 
the <I>c</I>_<I>cflag</I> field are as follows: 
<P>
<DL>
  <DT>CBAUD 
  <DD>000000017 No longer supported; see "Old termio" below. </DD></DL>
<DL>
  <DT>CSIZE 
  <DD>000000060 Character size: </DD></DL>
<DL>
  <DT>CS5 
  <DD>0 5 bits </DD></DL>
<DL>
  <DT>CS6 
  <DD>000000020 6 bits </DD></DL>
<DL>
  <DT>CS7 
  <DD>000000040 7 bits </DD></DL>
<DL>
  <DT>CS8 
  <DD>000000060 8 bits </DD></DL>
<DL>
  <DT>CSTOPB 
  <DD>000000100 Send two stop bits, else one. </DD></DL>
<DL>
  <DT>CREAD 
  <DD>000000200 Enable receiver. </DD></DL>
<DL>
  <DT>PARENB 
  <DD>000000400 Parity enable. </DD></DL>
<DL>
  <DT>PARODD 
  <DD>000001000 Odd parity, else even. </DD></DL>
<DL>
  <DT>HUPCL 
  <DD>000002000 Hang up on last close. </DD></DL>
<DL>
  <DT>CLOCAL 
  <DD>000004000 Local line, else dial-up. </DD></DL>
<DL>
  <DT>RCV1EN 
  <DD>000010000 Not supported. </DD></DL>
<DL>
  <DT>XMT1EN 
  <DD>000020000 Not supported. </DD></DL>
<DL>
  <DT>LOBLK 
  <DD>000040000 Block layer output. </DD></DL>
<DL>
  <DT>XCLUDE 
  <DD>000100000 Not supported. </DD></DL>
<DL>
  <DT>CIBAUD 
  <DD>003600000 Not supported. </DD></DL>
<DL>
  <DT>PAREXT 
  <DD>004000000 Not supported. CNEW_RTSCTS 010000000 Use RTS/CTS flow control 
  <P></P></DD></DL>
<DL>
  <DT><B>CSIZE</B> 
  <DD>The <B>CSIZE</B> bits specify the character size in bits for both 
  transmission and reception. This size does not include the parity bit, if any. 

  <P></P></DD></DL>
<DL>
  <DT><B>CSTOPB</B> 
  <DD>If <B>CSTOPB</B> is set, two stop bits are used, otherwise one stop bit. 
  For example, at 110 baud, two stops bits are required. 
  <P></P></DD></DL>
<DL>
  <DT><B>CREAD</B> 
  <DD>If <B>CREAD</B> is set, the receiver is enabled. Otherwise no characters 
  will be received. 
  <P></P></DD></DL>
<DL>
  <DT><B>PARENB</B> 
  <DD>If <B>PARENB</B> is set, parity generation and detection is enabled and a 
  parity bit is added to each character. 
  <P></P></DD></DL>
<DL>
  <DT><B>PARODD</B> 
  <DD>If parity is enabled, the <B>PARODD</B> flag specifies odd parity if set, 
  otherwise even parity is used. 
  <P></P></DD></DL>
<DL>
  <DT><B>HUPCL</B> 
  <DD>If <B>HUPCL</B> is set, the line will be disconnected when the last 
  process with the line open closes it or terminates. That is, the 
  data-terminal-ready signal will not be asserted. 
  <P></P></DD></DL>
<DL>
  <DT><B>CLOCAL</B> 
  <DD>If <B>CLOCAL</B> is set, the line is assumed to be a local, direct 
  connection with no modem control. Otherwise modem control is assumed. 
  <P></P></DD></DL>
<DL>
  <DT><B>LOBLK</B> 
  <DD>If <B>LOBLK</B> is set, the output of a job control layer will be blocked 
  when it is not the current layer. Otherwise the output generated by that layer 
  will be multiplexed onto the current layer. 
  <P></P></DD></DL>
<DL>
  <DT><B>CNEW_RTSCTS</B> 
  <DD>If <B>CNEW_RTSCTS</B> is set, and the communications port supports it, 
  RTS/CTS handshaking will be used. When the input queue becomes nearly full, 
  RTS will be dropped. RTS will be reasserted when the input queue has drained 
  sufficiently. Output is suspended when CTS is lowered and restarted when CTS 
  is raised. This flag is automatically set on the <B>ttyf</B> serial port 
  devices; see <A 
  href="http://tonka.bu.edu/cgi-bin/perl/manscript?serial(7)">serial(7)</A>. 
  <P></P></DD></DL><B>Local</B> <B>Modes</B> 
<P>The <I>c</I>_<I>lflag</I> field of the argument structure is used by the line 
discipline to control terminal functions. The following flags are currently 
defined: 
<P>
<DL>
  <DT>ISIG 
  <DD>0000001 Enable signals. ICANON 0000002 Canonical input (erase and kill 
  processing). </DD></DL>
<DL>
  <DT>XCASE 
  <DD>0000004 Canonical upper/lower presentation. </DD></DL>
<DL>
  <DT>ECHO 
  <DD>0000010 Enable echo. </DD></DL>
<DL>
  <DT>ECHOE 
  <DD>0000020 Echo erase character as BS-SP-BS. </DD></DL>
<DL>
  <DT>ECHOK 
  <DD>0000040 Echo NL after kill character. ECHONL 0000100 Echo NL. NOFLSH 
  0000200 Disable flush after interrupt or quit. IEXTEN 0000400 Enable extended 
  functions (not used by IRIX). ECHOCTL 0001000 Echo control characters as 
  ^char, delete as ^?. ECHOPRT 0002000 Echo erase character as character erased. 
  ECHOKE 0004000 BS-SP-BS entire line on line kill. FLUSHO 0020000 Output being 
  flushed. PENDIN 0040000 Retype pending input at next read or input char. 
  TOSTOP 0100000 Send SIGTTOU for background output. 
  <P></P></DD></DL>
<DL>
  <DT><B>ISIG</B> 
  <DD>If <B>ISIG</B> is set, each input character is checked against the special 
  control characters <B>INTR,</B> <B>SUSP,</B> <B>DSUSP,</B> and <B>QUIT.</B> If 
  an input character matches one of these control characters, the function 
  associated with that character is performed. If <B>ISIG</B> is not set, no 
  checking is done. Thus these special input functions are possible only if 
  <B>ISIG</B> is set. These functions may be disabled individually by changing 
  the value of the control character to <B>CNUL</B> or <B>_POSIX_VDISABLE</B> 
  <P></P></DD></DL>
<DL>
  <DT><B>ICANON</B> 
  <DD>If <B>ICANON</B> is set, canonical processing is enabled. This enables the 
  erase and kill edit functions, and the assembly of input characters into lines 
  delimited by <B>NL</B>, <B>EOF,</B> <B>EOL</B>and <B>EOL2</B>. If 
  <B>ICANON</B> is not set, read requests are satisfied directly from the input 
  queue. A read will not be satisfied until at least <B>MIN</B> characters have 
  been received or the timeout value <B>TIME</B> has expired between characters. 
  This allows fast bursts of input to be read efficiently while still allowing 
  single character input. The <B>MIN</B> and <B>TIME</B> values are stored in 
  the position for the <B>EOF</B> and <B>EOL</B> characters, respectively. The 
  time value represents tenths of seconds. 
  <P></P></DD></DL>
<DL>
  <DT><B>XCASE</B> 
  <DD>If <B>XCASE</B> is set, and if <B>ICANON</B> is set, an upper-case letter 
  is accepted on input by preceding it with a <B>\</B> character, and is output 
  preceded by a <B>\</B> character. In this mode, the following escape sequences 
  are generated on output and accepted on input: 
  <P></P></DD></DL>
<DL>
  <DT>for: 
  <DD>use: 
  <P></P></DD></DL>
<DL>
  <DT>` 
  <DD>\' </DD></DL>
<DL>
  <DT>| 
  <DD>\! </DD></DL>
<DL>
  <DT>~ 
  <DD>\^ </DD></DL>
<DL>
  <DT>{ 
  <DD>\( </DD></DL>
<DL>
  <DT>} 
  <DD>\) </DD></DL>
<DL>
  <DT>\ 
  <DD>\\ 
  <P></P></DD></DL>For example, ``A'' is input as ``\a'', ``\n'' as ``\\n'', and 
``\N'' as ``\\\n''. 
<P>
<DL>
  <DT><B>ECHO</B> 
  <DD>If <B>ECHO</B> is set, characters are echoed as received. 
  <P></P></DD></DL>When <B>ICANON</B> is set, the following echo functions are 
possible. 
<P>
<DL>
  <DT><B>ECHOE</B> 
  <DD>If <B>ECHO</B> and <B>ECHOE</B> are set, and <B>ECHOPRT</B> is not set, 
  the <B>ERASE</B> and <B>WERASE</B> characters are echoed as one or more ASCII 
  <B>BS</B> <B>SP</B> <B>BS,</B> which will clear the last character(s) from a 
  <B>CRT</B> screen. If <B>ECHOE</B> is set and <B>ECHO</B> is not set, the 
  erase character is echoed as ASCII <B>SP</B> <B>BS.</B> 
  <P></P></DD></DL>
<DL>
  <DT><B>ECHOK</B> 
  <DD>If <B>ECHOK</B> is set, and <B>ECHOKE</B> is not set, the <B>NL</B> 
  character will be echoed after the kill character to emphasize that the line 
  will be deleted. Note that an escape character or an <B>LNEXT</B> character 
  preceding the erase or kill character removes any special function (see 
  ``Special Characters'' above). 
  <P></P></DD></DL>
<DL>
  <DT><B>ECHONL</B> 
  <DD>If <B>ECHONL</B> is set, the <B>NL</B> character will be echoed even if 
  <B>ECHO</B> is not set. This is useful for terminals set to local echo 
  (so-called half duplex). Unless escaped, the <B>EOF</B> character is not 
  echoed. Because <B>EOT</B> is the default <B>EOF</B> character, this prevents 
  terminals that respond to <B>EOT</B> from hanging up. 
  <P></P></DD></DL>
<DL>
  <DT><B>NOFLSH</B> 
  <DD>If <B>NOFLSH</B> is set, the normal flush of the input and output queues 
  associated with the <B>INTR</B>, <B>QUIT</B>, and <B>SUSP</B> characters will 
  not be done. 
  <P></P></DD></DL>
<DL>
  <DT><B>TOSTOP</B> 
  <DD>If <B>TOSTOP</B> is set, the signal <B>SIGTTOU</B> is sent to a process 
  that tries to write to its controlling terminal if it is not in the foreground 
  process group for that terminal. This signal normally stops the process. 
  Otherwise, the output generated by that process is output to the current 
  output stream. Processes that are blocking or ignoring <B>SIGTTOU</B> signals 
  are excepted and allowed to produce output and the <B>SIGTTOU</B> signal is 
  not sent. 
  <P></P></DD></DL>
<DL>
  <DT><B>ECHOCTL</B> 
  <DD>If <B>ECHOCTL</B> is set, all control characters (characters with codes 
  between 0 and 37 octal) other than ASCII <B>TAB</B>, ASCII <B>NL</B>, the 
  <B>START</B> character, the <B>STOP</B> character, ASCII <B>CR</B>, and ASCII 
  <B>BS</B> are echoed as ^X, where X is the character given by adding 100 octal 
  to the code of the control character (so that the character with octal code 1 
  is echoed as ^A), and the ASCII <B>DEL</B> character, with code 177 octal is 
  echoed as ^?. 
  <P></P></DD></DL>
<DL>
  <DT><B>ECHOPRT</B> 
  <DD>If <B>ECHO</B> and <B>ECHOPRT</B> are set, the first <B>ERASE</B> or 
  <B>WERASE</B> character in a sequence echoes as a backslash (\), followed by 
  the characters being erased. Subsequent <B>ERASE</B> or <B>WERASE</B> 
  characters echo the characters being erased in reverse order. The next 
  non-erase character causes a slash (/) to be typed before it is echoed. 
  <P></P></DD></DL>
<DL>
  <DT><B>ECHOKE</B> 
  <DD>If <B>ECHOKE</B> is set, the kill character is echoed by erasing each 
  character on the line from the screen (using the mechanism selected by 
  <B>ECHOE</B> and <B>ECHOPRT</B>). 
  <P></P></DD></DL>
<DL>
  <DT><B>FLUSHO</B> 
  <DD>If <B>FLUSHO</B> is set, data written to the terminal is discarded. This 
  bit is set when the <B>FLUSH/DISCARD</B> character is typed. A program can 
  cancel the effect of typing the <B>FLUSH/DISCARD</B> character by clearing 
  <B>FLUSHO</B>. 
  <P></P></DD></DL>
<DL>
  <DT><B>PENDIN</B> 
  <DD>If <B>PENDIN</B> is set, any input that has not yet been read is reprinted 
  when the next character arrives as input. 
  <P></P></DD></DL><B>Speed</B> 
<P>The <I>c</I>_<I>ospeed</I> and <I>c</I>_<I>ispeed</I> fields control the 
output and input speeds of the line, respectively, in bits per second (bps). No 
current SGI devices support setting output and input speeds to different values, 
however, so <I>c</I>_<I>ispeed</I> is not supported. 
<P>
<DL>
  <DT>B0 
  <DD>0 Hang up </DD></DL>
<DL>
  <DT>B50 
  <DD>50 50 bps </DD></DL>
<DL>
  <DT>B75 
  <DD>75 75 bps </DD></DL>
<DL>
  <DT>B110 
  <DD>110 110 bps </DD></DL>
<DL>
  <DT>B134 
  <DD>134 134 bps </DD></DL>
<DL>
  <DT>B150 
  <DD>150 150 bps </DD></DL>
<DL>
  <DT>B200 
  <DD>200 200 bps </DD></DL>
<DL>
  <DT>B300 
  <DD>300 300 bps </DD></DL>
<DL>
  <DT>B600 
  <DD>600 600 bps 
  <P></P></DD></DL>
<DL>
  <DT>B1200 
  <DD>1200 1200 bps </DD></DL>
<DL>
  <DT>B1800 
  <DD>1800 1800 bps </DD></DL>
<DL>
  <DT>B2400 
  <DD>2400 2400 bps </DD></DL>
<DL>
  <DT>B4800 
  <DD>4800 4800 bps </DD></DL>
<DL>
  <DT>B9600 
  <DD>9600 9600 bps B19200 19200 19200 bps B38400 38400 38400 bps B57600 57600 
  57600 bps B76800 76800 76800 bps B115200 115200 115200 bps 
  <P></P></DD></DL>
<DL>
  <DT>SSPEED 
  <DD>B9600 Default baud rate. 
  <P></P></DD></DL>The B* names are provided only for convenience; applications 
may use plain integer values in <I>c</I>_<I>ospeed</I> and 
<I>c</I>_<I>ispeed</I>. 
<P>Note that capabilities of serial ports vary; not all devices support all bit 
rates. Some devices support additional rates. 
<P><B>Termio</B> <B>Structure</B><BR>The System V <B>termio</B> structure is 
used by some <B>ioctl</B>s; it is defined by <B>&lt;sys/termio.h&gt;</B> and 
includes the following members: 
<P>
<DL>
  <DT>struct 
  <DD>termio { </DD></DL>
<DL>
  <DT>tcflag_t 
  <DD>c_iflag; /* input modes */ </DD></DL>
<DL>
  <DT>tcflag_t 
  <DD>c_oflag; /* output modes */ </DD></DL>
<DL>
  <DT>tcflag_t 
  <DD>c_cflag; /* control modes */ </DD></DL>
<DL>
  <DT>tcflag_t 
  <DD>c_lflag; /* local modes */ </DD></DL>
<DL>
  <DT>speed_t 
  <DD>c_ospeed; /* output speed */ </DD></DL>
<DL>
  <DT>speed_t 
  <DD>c_ispeed; /* input speed; not supported */ </DD></DL>
<DL>
  <DT>char 
  <DD>c_line; /* line discipline */ </DD></DL>
<DL>
  <DT>cc_t 
  <DD>c_cc[NCCS]; /* control chars */ }; 
  <P></P></DD></DL>The <I>c</I>_<I>line</I> field defines the <I>line</I> 
<I>discipline</I> used to interpret control characters. A line discipline is 
associated with a family of interpretations. For example, <B>LDISC0</B> is the 
standard System V set of interpretations, while <B>LDISC1</B> is similar to the 
interpretations used in the 4.3BSD tty driver. In <B>LDISC1,</B> 
<P>
<DL>
  <DT>?additional control characters are available,
  <DD>
  <P></P></DD></DL>
<DL>
  <DT>?control characters which are not editing characters are echoed as `^'
  <DD>followed by the equivalent letter, 
  <P></P></DD></DL>
<DL>
  <DT>?backspacing does not back up into the prompt,
  <DD>
  <P></P></DD></DL>
<DL>
  <DT>?input is re-typed when backspacing encounters a confusion between what
  <DD>the user and the computer have typed, and 
  <P></P></DD></DL>
<DL>
  <DT>?job control is available.
  <DD>
  <P></P></DD></DL>The symbolic name <B>NCCS</B> is the size of the 
control-character array and is also defined by <B>&lt;termio.h&gt;</B>. The 
relative positions, subscript names, and typical default values for each 
function are as follows: 
<P>0 VINTR CINTR (DEL)<BR>1 VQUIT CQUIT (Control-\) 2 VERASE CERASE (Control-H 
(backspace)) 3 VKILL CKILL (Control-U) 4 VEOF CEOF (Control-D (EOT)) 4 VMIN<BR>5 
VEOL NUL<BR>5 VTIME<BR>6 VEOL2 NUL 
<P>If the line discipline (<I>c</I>_<I>line</I>) is set to <B>LDISC1,</B> then 
additional control characters are defined: 
<P>7 VSWTCH CNSWTCH (NUL)<BR>8 VSTART CSTART (Control-Q) 9 VSTOP CSTOP 
(Control-S) 10 VSUSP CNSWTCH (NUL)<BR>11 VDSUSP CNUL (NUL)<BR>12 VREPRINT CRPRNT 
(Control-R)<BR>13 VFLUSH CFLUSH (Control-O) 14 VWERASE CWERASE (Control-W)<BR>15 
VLNEXT CLNEXT (Control-V) 
<P><B>Old</B> <B>termio</B> <B>and</B> <B>termios</B><BR>For compatibility with 
existing binaries, MIPS ABI programs, and programs that cannot be ported to use 
the new <B>termio</B> or <B>termios</B> structures, the old interfaces are 
retained. Existing binaries automatically use the old interfaces. By defining 
<B>_OLD_TERMIOS</B> at compile time (before including <B>&lt;termios.h&gt;</B>, 
<B>&lt;termio.h&gt;</B>, or <B>&lt;sys/ttydev.h&gt;</B>), the old interfaces are 
in effect. The old <B>termios</B> structure is defined as follows: 
<P>
<DL>
  <DT>struct 
  <DD>termios { </DD></DL>
<DL>
  <DT>tcflag_t 
  <DD>c_iflag; /* input modes */ </DD></DL>
<DL>
  <DT>tcflag_t 
  <DD>c_oflag; /* output modes */ </DD></DL>
<DL>
  <DT>tcflag_t 
  <DD>c_cflag; /* control modes */ </DD></DL>
<DL>
  <DT>tcflag_t 
  <DD>c_lflag; /* local modes */ </DD></DL>
<DL>
  <DT>cc_t 
  <DD>c_cc[NCCS]; /* control chars */ }; 
  <P></P></DD></DL>and the old <B>termio</B> structure is defined as follows: 
<P>
<DL>
  <DT>struct 
  <DD>termio { </DD></DL>
<DL>
  <DT>tcflag_t 
  <DD>c_iflag; /* input modes */ </DD></DL>
<DL>
  <DT>tcflag_t 
  <DD>c_oflag; /* output modes */ </DD></DL>
<DL>
  <DT>tcflag_t 
  <DD>c_cflag; /* control modes */ 
  <P></P></DD></DL>
<DL>
  <DT>tcflag_t 
  <DD>c_lflag; /* local modes */ </DD></DL>
<DL>
  <DT>char 
  <DD>c_line; /* line discipline */ </DD></DL>
<DL>
  <DT>cc_t 
  <DD>c_cc[NCCS]; /* control chars */ }; 
  <P></P></DD></DL>The members are as described above, except for 
<I>c</I>_<I>cflag</I>, in which <B>CBAUD</B> encodes the bit rate: 
<P>CBAUD 000000017 Baud rate:<BR>B0 0 Hang up 
<DL>
  <DT>B50 
  <DD>000000001 50 baud </DD></DL>
<DL>
  <DT>B75 
  <DD>000000002 75 baud </DD></DL>
<DL>
  <DT>B110 
  <DD>000000003 110 baud </DD></DL>
<DL>
  <DT>B134 
  <DD>000000004 134 baud </DD></DL>
<DL>
  <DT>B150 
  <DD>000000005 150 baud </DD></DL>
<DL>
  <DT>B200 
  <DD>000000006 200 baud </DD></DL>
<DL>
  <DT>B300 
  <DD>000000007 300 baud </DD></DL>
<DL>
  <DT>B600 
  <DD>000000010 600 baud B1200 000000011 1200 baud B1800 000000012 1800 baud 
  B2400 000000013 2400 baud B4800 000000014 4800 baud B9600 000000015 9600 baud 
  B19200 000000016 19200 baud </DD></DL>
<DL>
  <DT>EXTA 
  <DD>000000016 External A B38400 000000017 38400 baud </DD></DL>
<DL>
  <DT>EXTB 
  <DD>000000017 External B 
  <P></P></DD></DL>SSPEED B9600 Default baud rate. 
<P><B>Mixing</B> <B>old</B> <B>and</B> <B>new</B> <B>interfaces</B><BR>If a bit 
rate is set using the new <B>termio</B> or <B>termios</B> interfaces (or the 
POSIX interfaces described in <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?termios(3)">termios(3)</A>) 
that cannot be represented in the old <B>CBAUD</B> field, then the old 
<B>termio</B>, <B>termios</B>, and POSIX interfaces will return 
<B>_INVALID_BAUD</B> in the <B>CBAUD</B> field. If the bit rate is set to 
<B>_INVALID_BAUD</B> using the old interfaces, the bit rate change will be 
ignored, and the actual line speed will remain unchanged. This allows many 
programs that do not explicitly manage bit rates to work with the new interfaces 
without change. And, it allows some old programs to work with new, fast bit 
rates without change. For example, sequences similar to the following (which are 
very common) work with either old or new interfaces, even if the line is 
currently set to a baud rate than cannot be represented in the old <B>CBAUD</B> 
field: 
<P>struct termio t; 
<P>ioctl(fd, TCGETA, &amp;t);<BR>t.c_cflag |= CREAD;<BR>t.c_lflag &amp;= 
~ECHO;<BR>/* t.c_cflag &amp; CBAUD may contain _INVALID_BAUD, but, if so, */ /* 
this TCSETA will not affect the actual bit rate */ ioctl(fd, TCSETA, &amp;t); 
<P><B>System</B> <B>Calls</B><BR>The <I>ioctl</I>()s supported by devices and 
<B>STREAMS</B> modules providing the <B>termio</B> and <B>termios</B> interface 
are listed below. 
<P>
<DL>
  <DT><B>TCGETA</B> 
  <DD>The argument is a pointer to a <B>termio</B> structure. Get the parameters 
  associated with the terminal and store in the <B>termio</B> structure 
  referenced by <B>arg</B>. 
  <P></P></DD></DL>
<DL>
  <DT><B>TCSETA</B> 
  <DD>The argument is a pointer to a <B>termio</B> structure. Set the parameters 
  associated with the terminal from the structure referenced by <B>arg</B>. The 
  change is immediate. 
  <P></P></DD></DL>
<DL>
  <DT><B>TCSETAW</B> 
  <DD>The argument is a pointer to a <B>termio</B> structure. Wait for the 
  output to drain before setting the new parameters. This form should be used 
  when changing parameters that will affect output. 
  <P></P></DD></DL>
<DL>
  <DT><B>TCSETAF</B> 
  <DD>The argument is a pointer to a <B>termio</B> structure. Wait for the 
  output to drain, then flush the input queue and set the new parameters. 
  <P></P></DD></DL>
<DL>
  <DT><B>TCGETS</B> 
  <DD>The argument is a pointer to a <B>termios</B> structure. Get the 
  parameters associated with the terminal and store in the <B>termios</B> 
  structure referenced by <B>arg</B>. See <A 
  href="http://tonka.bu.edu/cgi-bin/perl/manscript?tcgetattr(3)">tcgetattr(3)</A>. 

  <P></P></DD></DL>
<DL>
  <DT><B>TCSETS</B> 
  <DD>The argument is a pointer to a <B>termios</B> structure. Set the 
  parameters associated with the terminal from the structure referenced by 
  <B>arg</B>. The change is immediate. See <A 
  href="http://tonka.bu.edu/cgi-bin/perl/manscript?tcsetattr(3)">tcsetattr(3)</A>. 

  <P></P></DD></DL>
<DL>
  <DT><B>TCSETSW</B> 
  <DD>The argument is a pointer to a <B>termios</B> structure. Wait for the 
  output to drain before setting the new parameters. This form should be used 
  when changing parameters that will affect output. See <A 
  href="http://tonka.bu.edu/cgi-bin/perl/manscript?tcsetattr(3)">tcsetattr(3)</A>. 

  <P></P></DD></DL>
<DL>
  <DT><B>TCSETSF</B> 
  <DD>The argument is a pointer to a <B>termios</B> structure. Wait for the 
  output to drain, then flush the input queue and set the new parameters. See <A 
  href="http://tonka.bu.edu/cgi-bin/perl/manscript?tcsetattr(3)">tcsetattr(3)</A>. 

  <P></P></DD></DL>
<DL>
  <DT><B>TCSBRK</B> 
  <DD>The argument is an <B>int</B> value. Wait for the output to drain. If 
  <I>arg</I> is 0, then send a break (zero bits for 0.25 seconds). See <A 
  href="http://tonka.bu.edu/cgi-bin/perl/manscript?tcsendbreak(3)">tcsendbreak(3)</A> 
  and <A 
  href="http://tonka.bu.edu/cgi-bin/perl/manscript?tcdrain(3)">tcdrain(3)</A>. 
  <P></P></DD></DL>
<DL>
  <DT><B>TCXONC</B> 
  <DD>Start/stop control. The argument is an <B>int</B> value. If <I>arg</I> is 
  0, suspend output; if 1, restart suspended output; if 2, suspend input; if 3, 
  restart suspended input. See <A 
  href="http://tonka.bu.edu/cgi-bin/perl/manscript?tcflow(3)">tcflow(3)</A>. 
  <P></P></DD></DL>
<DL>
  <DT><B>TCFLSH</B> 
  <DD>The argument is an <B>int</B> value. If <I>arg</I> is 0, flush the input 
  queue; if 1, flush the output queue; if 2, flush both the input and output 
  queues. See <A 
  href="http://tonka.bu.edu/cgi-bin/perl/manscript?tcflush(3)">tcflush(3)</A>. 
  <P></P></DD></DL>
<DL>
  <DT><B>TIOCNOTTY</B> 
  <DD>Disconnect calling process from terminal and session. 
  <P></P></DD></DL>
<DL>
  <DT><B>TIOCSTI</B> 
  <DD>Simulate terminal input: <I>arg</I> points to a character which the system 
  pretends has been typed on the terminal. 
  <P></P></DD></DL>
<DL>
  <DT><B>TIOCSPGRP</B> 
  <DD>Set process group of tty: <I>arg</I> is a pointer to a <B>pid_t</B> which 
  is the value to which the process group ID for this terminal will be set. See 
  <I>tcsetpgrp</I>(<I>3</I>). 
  <P></P></DD></DL>
<DL>
  <DT><B>TIOCGPGRP</B> 
  <DD>Get process group of tty: <I>arg</I> is a pointer to a <B>pid_t</B> into 
  which is placed the process group ID of the process group for which this 
  terminal is the controlling terminal. See <I>tcgetpgrp</I>(<I>3</I>). 
  <P></P></DD></DL>
<DL>
  <DT><B>TIOCGSID</B> 
  <DD><I>arg</I> is a pointer to a <B>pid_t</B> into which is placed the session 
  ID of the terminal. 
  <P></P></DD></DL>
<DL>
  <DT><B>TIOCFLUSH</B> 
  <DD>If the <B>int</B> pointed to by <I>arg</I> has a zero value, all 
  characters waiting in input or output queues are flushed. Otherwise, the value 
  of the <B>int</B> is for the FREAD and FWRITE bits defined in 
  &lt;<I>sys</I>/<I>file</I>.<I>h</I>&gt;; if the FREAD bit is set, all 
  characters waiting in input queues are flushed, and if the FWRITE bit is set, 
  all characters waiting in output queues are flushed. 
  <P></P></DD></DL>
<DL>
  <DT><B>TIOCMGET</B> 
  <DD>The argument is a pointer to an <B>int</B> sized bit field into which the 
  current state of the modem status lines is stored. This <I>ioctl</I>() is 
  supported only on special files representing serial ports. See <A 
  href="http://tonka.bu.edu/cgi-bin/perl/manscript?serial(7)">serial(7)</A>. The 
  symbolic names of the bits returned in <I>arg</I> are defined by 
  &lt;<I>sys</I>/<I>termios</I>.<I>h</I>&gt;: 
  <P></P></DD></DL>
<DL>
  <DT>TIOCM_LE 
  <DD>line enable </DD></DL>
<DL>
  <DT>TIOCM_DTR 
  <DD>data terminal ready </DD></DL>
<DL>
  <DT>TIOCM_RTS 
  <DD>request to send </DD></DL>
<DL>
  <DT>TIOCM_ST 
  <DD>secondary transmit </DD></DL>
<DL>
  <DT>TIOCM_SR 
  <DD>secondary receive </DD></DL>
<DL>
  <DT>TIOCM_CTS 
  <DD>clear to send </DD></DL>
<DL>
  <DT>TIOCM_CAR 
  <DD>carrier detect </DD></DL>
<DL>
  <DT>TIOCM_CD 
  <DD>synonym for TIOCM_CAR TIOCM_RNG ring </DD></DL>
<DL>
  <DT>TIOCM_RI 
  <DD>synonym for TIOCM_RNG </DD></DL>
<DL>
  <DT>TIOCM_DSR 
  <DD>data set ready 
  <P></P></DD></DL>Not all of these are necessarily supported by any particular 
device. 
<P>
<DL>
  <DT><B>TIOCMSET</B> 
  <DD>The argument is a pointer to an <B>int</B> sized bit field used to set the 
  state of the modem status lines. If a bit is set, the coresponding modem 
  status line is turned on. If a bit is cleared the coresponding modem status 
  line is turned off. This <I>ioctl</I>() is supported only on special files 
  representing serial ports. See <A 
  href="http://tonka.bu.edu/cgi-bin/perl/manscript?serial(7)">serial(7)</A>. The 
  symbolic names of the bits used in <I>arg</I> are the same as for 
  <B>TIOCMGET.</B> Only DTR and RTS are settable with this <I>ioctl</I>(). Not 
  all of these are necessarily supported by any particular device. 
  <P></P></DD></DL><B>TIOCGWINSZ</B> Get window size: <I>arg</I> is a pointer to a 
structure of the following form: Window size structure: 
<P>struct winsize {<BR>unsigned short ws_row; /* rows, in chars */ unsigned 
short ws_col; /* columns, in chars */ unsigned short ws_xpixel; /* horiz. pixels 
*/ unsigned short ws_ypixel; /* vert. pixels */ }; 
<P><B>TIOCSWINSZ</B> Set window size: <I>arg</I> is a pointer to a structure of 
a <I>winsize</I> structure. 
<P><B>FIONREAD</B> Return the number of bytes currently available to read. 
<I>arg</I> is a pointer to an <I>int</I>. 
<P>
<DL>
  <DT><B>FIONBIO</B> 
  <DD>Enables or disables non-blocking mode, according to the boolean value of 
  the contents of <I>arg</I>. <I>arg</I> is a pointer to an <I>int</I>. Enabling 
  this mode has the same effect as the <B>O_NDELAY</B> flag for <A 
  href="http://tonka.bu.edu/cgi-bin/perl/manscript?open(2)">open(2)</A>. 
  <P></P></DD></DL>The following <I>ioctl</I> calls apply only to pseudo 
terminals; see <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?pty(7M)">pty(7M)</A> for their 
descriptions: 
<P><B>TIOCPKT</B>, <B>TIOCPKT_DATA</B>, <B>TIOCPKT_FLUSHREAD</B>, 
<B>TIOCPKT_FLUSHWRITE</B>, <B>TIOCPKT_STOP</B>, <B>TIOCPKT_START</B>, 
<B>TIOCPKT_NOSTOP</B> and <B>TIOCPKT_DOSTOP</B>. 
<P>
<H2><A href="http://conx.bu.edu/cgi-bin/perl/manscript?termio(7)#toc4" 
name=sect4><B>NOTES</B></A></H2>Of the <I>ioctl</I> commands listed above, all 
except <B>TCGETA</B> and <B>TCGETS</B> alter the state of the terminal. For this 
reason, a background job which issues any of commands except <B>TCGETA</B> or 
<B>TCGETS</B> will be suspended. Refer to <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?csh(1)">csh(1)</A> or <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?ksh(1)">ksh(1)</A> for more 
information about job control. 
<P>
<H2><A href="http://conx.bu.edu/cgi-bin/perl/manscript?termio(7)#toc5" 
name=sect5><B>FILES</B></A></H2>/dev/tty* 
<P>
<H2><A href="http://conx.bu.edu/cgi-bin/perl/manscript?termio(7)#toc6" 
name=sect6><B>SEE</B> <B>ALSO</B></A></H2><A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?stty(1)">stty(1)</A>, <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?fork(2)">fork(2)</A>, <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?ioctl(2)">ioctl(2)</A>, <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?setsid(2)">setsid(2)</A>, <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?setpgrp(2)">setpgrp(2)</A>, <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?signal(2)">signal(2)</A>, <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?tcdrain(3)">tcdrain(3)</A>, <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?tcflow(3)">tcflow(3)</A>, <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?tcflush(3)">tcflush(3)</A>, <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?tcgetattr(3)">tcgetattr(3)</A>, 
<A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?tcgetpgrp(3)">tcgetpgrp(3)</A>, 
<A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?tcsendbreak(3)">tcsendbreak(3)</A>, 
<A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?tcsetattr(3)">tcsetattr(3)</A>, 
<A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?tcsetpgrp(3)">tcsetpgrp(3)</A>, 
<A href="http://tonka.bu.edu/cgi-bin/perl/manscript?pty(7M)">pty(7M)</A>, <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?serial(7)">serial(7)</A>, <A 
href="http://tonka.bu.edu/cgi-bin/perl/manscript?termios(3)">termios(3)</A> 
<P>
<HR>

<P><A name=toc><B>Table of Contents</B></A>
<P>
<UL>
  <LI><A href="http://conx.bu.edu/cgi-bin/perl/manscript?termio(7)#sect1" 
  name=toc1>NAME</A> 
  <LI><A href="http://conx.bu.edu/cgi-bin/perl/manscript?termio(7)#sect2" 
  name=toc2>SYNOPSIS</A> 
  <LI><A href="http://conx.bu.edu/cgi-bin/perl/manscript?termio(7)#sect3" 
  name=toc3>DESCRIPTION</A> 
  <LI><A href="http://conx.bu.edu/cgi-bin/perl/manscript?termio(7)#sect4" 
  name=toc4>NOTES</A> 
  <LI><A href="http://conx.bu.edu/cgi-bin/perl/manscript?termio(7)#sect5" 
  name=toc5>FILES</A> 
  <LI><A href="http://conx.bu.edu/cgi-bin/perl/manscript?termio(7)#sect6" 
  name=toc6>SEE ALSO</A> </LI></UL></BODY></HTML>

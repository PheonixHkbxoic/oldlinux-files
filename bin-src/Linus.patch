diff -c --recursive --new-file std/Configure linux/Configure
*** std/Configure	Wed Mar 31 16:36:25 1993
--- linux/Configure	Sat Apr 24 19:39:35 1993
***************
*** 1,27 ****
  #! /bin/sh
  #
! # This script is used to configure the linux kernel.
! # It's a fast hack - feel free to do something better.
! CONFIG=.config~
! CONFIG_H=include/linux/autoconf.h
! > config.new
! echo "#" > $CONFIG
! echo "# Automatically generated make config: don't edit" >> $CONFIG
! echo "#" >> $CONFIG
! 
! echo "/*" > $CONFIG_H
! echo " * Automatically generated C config: don't edit" >> $CONFIG_H
! echo " */" >> $CONFIG_H
! 
! next="y"
! old="y"
  
! while read i
! do
  	echo $i >> config.new
! 	echo >> $CONFIG
! 	echo >> $CONFIG_H
! 	echo
  	echo "#" >> $CONFIG
  	echo "/*" >> $CONFIG_H
  	echo "**"
--- 1,55 ----
  #! /bin/sh
+ # Configure	This script is used to configure the Linux kernel.
  #
! # Usage:	Configure [-pro]
! #
! # Version;	@(#)Configure	1.3	04/05/93
! #
! # Author:	Linus Torvalds, <torvalds@helsinki.fi>
! #
  
!   # Set variables to initial state.
!   OPTS=""
!   CONFIG=.config~
!   CONFIG_H=include/linux/autoconf.h
!   next="y"
!   old="y"
! 
!   # Check commandline arguments.
!   >config.new
!   while [ $# != 0 ]
!   do
! 	case $1 in
! 		-pro)	OPTS="UTS_SYSNAME \"LINUX/Pro\""
! 			;;
! 		*)	echo "Usage: Configure [-pro]"
! 			exit 1
! 			;;
! 	esac
! 	shift
!   done
!  	
!   echo "#" > $CONFIG
!   echo "# Automatically generated make config: don't edit" >> $CONFIG
!   echo "#" >> $CONFIG
! 
!   echo "/*" > $CONFIG_H
!   echo " * Automatically generated C config: don't edit" >> $CONFIG_H
!   echo " */" >> $CONFIG_H
! 
!   # First of all, emit the "special" features to <linux/autoconf.h>.
!   if [ "${OPTS}" ]
!   then
! 	echo "#define ${OPTS}" >> $CONFIG_H
!   fi
! 
!   # Read our standard input (which is the CONFIG.IN file).
!   while read i
!   do
  	echo $i >> config.new
!   	echo >> $CONFIG
!   	echo >> $CONFIG_H
!   	echo
  	echo "#" >> $CONFIG
  	echo "/*" >> $CONFIG_H
  	echo "**"
***************
*** 69,83 ****
  	then
  		next="n"
  	fi
! done
! 
! mv config.new config.in
  
! echo
! echo "The linux kernel is now hopefully configured for your setup."
! echo "Check the top-level Makefile for additional configuration,"
! echo "and do a 'make dep ; make clean' if you want to be sure all"
! echo "the files are correctly re-made"
! echo
  
! exit 0
--- 97,110 ----
  	then
  		next="n"
  	fi
!   done
!   mv config.new config.in
  
!   echo
!   echo "The linux kernel is now hopefully configured for your setup."
!   echo "Check the top-level Makefile for additional configuration,"
!   echo "and do a 'make dep ; make clean' if you want to be sure all"
!   echo "the files are correctly re-made"
!   echo
  
!   exit 0
diff -c --recursive --new-file std/Makefile linux/Makefile
*** std/Makefile	Thu Apr 22 23:10:11 1993
--- linux/Makefile	Sat Apr 24 22:36:50 1993
***************
*** 44,52 ****
  # 0x08 - tilde (~)
  # 0x10 - dieresis (umlaut)
  
! KEYBOARD = -DKBD_FINNISH -DKBDFLAGS=0
  # KEYBOARD = -DKBD_FINNISH_LATIN1 -DKBDFLAGS=0x1F
! # KEYBOARD = -DKBD_US -DKBDFLAGS=0
  # KEYBOARD = -DKBD_GR -DKBDFLAGS=0
  # KEYBOARD = -DKBD_GR_LATIN1 -DKBDFLAGS=0x1F
  # KEYBOARD = -DKBD_FR -DKBDFLAGS=0
--- 44,52 ----
  # 0x08 - tilde (~)
  # 0x10 - dieresis (umlaut)
  
! # KEYBOARD = -DKBD_FINNISH -DKBDFLAGS=0
  # KEYBOARD = -DKBD_FINNISH_LATIN1 -DKBDFLAGS=0x1F
! KEYBOARD = -DKBD_US -DKBDFLAGS=0
  # KEYBOARD = -DKBD_GR -DKBDFLAGS=0
  # KEYBOARD = -DKBD_GR_LATIN1 -DKBDFLAGS=0x1F
  # KEYBOARD = -DKBD_FR -DKBDFLAGS=0
***************
*** 68,75 ****
  # The number is the same as you would ordinarily press at bootup.
  #
  
! SVGA_MODE=	-DSVGA_MODE=3
  
  #
  # standard CFLAGS
  #
--- 68,78 ----
  # The number is the same as you would ordinarily press at bootup.
  #
  
! SVGA_MODE=	-DSVGA_MODE=NORMAL_VGA
  
+ # Special options.
+ OPTS	= -pro
+ 
  #
  # standard CFLAGS
  #
***************
*** 125,131 ****
  	/etc/lilo/install
  
  config:
! 	sh Configure < config.in
  	mv .config~ .config
  	$(MAKE) soundconf
  
--- 128,134 ----
  	/etc/lilo/install
  
  config:
! 	sh Configure $(OPTS) < config.in
  	mv .config~ .config
  	$(MAKE) soundconf
  
***************
*** 139,146 ****
  
  tools/version.h: $(CONFIGURE) Makefile
  	@./makever.sh
! 	@echo \#define UTS_RELEASE \"0.99.pl9-`cat .version`\" > tools/version.h
! 	@echo \#define UTS_VERSION \"`date +%D`\" >> tools/version.h
  	@echo \#define LINUX_COMPILE_TIME \"`date +%T`\" >> tools/version.h
  	@echo \#define LINUX_COMPILE_BY \"`whoami`\" >> tools/version.h
  	@echo \#define LINUX_COMPILE_HOST \"`hostname`\" >> tools/version.h
--- 142,149 ----
  
  tools/version.h: $(CONFIGURE) Makefile
  	@./makever.sh
! 	@echo \#define UTS_RELEASE \"0.99.9-`cat .version`\" > tools/version.h
! 	@echo \#define UTS_VERSION \"`date`\" >> tools/version.h
  	@echo \#define LINUX_COMPILE_TIME \"`date +%T`\" >> tools/version.h
  	@echo \#define LINUX_COMPILE_BY \"`whoami`\" >> tools/version.h
  	@echo \#define LINUX_COMPILE_HOST \"`hostname`\" >> tools/version.h
diff -c --recursive --new-file std/config.in linux/config.in
*** std/config.in	Fri Apr 23 20:41:46 1993
--- linux/config.in	Sat Apr 24 21:04:24 1993
***************
*** 1,78 ****
  General setup
  .
  Kernel math emulation
! CONFIG_MATH_EMULATION y/n n
  Normal harddisk support
  CONFIG_BLK_DEV_HD y/n y
  XT harddisk support
  CONFIG_BLK_DEV_XD y/n n
! TCP/IP
! CONFIG_TCPIP y/n y
  Kernel profiling support
  CONFIG_PROFILE y/n n
  Limit memory to low 16MB
! CONFIG_MAX_16M y/n n
  Use -m486 flag for 486-specific optimizations
  CONFIG_M486 y/n y
  :
  SCSI support
  .
  SCSI support?
! CONFIG_SCSI y/n n
  :
  SCSI support type (disk, tape, CDrom)
  .
  Scsi disk support
! CONFIG_BLK_DEV_SD y/n n
  Scsi tape support
! CONFIG_BLK_DEV_ST y/n n
  Scsi CDROM support
! CONFIG_BLK_DEV_SR y/n n
  .
  SCSI low-level drivers
  .
  Adaptec AHA1542 support
! CONFIG_SCSI_AHA1542 y/n n
  Adaptec AHA1740 support
! CONFIG_SCSI_AHA1740 y/n n
  Future Domain SCSI support
! CONFIG_SCSI_FUTURE_DOMAIN y/n n
  Seagate ST-02 and Future Domain TMC-8xx SCSI support
! CONFIG_SCSI_SEAGATE y/n n
  UltraStor SCSI support
! CONFIG_SCSI_ULTRASTOR y/n n
  7000FASST SCSI support
! CONFIG_SCSI_7000FASST y/n n
  .
  Filesystems
  .
- Mount root initially readonly
- CONFIG_ROOT_RDONLY y/n n
  Standard (minix) fs support
  CONFIG_MINIX_FS y/n y
  Extended fs support
! CONFIG_EXT_FS y/n n
  Second extended fs support
! CONFIG_EXT2_FS y/n n
  xiafs filesystem support
! CONFIG_XIA_FS y/n n
  msdos fs support
  CONFIG_MSDOS_FS y/n y
  /proc filesystem support
  CONFIG_PROC_FS y/n y
  NFS filesystem support
! CONFIG_NFS_FS y/n n
  ISO9660 cdrom filesystem support
! CONFIG_ISO9660_FS y/n n
  .
  Various character device drivers..
  .
  Keyboard meta-key sends ESC-prefix
! CONFIG_KBD_META y/n y
  Autoconfigure serial IRQ lines at bootup
  CONFIG_AUTO_IRQ y/n n
  AST Fourport serial driver support
! CONFIG_AST_FOURPORT y/n n
  Accent Async 4 serial support
  CONFIG_ACCENT_ASYNC y/n n
  Logitech busmouse support
--- 1,78 ----
  General setup
  .
  Kernel math emulation
! CONFIG_MATH_EMULATION y/n y
  Normal harddisk support
  CONFIG_BLK_DEV_HD y/n y
  XT harddisk support
  CONFIG_BLK_DEV_XD y/n n
! TCP/IP version 1 Networking
! CONFIG_TCPIP y/n y
! TCP/IP version 2 Networking
! CONFIG_INET y/n n
  Kernel profiling support
  CONFIG_PROFILE y/n n
  Limit memory to low 16MB
! CONFIG_MAX_16M y/n y
  Use -m486 flag for 486-specific optimizations
  CONFIG_M486 y/n y
  :
  SCSI support
  .
  SCSI support?
! CONFIG_SCSI y/n y
  :
  SCSI support type (disk, tape, CDrom)
  .
  Scsi disk support
! CONFIG_BLK_DEV_SD y/n y
  Scsi tape support
! CONFIG_BLK_DEV_ST y/n y
  Scsi CDROM support
! CONFIG_BLK_DEV_SR y/n y
  .
  SCSI low-level drivers
  .
  Adaptec AHA1542 support
! CONFIG_SCSI_AHA1542 y/n y
  Adaptec AHA1740 support
! CONFIG_SCSI_AHA1740 y/n y
  Future Domain SCSI support
! CONFIG_SCSI_FUTURE_DOMAIN y/n y
  Seagate ST-02 and Future Domain TMC-8xx SCSI support
! CONFIG_SCSI_SEAGATE y/n y
  UltraStor SCSI support
! CONFIG_SCSI_ULTRASTOR y/n y
  7000FASST SCSI support
! CONFIG_SCSI_7000FASST y/n y
  .
  Filesystems
  .
  Standard (minix) fs support
  CONFIG_MINIX_FS y/n y
  Extended fs support
! CONFIG_EXT_FS y/n y
  Second extended fs support
! CONFIG_EXT2_FS y/n y
  xiafs filesystem support
! CONFIG_XIA_FS y/n y
  msdos fs support
  CONFIG_MSDOS_FS y/n y
  /proc filesystem support
  CONFIG_PROC_FS y/n y
  NFS filesystem support
! CONFIG_NFS_FS y/n y
  ISO9660 cdrom filesystem support
! CONFIG_ISO9660_FS y/n y
  .
  Various character device drivers..
  .
  Keyboard meta-key sends ESC-prefix
! CONFIG_KBD_META y/n n
  Autoconfigure serial IRQ lines at bootup
  CONFIG_AUTO_IRQ y/n n
  AST Fourport serial driver support
! CONFIG_AST_FOURPORT y/n y
  Accent Async 4 serial support
  CONFIG_ACCENT_ASYNC y/n n
  Logitech busmouse support
diff -c --recursive --new-file std/fs/nfs/proc.c linux/fs/nfs/proc.c
*** std/fs/nfs/proc.c	Mon Mar  1 10:16:26 1993
--- linux/fs/nfs/proc.c	Sat Apr 24 23:53:27 1993
***************
*** 16,21 ****
--- 16,22 ----
  #define NFS_PROC_DEBUG
  #endif
  
+ #include <linux/config.h>
  #include <linux/param.h>
  #include <linux/sched.h>
  #include <linux/mm.h>
***************
*** 24,30 ****
--- 25,36 ----
  #include <linux/errno.h>
  #include <linux/string.h>
  
+ #ifdef CONFIG_TCPIP
  #include <netinet/in.h>
+ #endif
+ #ifdef CONFIG_INET
+ #include <linux/in.h>
+ #endif
  
  #ifdef NFS_PROC_DEBUG
  static int proc_debug = 0;
diff -c --recursive --new-file std/fs/nfs/sock.c linux/fs/nfs/sock.c
*** std/fs/nfs/sock.c	Mon Mar  1 10:16:26 1993
--- linux/fs/nfs/sock.c	Sat Apr 24 21:15:57 1993
***************
*** 6,11 ****
--- 6,12 ----
   *  low-level nfs remote procedure call interface
   */
  
+ #include <linux/config.h>
  #include <linux/sched.h>
  #include <linux/nfs_fs.h>
  #include <linux/errno.h>
***************
*** 13,21 ****
  #include <linux/fcntl.h>
  #include <asm/segment.h>
  
  #include <netinet/in.h>
- 
  #include "../../net/kern_sock.h"
  
  extern struct socket *socki_lookup(struct inode *inode);
  
--- 14,28 ----
  #include <linux/fcntl.h>
  #include <asm/segment.h>
  
+ #ifdef CONFIG_TCPIP			/* FIXME: old-style NET */
  #include <netinet/in.h>
  #include "../../net/kern_sock.h"
+ #endif
+ #ifdef CONFIG_INET			/* FIXME: new-style NET */
+ #include <linux/in.h>
+ #include <linux/net.h>
+ #endif
+ 
  
  extern struct socket *socki_lookup(struct inode *inode);
  
diff -c --recursive --new-file std/fs/proc/Makefile linux/fs/proc/Makefile
*** std/fs/proc/Makefile	Fri Dec 25 21:34:36 1992
--- linux/fs/proc/Makefile	Sat Apr 24 19:39:35 1993
***************
*** 14,20 ****
  .s.o:
  	$(AS) -o $*.o $<
  
! OBJS=	inode.o root.o base.o mem.o link.o fd.o array.o kmsg.o
  
  proc.o: $(OBJS)
  	$(LD) -r -o proc.o $(OBJS)
--- 14,20 ----
  .s.o:
  	$(AS) -o $*.o $<
  
! OBJS=	inode.o root.o base.o mem.o link.o fd.o array.o kmsg.o net.o
  
  proc.o: $(OBJS)
  	$(LD) -r -o proc.o $(OBJS)
diff -c --recursive --new-file std/fs/proc/inode.c linux/fs/proc/inode.c
*** std/fs/proc/inode.c	Thu Apr  8 06:17:54 1993
--- linux/fs/proc/inode.c	Sat Apr 24 19:39:35 1993
***************
*** 100,111 ****
  		inode->i_op = &proc_root_inode_operations;
  		return;
  	}
! 	if (!pid) {
  		inode->i_mode = S_IFREG | 0444;
! 		inode->i_op = &proc_array_inode_operations;
! 		if (ino == 5) {
! 			inode->i_mode = S_IFREG | 0400;
! 			inode->i_op = &proc_kmsg_inode_operations;
  		}
  		return;
  	}
--- 100,125 ----
  		inode->i_op = &proc_root_inode_operations;
  		return;
  	}
! 	if ((ino >= 128) && (ino <= 160)) { /* files within /proc/net */
  		inode->i_mode = S_IFREG | 0444;
! 		inode->i_op = &proc_net_inode_operations;
! 		return;
! 	}
! 	if (!pid) {
! 		switch (ino) {
! 			case 5:
! 				inode->i_mode = S_IFREG | 0444;
! 				inode->i_op = &proc_kmsg_inode_operations;
! 				break;
! 			case 8: /* for the net directory */
! 				inode->i_mode = S_IFDIR | 0555;
! 				inode->i_nlink = 2;
! 				inode->i_op = &proc_net_inode_operations;
! 				break;
! 			default:
! 				inode->i_mode = S_IFREG | 0444;
! 				inode->i_op = &proc_array_inode_operations;
! 				break;
  		}
  		return;
  	}
diff -c --recursive --new-file std/fs/proc/net.c linux/fs/proc/net.c
*** std/fs/proc/net.c
--- linux/fs/proc/net.c	Sat Apr 24 21:05:18 1993
***************
*** 0 ****
--- 1,211 ----
+ /*
+  *  linux/fs/proc/net.c
+  *
+  *  Copyright (C) 1991, 1992 Linus Torvalds
+  *
+  *  gjh 3/'93 heim@peanuts.informatik.uni-tuebingen.de (Gerald J. Heim)
+  *            most of this file is stolen from base.c
+  *            it works, but you shouldn't use it as a guideline
+  *            for new proc-fs entries. once i'll make it better.
+  * fvk 3/'93  waltje@uwalt.nl.mugnet.org (Fred N. van Kempen)
+  *	      cleaned up the whole thing, moved "net" specific code to
+  *	      the NET kernel layer (where it belonged in the first place).
+  * Michael K. Johnson (johnsonm@stolaf.edu) 3/93
+  *            Added support from my previous inet.c.  Cleaned things up
+  *            quite a bit, modularized the code.
+  * fvk 4/'93  waltje@uwalt.nl.mugnet.org (Fred N. van Kempen)
+  *	      Renamed "route_get_info()" to "rt_get_info()" for consistency.
+  *
+  *  proc net directory handling functions
+  */
+ #include <linux/autoconf.h>
+ 
+ #include <asm/segment.h>
+ 
+ #include <linux/errno.h>
+ #include <linux/sched.h>
+ #include <linux/proc_fs.h>
+ #include <linux/stat.h>
+ 
+ /* forward references */
+ static int proc_readnet(struct inode * inode, struct file * file,
+ 			 char * buf, int count);
+ static int proc_readnetdir(struct inode *, struct file *,
+ 			   struct dirent *, int);
+ static int proc_lookupnet(struct inode *,const char *,int,struct inode **);
+ 
+ /* the get_*_info() functions are in the net code, and are configured
+    in via the standard mechanism... */
+ #ifdef CONFIG_INET
+ extern int unix_get_info(char *);
+ extern int tcp_get_info(char *);
+ extern int udp_get_info(char *);
+ extern int raw_get_info(char *);
+ extern int arp_get_info(char *);
+ extern int dev_get_info(char *);
+ extern int rt_get_info(char *);
+ #endif /* CONFIG_INET */
+ 
+ 
+ static struct file_operations proc_net_operations = {
+ 	NULL,			/* lseek - default */
+ 	proc_readnet,		/* read - bad */
+ 	NULL,			/* write - bad */
+ 	proc_readnetdir,	/* readdir */
+ 	NULL,			/* select - default */
+ 	NULL,			/* ioctl - default */
+ 	NULL,			/* mmap */
+ 	NULL,			/* no special open code */
+ 	NULL,			/* no special release code */
+ 	NULL			/* can't fsync */
+ };
+ 
+ /*
+  * proc directories can do almost nothing..
+  */
+ struct inode_operations proc_net_inode_operations = {
+ 	&proc_net_operations,	/* default net directory file-ops */
+ 	NULL,			/* create */
+ 	proc_lookupnet,		/* lookup */
+ 	NULL,			/* link */
+ 	NULL,			/* unlink */
+ 	NULL,			/* symlink */
+ 	NULL,			/* mkdir */
+ 	NULL,			/* rmdir */
+ 	NULL,			/* mknod */
+ 	NULL,			/* rename */
+ 	NULL,			/* readlink */
+ 	NULL,			/* follow_link */
+ 	NULL,			/* bmap */
+ 	NULL,			/* truncate */
+ 	NULL			/* permission */
+ };
+ 
+ static struct proc_dir_entry net_dir[] = {
+ 	{ 1,2,".." },
+ 	{ 8,1,"." }
+ #ifdef CONFIG_INET
+ 	,{ 128,4,"unix" },
+ 	{ 129,3,"arp" },
+ 	{ 130,5,"route" },
+ 	{ 131,3,"dev" },
+ 	{ 132,3,"raw" },
+ 	{ 133,3,"tcp" },
+ 	{ 134,3,"udp" }
+ #endif	/* CONFIG_INET */
+ };
+ 
+ #define NR_NET_DIRENTRY ((sizeof (net_dir))/(sizeof (net_dir[0])))
+ 
+ 
+ static int proc_lookupnet(struct inode * dir,const char * name, int len,
+ 	struct inode ** result)
+ {
+ 	unsigned int ino;
+ 	int i;
+ 
+ 	*result = NULL;
+ 	if (!dir)
+ 		return -ENOENT;
+ 	if (!S_ISDIR(dir->i_mode)) {
+ 		iput(dir);
+ 		return -ENOENT;
+ 	}
+ 	i = NR_NET_DIRENTRY;
+ 	while (i-- > 0 && !proc_match(len,name,net_dir+i))
+ 		/* nothing */;
+ 	if (i < 0) {
+ 		iput(dir);
+ 		return -ENOENT;
+ 	}
+ 	ino = net_dir[i].low_ino;
+ 	if (!(*result = iget(dir->i_sb,ino))) {
+ 		iput(dir);
+ 		return -ENOENT;
+ 	}
+ 	iput(dir);
+ 	return 0;
+ }
+ 
+ static int proc_readnetdir(struct inode * inode, struct file * filp,
+ 	struct dirent * dirent, int count)
+ {
+ 	struct proc_dir_entry * de;
+ 	unsigned int ino;
+ 	int i,j;
+ 
+ 	if (!inode || !S_ISDIR(inode->i_mode))
+ 		return -EBADF;
+ 	ino = inode->i_ino;
+ 	if (((unsigned) filp->f_pos) < NR_NET_DIRENTRY) {
+ 		de = net_dir + filp->f_pos;
+ 		filp->f_pos++;
+ 		i = de->namelen;
+ 		ino = de->low_ino;
+ 		put_fs_long(ino, &dirent->d_ino);
+ 		put_fs_word(i,&dirent->d_reclen);
+ 		put_fs_byte(0,i+dirent->d_name);
+ 		j = i;
+ 		while (i--)
+ 			put_fs_byte(de->name[i], i+dirent->d_name);
+ 		return j;
+ 	}
+ 	return 0;
+ }
+ 
+ 
+ static int proc_readnet(struct inode * inode, struct file * file,
+ 			char * buf, int count)
+ {
+ 	char * page;
+ 	int length;
+ 	int end;
+ 	unsigned int ino;
+ 
+ 	if (count < 0)
+ 		return -EINVAL;
+ 	page = (char *) get_free_page(GFP_KERNEL);
+ 	if (!page)
+ 		return -ENOMEM;
+ 	ino = inode->i_ino;
+ 	switch (ino) {
+ #ifdef CONFIG_INET
+ 		case 128:
+ 			length = unix_get_info(page);
+ 			break;
+ 		case 129:
+ 			length = arp_get_info(page);
+ 			break;
+ 		case 130:
+ 			length = rt_get_info(page);
+ 			break;
+ 		case 131:
+ 			length = dev_get_info(page);
+ 			break;
+ 		case 132:
+ 			length = raw_get_info(page);
+ 			break;
+ 		case 133:
+ 			length = tcp_get_info(page);
+ 			break;
+ 		case 134:
+ 			length = udp_get_info(page);
+ 			break;
+ #endif /* CONFIG_INET */
+ 		default:
+ 			free_page((unsigned long) page);
+ 			return -EBADF;
+ 	}
+ 	if (file->f_pos >= length) {
+ 		free_page((unsigned long) page);
+ 		return 0;
+ 	}
+ 	if (count + file->f_pos > length)
+ 		count = length - file->f_pos;
+ 	end = count + file->f_pos;
+ 	memcpy_tofs(buf, page + file->f_pos, count);
+ 	free_page((unsigned long) page);
+ 	file->f_pos = end;
+ 	return count;
+ 
+ }
diff -c --recursive --new-file std/fs/proc/root.c linux/fs/proc/root.c
*** std/fs/proc/root.c	Sun Feb 28 11:59:43 1993
--- linux/fs/proc/root.c	Sat Apr 24 19:39:35 1993
***************
*** 58,64 ****
  	{ 4,7,"meminfo" },
  	{ 5,4,"kmsg" },
  	{ 6,7,"version" },
! 	{ 7,4,"self" }	/* will change inode # */
  };
  
  #define NR_ROOT_DIRENTRY ((sizeof (root_dir))/(sizeof (root_dir[0])))
--- 58,65 ----
  	{ 4,7,"meminfo" },
  	{ 5,4,"kmsg" },
  	{ 6,7,"version" },
! 	{ 7,4,"self" },	/* will change inode # */
! 	{ 8,3,"net" }
  };
  
  #define NR_ROOT_DIRENTRY ((sizeof (root_dir))/(sizeof (root_dir[0])))
diff -c --recursive --new-file std/include/linux/ddi.h linux/include/linux/ddi.h
*** std/include/linux/ddi.h
--- linux/include/linux/ddi.h	Sat Apr 24 19:39:35 1993
***************
*** 0 ****
--- 1,79 ----
+ /*
+  * ddi.h	Define the structure for linking in I/O drivers into the
+  *		operating system kernel.  This method is currently only
+  *		used by NET layer drivers, but it will be expanded into
+  *		a link methos for ALL kernel-resident device drivers.
+  *
+  * Version:	@(#)ddi.h	1.0.2	04/22/93
+  *
+  * Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
+  */
+ #ifndef _LINUX_DDI_H
+ #define _LINUX_DDI_H
+ 
+ 
+ /* DDI control block flags. */
+ #define DDI_FREADY	0x10000000	/* device is initialized	*/
+ #define DDI_FPRESENT	0x20000000	/* device hardware is present	*/
+ #define DDI_FBLKDEV	0x00000001	/* device has a BLK spec. file	*/
+ #define DDI_FCHRDEV	0x00000002	/* device has a CHR spec. file	*/
+ 
+ /* Various constants. */
+ #define DDI_MAXNAME	16		/* length of a DDI ID string	*/
+ 
+ 
+ /* This structure is used to set up a DDI driver. */
+ struct ddconf {
+   int		ioaddr;			/* main I/O (port) address	*/
+   int		ioaux;			/* auxiliary I/O (HD, AST)	*/
+   int		irq;			/* IRQ channel			*/
+   int		dma;			/* DMA channel to use		*/
+   unsigned long	memsize;		/* size of onboard memory	*/
+   unsigned long	memaddr;		/* base address of memory	*/
+ };
+ 
+ 
+ /* The DDI device control block. */
+ struct ddi_device {
+   char		*title;			/* title of the driver		*/
+   char		name[DDI_MAXNAME];	/* unit name of the I/O driver	*/
+   short int	unit;			/* unit number of this driver	*/
+   short int	nunits;			/* number of units in driver	*/
+   int		(*init)(struct ddi_device *);	/* initialization func		*/
+   int		(*handler)(int, ...);	/* command handler		*/
+   short	int	major;			/* driver major dev number	*/
+   short	int	minor;			/* driver minor dev number	*/
+   unsigned long	flags;			/* various flags		*/
+   struct ddconf config;			/* driver HW setup		*/
+ };
+ 
+ 
+ /* This structure is used to set up networking protocols. */
+ struct ddi_proto {
+   char		*name;			/* protocol name		*/
+   void		(*init)(struct ddi_proto *);	/* initialization func	*/
+ };
+ 
+ 
+ /* This structure is used to link a STREAMS interface. */
+ struct iflink {
+   char		id[DDI_MAXNAME];	/* DDI ID string		*/
+   char		stream[DDI_MAXNAME];	/* STREAMS interface name	*/
+   int		family;			/* address (protocol) family	*/
+   unsigned int	flags;			/* any flags needed (unused)	*/
+ };
+ 
+ 
+ /* DDI control requests. */
+ #define DDIOCSDBG	0x9000		/* set DDI debug level		*/
+ #define DDIOCGNAME	0x9001		/* get DDI ID name		*/
+ #define DDIOCGCONF	0x9002		/* get DDI HW config		*/
+ #define DDIOCSCONF	0x9003		/* set DDI HW config		*/
+ 
+ 
+ /* DDI global functions. */
+ extern void			ddi_init(void);
+ extern struct ddi_device	*ddi_map(const char *id);
+ 
+ 
+ #endif	/* _LINUX_DDI_H */
diff -c --recursive --new-file std/include/linux/fs.h linux/include/linux/fs.h
*** std/include/linux/fs.h	Thu Apr 22 10:06:20 1993
--- linux/include/linux/fs.h	Sat Apr 24 19:39:35 1993
***************
*** 21,31 ****
   * recompiled to take full advantage of the new limits..
   */
  #undef NR_OPEN
! #define NR_OPEN 256	/* don't change - fd_set etc depend on this */
  
! #define NR_INODE 256	/* this should be bigger than NR_FILE */
! #define NR_FILE 128	/* this can well be larger on a larger system */
! #define NR_SUPER 16
  #define NR_HASH 997
  #define NR_FILE_LOCKS 32
  #define BLOCK_SIZE 1024
--- 21,31 ----
   * recompiled to take full advantage of the new limits..
   */
  #undef NR_OPEN
! #define NR_OPEN 256
  
! #define NR_INODE 1024	/* changed for LINUX/Pro - FvK */
! #define NR_FILE	512	/* changed for LINUX/Pro - FvK */
! #define NR_SUPER 32	/* changed for LINUX/Pro - FvK */
  #define NR_HASH 997
  #define NR_FILE_LOCKS 32
  #define BLOCK_SIZE 1024
diff -c --recursive --new-file std/include/linux/icmp.h linux/include/linux/icmp.h
*** std/include/linux/icmp.h
--- linux/include/linux/icmp.h	Sat Apr 24 19:39:35 1993
***************
*** 0 ****
--- 1,69 ----
+ /*
+  * INET		An implementation of the TCP/IP protocol suite for the LINUX
+  *		operating system.  INET is implemented using the  BSD Socket
+  *		interface as the means of communication with the user level.
+  *
+  *		Definitions for the ICMP protocol.
+  *
+  * Version:	@(#)icmp.h	1.0.1	03/21/93
+  *
+  * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+  *
+  *		This program is free software; you can redistribute it and/or
+  *		modify it under the terms of the GNU General Public License
+  *		as published by the Free Software Foundation; either version
+  *		2 of the License, or (at your option) any later version.
+  */
+ #ifndef _LINUX_ICMP_H
+ #define	_LINUX_ICMP_H
+ 
+ #define ICMP_ECHOREPLY		0
+ #define ICMP_DEST_UNREACH	3
+ #define ICMP_SOURCE_QUENCH	4
+ #define ICMP_REDIRECT		5
+ #define ICMP_ECHO		8
+ #define ICMP_TIME_EXCEEDED     11
+ #define ICMP_PARAMETERPROB     12
+ #define ICMP_TIMESTAMP	       13
+ #define ICMP_TIMESTAMPREPLY    14
+ #define ICMP_INFO_REQUEST      15
+ #define ICMP_INFO_REPLY	       16
+ 
+ 
+ /* Used by unreachable. */
+ #define ICMP_NET_UNREACH	0
+ #define ICMP_HOST_UNREACH	1
+ #define ICMP_PROT_UNREACH	2
+ #define ICMP_PORT_UNREACH	3 /* lots of room for confusion. */
+ #define ICMP_FRAG_NNEDED	4
+ #define ICMP_SR_FAILED		5
+ #define ICMP_NET_UNKNOWN	6
+ #define ICMP_HOST_UNKNOWN	7
+ #define ICMP_HOST_ISOLATED	8
+ #define ICMP_NET_ANO		9
+ #define ICMP_HOST_ANO	       10
+ #define ICMP_NET_UNR_TOS       11
+ #define ICMP_HOST_UNR_TOS      12
+ 
+ 
+ struct icmp_header {
+   unsigned char		type;
+   unsigned char		code;
+   unsigned short	checksum;
+   union {
+ 	struct {
+ 		unsigned short	id;
+ 		unsigned short	sequence;
+ 	} echo;
+ 	unsigned long gateway;
+   } un;
+ };
+ 
+ 
+ struct icmp_err {
+   int		errno;
+   unsigned	fatal:1;
+ };
+ 
+ 
+ #endif	/* _LINUX_ICMP_H */
diff -c --recursive --new-file std/include/linux/if.h linux/include/linux/if.h
*** std/include/linux/if.h
--- linux/include/linux/if.h	Sat Apr 24 19:39:35 1993
***************
*** 0 ****
--- 1,147 ----
+ /*
+  * INET		An implementation of the TCP/IP protocol suite for the LINUX
+  *		operating system.  INET is implemented using the  BSD Socket
+  *		interface as the means of communication with the user level.
+  *
+  *		Global definitions for the INET interface module.
+  *
+  * Version:	@(#)if.h	1.0.2	04/18/93
+  *
+  * Authors:	Original taken from Berkeley UNIX 4.3, (c) UCB 1982-1988
+  *		Ross Biro, <bir7@leland.Stanford.Edu>
+  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+  *
+  *		This program is free software; you can redistribute it and/or
+  *		modify it under the terms of the GNU General Public License
+  *		as published by the Free Software Foundation; either version
+  *		2 of the License, or (at your option) any later version.
+  */
+ #ifndef _LINUX_IF_H
+ #define _LINUX_IF_H
+ 
+ #include <linux/types.h>		/* for "caddr_t" et al		*/
+ #include <linux/socket.h>		/* for "struct sockaddr" et al	*/
+ 
+ 
+ /* Structure defining a queue for a network interface. */
+ struct ifnet {
+   char		*if_name;		/* name, e.g. ``en'' or ``lo''	*/
+   short		if_unit;		/* sub-unit for device driver	*/
+   short		if_mtu;			/* maximum transmission unit	*/
+   short		if_flags;		/* up/down, broadcast, etc.	*/
+   short		if_timer;		/* time 'til if_watchdog called	*/
+   int		if_metric;		/* routing metric (not used)	*/
+   struct	ifaddr *if_addrlist;	/* linked list of addrs per if	*/
+   struct	ifqueue {
+ #ifdef not_yet_in_linux
+ 	struct mbuf	*ifq_head;
+ 	struct mbuf	*ifq_tail;
+ 	int		ifq_len;
+ 	int		ifq_maxlen;
+ 	int		ifq_drops;
+ #endif
+   } if_snd;				/* output queue			*/
+ 
+   /* Procedure handles. */
+   int		(*if_init)();		/* init routine			*/
+   int		(*if_output)();		/* output routine		*/
+   int		(*if_ioctl)();		/* ioctl routine		*/
+   int		(*if_reset)();		/* bus reset routine		*/
+   int		(*if_watchdog)();	/* timer routine		*/
+ 
+   /* Generic interface statistics. */
+   int		if_ipackets;		/* packets recv'd on interface	*/
+   int		if_ierrors;		/* input errors on interface	*/
+   int		if_opackets;		/* packets sent on interface	*/
+   int		if_oerrors;		/* output errors on interface	*/
+   int		if_collisions;		/* collisions on CSMA i'faces	*/
+ 
+   /* Linked list: pointer to next interface. */
+   struct ifnet	*if_next;
+ };
+ 
+ /* Standard interface flags. */
+ #define	IFF_UP		0x1		/* interface is up		*/
+ #define	IFF_BROADCAST	0x2		/* broadcast address valid	*/
+ #define	IFF_DEBUG	0x4		/* turn on debugging		*/
+ #define	IFF_LOOPBACK	0x8		/* is a loopback net		*/
+ #define	IFF_POINTOPOINT	0x10		/* interface is has p-p link	*/
+ #define	IFF_NOTRAILERS	0x20		/* avoid use of trailers	*/
+ #define	IFF_RUNNING	0x40		/* resources allocated		*/
+ #define	IFF_NOARP	0x80		/* no ARP protocol		*/
+ 
+ /* These are not yet used: */
+ #define	IFF_PROMISC	0x100		/* recve all packets		*/
+ #define	IFF_ALLMULTI	0x200		/* recve all multicast packets	*/
+ 
+ 
+ /*
+  * The ifaddr structure contains information about one address
+  * of an interface.  They are maintained by the different address
+  * families, are allocated and attached when an address is set,
+  * and are linked together so all addresses for an interface can
+  * be located.
+  */
+ struct ifaddr {
+   struct sockaddr	ifa_addr;	/* address of interface		*/
+   union {
+ 	struct sockaddr	ifu_broadaddr;
+ 	struct sockaddr	ifu_dstaddr;
+   } ifa_ifu;
+   struct iface		*ifa_ifp;	/* back-pointer to interface	*/
+   struct ifaddr		*ifa_next;	/* next address for interface	*/
+ };
+ #define	ifa_broadaddr	ifa_ifu.ifu_broadaddr	/* broadcast address	*/
+ #define	ifa_dstaddr	ifa_ifu.ifu_dstaddr	/* other end of link	*/
+ 
+ /*
+  * Interface request structure used for socket
+  * ioctl's.  All interface ioctl's must have parameter
+  * definitions which begin with ifr_name.  The
+  * remainder may be interface specific.
+  */
+ struct ifreq {
+ #define	IFNAMSIZ	16
+ 	char	ifr_name[IFNAMSIZ];		/* if name, e.g. "en0" */
+ 	union {
+ 		struct	sockaddr ifru_addr;
+ 		struct	sockaddr ifru_dstaddr;
+ 		struct	sockaddr ifru_broadaddr;
+ 		struct	sockaddr ifru_netmask;
+ 		short	ifru_flags;
+ 		int	ifru_metric;
+ 		int	ifru_mtu;
+ 		caddr_t	ifru_data;
+ 	} ifr_ifru;
+ };
+ #define	ifr_addr	ifr_ifru.ifru_addr	/* address		*/
+ #define	ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-p lnk	*/
+ #define	ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address	*/
+ #define	ifr_netmask	ifr_ifru.ifru_netmask	/* interface net mask	*/
+ #define	ifr_flags	ifr_ifru.ifru_flags	/* flags		*/
+ #define	ifr_metric	ifr_ifru.ifru_metric	/* metric		*/
+ #define	ifr_mtu		ifr_ifru.ifru_mtu	/* mtu			*/
+ #define	ifr_data	ifr_ifru.ifru_data	/* for use by interface	*/
+ 
+ /*
+  * Structure used in SIOCGIFCONF request.
+  * Used to retrieve interface configuration
+  * for machine (useful for programs which
+  * must know all networks accessible).
+  */
+ struct ifconf {
+ 	int	ifc_len;			/* size of buffer	*/
+ 	union {
+ 		caddr_t	ifcu_buf;
+ 		struct	ifreq *ifcu_req;
+ 	} ifc_ifcu;
+ };
+ #define	ifc_buf	ifc_ifcu.ifcu_buf		/* buffer address	*/
+ #define	ifc_req	ifc_ifcu.ifcu_req		/* array of structures	*/
+ 
+ 
+ /* BSD UNIX expects to find these here, so here we go: */
+ #include <linux/if_arp.h>
+ #include <linux/route.h>
+ 
+ #endif /* _NET_IF_H */
diff -c --recursive --new-file std/include/linux/if_arp.h linux/include/linux/if_arp.h
*** std/include/linux/if_arp.h
--- linux/include/linux/if_arp.h	Sat Apr 24 19:39:35 1993
***************
*** 0 ****
--- 1,83 ----
+ /*
+  * INET		An implementation of the TCP/IP protocol suite for the LINUX
+  *		operating system.  INET is implemented using the  BSD Socket
+  *		interface as the means of communication with the user level.
+  *
+  *		Global definitions for the ARP (RFC 826) protocol.
+  *
+  * Version:	@(#)if_arp.h	1.0.1	04/16/93
+  *
+  * Authors:	Original taken from Berkeley UNIX 4.3, (c) UCB 1986-1988
+  *		Portions taken from the KA9Q/NOS (v2.00m PA0GRI) source.
+  *		Ross Biro, <bir7@leland.Stanford.Edu>
+  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+  *
+  *		This program is free software; you can redistribute it and/or
+  *		modify it under the terms of the GNU General Public License
+  *		as published by the Free Software Foundation; either version
+  *		2 of the License, or (at your option) any later version.
+  */
+ #ifndef _LINUX_IF_ARP_H
+ #define _LINUX_IF_ARP_H
+ 
+ /* ARP protocol HARDWARE identifiers. */
+ #define ARPHRD_NETROM	0		/* from KA9Q: NET/ROM pseudo	*/
+ #define ARPHRD_ETHER 	1		/* Ethernet 10Mbps		*/
+ #define	ARPHRD_EETHER	2		/* Experimental Ethernet	*/
+ #define	ARPHRD_AX25	3		/* AX.25 Level 2		*/
+ #define	ARPHRD_PRONET	4		/* PROnet token ring		*/
+ #define	ARPHRD_CHAOS	5		/* Chaosnet			*/
+ #define	ARPHRD_IEEE802	6		/* IEEE 802.2 Ethernet- huh?	*/
+ #define	ARPHRD_ARCNET	7		/* ARCnet			*/
+ #define	ARPHRD_APPLETLK	8		/* APPLEtalk			*/
+ 
+ /* ARP protocol opcodes. */
+ #define	ARPOP_REQUEST	1		/* ARP request			*/
+ #define	ARPOP_REPLY	2		/* ARP reply			*/
+ #define	ARPOP_RREQUEST	3		/* RARP request			*/
+ #define	ARPOP_RREPLY	4		/* RARP reply			*/
+ 
+ 
+ /*
+  * Address Resolution Protocol.
+  *
+  * See RFC 826 for protocol description.  ARP packets are variable
+  * in size; the arphdr structure defines the fixed-length portion.
+  * Protocol type values are the same as those for 10 Mb/s Ethernet.
+  * It is followed by the variable-sized fields ar_sha, arp_spa,
+  * arp_tha and arp_tpa in that order, according to the lengths
+  * specified.  Field names used correspond to RFC 826.
+  */
+ struct arphdr {
+   unsigned short	ar_hrd;		/* format of hardware address	*/
+   unsigned short	ar_pro;		/* format of protocol address	*/
+   unsigned char		ar_hln;		/* length of hardware address	*/
+   unsigned char		ar_pln;		/* length of protocol address	*/
+   unsigned short	ar_op;		/* ARP opcode (command)		*/
+ 
+   /* The rest is variable in size, according to the sizes above. */
+ #if 0
+   unsigned char		ar_sha[];	/* sender hardware address	*/
+   unsigned char		ar_spa[];	/* sender protocol address	*/
+   unsigned char		ar_tha[];	/* target hardware address	*/
+   unsigned char		ar_tpa[];	/* target protocol address	*/
+ #endif	/* not actually included! */
+ };
+ 
+ 
+ /* ARP ioctl request. */
+ struct arpreq {
+   struct sockaddr	arp_pa;		/* protocol address		*/
+   struct sockaddr	arp_ha;		/* hardware address		*/
+   int			arp_flags;	/* flags			*/
+ };
+ 
+ /* ARP Flag values. */
+ #define	ATF_INUSE	0x01		/* entry in use			*/
+ #define ATF_COM		0x02		/* completed entry (ha valid)	*/
+ #define	ATF_PERM	0x04		/* permanent entry		*/
+ #define	ATF_PUBL	0x08		/* publish entry		*/
+ #define	ATF_USETRAILERS	0x10		/* has requested trailers	*/
+ 
+ 
+ #endif	/* _LINUX_IF_ARP_H */
diff -c --recursive --new-file std/include/linux/if_ether.h linux/include/linux/if_ether.h
*** std/include/linux/if_ether.h
--- linux/include/linux/if_ether.h	Sat Apr 24 19:39:35 1993
***************
*** 0 ****
--- 1,88 ----
+ /*
+  * INET		An implementation of the TCP/IP protocol suite for the LINUX
+  *		operating system.  INET is implemented using the  BSD Socket
+  *		interface as the means of communication with the user level.
+  *
+  *		Global definitions for the Ethernet IEE 802.3 interface.
+  *
+  * Version:	@(#)if_ether.h	1.0.1	03/15/93
+  *
+  * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+  *
+  *		This program is free software; you can redistribute it and/or
+  *		modify it under the terms of the GNU General Public License
+  *		as published by the Free Software Foundation; either version
+  *		2 of the License, or (at your option) any later version.
+  */
+ #ifndef _LINUX_IF_ETHER_H
+ #define _LINUX_IF_ETHER_H
+ 
+ 
+ /* IEEE 802.3 Ethernet magic constants. */
+ #define ETH_ALEN	6		/* #bytes in eth addr		*/
+ #define ETH_HLEN	14		/* #bytes in eth header		*/
+ #define ETH_ZLEN	64		/* min #bytes in frame		*/
+ #define ETH_FLEN	1536		/* max #bytes in frame		*/
+ #define ETH_DLEN	(ETH_FLEN - ETH_HLEN)	/* max #bytes of data	*/
+ 
+ /* These are the defined Ethernet Protocol ID's. */
+ #define ETH_P_LOOP	0x0060		/* Ethernet Loopback packet	*/
+ #define ETH_P_ECHO	0x0200		/* Ethernet Echo packet		*/
+ #define ETH_P_PUP	0x0400		/* Xerox PUP packet		*/
+ #define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
+ #define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
+ #define ETH_P_RARP      0x0835		/* Reverse Addr Res packet	*/
+ 
+ /* Define the Ethernet Broadcast Address (48 bits set to "1"). */
+ #define ETH_A_BCAST     "\377\377\377\377\377\377"
+ 
+ /* This is an Ethernet frame header. */
+ struct ethhdr {
+   unsigned char		h_dest[ETH_ALEN];	/* destination eth addr	*/
+   unsigned char		h_source[ETH_ALEN];	/* source ether addr	*/
+   unsigned short	h_proto;		/* packet type ID field	*/
+ };
+ 
+ /* This is the complete Ethernet frame. */
+ struct ethframe {
+   struct ethhdr		f_hdr;			/* frame header		*/
+   char			f_data[ETH_DLEN];	/* frame data (variable)*/
+ };
+ 
+ 
+ /* Receiver modes */
+ #define ETH_MODE_MONITOR	1	/* Monitor mode - no receive	*/
+ #define ETH_MODE_PHYS		2	/* Physical address receive only */
+ #define ETH_MODE_BCAST		3	/* Broadcast receive + mode 2	*/
+ #define ETH_MODE_MCAST		4	/* Multicast receive + mode 3	*/
+ #define ETH_MODE_PROMISC	5	/* Promiscuous mode - receive all */
+ 
+ 
+ /* Ethernet statistics collection data. */
+ struct enet_statistics{
+   int	rx_packets;			/* total packets received	*/
+   int	tx_packets;			/* total packets transmitted	*/
+   int	rx_errors;			/* bad packets received		*/
+   int	tx_errors;			/* packet transmit problems	*/
+   int	rx_dropped;			/* no space in linux buffers	*/
+   int	tx_dropped;			/* no space available in linux	*/
+   int	multicast;			/* multicast packets received	*/
+   int	collisions;
+ 
+   /* detailed rx_errors: */
+   int	rx_length_errors;
+   int	rx_over_errors;			/* receiver ring buff overflow	*/
+   int	rx_crc_errors;			/* recved pkt with crc error	*/
+   int	rx_frame_errors;		/* recv'd frame alignment error */
+   int	rx_fifo_errors;			/* recv'r fifo overrun		*/
+   int	rx_missed_errors;		/* receiver missed packet	*/
+ 
+   /* detailed tx_errors */
+   int	tx_aborted_errors;
+   int	tx_carrier_errors;
+   int	tx_fifo_errors;
+   int	tx_heartbeat_errors;
+   int	tx_window_errors;
+ };
+ 
+ #endif	/* _LINUX_IF_ETHER_H */
diff -c --recursive --new-file std/include/linux/in.h linux/include/linux/in.h
*** std/include/linux/in.h
--- linux/include/linux/in.h	Sat Apr 24 19:39:35 1993
***************
*** 0 ****
--- 1,171 ----
+ /*
+  * INET		An implementation of the TCP/IP protocol suite for the LINUX
+  *		operating system.  INET is implemented using the  BSD Socket
+  *		interface as the means of communication with the user level.
+  *
+  *		Definitions of the Internet Protocol.
+  *
+  * Version:	@(#)in.h	1.0.1	04/21/93
+  *
+  * Authors:	Original taken from the GNU Project <netinet/in.h> file.
+  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+  *
+  *		This program is free software; you can redistribute it and/or
+  *		modify it under the terms of the GNU General Public License
+  *		as published by the Free Software Foundation; either version
+  *		2 of the License, or (at your option) any later version.
+  */
+ #ifndef _LINUX_IN_H
+ #define _LINUX_IN_H
+ 
+ 
+ /* Standard well-defined IP protocols.  */
+ enum {
+   IPPROTO_IP = 0,		/* Dummy protocol for TCP		*/
+   IPPROTO_ICMP = 1,		/* Internet Control Message Protocol	*/
+   IPPROTO_GGP = 2,		/* Gateway Protocol (deprecated)	*/
+   IPPROTO_TCP = 6,		/* Transmission Control Protocol	*/
+   IPPROTO_EGP = 8,		/* Exterior Gateway Protocol		*/
+   IPPROTO_PUP = 12,		/* PUP protocol				*/
+   IPPROTO_UDP = 17,		/* User Datagram Protocol		*/
+   IPPROTO_IDP = 22,		/* XNS IDP protocol			*/
+ 
+   IPPROTO_RAW = 255,		/* Raw IP packets			*/
+   IPPROTO_MAX
+ };
+ 
+ 
+ /* Internet address. */
+ struct in_addr {
+ 	unsigned long int	s_addr;
+ };
+ 
+ 
+ /* Structure describing an Internet (IP) socket address. */
+ #define __SOCK_SIZE__	16		/* sizeof(struct sockaddr)	*/
+ struct sockaddr_in {
+   short int		sin_family;	/* Address family		*/
+   unsigned short int	sin_port;	/* Port number			*/
+   struct in_addr	sin_addr;	/* Internet address		*/
+ 
+   /* Pad to size of `struct sockaddr'. */
+   unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) -
+ 			sizeof(unsigned short int) - sizeof(struct in_addr)];
+ };
+ #define sin_zero	__pad		/* for BSD UNIX comp. -FvK	*/
+ 
+ 
+ /*
+  * Definitions of the bits in an Internet address integer.
+  * On subnets, host and network parts are found according
+  * to the subnet mask, not these masks.
+  */
+ #define	IN_CLASSA(a)		((((long int) (a)) & 0x80000000) == 0)
+ #define	IN_CLASSA_NET		0xff000000
+ #define	IN_CLASSA_NSHIFT	24
+ #define	IN_CLASSA_HOST		(0xffffffff & ~IN_CLASSA_NET)
+ #define	IN_CLASSA_MAX		128
+ 
+ #define	IN_CLASSB(a)		((((long int) (a)) & 0xc0000000) == 0x80000000)
+ #define	IN_CLASSB_NET		0xffff0000
+ #define	IN_CLASSB_NSHIFT	16
+ #define	IN_CLASSB_HOST		(0xffffffff & ~IN_CLASSB_NET)
+ #define	IN_CLASSB_MAX		65536
+ 
+ #define	IN_CLASSC(a)		((((long int) (a)) & 0xc0000000) == 0xc0000000)
+ #define	IN_CLASSC_NET		0xffffff00
+ #define	IN_CLASSC_NSHIFT	8
+ #define	IN_CLASSC_HOST		(0xffffffff & ~IN_CLASSC_NET)
+ 
+ #define	IN_CLASSD(a)		((((long int) (a)) & 0xf0000000) = 0xe0000000)
+ #define	IN_MULTICAST(a)		IN_CLASSD(a)
+ 
+ #define	IN_EXPERIMENTAL(a)	((((long int) (a)) & 0xe0000000) = 0xe0000000)
+ #define	IN_BADCLASS(a)		((((long int) (a)) & 0xf0000000) = 0xf0000000)
+ 
+ /* Address to accept any incoming messages. */
+ #define	INADDR_ANY		((unsigned long int) 0x00000000)
+ 
+ /* Address to send to all hosts. */
+ #define	INADDR_BROADCAST	((unsigned long int) 0xffffffff)
+ 
+ /* Address indicating an error return. */
+ #define	INADDR_NONE		0xffffffff
+ 
+ /* Network number for local host loopback. */
+ #define	IN_LOOPBACKNET		127
+ 
+ /* Address to loopback in software to local host.  */
+ #define	INADDR_LOOPBACK		0x7f000001	/* 127.0.0.1		*/
+ 
+ 
+ /*
+  * Options for use with `getsockopt' and `setsockopt' at
+  * the IP level.  LINUX does not yet have the IP_OPTIONS
+  * option (grin), so we undefine it for now.- HJ && FvK
+  */
+ #if 0
+ # define IP_OPTIONS	1		/* IP per-packet options	*/
+ #endif
+ #define IP_HDRINCL	2		/* raw packet header option	*/
+ 
+ 
+ /* Linux Internet number representation function declarations. */
+ #undef ntohl
+ #undef ntohs
+ #undef htonl
+ #undef htons
+ 
+ extern unsigned long int	ntohl(unsigned long int);
+ extern unsigned short int	ntohs(unsigned short int);
+ extern unsigned long int	htonl(unsigned long int);
+ extern unsigned short int	htons(unsigned short int);
+ 
+ static __inline__ unsigned long int
+ __ntohl(unsigned long int x)
+ {
+   register unsigned long int tmp __asm__ ("ax") = x;
+   __asm__ __volatile__ ("xchgb %%al,%%ah\n\t"   /* swap lower bytes	*/
+ 		"rorl $16,%%eax\n\t"		/* swap words		*/
+ 		"xchgb %%al,%%ah\n\t"		/* swap higher bytes	*/
+ 		: "=a" (tmp) : "a" (tmp) );
+   return(tmp);
+ }
+ 
+ static __inline__ unsigned short int
+ __ntohs(unsigned short int x)
+ {
+   register unsigned short int tmp __asm__ ("ax") = x;
+   __asm__ __volatile__ ("xchgb %%al,%%ah\n\t"	/* swap bytes		*/
+ 		: "=a" (tmp) : "a" (tmp));
+   return(tmp);
+ }
+ 
+ static __inline__ unsigned long int
+ __htonl(unsigned long int x)
+ {
+   register unsigned long int tmp __asm__ ("ax") = x;
+   __asm__ __volatile__ ("xchgb %%al,%%ah\n\t"	/* swap lower bytes	*/
+ 		"rorl $16,%%eax\n\t"		/* swap words		*/
+ 		"xchgb %%al,%%ah\n\t"		/* swap higher bytes	*/
+ 		: "=a" (tmp) : "a" (tmp));
+   return(tmp);
+ }
+ 
+ static __inline__ unsigned short int
+ __htons(unsigned short int x)
+ {
+   register unsigned short int tmp __asm__ ("ax") = x;
+   __asm__ __volatile__ ("xchgb %%al,%%ah\n\t"   /* swap bytes */
+ 		: "=a" (tmp) : "a" (tmp));
+   return(tmp);
+ }
+ 
+ #ifdef  __OPTIMIZE__
+ #  define ntohl(x)	__ntohl((x))
+ #  define ntohs(x)	__ntohs((x))
+ #  define htonl(x)	__htonl((x))
+ #  define htons(x)	__htons((x))
+ #endif
+ 
+ #endif	/* _LINUX_IN_H */
diff -c --recursive --new-file std/include/linux/ip.h linux/include/linux/ip.h
*** std/include/linux/ip.h
--- linux/include/linux/ip.h	Sat Apr 24 19:39:35 1993
***************
*** 0 ****
--- 1,81 ----
+ /*
+  * INET		An implementation of the TCP/IP protocol suite for the LINUX
+  *		operating system.  INET is implemented using the  BSD Socket
+  *		interface as the means of communication with the user level.
+  *
+  *		Definitions for the IP protocol.
+  *
+  * Version:	@(#)ip.h	1.0.1	03/21/93
+  *
+  * Authors:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+  *
+  *		This program is free software; you can redistribute it and/or
+  *		modify it under the terms of the GNU General Public License
+  *		as published by the Free Software Foundation; either version
+  *		2 of the License, or (at your option) any later version.
+  */
+ #ifndef _LINUX_IP_H
+ #define _LINUX_IP_H
+ 
+ 
+ #define IPOPT_END	0
+ #define IPOPT_NOOP	1
+ #define IPOPT_SEC	130
+ #define IPOPT_LSRR	131
+ #define IPOPT_SSRR	137
+ #define IPOPT_RR	7
+ #define IPOPT_SID	136
+ #define IPOPT_TIMESTAMP	68
+ 
+ 
+ struct timestamp {
+   unsigned char	len;
+   unsigned char ptr;
+   union {
+ 	unsigned char	flags:4,
+ 			overflow:4;
+ 	unsigned char	full_char;
+   } x;
+   unsigned long	data[9];
+ };
+ 
+ 
+ #define MAX_ROUTE	16
+ 
+ struct route {
+   char		route_size;
+   char		pointer;
+   unsigned long route[MAX_ROUTE];
+ };
+ 
+ 
+ struct options {
+   struct route		record_route;
+   struct route		loose_route;
+   struct route		strict_route;
+   struct timestamp	tstamp;
+   unsigned short	security;
+   unsigned short	compartment;
+   unsigned short	handling;
+   unsigned short	stream;
+   unsigned		tcc;
+ };
+ 
+ 
+ struct ip_header {
+   unsigned char		ihl:4,
+ 			version:4;
+   unsigned char		tos;
+   unsigned short	tot_len;
+   unsigned short	id;
+   unsigned short	frag_off;
+   unsigned char		ttl;
+   unsigned char		protocol;
+   unsigned short	check;
+   unsigned long		saddr;
+   unsigned long		daddr;
+   /*The options start here. */
+ };
+ 
+ 
+ #endif	/* _LINUX_IP_H */
diff -c --recursive --new-file std/include/linux/net.h linux/include/linux/net.h
*** std/include/linux/net.h
--- linux/include/linux/net.h	Sat Apr 24 19:39:35 1993
***************
*** 0 ****
--- 1,130 ----
+ /*
+  * NET		An implementation of the SOCKET network access protocol.
+  *		This is the master header file for the Linux NET layer,
+  *		or, in plain English: the networking handling part of the
+  *		kernel.
+  *
+  * Version:	@(#)net.h	1.0.1	04/22/93
+  *
+  * Authors:	???
+  *		Ross Biro, <bir7@leland.Stanford.Edu>
+  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+  *
+  *		This program is free software; you can redistribute it and/or
+  *		modify it under the terms of the GNU General Public License
+  *		as published by the Free Software Foundation; either version
+  *		2 of the License, or (at your option) any later version.
+  */
+ #ifndef _LINUX_NET_H
+ #define _LINUX_NET_H
+ 
+ 
+ #define NSOCKETS	128		/* should be dynamic, later...	*/
+ #define NPROTO		16		/* should be enough for now..	*/
+ #define SOCKET_MAJOR	16		/* Linux VFS major dev number	*/
+ 
+ 
+ #define SYS_SOCKET	1		/* sys_socket(2)		*/
+ #define SYS_BIND	2		/* sys_bind(2)			*/
+ #define SYS_CONNECT	3		/* sys_connect(2)		*/
+ #define SYS_LISTEN	4		/* sys_listen(2)		*/
+ #define SYS_ACCEPT	5		/* sys_accept(2)		*/
+ #define SYS_GETSOCKNAME	6		/* sys_getsockname(2)		*/
+ #define SYS_GETPEERNAME	7		/* sys_getpeername(2)		*/
+ #define SYS_SOCKETPAIR	8		/* sys_socketpair(2)		*/
+ #define SYS_SEND	9		/* sys_send(2)			*/
+ #define SYS_RECV	10		/* sys_recv(2)			*/
+ #define SYS_SENDTO	11		/* sys_sendto(2)		*/
+ #define SYS_RECVFROM	12		/* sys_recvfrom(2)		*/
+ #define SYS_SHUTDOWN	13		/* sys_shutdown(2)		*/
+ #define SYS_SETSOCKOPT	14		/* sys_setsockopt(2)		*/
+ #define SYS_GETSOCKOPT	15		/* sys_getsockopt(2)		*/
+ 
+ 
+ typedef enum {
+   SS_FREE = 0,				/* not allocated		*/
+   SS_UNCONNECTED,			/* unconnected to any socket	*/
+   SS_CONNECTING,			/* in process of connecting	*/
+   SS_CONNECTED,				/* connected to socket		*/
+   SS_DISCONNECTING,			/* in process of disconnecting	*/
+ } socket_state;
+ 
+ #define SO_ACCEPTCON	(1<<16)		/* performed a listen		*/
+ 
+ 
+ /*
+  * Internel representation of a socket. not all the fields are used by
+  * all configurations:
+  *
+  *		server			client
+  * conn		client connected to	server connected to
+  * iconn	list of clients		-unused-
+  *		 awaiting connections
+  * wait		sleep for clients,	sleep for connection,
+  *		sleep for i/o		sleep for i/o
+  */
+ struct socket {
+   short			type;		/* SOCK_STREAM, ...		*/
+   socket_state		state;
+   long			flags;
+   struct proto_ops	*ops;		/* protocols do most everything	*/
+   void			*data;		/* protocol data		*/
+   struct socket		*conn;		/* server socket connected to	*/
+   struct socket		*iconn;		/* incomplete client conn.s	*/
+   struct socket		*next;
+   struct wait_queue	**wait;		/* ptr to place to wait on	*/
+   void			*dummy;
+ };
+ 
+ #define SOCK_INODE(S)	((struct inode *)(S)->dummy)
+ extern struct socket	sockets[NSOCKETS];
+ #define last_socket	(sockets + NSOCKETS - 1)
+ 
+ 
+ struct proto_ops {
+   int	family;
+ 
+   int	(*create)	(struct socket *sock, int protocol);
+   int	(*dup)		(struct socket *newsock, struct socket *oldsock);
+   int	(*release)	(struct socket *sock, struct socket *peer);
+   int	(*bind)		(struct socket *sock, struct sockaddr *umyaddr,
+ 			 int sockaddr_len);
+   int	(*connect)	(struct socket *sock, struct sockaddr *uservaddr,
+ 			 int sockaddr_len, int flags);
+   int	(*socketpair)	(struct socket *sock1, struct socket *sock2);
+   int	(*accept)	(struct socket *sock, struct socket *newsock,
+ 			 int flags);
+   int	(*getname)	(struct socket *sock, struct sockaddr *uaddr,
+ 			 int *usockaddr_len, int peer);
+   int	(*read)		(struct socket *sock, char *ubuf, int size,
+ 			 int nonblock);
+   int	(*write)	(struct socket *sock, char *ubuf, int size,
+ 			 int nonblock);
+   int	(*select)	(struct socket *sock, int sel_type,
+ 			 select_table *wait);
+   int	(*ioctl)	(struct socket *sock, unsigned int cmd,
+ 			 unsigned long arg);
+   int	(*listen)	(struct socket *sock, int len);
+   int	(*send)		(struct socket *sock, void *buff, int len, int nonblock,
+ 			 unsigned flags);
+   int	(*recv)		(struct socket *sock, void *buff, int len, int nonblock,
+ 			 unsigned flags);
+   int	(*sendto)	(struct socket *sock, void *buff, int len, int nonblock,
+ 			 unsigned flags, struct sockaddr *, int addr_len);
+   int	(*recvfrom)	(struct socket *sock, void *buff, int len, int nonblock,
+ 			 unsigned flags, struct sockaddr *, int *addr_len);
+   int	(*shutdown)	(struct socket *sock, int flags);
+   int	(*setsockopt)	(struct socket *sock, int level, int optname,
+ 			 char *optval, int optlen);
+   int	(*getsockopt)	(struct socket *sock, int level, int optname,
+ 			 char *optval, int *optlen);
+   int	(*fcntl)	(struct socket *sock, unsigned int cmd,
+ 			 unsigned long arg);	
+ };
+ 
+ 
+ extern int	sock_awaitconn(struct socket *mysock, struct socket *servsock);
+ extern int	sock_register(int family, struct proto_ops *ops);
+ 
+ 
+ #endif	/* _LINUX_NET_H */
diff -c --recursive --new-file std/include/linux/nfs_fs.h linux/include/linux/nfs_fs.h
*** std/include/linux/nfs_fs.h	Tue Apr  6 20:57:21 1993
--- linux/include/linux/nfs_fs.h	Sat Apr 24 19:39:35 1993
***************
*** 11,17 ****
  
  #include <linux/nfs.h>
  
! #include <netinet/in.h>
  #include <linux/nfs_mount.h>
  
  /*
--- 11,17 ----
  
  #include <linux/nfs.h>
  
! #include <linux/in.h>
  #include <linux/nfs_mount.h>
  
  /*
diff -c --recursive --new-file std/include/linux/proc_fs.h linux/include/linux/proc_fs.h
*** std/include/linux/proc_fs.h	Tue Apr  6 20:57:21 1993
--- linux/include/linux/proc_fs.h	Sat Apr 24 19:39:35 1993
***************
*** 25,34 ****
--- 25,36 ----
  
  extern struct inode_operations proc_root_inode_operations;
  extern struct inode_operations proc_base_inode_operations;
+ extern struct inode_operations proc_net_inode_operations;
  extern struct inode_operations proc_mem_inode_operations;
  extern struct inode_operations proc_array_inode_operations;
  extern struct inode_operations proc_kmsg_inode_operations;
  extern struct inode_operations proc_link_inode_operations;
  extern struct inode_operations proc_fd_inode_operations;
+ extern struct inode_operations proc_net_inode_operations;
  
  #endif
diff -c --recursive --new-file std/include/linux/route.h linux/include/linux/route.h
*** std/include/linux/route.h
--- linux/include/linux/route.h	Sat Apr 24 19:39:36 1993
***************
*** 0 ****
--- 1,49 ----
+ /*
+  * INET		An implementation of the TCP/IP protocol suite for the LINUX
+  *		operating system.  INET is implemented using the  BSD Socket
+  *		interface as the means of communication with the user level.
+  *
+  *		Global definitions for the IP router interface.
+  *
+  * Version:	@(#)route.h	1.0.2	04/16/93
+  *
+  * Authors:	Original taken from Berkeley UNIX 4.3, (c) UCB 1986-1988
+  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+  *
+  *		This program is free software; you can redistribute it and/or
+  *		modify it under the terms of the GNU General Public License
+  *		as published by the Free Software Foundation; either version
+  *		2 of the License, or (at your option) any later version.
+  */
+ #ifndef _LINUX_ROUTE_H
+ #define _LINUX_ROUTE_H
+ 
+ #include <linux/if.h>
+ 
+ 
+ /*
+  * This structure gets passed by the SIOCADDRT and SIOCDELRT calls.
+  * It is not exactly identical to the BSD UNIX version of "rtentry",
+  * because BSD used /dev/kmem to figure out interface addresses. We
+  * do it cleaner, using a character array to stuff the name into.
+  * Also, to clean up things, the real IP routing table does not use
+  * the "struct sockaddr" addresses- it uses simple "unsigned long"
+  * fields.  Routing is a protocol-dependent thing anyway. -FvK
+  */
+ struct rtentry {
+   char			rt_dev[IFNAMSIZ];
+   struct sockaddr	rt_dst;
+   struct sockaddr	rt_gateway;
+   u_char		rt_flags;
+   u_char		rt_metric;
+   short			rt_refcnt;
+   unsigned long		rt_use;
+ };
+ #define	RTF_UP		0x0001		/* route useable		*/
+ #define	RTF_GATEWAY	0x0002		/* destination is a gateway	*/
+ #define	RTF_HOST	0x0004		/* host entry (net otherwise)	*/
+ #define RTF_REINSTATE	0x0008		/* re-instate route after tmout	*/
+ #define	RTF_DYNAMIC	0x0010		/* created dyn. (by redirect)	*/
+ #define	RTF_MODIFIED	0x0020		/* modified dyn. (by redirect)	*/
+ 
+ #endif	/* _LINUX_ROUTE_H */
diff -c --recursive --new-file std/include/linux/sock_ioctl.h linux/include/linux/sock_ioctl.h
*** std/include/linux/sock_ioctl.h	Sun Feb 28 14:59:14 1993
--- linux/include/linux/sock_ioctl.h	Sat Apr 24 19:39:36 1993
***************
*** 1,35 ****
- #ifndef _LINUX_SOCK_IOCTL_H
- #define _LINUX_SOCK_IOCTL_H
- 
- #define MAX_IP_NAME 20
- /* some ioctl.  Their values are not special. */
- #define IP_SET_DEV 0x2401
- 
- struct ip_config
- {
-    char name[MAX_IP_NAME];
-    unsigned long paddr;
-    unsigned long router;
-    unsigned long net;
-    unsigned long up:1,destroy:1;
- };
- 
- #define SIOCSARP	0x2501
- #define SIOCGARP	0x2502
- #define SIOCDARP	0x2503
- 
- /*
-  * ARP ioctl request
-  */
- struct arpreq {
- 	struct	sockaddr arp_pa;		/* protocol address */
- 	struct	sockaddr arp_ha;		/* hardware address */
- 	int	arp_flags;			/* flags */
- };
- 
- #define ATF_COM		0x02
- #define ATF_PERM	0x04
- #define ATF_PUBL	0x08
- #define ATF_USETRAILERS	0x10
- 
- #endif
--- 0 ----
diff -c --recursive --new-file std/include/linux/socket.h linux/include/linux/socket.h
*** std/include/linux/socket.h	Tue Nov 10 12:54:55 1992
--- linux/include/linux/socket.h	Sat Apr 24 19:39:36 1993
***************
*** 1,51 ****
  #ifndef _LINUX_SOCKET_H
  #define _LINUX_SOCKET_H
  
  struct sockaddr {
! 	unsigned short sa_family;	/* address family, AF_xxx */
! 	char sa_data[14];		/* 14 bytes of protocol address */
  };
  
! /*
!  * socket types
!  */
! #define SOCK_STREAM	1		/* stream (connection) socket */
! #define SOCK_DGRAM	2		/* datagram (connectionless) socket */
! #define SOCK_RAW	3		/* raw socket */
! #define SOCK_RDM	4		/* reliably-delivered message */
! #define SOCK_SEQPACKET	5		/* sequential packet socket */
! #define SOCK_PACKET    10		/* linux specific way of getting
! 					   packets at the dev level.  For
! 					   writing rarp and other similiar
! 					   things on the user level. */
! 
! /*
!  * supported address families
!  */
  #define AF_UNSPEC	0
  #define AF_UNIX		1
  #define AF_INET		2
  
! /*
!  * protocol families, same as address families
!  */
  #define PF_UNIX		AF_UNIX
  #define PF_INET		AF_INET
  
! /* flags we can use with send/ and recv. */
  #define MSG_OOB		1
  #define MSG_PEEK	2
  
! /* ioctl's */
! #define FIOSETOWN 	0x8901	 /* the 89 is for uniqueness.
! 				    This should be somewhere else. */
! #define SIOCSPGRP	0x8902
! #define FIOGETOWN	0x8903   /* this too. */
! #define SIOCGPGRP	0x8904
! #define SIOCATMARK	0x8905
! 
  
! /* for setsockoptions */
  #define SO_DEBUG	1
  #define SO_REUSEADDR	2
  #define SO_TYPE		3
--- 1,43 ----
  #ifndef _LINUX_SOCKET_H
  #define _LINUX_SOCKET_H
  
+ #include <linux/sockios.h>		/* the SIOCxxx I/O controls	*/
+ 
+ 
  struct sockaddr {
!   unsigned short	sa_family;	/* address family, AF_xxx	*/
!   char			sa_data[14];	/* 14 bytes of protocol address	*/
  };
  
! /* Socket types. */
! #define SOCK_STREAM	1		/* stream (connection) socket	*/
! #define SOCK_DGRAM	2		/* datagram (conn.less) socket	*/
! #define SOCK_RAW	3		/* raw socket			*/
! #define SOCK_RDM	4		/* reliably-delivered message	*/
! #define SOCK_SEQPACKET	5		/* sequential packet socket	*/
! #define SOCK_PACKET	10		/* linux specific way of	*/
! 					/* getting packets at the dev	*/
! 					/* level.  For writing rarp and	*/
! 					/* other similiar things on the	*/
! 					/* user level.			*/
! 
! /* Supported address families. */
  #define AF_UNSPEC	0
  #define AF_UNIX		1
  #define AF_INET		2
  
! /* Protocol families, same as address families. */
  #define PF_UNIX		AF_UNIX
  #define PF_INET		AF_INET
  
! /* Flags we can use with send/ and recv. */
  #define MSG_OOB		1
  #define MSG_PEEK	2
  
! /* Setsockoptions(2) level. */
! #define SOL_SOCKET	1
  
! /* For setsockoptions(2) */
  #define SO_DEBUG	1
  #define SO_REUSEADDR	2
  #define SO_TYPE		3
***************
*** 55,71 ****
  #define SO_SNDBUF	7
  #define SO_RCVBUF	8
  #define SO_KEEPALIVE	9
! #define SO_OOBINLINE   10
! #define SO_NO_CHECK    11
! #define SO_PRIORITY    12
! #define SO_LINGER      13
  
! /* the different priorities */
  #define SOPRI_INTERACTIVE	0
  #define SOPRI_NORMAL		1
  #define SOPRI_BACKGROUND	2
  
- /* setsockoptions level */
- #define SOL_SOCKET	1
- 
  #endif /* _LINUX_SOCKET_H */
--- 47,60 ----
  #define SO_SNDBUF	7
  #define SO_RCVBUF	8
  #define SO_KEEPALIVE	9
! #define SO_OOBINLINE	10
! #define SO_NO_CHECK	11
! #define SO_PRIORITY	12
! #define SO_LINGER	13
  
! /* The various priorities. */
  #define SOPRI_INTERACTIVE	0
  #define SOPRI_NORMAL		1
  #define SOPRI_BACKGROUND	2
  
  #endif /* _LINUX_SOCKET_H */
diff -c --recursive --new-file std/include/linux/sockios.h linux/include/linux/sockios.h
*** std/include/linux/sockios.h
--- linux/include/linux/sockios.h	Sat Apr 24 19:39:36 1993
***************
*** 0 ****
--- 1,72 ----
+ /*
+  * INET		An implementation of the TCP/IP protocol suite for the LINUX
+  *		operating system.  INET is implemented using the  BSD Socket
+  *		interface as the means of communication with the user level.
+  *
+  *		Definitions of the socket-level I/O control calls.
+  *
+  * Version:	@(#)sockios.h	1.0.2	03/09/93
+  *
+  * Authors:	Ross Biro, <bir7@leland.Stanford.Edu>
+  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+  *
+  *		This program is free software; you can redistribute it and/or
+  *		modify it under the terms of the GNU General Public License
+  *		as published by the Free Software Foundation; either version
+  *		2 of the License, or (at your option) any later version.
+  */
+ #ifndef _LINUX_SOCKIOS_H
+ #define _LINUX_SOCKIOS_H
+ 
+ /* This section will go away soon! */
+ #if 1	/* FIXME: */
+ #define MAX_IP_NAME	20
+ #define IP_SET_DEV	0x2401
+ 
+ struct ip_config {
+   char		name[MAX_IP_NAME];
+   unsigned long	paddr;
+   unsigned long	router;
+   unsigned long	net;
+   unsigned long	up:1,destroy:1;
+ };
+ #endif	/* FIXME: */
+ 
+ /* Socket-level I/O control calls. */
+ #define FIOSETOWN 	0x8901
+ #define SIOCSPGRP	0x8902
+ #define FIOGETOWN	0x8903
+ #define SIOCGPGRP	0x8904
+ #define SIOCATMARK	0x8905
+ 
+ /* Socket configuration controls. */
+ #define SIOCGIFNAME	0x8910		/* get iface name		*/
+ #define SIOCSIFLINK	0x8911		/* set iface channel		*/
+ #define SIOCGIFCONF	0x8912		/* get iface list		*/
+ #define SIOCGIFFLAGS	0x8913		/* get flags			*/
+ #define SIOCSIFFLAGS	0x8914		/* set flags			*/
+ #define SIOCGIFADDR	0x8915		/* get PA address		*/
+ #define SIOCSIFADDR	0x8916		/* set PA address		*/
+ #define SIOCGIFDSTADDR	0x8917		/* get remote PA address	*/
+ #define SIOCSIFDSTADDR	0x8918		/* set remote PA address	*/
+ #define SIOCGIFBRDADDR	0x8919		/* get broadcast PA address	*/
+ #define SIOCSIFBRDADDR	0x891a		/* set broadcast PA address	*/
+ #define SIOCGIFNETMASK	0x891b		/* get network PA mask		*/
+ #define SIOCSIFNETMASK	0x891c		/* set network PA mask		*/
+ #define SIOCGIFMETRIC	0x891d		/* get metric			*/
+ #define SIOCSIFMETRIC	0x891e		/* set metric			*/
+ #define SIOCGIFMEM	0x891f		/* get memory address (BSD)	*/
+ #define SIOCSIFMEM	0x8920		/* set memory address (BSD)	*/
+ #define SIOCGIFMTU	0x8921		/* get MTU size			*/
+ #define SIOCSIFMTU	0x8922		/* set MTU size			*/
+ 
+ /* Routing table calls. */
+ #define SIOCADDRT	0x8940		/* add routing table entry	*/
+ #define SIOCDELRT	0x8941		/* delete routing table entry	*/
+ 
+ /* ARP cache control calls. */
+ #define SIOCDARP	0x8950		/* delete ARP table entry	*/
+ #define SIOCGARP	0x8951		/* get ARP table entry		*/
+ #define SIOCSARP	0x8952		/* set ARP table entry		*/
+ 
+ #endif	/* _LINUX_SOCKIOS_H */
diff -c --recursive --new-file std/include/linux/tcp.h linux/include/linux/tcp.h
*** std/include/linux/tcp.h
--- linux/include/linux/tcp.h	Sat Apr 24 19:39:36 1993
***************
*** 0 ****
--- 1,61 ----
+ /*
+  * INET		An implementation of the TCP/IP protocol suite for the LINUX
+  *		operating system.  INET is implemented using the  BSD Socket
+  *		interface as the means of communication with the user level.
+  *
+  *		Definitions for the TCP protocol.
+  *
+  * Version:	@(#)tcp.h	1.0.1	03/21/93
+  *
+  * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+  *
+  *		This program is free software; you can redistribute it and/or
+  *		modify it under the terms of the GNU General Public License
+  *		as published by the Free Software Foundation; either version
+  *		2 of the License, or (at your option) any later version.
+  */
+ #ifndef _LINUX_TCP_H
+ #define _LINUX_TCP_H
+ 
+ 
+ #define HEADER_SIZE	64		/* maximum header size		*/
+ 
+ 
+ struct tcp_header {
+   unsigned short	source;
+   unsigned short	dest;
+   unsigned long		seq;
+   unsigned long		ack_seq;
+   unsigned short	res1:4,
+ 			doff:4,
+ 			fin:1,
+ 			syn:1,
+ 			rst:1,
+ 			psh:1,
+ 			ack:1,
+ 			urg:1,
+ 			res2:2;
+   unsigned short	window;
+   unsigned short	check;
+   unsigned short	urg_ptr;
+ };
+ 
+ 
+ enum {
+   TCP_ESTABLISHED = 1,
+   TCP_SYN_SENT,
+   TCP_SYN_RECV,
+ #if 0
+   TCP_CLOSING, /* not a valid state, just a seperator so we can use
+ 		  < tcp_closing or > tcp_closing for checks. */
+ #endif
+   TCP_FIN_WAIT1,
+   TCP_FIN_WAIT2,
+   TCP_TIME_WAIT,
+   TCP_CLOSE,
+   TCP_CLOSE_WAIT,
+   TCP_LAST_ACK,
+   TCP_LISTEN
+ };
+ 
+ #endif	/* _LINUX_TCP_H */
diff -c --recursive --new-file std/include/linux/tty.h linux/include/linux/tty.h
*** std/include/linux/tty.h	Thu Apr 22 20:32:21 1993
--- linux/include/linux/tty.h	Sat Apr 24 19:48:45 1993
***************
*** 340,345 ****
--- 340,349 ----
  extern void wait_until_sent(struct tty_struct * tty);
  extern void copy_to_cooked(struct tty_struct * tty);
  extern int tty_register_ldisc(int disc, struct tty_ldisc *new);
+ extern int tty_read_raw_data(struct tty_struct *tty, unsigned char *bufp,
+ 			     int buflen);
+ extern int tty_write_data(struct tty_struct *tty, char *bufp, int buflen,
+ 			  void (*callback)(void * data), void * callarg);
  
  extern int tty_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
  extern int is_orphaned_pgrp(int pgrp);
diff -c --recursive --new-file std/include/linux/udp.h linux/include/linux/udp.h
*** std/include/linux/udp.h
--- linux/include/linux/udp.h	Sat Apr 24 19:39:36 1993
***************
*** 0 ****
--- 1,29 ----
+ /*
+  * INET		An implementation of the TCP/IP protocol suite for the LINUX
+  *		operating system.  INET is implemented using the  BSD Socket
+  *		interface as the means of communication with the user level.
+  *
+  *		Definitions for the UDP protocol.
+  *
+  * Version:	@(#)udp.h	1.0.1	03/21/93
+  *
+  * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+  *
+  *		This program is free software; you can redistribute it and/or
+  *		modify it under the terms of the GNU General Public License
+  *		as published by the Free Software Foundation; either version
+  *		2 of the License, or (at your option) any later version.
+  */
+ #ifndef _LINUX_UDP_H
+ #define _LINUX_UDP_H
+ 
+ 
+ struct udp_header {
+   unsigned short	source;
+   unsigned short	dest;
+   unsigned short	len;
+   unsigned short	check;
+ };
+ 
+ 
+ #endif	/* _LINUX_UDP_H */
diff -c --recursive --new-file std/kernel/blk_drv/ramdisk.c linux/kernel/blk_drv/ramdisk.c
*** std/kernel/blk_drv/ramdisk.c	Wed Feb 17 19:25:55 1993
--- linux/kernel/blk_drv/ramdisk.c	Sat Apr 24 19:39:36 1993
***************
*** 2,7 ****
--- 2,10 ----
   *  linux/kernel/blk_drv/ramdisk.c
   *
   *  Written by Theodore Ts'o, 12/2/91
+  *
+  * Modifications by Fred N. van Kempen to allow for bootable root
+  * disks (which are used in LINUX/Pro).  Also some cleanups.  03/03/93
   */
  
  
***************
*** 14,22 ****
  #include <asm/system.h>
  #include <asm/segment.h>
  
! #define MAJOR_NR 1
  #include "blk.h"
  
  char	*rd_start;
  int	rd_length = 0;
  
--- 17,30 ----
  #include <asm/system.h>
  #include <asm/segment.h>
  
! #define MAJOR_RAMDISK	1		/* should be in <linux/major.h>	*/
! #define MAJOR_FLOPPY	2		/* should be in <linux/major.h>	*/
! #define MINOR_RAMDISK	1
! 
! #define MAJOR_NR	MAJOR_RAMDISK	/* weird hack- FvK */
  #include "blk.h"
  
+ 
  char	*rd_start;
  int	rd_length = 0;
  
***************
*** 29,35 ****
  	INIT_REQUEST;
  	addr = rd_start + (CURRENT->sector << 9);
  	len = CURRENT->nr_sectors << 9;
! 	if ((MINOR(CURRENT->dev) != 1) || (addr+len > rd_start+rd_length)) {
  		end_request(0);
  		goto repeat;
  	}
--- 37,44 ----
  	INIT_REQUEST;
  	addr = rd_start + (CURRENT->sector << 9);
  	len = CURRENT->nr_sectors << 9;
! 	if ((MINOR(CURRENT->dev) != MINOR_RAMDISK) ||
! 	    (addr+len > rd_start+rd_length)) {
  		end_request(0);
  		goto repeat;
  	}
***************
*** 42,48 ****
  			      addr,
  			      len);
  	} else
! 		panic("unknown ramdisk-command");
  	end_request(1);
  	goto repeat;
  }
--- 51,57 ----
  			      addr,
  			      len);
  	} else
! 		panic("RAMDISK: unknown RAM disk command !\n");
  	end_request(1);
  	goto repeat;
  }
***************
*** 67,77 ****
  	int	i;
  	char	*cp;
  
! 	if (register_blkdev(MAJOR_NR,"rd",&rd_fops)) {
! 		printk("Unable to get major %d for ramdisk\n",MAJOR_NR);
  		return 0;
  	}
! 	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
  	rd_start = (char *) mem_start;
  	rd_length = length;
  	cp = rd_start;
--- 76,86 ----
  	int	i;
  	char	*cp;
  
! 	if (register_blkdev(MAJOR_RAMDISK,"rd",&rd_fops)) {
! 		printk("RAMDISK: Unable to get major %d.\n", MAJOR_RAMDISK);
  		return 0;
  	}
! 	blk_dev[MAJOR_RAMDISK].request_fn = DEVICE_REQUEST;
  	rd_start = (char *) mem_start;
  	rd_length = length;
  	cp = rd_start;
***************
*** 81,142 ****
  }
  
  /*
!  * If the root device is the ram disk, try to load it.
   * In order to do this, the root device is originally set to the
!  * floppy, and we later change it to be ram disk.
   */
  void rd_load(void)
  {
  	struct buffer_head *bh;
  	struct minix_super_block s;
! 	int		block = 512;	/* Start at block 512 */
  	int		i = 1;
  	int		nblocks;
! 	char		*cp;		/* Move pointer */
! 	
! 	if (!rd_length)
! 		return;
! 	printk("Ram disk: %d bytes, starting at 0x%x\n", rd_length,
! 		(int) rd_start);
! 	if (MAJOR(ROOT_DEV) != 2)
! 		return;
! 	bh = breada(ROOT_DEV,block+1,block,block+2,-1);
! 	if (!bh) {
! 		printk("Disk error while looking for ramdisk!\n");
! 		return;
! 	}
! 	*((struct minix_super_block *) &s) = *((struct minix_super_block *) bh->b_data);
! 	brelse(bh);
! 	if (s.s_magic != MINIX_SUPER_MAGIC)
! 		/* No ram disk image present, assume normal floppy boot */
! 		return;
! 	nblocks = s.s_nzones << s.s_log_zone_size;
! 	if (nblocks > (rd_length >> BLOCK_SIZE_BITS)) {
! 		printk("Ram disk image too big!  (%d blocks, %d avail)\n", 
! 			nblocks, rd_length >> BLOCK_SIZE_BITS);
! 		return;
! 	}
! 	printk("Loading %d bytes into ram disk\n",
! 		nblocks << BLOCK_SIZE_BITS);
! 	cp = rd_start;
! 	while (nblocks) {
! 		if (nblocks > 2) 
! 			bh = breada(ROOT_DEV, block, block+1, block+2, -1);
! 		else
! 			bh = bread(ROOT_DEV, block, BLOCK_SIZE);
  		if (!bh) {
! 			printk("I/O error on block %d, aborting load\n", 
! 				block);
  			return;
  		}
! 		(void) memcpy(cp, bh->b_data, BLOCK_SIZE);
  		brelse(bh);
! 		if (!(nblocks-- & 15))
! 			printk(".");
! 		cp += BLOCK_SIZE;
! 		block++;
! 		i++;
  	}
- 	printk("\ndone\n");
- 	ROOT_DEV=0x0101;
  }
--- 90,172 ----
  }
  
  /*
!  * If the root device is the RAM disk, try to load it.
   * In order to do this, the root device is originally set to the
!  * floppy, and we later change it to be RAM disk.
   */
  void rd_load(void)
  {
  	struct buffer_head *bh;
  	struct minix_super_block s;
! 	int		block, try;
  	int		i = 1;
  	int		nblocks;
! 	char		*cp;
! 
! 	/* If no RAM disk specified, give up early. */
! 	if (!rd_length) return;
! 	printk("RAMDISK: %d bytes, starting at 0x%x\n",
! 					rd_length, (int) rd_start);
! 
! 	/* If we are doing a diskette boot, we might have to pre-load it. */
! 	if (MAJOR(ROOT_DEV) != MAJOR_FLOPPY) return;
! 
! 	/*
! 	 * Check for a super block on the diskette.
! 	 * The old-style boot/root diskettes had their RAM image
! 	 * starting at block 512 of the boot diskette.  LINUX/Pro
! 	 * uses the enire diskette as a file system, so in that
! 	 * case, we have to look at block 0.  Be intelligent about
! 	 * this, and check both... - FvK
! 	 */
! 	for (try = 0; try < 1000; try += 512) {
! 		block = try;
! 		bh = breada(ROOT_DEV,block+1,block,block+2,-1);
  		if (!bh) {
! 			printk("RAMDISK: I/O error while looking for super block!\n");
  			return;
  		}
! 
! 		/* This is silly- why do we require it to be a MINIX FS? */
! 		*((struct minix_super_block *) &s) =
! 			*((struct minix_super_block *) bh->b_data);
  		brelse(bh);
! 		nblocks = s.s_nzones << s.s_log_zone_size;
! 		if (s.s_magic != MINIX_SUPER_MAGIC) {
! 			printk("RAMDISK: trying old-style RAM image.\n");
! 			continue;
! 		}
! 
! 		if (nblocks > (rd_length >> BLOCK_SIZE_BITS)) {
! 			printk("RAMDISK: image too big! (%d/%d blocks)\n",
! 					nblocks, rd_length >> BLOCK_SIZE_BITS);
! 			return;
! 		}
! 		printk("RAMDISK: Loading %d blocks into RAM disk", nblocks);
! 
! 		/* We found an image file system.  Load it into core! */
! 		cp = rd_start;
! 		while (nblocks) {
! 			if (nblocks > 2) 
! 				bh = breada(ROOT_DEV, block, block+1, block+2, -1);
! 			else
! 				bh = bread(ROOT_DEV, block, BLOCK_SIZE);
! 			if (!bh) {
! 				printk("RAMDISK: I/O error on block %d, aborting!\n", 
! 				block);
! 				return;
! 			}
! 			(void) memcpy(cp, bh->b_data, BLOCK_SIZE);
! 			brelse(bh);
! 			if (!(nblocks-- & 15)) printk(".");
! 			cp += BLOCK_SIZE;
! 			block++;
! 			i++;
! 		}
! 		printk("\ndone\n");
! 
! 		/* We loaded the file system image.  Prepare for mounting it. */
! 		ROOT_DEV = ((MAJOR_RAMDISK << 8) | MINOR_RAMDISK);
! 		return;
  	}
  }
diff -c --recursive --new-file std/kernel/chr_drv/tty_io.c linux/kernel/chr_drv/tty_io.c
*** std/kernel/chr_drv/tty_io.c	Thu Apr 22 20:21:02 1993
--- linux/kernel/chr_drv/tty_io.c	Sat Apr 24 19:39:36 1993
***************
*** 1391,1396 ****
--- 1391,1397 ----
  	while (count && VLEFT > 0) {
  		tty->write_q.buf[head++] = *p++;
  		head &= TTY_BUF_SIZE-1;
+ 		count--;
  	}
  	tty->write_q.head = head;
  	if (count) {
***************
*** 1400,1405 ****
--- 1401,1407 ----
  		tty->write_data_arg = callarg;
  	}
  	__asm__ __volatile__("pushl %0 ; popfl"::"r" (flags));
+ 	tty->write(tty);
  	return count;
  }
  
diff -c --recursive --new-file std/net/tcp/arp.h linux/net/tcp/arp.h
*** std/net/tcp/arp.h	Mon Jan 25 19:26:55 1993
--- linux/net/tcp/arp.h	Sat Apr 24 20:26:41 1993
***************
*** 52,57 ****
--- 52,60 ----
  #ifndef _TCP_ARP_H
  #define _TCP_ARP_H
  
+ #include <linux/if_arp.h>
+ 
+ 
  struct arp
  {
    unsigned short hrd;

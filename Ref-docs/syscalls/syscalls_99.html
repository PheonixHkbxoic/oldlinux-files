<html><!-- This HTML file has been created by texi2html 1.29
     from syscalls.texi on 4 June 1994 -->

<TITLE>Syscall specifications of Linux - sigaction</TITLE>
<P>Go to the <A HREF="syscalls_98.html" tppabs="http://www.infran.ru/TechInfo/syscalls/syscalls_98.html">previous</A>, <A HREF="syscalls_100.html" tppabs="http://www.infran.ru/TechInfo/syscalls/syscalls_100.html">next</A> section.<P>
<H2><A NAME="SEC99" HREF="syscalls_toc.html#SEC99" tppabs="http://www.infran.ru/TechInfo/syscalls/syscalls_toc.html#SEC99">sigaction and signal</A></H2>
<P>
<H3>SYNOPSIS</H3>
<P>
<CODE>int sigaction(int <VAR>signum</VAR>, const struct sigaction *<VAR>new</VAR>,
struct sigaction *<VAR>old</VAR>);</CODE>
<P>
<CODE>(void *) (int) signal(int <VAR>signum</VAR>, (void *<VAR>handler</VAR>)(int));</CODE>
<P>
<H3>PARAMETERS</H3>
<P>
<VAR>signum</VAR>: [in] a signal number.
<P>
<VAR>new</VAR>: [in] the action to take for this signal.
<P>
<VAR>old</VAR>: [out] the previous action that was associated to the signal.
<P>
<VAR>handler</VAR>: [in] points to the new signal handler.
<P>
<H3>DESCRIPTION</H3>
<P>
<CODE>sigaction</CODE> is used to specify the action to take in case the
signal <VAR>signum</VAR> is raised. <VAR>signum</VAR> can take one of the
following values:
<P>
<DL COMPACT>
<DT><CODE>SIGHUP</CODE>
<DD>(terminates) the controling terminal has been disconnected.
<P>
<DT><CODE>SIGINT</CODE>
<DD>(terminates) the interrupt key has been pressed (Ctrl-C usually).
<P>
<DT><CODE>SIGQUIT</CODE>
<DD>(terminates and dumps core) the quit key has been pressed (Ctrl-\ usually).
<P>
<DT><CODE>SIGILL</CODE>
<DD>(terminates and dumps core) the task has executed an illegal instruction
(or is ill?).
<P>
<DT><CODE>SIGTRAP</CODE>
<DD>(terminates and dumps core) caught an hardware fault.
<P>
<DT><CODE>SIGABRT</CODE>
<DD>(terminates and dumps core) usually generated by the <CODE>abort</CODE> function.
<P>
<DT><CODE>SIGIOT</CODE>
<DD>(terminates and dumps core) caught an hardware fault.
<P>
<DT><CODE>SIGUNUSED</CODE>
<DD>(terminates) unused.
<P>
<DT><CODE>SIGFPE</CODE>
<DD>(terminates and dumps core) the task has generated a floating-point exception.
<P>
<DT><CODE>SIGKILL</CODE>
<DD>(terminates) kills the task. This signal can't be caught or ignored.
<P>
<DT><CODE>SIGUSR1</CODE>
<DD>(terminates) user defined signal.
<P>
<DT><CODE>SIGSEGV</CODE>
<DD>(terminates and dumps core) the task has made an invalid memory reference.
<P>
<DT><CODE>SIGUSR2</CODE>
<DD>(terminates) user defined signal.
<P>
<DT><CODE>SIGPIPE</CODE>
<DD>(terminates) the task tried to write to a pipe/socket but the reader is dead.
<P>
<DT><CODE>SIGALRM</CODE>
<DD>(terminates) an alarm has expired.
<P>
<DT><CODE>SIGTERM</CODE>
<DD>(terminates) termination signal.
<P>
<DT><CODE>SIGSTKFLT</CODE>
<DD>??
<P>
<DT><CODE>SIGCHLD</CODE>
<DD>(ignore) a child has died. 
<P>
<DT><CODE>SIGCONT</CODE>
<DD>(ignored or resumes) send to a stopped task to make it resume its execution.
<P>
<DT><CODE>SIGSTOP</CODE>
<DD>(stops) send to a task to make it stop its execution. This signal can't
be caught or ignored.
<P>
<DT><CODE>SIGTSTP</CODE>
<DD>(stops) interactive stop signal generated by the terminal (usually Ctrl-Z).
<P>
<DT><CODE>SIGTTIN</CODE>
<DD>(stops) the process is in background and tried to read from its
controling terminal.
<P>
<DT><CODE>SIGTTOU</CODE>
<DD>(stops) the process is in background and tried to write to its controling
terminal.
<P>
<DT><CODE>SIGIO</CODE>
<DD>(terminates) an asynchronous I/O event has occured.
<P>
<DT><CODE>SIGPOLL</CODE>
<DD>(terminates) an event has occurend on a pooling device.
<P>
<DT><CODE>SIGURG</CODE>
<DD>(terminates) an urgent condition has occured. (Usually the reception of out-of-band
data on a network connection.)
<P>
<DT><CODE>SIGXCPU</CODE>
<DD>(terminates) the task has exceeded its CPU time limit.
<P>
<DT><CODE>SIGXFSZ</CODE>
<DD>(terminates) the taks exceeds its size limit.
<P>
<DT><CODE>SIGVTALRM</CODE>
<DD>(terminates) a virtual interval timer has expired.
<P>
<DT><CODE>SIGPROF</CODE>
<DD>(terminates) a profiling interval timer has expired.
<P>
<DT><CODE>SIGWINCH</CODE>
<DD>(ignored) the controling terminal size has changed.
<P>
<DT><CODE>SIGPWR</CODE>
<DD>(terminates) power failure: run for cover!
<P>
<DT><CODE>SIGBUS</CODE>
<DD>(terminates) a hardware fault has occured. If we look in the kernel
sources, we see: Arggh. Bad user source code wants this.
</DL>
<P>
There is also a signal <CODE>SIGLOST</CODE> in the sources, however it is
commented out.
<P>
The action to take is specified by a <CODE>sigcaction</CODE> structure that
has the following layout:
<P>
<PRE>
struct sigaction {
	__sighandler_t sa_handler;  /* the handler (or a special value) */
	sigset_t sa_mask;           /* signals to block on entry */
	int sa_flags;               /* some flags */
	void (*sa_restorer)(void);  /* not used */
};
</PRE>
<P>
<CODE>sa_handler</CODE> may be set to the address of the handler to start to
handle the signal or it may be set to one of the following special
values:
<P>
<DL COMPACT>
<DT><CODE>SIG_ING</CODE>
<DD>means to ignore the signal.
<P>
<DT><CODE>SIG_DFL</CODE>
<DD>means to use the default handler.
</DL>
<P>
<VAR>sa_mask</VAR> specifies signals to be added to the signal mask of the
process before calling the signal handler. The signal mask is restored
to its initial value upon return from the handler.
<P>
<VAR>sa_flags</VAR> specifies some options for the handling of the signal:
<P>
<DL COMPACT>
<DT><CODE>SA_NOCLDSTOP</CODE>
<DD>disable the generation of the <CODE>SIGCHLD</CODE> signal when a child stops.
<VAR>signum</VAR> must be <CODE>SIGCHLD</CODE>.
<P>
<DT><CODE>SA_RESTART</CODE>
<DD>ask for automatic restart of system calls interrupted by this signal.
<P>
<DT><CODE>SA_STACK</CODE>
<DD>not implemented.
<P>
<DT><CODE>SA_INTERRUPT</CODE>
<DD>ignored.
<P>
<DT><CODE>SA_NOMASK</CODE>
<DD>do not mask anything (not even the current signal). (Looks like
<CODE>SA_NODEFER</CODE> in [Stevens].) 
<P>
<DT><CODE>SA_ONESHOT</CODE>
<DD>the handler will be used only once. (Looks like
<CODE>SA_RESETHAND</CODE> in [Stevens].)
</DL>
<P>
The previous value of the <CODE>sigaction</CODE> structure for the signal is
stored to the area pointed to by <VAR>old</VAR>.
<P>
<CODE>signal</CODE> is some kind of proto-<CODE>sigaction</CODE>. It sets the
handler of <VAR>signum</VAR> to <VAR>handler</VAR>. It is equivalent to
<P>
<PRE>
struct sigaction new;
new.sa_handler=handler;
new.sa_mask=0;
new.sa_flags=SA_NOMASK | SA_ONESHOT;
new.sa_restorer=NULL;
sigaction(signum, &#38;new, NULL);
</PRE>
<P>
It could be implemented as a <CODE>sigaction</CODE> wrapper.
<P>
<H3>RETURN VALUE</H3>
<P>
On success, <CODE>sigaction</CODE> returns zero and <CODE>signal</CODE> returns the
pointer to the signal handler. On error, both return -1. The possible
values of <CODE>errno</CODE> are:
<P>
<UL>
<LI><CODE>EINVAL</CODE>: tried to set the handler of <CODE>SIGKILL</CODE> or
<CODE>SIGSTOP</CODE>.
<LI><CODE>EFAULT</CODE>.
</UL>
<P>
<P>Go to the <A HREF="syscalls_98.html" tppabs="http://www.infran.ru/TechInfo/syscalls/syscalls_98.html">previous</A>, <A HREF="syscalls_100.html" tppabs="http://www.infran.ru/TechInfo/syscalls/syscalls_100.html">next</A> section.<P>

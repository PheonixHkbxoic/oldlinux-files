<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>File and Archiving Commands</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.64
"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="External Filters, Programs and Commands"
HREF="external.html"><LINK
REL="PREVIOUS"
TITLE="Text Processing Commands"
HREF="textproc.html"><LINK
REL="NEXT"
TITLE="Communications Commands"
HREF="communications.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-family: sans-serif;"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="textproc.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 12. External Filters, Programs and Commands</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="communications.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="FILEARCHIV"
>12.5. File and Archiving Commands</A
></H1
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="FAARCHIVING1"
></A
>Archiving</B
></P
><DL
><DT
><A
NAME="TARREF"
></A
><B
CLASS="COMMAND"
>tar</B
></DT
><DD
><P
>The standard UNIX archiving utility. Originally a
	      <I
CLASS="WORDASWORD"
>Tape ARchiving</I
> program,
	      it has developed into a general purpose package that
	      can handle all manner of archiving with all types of
	      destination devices, ranging from tape drives to regular
	      files to even <TT
CLASS="FILENAME"
>stdout</TT
> (see <A
HREF="special-chars.html#EX58"
>Example 4-3</A
>). GNU tar has long since been patched to
	      accept <A
HREF="filearchiv.html#GZIPREF"
>gzip</A
> compression
	      options, such as <B
CLASS="COMMAND"
>tar czvf archive-name.tar.gz
	      *</B
>, which recursively archives and compresses all
	      files in a directory tree except <A
HREF="external.html#DOTFILESREF"
>dotfiles</A
> in the current
	      working directory (<B
CLASS="COMMAND"
>$PWD</B
>).
		<A
NAME="AEN7431"
HREF="#FTN.AEN7431"
>[1]</A
>
            </P
><P
>Some useful <B
CLASS="COMMAND"
>tar</B
> options:  
	      <OL
TYPE="1"
><LI
><P
><TT
CLASS="OPTION"
>-c</TT
> create (a new archive)</P
></LI
><LI
><P
><TT
CLASS="OPTION"
>--delete</TT
> delete (files from the archive)</P
></LI
><LI
><P
><TT
CLASS="OPTION"
>-r</TT
> append (files to the archive)</P
></LI
><LI
><P
><TT
CLASS="OPTION"
>-t</TT
> list (archive contents)</P
></LI
><LI
><P
><TT
CLASS="OPTION"
>-u</TT
> update archive</P
></LI
><LI
><P
><TT
CLASS="OPTION"
>-x</TT
> extract (files from the archive)</P
></LI
><LI
><P
><TT
CLASS="OPTION"
>-z</TT
> <A
HREF="filearchiv.html#GZIPREF"
>gzip</A
> the archive</P
></LI
></OL
>
	      </P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>It may be difficult to recover data from a
	      corrupted <I
CLASS="EMPHASIS"
>gzipped</I
> tar
	      archive. When archiving important files, make multiple
	      backups.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>shar</B
></DT
><DD
><P
>Shell archiving utility. The files in a shell archive
	      are concatenated without compression, and the resultant
	      archive is essentially a shell script, complete with
	      <SPAN
CLASS="TOKEN"
>#!/bin/sh</SPAN
> header, and containing all
	      the necessary unarchiving commands.  Shar archives
	      still show up in Internet newsgroups, but otherwise
	      <B
CLASS="COMMAND"
>shar</B
> has been pretty well replaced by
	      <B
CLASS="COMMAND"
>tar</B
>/<B
CLASS="COMMAND"
>gzip</B
>. The
	      <B
CLASS="COMMAND"
>unshar</B
> command unpacks
	      <B
CLASS="COMMAND"
>shar</B
> archives.</P
></DD
><DT
><B
CLASS="COMMAND"
>ar</B
></DT
><DD
><P
>Creation and manipulation utility for archives, mainly
	      used for binary object file libraries.</P
></DD
><DT
><B
CLASS="COMMAND"
>cpio</B
></DT
><DD
><P
>This specialized archiving copy command
	      (<B
CLASS="COMMAND"
>c</B
>o<B
CLASS="COMMAND"
>p</B
>y
	      <B
CLASS="COMMAND"
>i</B
>nput and <B
CLASS="COMMAND"
>o</B
>utput)
	      is rarely seen any more, having been supplanted by
	      <B
CLASS="COMMAND"
>tar</B
>/<B
CLASS="COMMAND"
>gzip</B
>. It still
	      has its uses, such as moving a directory tree.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX48"
></A
><P
><B
>Example 12-22. Using <B
CLASS="COMMAND"
>cpio</B
> to move a directory tree</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# Copying a directory tree using cpio.
   4&nbsp;
   5&nbsp;ARGS=2
   6&nbsp;E_BADARGS=65
   7&nbsp;
   8&nbsp;if [ $# -ne "$ARGS" ]
   9&nbsp;then
  10&nbsp;  echo "Usage: `basename $0` source destination"
  11&nbsp;  exit $E_BADARGS
  12&nbsp;fi  
  13&nbsp;
  14&nbsp;source=$1
  15&nbsp;destination=$2
  16&nbsp;
  17&nbsp;find "$source" -depth | cpio -admvp "$destination"
  18&nbsp;# Read the man page to decipher these cpio options.
  19&nbsp;
  20&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="DERPM"
></A
><P
><B
>Example 12-23. Unpacking an <I
CLASS="EMPHASIS"
>rpm</I
> archive</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# de-rpm.sh: Unpack an 'rpm' archive
   3&nbsp;
   4&nbsp;E_NO_ARGS=65
   5&nbsp;TEMPFILE=$$.cpio                         # Tempfile with "unique" name.
   6&nbsp;                                         # $$ is process ID of script.
   7&nbsp;
   8&nbsp;if [ -z "$1" ] 
   9&nbsp;then
  10&nbsp;  echo "Usage: `basename $0` filename"
  11&nbsp;exit $E_NO_ARGS
  12&nbsp;fi
  13&nbsp;
  14&nbsp;
  15&nbsp;rpm2cpio &#60; $1 &#62; $TEMPFILE                # Converts rpm archive into cpio archive.
  16&nbsp;cpio --make-directories -F $TEMPFILE -i  # Unpacks cpio archive.
  17&nbsp;rm -f $TEMPFILE                          # Deletes cpio archive.
  18&nbsp;
  19&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="FACOMPRESSION1"
></A
>Compression</B
></P
><DL
><DT
><A
NAME="GZIPREF"
></A
><B
CLASS="COMMAND"
>gzip</B
></DT
><DD
><P
>The standard GNU/UNIX compression utility, replacing
	      the inferior and proprietary
	      <B
CLASS="COMMAND"
>compress</B
>. The corresponding decompression
	      command is <B
CLASS="COMMAND"
>gunzip</B
>, which is the equivalent of
	      <B
CLASS="COMMAND"
>gzip -d</B
>.</P
><P
>The <B
CLASS="COMMAND"
>zcat</B
> filter decompresses a
	      <I
CLASS="EMPHASIS"
>gzipped</I
> file to
	      <TT
CLASS="FILENAME"
>stdout</TT
>, as possible input to a pipe or
	      redirection. This is, in effect, a <B
CLASS="COMMAND"
>cat</B
>
	      command that works on compressed files (including files
	      processed with the older <B
CLASS="COMMAND"
>compress</B
>
	      utility). The <B
CLASS="COMMAND"
>zcat</B
> command is equivalent to
	      <B
CLASS="COMMAND"
>gzip -dc</B
>.</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>On some commercial UNIX systems, <B
CLASS="COMMAND"
>zcat</B
>
	      is a synonym for <B
CLASS="COMMAND"
>uncompress -c</B
>,
	      and will not work on <I
CLASS="EMPHASIS"
>gzipped</I
>
	      files.</P
></TD
></TR
></TABLE
></DIV
><P
>See also <A
HREF="comparison-ops.html#EX14"
>Example 7-6</A
>.</P
></DD
><DT
><A
NAME="BZIPREF"
></A
><B
CLASS="COMMAND"
>bzip2</B
></DT
><DD
><P
>An alternate compression utility, usually more efficient
	      than <B
CLASS="COMMAND"
>gzip</B
>, especially on large files. The
	      corresponding decompression command is
	      <B
CLASS="COMMAND"
>bunzip2</B
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>compress</B
>, <B
CLASS="COMMAND"
>uncompress</B
></DT
><DD
><P
>This is an older, proprietary compression
	      utility found in commercial UNIX distributions. The
	      more efficient <B
CLASS="COMMAND"
>gzip</B
> has largely
	      replaced it. Linux distributions generally include a
	      <B
CLASS="COMMAND"
>compress</B
> workalike for compatibility,
	      although <B
CLASS="COMMAND"
>gunzip</B
> can unarchive files
	      treated with <B
CLASS="COMMAND"
>compress</B
>.</P
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <B
CLASS="COMMAND"
>znew</B
> command transforms
	      <I
CLASS="EMPHASIS"
>compressed</I
> files into
	      <I
CLASS="EMPHASIS"
>gzipped</I
> ones.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>sq</B
></DT
><DD
><P
>Yet another compression utility, a filter that works
	      only on sorted ASCII word lists. It uses the standard
	      invocation syntax for a filter, <B
CLASS="COMMAND"
>sq &#60; input-file &#62;
	      output-file</B
>.  Fast, but not nearly as efficient
	      as <A
HREF="filearchiv.html#GZIPREF"
>gzip</A
>.  The corresponding
	      uncompression filter is <B
CLASS="COMMAND"
>unsq</B
>, invoked
	      like <B
CLASS="COMMAND"
>sq</B
>.</P
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The output of <B
CLASS="COMMAND"
>sq</B
> may be
	        piped to <B
CLASS="COMMAND"
>gzip</B
> for further
		compression.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>zip</B
>, <B
CLASS="COMMAND"
>unzip</B
></DT
><DD
><P
>Cross-platform file archiving and compression utility
	      compatible with DOS <I
CLASS="EMPHASIS"
>PKZIP</I
>.
	      <SPAN
CLASS="QUOTE"
>"Zipped"</SPAN
> archives seem to be a more
	      acceptable medium of exchange on the Internet than
	      <SPAN
CLASS="QUOTE"
>"tarballs"</SPAN
>.</P
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="FAINFORMATION1"
></A
>File Information</B
></P
><DL
><DT
><A
NAME="FILEREF"
></A
><B
CLASS="COMMAND"
>file</B
></DT
><DD
><P
>A utility for identifying file types. The command
	      <TT
CLASS="USERINPUT"
><B
>file file-name</B
></TT
> will return a
	      file specification for <TT
CLASS="FILENAME"
>file-name</TT
>,
	      such as <TT
CLASS="COMPUTEROUTPUT"
>ascii text</TT
> or
	      <TT
CLASS="COMPUTEROUTPUT"
>data</TT
>. It references
	      the <A
HREF="sha-bang.html#MAGNUMREF"
>magic numbers</A
>
	      found in <TT
CLASS="FILENAME"
>/usr/share/magic</TT
>,
	      <TT
CLASS="FILENAME"
>/etc/magic</TT
>, or
	      <TT
CLASS="FILENAME"
>/usr/lib/magic</TT
>, depending on the
	      Linux/UNIX distribution.</P
><P
>The <TT
CLASS="OPTION"
>-f</TT
> option causes
	      <B
CLASS="COMMAND"
>file</B
> to run in batch mode, to read from
	      a designated file a list of filenames to analyze. The
	      <TT
CLASS="OPTION"
>-z</TT
> option, when used on a compressed
	      target file, forces an attempt to analyze the uncompressed
	      file type.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>file test.tar.gz</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>test.tar.gz: gzip compressed data, deflated, last modified: Sun Sep 16 13:34:51 2001, os: Unix</TT
>
 
 <TT
CLASS="PROMPT"
>bash </TT
><TT
CLASS="USERINPUT"
><B
>file -z test.tar.gz</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>test.tar.gz: GNU tar archive (gzip compressed data, deflated, last modified: Sun Sep 16 13:34:51 2001, os: Unix)</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="STRIPC"
></A
><P
><B
>Example 12-24. stripping comments from C program files</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# strip-comment.sh: Strips out the comments (/* COMMENT */) in a C program.
   3&nbsp;
   4&nbsp;E_NOARGS=65
   5&nbsp;E_ARGERROR=66
   6&nbsp;E_WRONG_FILE_TYPE=67
   7&nbsp;
   8&nbsp;if [ $# -eq "$E_NOARGS" ]
   9&nbsp;then
  10&nbsp;  echo "Usage: `basename $0` C-program-file" &#62;&#38;2 # Error message to stderr.
  11&nbsp;  exit $E_ARGERROR
  12&nbsp;fi  
  13&nbsp;
  14&nbsp;# Test for correct file type.
  15&nbsp;type=`eval file $1 | awk '{ print $2, $3, $4, $5 }'`
  16&nbsp;# "file $1" echoes file type...
  17&nbsp;# then awk removes the first field of this, the filename...
  18&nbsp;# then the result is fed into the variable "type".
  19&nbsp;correct_type="ASCII C program text"
  20&nbsp;
  21&nbsp;if [ "$type" != "$correct_type" ]
  22&nbsp;then
  23&nbsp;  echo
  24&nbsp;  echo "This script works on C program files only."
  25&nbsp;  echo
  26&nbsp;  exit $E_WRONG_FILE_TYPE
  27&nbsp;fi  
  28&nbsp;
  29&nbsp;
  30&nbsp;# Rather cryptic sed script:
  31&nbsp;#--------
  32&nbsp;sed '
  33&nbsp;/^\/\*/d
  34&nbsp;/.*\/\*/d
  35&nbsp;' $1
  36&nbsp;#--------
  37&nbsp;# Easy to understand if you take several hours to learn sed fundamentals.
  38&nbsp;
  39&nbsp;
  40&nbsp;#  Need to add one more line to the sed script to deal with
  41&nbsp;#+ case where line of code has a comment following it on same line.
  42&nbsp;#  This is left as a non-trivial exercise.
  43&nbsp;
  44&nbsp;# Also, the above code deletes lines with a "*/" or "/*",
  45&nbsp;# not a desirable result.
  46&nbsp;
  47&nbsp;exit 0
  48&nbsp;
  49&nbsp;
  50&nbsp;# ----------------------------------------------------------------
  51&nbsp;# Code below this line will not execute because of 'exit 0' above.
  52&nbsp;
  53&nbsp;# Stephane Chazelas suggests the following alternative:
  54&nbsp;
  55&nbsp;usage() {
  56&nbsp;  echo "Usage: `basename $0` C-program-file" &#62;&#38;2
  57&nbsp;  exit 1
  58&nbsp;}
  59&nbsp;
  60&nbsp;WEIRD=`echo -n -e '\377'`   # or WEIRD=$'\377'
  61&nbsp;[[ $# -eq 1 ]] || usage
  62&nbsp;case `file "$1"` in
  63&nbsp;  *"C program text"*) sed -e "s%/\*%${WEIRD}%g;s%\*/%${WEIRD}%g" "$1" \
  64&nbsp;     | tr '\377\n' '\n\377' \
  65&nbsp;     | sed -ne 'p;n' \
  66&nbsp;     | tr -d '\n' | tr '\377' '\n';;
  67&nbsp;  *) usage;;
  68&nbsp;esac
  69&nbsp;
  70&nbsp;# This is still fooled by things like:
  71&nbsp;# printf("/*");
  72&nbsp;# or
  73&nbsp;# /*  /* buggy embedded comment */
  74&nbsp;#
  75&nbsp;# To handle all special cases (comments in strings, comments in string
  76&nbsp;# where there is a \", \\" ...) the only way is to write a C parser
  77&nbsp;# (lex or yacc perhaps?).
  78&nbsp;
  79&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><A
NAME="WHICHREF"
></A
><B
CLASS="COMMAND"
>which</B
></DT
><DD
><P
><B
CLASS="COMMAND"
>which command-xxx</B
> gives the full path
	      to <SPAN
CLASS="QUOTE"
>"command-xxx"</SPAN
>. This is useful for finding
	      out whether a particular command or utility is installed
	      on the system.</P
><P
><TT
CLASS="USERINPUT"
><B
>$bash which rm</B
></TT
>
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="COMPUTEROUTPUT"
>/usr/bin/rm</TT
></PRE
></TD
></TR
></TABLE
>
	  </P
></DD
><DT
><B
CLASS="COMMAND"
>whereis</B
></DT
><DD
><P
>Similar to <B
CLASS="COMMAND"
>which</B
>, above,
	      <B
CLASS="COMMAND"
>whereis command-xxx</B
> gives the
	      full path to <SPAN
CLASS="QUOTE"
>"command-xxx"</SPAN
>, but also to its
	      <I
CLASS="EMPHASIS"
>manpage</I
>.</P
><P
><TT
CLASS="USERINPUT"
><B
>$bash whereis rm</B
></TT
>
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="COMPUTEROUTPUT"
>rm: /bin/rm /usr/share/man/man1/rm.1.bz2</TT
></PRE
></TD
></TR
></TABLE
>
	  </P
></DD
><DT
><A
NAME="WHATISREF"
></A
><B
CLASS="COMMAND"
>whatis</B
></DT
><DD
><P
><B
CLASS="COMMAND"
>whatis filexxx</B
> looks up
	      <SPAN
CLASS="QUOTE"
>"filexxx"</SPAN
> in the
	      <TT
CLASS="REPLACEABLE"
><I
>whatis</I
></TT
> database. This is useful
	      for identifying system commands and important configuration
	      files. Consider it a simplified <B
CLASS="COMMAND"
>man</B
>
	      command.</P
><P
><TT
CLASS="USERINPUT"
><B
>$bash whatis whatis</B
></TT
>
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="COMPUTEROUTPUT"
>whatis               (1)  - search the whatis database for complete words</TT
></PRE
></TD
></TR
></TABLE
>
	  </P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="WHAT"
></A
><P
><B
>Example 12-25. <B
CLASS="COMMAND"
>Exploring <TT
CLASS="FILENAME"
>/usr/X11R6/bin</TT
></B
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# What are all those mysterious binaries in /usr/X11R6/bin?
   4&nbsp;
   5&nbsp;DIRECTORY="/usr/X11R6/bin"
   6&nbsp;# Try also "/bin", "/usr/bin", "/usr/local/bin", etc.
   7&nbsp;
   8&nbsp;for file in $DIRECTORY/*
   9&nbsp;do
  10&nbsp;  whatis `basename $file`   # Echoes info about the binary.
  11&nbsp;done
  12&nbsp;
  13&nbsp;exit 0
  14&nbsp;# You may wish to redirect output of this script, like so:
  15&nbsp;# ./what.sh &#62;&#62;whatis.db
  16&nbsp;# or view it a page at a time on stdout,
  17&nbsp;# ./what.sh | less</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>See also <A
HREF="loops.html#FILEINFO"
>Example 10-3</A
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>vdir</B
></DT
><DD
><P
>Show a detailed directory listing. The effect is similar to
	      <A
HREF="external.html#LSREF"
>ls -l</A
>.</P
><P
>This is one of the GNU <I
CLASS="EMPHASIS"
>fileutils</I
>.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>vdir</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</TT
>
 
 <TT
CLASS="PROMPT"
>bash </TT
><TT
CLASS="USERINPUT"
><B
>ls -l</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
></DD
><DT
><A
NAME="SHREDREF"
></A
><B
CLASS="COMMAND"
>shred</B
></DT
><DD
><P
>Securely erase a file by overwriting it multiple times with
	      random bit patterns before deleting it. This command has
	      the same effect as <A
HREF="extmisc.html#BLOTOUT"
>Example 12-36</A
>, but does it
	      in a more thorough and elegant manner.</P
><P
>This is one of the GNU <I
CLASS="EMPHASIS"
>fileutils</I
>.</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Using <B
CLASS="COMMAND"
>shred</B
> on a file may
	      not prevent recovery of some or all of its contents using
	      advanced forensic technology.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>locate</B
>, <B
CLASS="COMMAND"
>slocate</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>locate</B
> command searches for files using a
	      database stored for just that purpose. The
	      <B
CLASS="COMMAND"
>slocate</B
> command is the secure version of
	      <B
CLASS="COMMAND"
>locate</B
> (which may be aliased to
	      <B
CLASS="COMMAND"
>slocate</B
>).</P
><P
><TT
CLASS="USERINPUT"
><B
>$bash locate hickson</B
></TT
>
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="COMPUTEROUTPUT"
>/usr/lib/xephem/catalogs/hickson.edb</TT
></PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><B
CLASS="COMMAND"
>strings</B
></DT
><DD
><P
>Use the <B
CLASS="COMMAND"
>strings</B
> command to find
	      printable strings in a binary or data file. It will list
	      sequences of printable characters found in the target
	      file. This might be handy for a quick 'n dirty examination
	      of a core dump or for looking at an unknown graphic image
	      file (<TT
CLASS="USERINPUT"
><B
>strings image-file | more</B
></TT
> might
	      show something like <TT
CLASS="COMPUTEROUTPUT"
>JFIF</TT
>,
	      which would identify the file as a <I
CLASS="EMPHASIS"
>jpeg</I
>
	      graphic). In a script, you would probably
	      parse the output of <B
CLASS="COMMAND"
>strings</B
>
	      with <A
HREF="textproc.html#GREPREF"
>grep</A
> or <A
HREF="sedawk.html#SEDREF"
>sed</A
>. See <A
HREF="loops.html#BINGREP"
>Example 10-7</A
>
	      and <A
HREF="loops.html#FINDSTRING"
>Example 10-8</A
>.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="WSTRINGS"
></A
><P
><B
>Example 12-26. An <SPAN
CLASS="QUOTE"
>"improved"</SPAN
> <I
CLASS="EMPHASIS"
>strings</I
>
	        command</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# wstrings.sh: "word-strings" (enhanced "strings" command)
   3&nbsp;#
   4&nbsp;#  This script filters the output of "strings" by checking it
   5&nbsp;#+ against a standard word list file.
   6&nbsp;#  This effectively eliminates all the gibberish and noise,
   7&nbsp;#+ and outputs only recognized words.
   8&nbsp;
   9&nbsp;# =================================================================
  10&nbsp;#                 Standard Check for Script Argument(s)
  11&nbsp;ARGS=1
  12&nbsp;E_BADARGS=65
  13&nbsp;E_NOFILE=66
  14&nbsp;
  15&nbsp;if [ $# -ne $ARGS ]
  16&nbsp;then
  17&nbsp;  echo "Usage: `basename $0` filename"
  18&nbsp;  exit $E_BADARGS
  19&nbsp;fi
  20&nbsp;
  21&nbsp;if [ -f "$1" ]                        # Check if file exists.
  22&nbsp;then
  23&nbsp;    file_name=$1
  24&nbsp;else
  25&nbsp;    echo "File \"$1\" does not exist."
  26&nbsp;    exit $E_NOFILE
  27&nbsp;fi
  28&nbsp;# =================================================================
  29&nbsp;
  30&nbsp;
  31&nbsp;MINSTRLEN=3                           #  Minimum string length.
  32&nbsp;WORDFILE=/usr/share/dict/linux.words  #  Dictionary file.
  33&nbsp;                                      #  May specify a different
  34&nbsp;                                      #+ word list file
  35&nbsp;                                      #+ of format 1 word per line.
  36&nbsp;
  37&nbsp;
  38&nbsp;wlist=`strings "$1" | tr A-Z a-z | tr '[:space:]' Z | \
  39&nbsp;tr -cs '[:alpha:]' Z | tr -s '\173-\377' Z | tr Z ' '`
  40&nbsp;
  41&nbsp;# Translate output of 'strings' command with multiple passes of 'tr'.
  42&nbsp;#  "tr A-Z a-z"  converts to lowercase.
  43&nbsp;#  "tr '[:space:]'"  converts whitespace characters to Z's.
  44&nbsp;#  "tr -cs '[:alpha:]' Z"  converts non-alphabetic characters to Z's,
  45&nbsp;#+ and squeezes multiple consecutive Z's.
  46&nbsp;#  "tr -s '\173-\377' Z"  converts all characters past 'z' to Z's
  47&nbsp;#+ and squeezes multiple consecutive Z's,
  48&nbsp;#+ which gets rid of all the weird characters that the previous
  49&nbsp;#+ translation failed to deal with.
  50&nbsp;#  Finally, "tr Z ' '" converts all those Z's to whitespace,
  51&nbsp;#+ which will be seen as word separators in the loop below.
  52&nbsp;
  53&nbsp;#  Note the technique of feeding the output of 'tr' back to itself,
  54&nbsp;#+ but with different arguments and/or options on each pass.
  55&nbsp;
  56&nbsp;
  57&nbsp;for word in $wlist                    # Important:
  58&nbsp;                                      # $wlist must not be quoted here.
  59&nbsp;                                      # "$wlist" does not work.
  60&nbsp;                                      # Why?
  61&nbsp;do
  62&nbsp;
  63&nbsp;  strlen=${#word}                     # String length.
  64&nbsp;  if [ "$strlen" -lt "$MINSTRLEN" ]   # Skip over short strings.
  65&nbsp;  then
  66&nbsp;    continue
  67&nbsp;  fi
  68&nbsp;
  69&nbsp;  grep -Fw $word "$WORDFILE"          # Match whole words only.
  70&nbsp;
  71&nbsp;done  
  72&nbsp;
  73&nbsp;
  74&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="FAUTILS1"
></A
>Utilities</B
></P
><DL
><DT
><B
CLASS="COMMAND"
>basename</B
></DT
><DD
><P
>Strips the path information from a file name, printing
	      only the file name. The construction  <TT
CLASS="USERINPUT"
><B
>basename
		$0</B
></TT
> lets the script know its name, that is, the name it
	      was invoked by. This can be used for <SPAN
CLASS="QUOTE"
>"usage"</SPAN
> messages if, 
	      for example a script is called with missing arguments:
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo "Usage: `basename $0` arg1 arg2 ... argn"</PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><B
CLASS="COMMAND"
>dirname</B
></DT
><DD
><P
>Strips the <B
CLASS="COMMAND"
>basename</B
> from
	    a filename, printing only the path information.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><B
CLASS="COMMAND"
>basename</B
> and <B
CLASS="COMMAND"
>dirname</B
>
		can operate on any arbitrary string. The argument
		does not need to refer to an existing file, or
		even be a filename for that matter (see <A
HREF="contributed-scripts.html#DAYSBETWEEN"
>Example A-6</A
>).</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX35"
></A
><P
><B
>Example 12-27. <B
CLASS="COMMAND"
>basename</B
> and <B
CLASS="COMMAND"
>dirname</B
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;a=/home/bozo/daily-journal.txt
   4&nbsp;
   5&nbsp;echo "Basename of /home/bozo/daily-journal.txt = `basename $a`"
   6&nbsp;echo "Dirname of /home/bozo/daily-journal.txt = `dirname $a`"
   7&nbsp;echo
   8&nbsp;echo "My own home is `basename ~/`."         # Also works with just ~.
   9&nbsp;echo "The home of my home is `dirname ~/`."  # Also works with just ~.
  10&nbsp;
  11&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><B
CLASS="COMMAND"
>split</B
></DT
><DD
><P
>Utility for splitting a file into smaller chunks. Usually used 
	      for splitting up large files in order to back them up on floppies or
	      preparatory to e-mailing or uploading them.</P
></DD
><DT
><B
CLASS="COMMAND"
>sum</B
>, <B
CLASS="COMMAND"
>cksum</B
>, <A
NAME="MD5SUMREF"
></A
><B
CLASS="COMMAND"
>md5sum</B
></DT
><DD
><P
>These are utilities for generating checksums. A
	      <I
CLASS="EMPHASIS"
>checksum</I
> is a number mathematically
	      calculated from the contents of a file, for the purpose
	      of checking its integrity. A script might refer to a list
	      of checksums for security purposes, such as ensuring that
	      the contents of key system files have not been altered or
	      corrupted. The <B
CLASS="COMMAND"
>md5sum</B
> command is the most
	      appropriate of these in security applications.</P
><P
>Note that <B
CLASS="COMMAND"
>cksum</B
> also shows the size,
	    in bytes, of the target file.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>cksum /boot/vmlinuz</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>1670054224 804083 /boot/vmlinuz</TT
>
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>md5sum /boot/vmlinuz</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>0f43eccea8f09e0a0b2b5cf1dcf333ba  /boot/vmlinuz</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="FAENCENCR1"
></A
>Encoding and Encryption</B
></P
><DL
><DT
><B
CLASS="COMMAND"
>uuencode</B
></DT
><DD
><P
>This utility encodes binary files into ASCII characters, making them
	      suitable for transmission in the body of an e-mail message or in a
	      newsgroup posting.</P
></DD
><DT
><B
CLASS="COMMAND"
>uudecode</B
></DT
><DD
><P
>This reverses the encoding, decoding uuencoded files back into the
	      original binaries.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX52"
></A
><P
><B
>Example 12-28. uudecoding encoded files</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;lines=35        # Allow 35 lines for the header (very generous).
   4&nbsp;
   5&nbsp;for File in *   # Test all the files in the current working directory...
   6&nbsp;do
   7&nbsp;  search1=`head -$lines $File | grep begin | wc -w`
   8&nbsp;  search2=`tail -$lines $File | grep end | wc -w`
   9&nbsp;  #  Uuencoded files have a "begin" near the beginning,
  10&nbsp;  #+ and an "end" near the end.
  11&nbsp;  if [ "$search1" -gt 0 ]
  12&nbsp;  then
  13&nbsp;    if [ "$search2" -gt 0 ]
  14&nbsp;    then
  15&nbsp;      echo "uudecoding - $File -"
  16&nbsp;      uudecode $File
  17&nbsp;    fi  
  18&nbsp;  fi
  19&nbsp;done  
  20&nbsp;
  21&nbsp;#  Note that running this script upon itself fools it
  22&nbsp;#+ into thinking it is a uuencoded file,
  23&nbsp;#+ because it contains both "begin" and "end".
  24&nbsp;
  25&nbsp;# Exercise:
  26&nbsp;# Modify this script to check for a newsgroup header.
  27&nbsp;
  28&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="TIP"
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <A
HREF="textproc.html#FOLDREF"
>fold -s</A
> command
	    may be useful (possibly in a pipe) to process long uudecoded
	    text messages downloaded from Usenet newsgroups.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><B
CLASS="COMMAND"
>mimencode</B
>, <B
CLASS="COMMAND"
>mmencode</B
></DT
><DD
><P
>The <B
CLASS="COMMAND"
>mimencode</B
> and
	      <B
CLASS="COMMAND"
>mmencode</B
> commands process
	      multimedia-encoded e-mail attachments. Although
	      <I
CLASS="EMPHASIS"
>mail user agents</I
> (such as
	      <B
CLASS="COMMAND"
>pine</B
> or <B
CLASS="COMMAND"
>kmail</B
>)
	      normally handle this automatically, these particular
	      utilities permit manipulating such attachments manually
	      from the command line or in a batch by means of a shell
	      script.</P
></DD
><DT
><B
CLASS="COMMAND"
>crypt</B
></DT
><DD
><P
>At one time, this was the standard UNIX file encryption
	      utility.

              <A
NAME="AEN7955"
HREF="#FTN.AEN7955"
>[2]</A
>

	      Politically motivated government regulations
	      prohibiting the export of encryption software resulted
	      in the disappearance of <B
CLASS="COMMAND"
>crypt</B
>
	      from much of the UNIX world, and it is still
	      missing from most Linux distributions. Fortunately,
	      programmers have come up with a number of decent
	      alternatives to it, among them the author's very own <A
HREF="ftp://metalab.unc.edu/pub/Linux/utils/file/cruft-0.2.tar.gz"
TARGET="_top"
>cruft</A
>
	      (see <A
HREF="contributed-scripts.html#ENCRYPTEDPW"
>Example A-4</A
>).  </P
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="FAMISC1"
></A
>Miscellaneous</B
></P
><DL
><DT
><B
CLASS="COMMAND"
>make</B
></DT
><DD
><P
>Utility for building and compiling binary packages. 
	      This can also be used for any set of operations that is
	      triggered by incremental changes in source files.</P
><P
><A
NAME="MAKEFILEREF"
></A
></P
><P
>The <B
CLASS="COMMAND"
>make</B
> command checks a
	    <TT
CLASS="FILENAME"
>Makefile</TT
>, a list of file dependencies and
	      operations to be carried out.</P
></DD
><DT
><B
CLASS="COMMAND"
>install</B
></DT
><DD
><P
>Special purpose file copying command, similar to
	      <B
CLASS="COMMAND"
>cp</B
>, but capable of setting permissions
	      and attributes of the copied files. This command seems
	      tailormade for installing software packages, and as such it
	      shows up frequently in <TT
CLASS="FILENAME"
>Makefiles</TT
>
	      (in the <TT
CLASS="REPLACEABLE"
><I
>make install :</I
></TT
>
	      section). It could likewise find use in installation
	      scripts.</P
></DD
><DT
><B
CLASS="COMMAND"
>more</B
>, <B
CLASS="COMMAND"
>less</B
></DT
><DD
><P
>Pagers that display a text file or stream to
	      <TT
CLASS="FILENAME"
>stdout</TT
>, one screenful at a time.
	      These may be used to filter the output of a script.</P
></DD
></DL
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN7431"
HREF="filearchiv.html#AEN7431"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>		    A <B
CLASS="COMMAND"
>tar czvf ...</B
>
		    <I
CLASS="EMPHASIS"
>will</I
> include dotfiles in
		    directories <I
CLASS="EMPHASIS"
>below</I
> the current
		    working directory. This is an undocumented
		    <B
CLASS="COMMAND"
>tar</B
> <SPAN
CLASS="QUOTE"
>"feature"</SPAN
>.
		  </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN7955"
HREF="filearchiv.html#AEN7955"
>[2]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>This is a symmetric block cipher, used to
	        encrypt files on a single system or local network, as opposed
		to the <SPAN
CLASS="QUOTE"
>"public key"</SPAN
> cipher class, of which
		<B
CLASS="COMMAND"
>pgp</B
> is a well-known
		example.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="textproc.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="communications.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Text Processing Commands</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="external.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Communications Commands</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
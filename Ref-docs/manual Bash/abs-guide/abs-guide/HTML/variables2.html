<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Variables Revisited</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.64
"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="Beyond the Basics"
HREF="part3.html"><LINK
REL="PREVIOUS"
TITLE="Beyond the Basics"
HREF="part3.html"><LINK
REL="NEXT"
TITLE="Manipulating Strings"
HREF="string-manipulation.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-family: sans-serif;"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="part3.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="string-manipulation.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="VARIABLES2"
>Chapter 9. Variables Revisited</A
></H1
><P
>Used properly, variables can add power and flexibility
	  to scripts. This requires learning their subtleties and
	  nuances.</P
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="INTERNALVARIABLES"
>9.1. Internal Variables</A
></H1
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
><A
HREF="internal.html#BUILTINREF"
>Builtin</A
> variables</I
></TT
></DT
><DD
><P
>variables affecting bash script behavior</P
></DD
><DT
><TT
CLASS="VARNAME"
>$BASH</TT
></DT
><DD
><P
>the path to the <I
CLASS="EMPHASIS"
>Bash</I
>
	    binary itself, usually <TT
CLASS="FILENAME"
>/bin/bash</TT
></P
></DD
><DT
><TT
CLASS="VARNAME"
>$BASH_ENV</TT
></DT
><DD
><P
>an environmental variable pointing to a Bash startup
	      file to be read when a script is invoked</P
></DD
><DT
><TT
CLASS="VARNAME"
>$BASH_VERSINFO[n]</TT
></DT
><DD
><P
>a 6-element <A
HREF="arrays.html#ARRAYREF"
>array</A
>
	    containing version information about the installed release
	    of Bash. This is similar to <TT
CLASS="VARNAME"
>$BASH_VERSION</TT
>,
	    below, but a bit more detailed.</P
><P
>	  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# Bash version info:
   2&nbsp;
   3&nbsp;for n in 0 1 2 3 4 5
   4&nbsp;do
   5&nbsp;  echo "BASH_VERSINFO[$n] = ${BASH_VERSINFO[$n]}"
   6&nbsp;done  
   7&nbsp;
   8&nbsp;# BASH_VERSINFO[0] = 2                      # Major version no.
   9&nbsp;# BASH_VERSINFO[1] = 04                     # Minor version no.
  10&nbsp;# BASH_VERSINFO[2] = 21                     # Patch level.
  11&nbsp;# BASH_VERSINFO[3] = 1                      # Build version.
  12&nbsp;# BASH_VERSINFO[4] = release                # Release status.
  13&nbsp;# BASH_VERSINFO[5] = i386-redhat-linux-gnu  # Architecture
  14&nbsp;                                            # (same as $MACHTYPE).</PRE
></TD
></TR
></TABLE
>
	  </P
></DD
><DT
><TT
CLASS="VARNAME"
>$BASH_VERSION</TT
></DT
><DD
><P
>the version of Bash installed on the system</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $BASH_VERSION</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>2.04.12(1)-release</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>tcsh% </TT
><TT
CLASS="USERINPUT"
><B
>echo $BASH_VERSION</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>BASH_VERSION: Undefined variable.</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><P
>Checking $BASH_VERSION is a good method of determining which
	    shell is running. <A
HREF="variables2.html#SHELLVARREF"
>$SHELL</A
>
	    does not necessarily give the correct answer.</P
></DD
><DT
><A
NAME="DIRSTACKREF"
></A
><TT
CLASS="VARNAME"
>$DIRSTACK</TT
></DT
><DD
><P
>contents of the directory stack (affected by
	    <A
HREF="internal.html#PUSHDREF"
>pushd</A
> and <A
HREF="internal.html#POPDREF"
>popd</A
>)</P
><P
>This
	    builtin variable is the counterpart to the <A
HREF="internal.html#DIRSD"
>dirs</A
> command.</P
></DD
><DT
><TT
CLASS="VARNAME"
>$EDITOR</TT
></DT
><DD
><P
>the default editor invoked by a script, usually
	      <B
CLASS="COMMAND"
>vi</B
> or <B
CLASS="COMMAND"
>emacs</B
>.</P
></DD
><DT
><A
NAME="EUIDREF"
></A
><TT
CLASS="VARNAME"
>$EUID</TT
></DT
><DD
><P
><SPAN
CLASS="QUOTE"
>"effective"</SPAN
> user id number</P
><P
>Identification number of whatever identity the
	      current user has assumed, perhaps by means of <A
HREF="system.html#SUREF"
>su</A
>.</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="VARNAME"
>$EUID</TT
> is not necessarily
	      the same as the <A
HREF="variables2.html#UIDREF"
>$UID</A
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="VARNAME"
>$FUNCNAME</TT
></DT
><DD
><P
>name of the current function</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;xyz23 ()
   2&nbsp;{
   3&nbsp;  echo "$FUNCNAME now executing."  # xyz23 now executing.
   4&nbsp;}
   5&nbsp;
   6&nbsp;xyz23
   7&nbsp;
   8&nbsp;echo "FUNCNAME = $FUNCNAME"        # FUNCNAME =
   9&nbsp;                                   # Null value outside a function.</PRE
></TD
></TR
></TABLE
>
            </P
></DD
><DT
><TT
CLASS="VARNAME"
>$GLOBIGNORE</TT
></DT
><DD
><P
>A list of filename patterns to be excluded from
	    matching in <A
HREF="globbingref.html"
>globbing</A
>.</P
></DD
><DT
><A
NAME="GROUPSREF"
></A
><TT
CLASS="VARNAME"
>$GROUPS</TT
></DT
><DD
><P
>groups current user belongs to</P
><P
>This is a listing (array) of the group id numbers for
	      current user, as  recorded in
	      <TT
CLASS="FILENAME"
>/etc/passwd</TT
>.
	    </P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>root# </TT
><TT
CLASS="USERINPUT"
><B
>echo $GROUPS</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>0</TT
>
 
 
 <TT
CLASS="PROMPT"
>root# </TT
><TT
CLASS="USERINPUT"
><B
>echo ${GROUPS[1]}</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>1</TT
>
 
 
 <TT
CLASS="PROMPT"
>root# </TT
><TT
CLASS="USERINPUT"
><B
>echo ${GROUPS[5]}</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>6</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
></DD
><DT
><A
NAME="HOMEDIRREF"
></A
><TT
CLASS="VARNAME"
>$HOME</TT
></DT
><DD
><P
>home directory of the user, usually <TT
CLASS="FILENAME"
>/home/username</TT
> (see <A
HREF="parameter-substitution.html#EX6"
>Example 9-11</A
>)</P
></DD
><DT
><A
NAME="HOSTNAMEREF"
></A
><TT
CLASS="VARNAME"
>$HOSTNAME</TT
></DT
><DD
><P
>The <A
HREF="system.html#HNAMEREF"
>hostname</A
> command
	    assigns the system name at bootup in an init script.
	    However, the <TT
CLASS="FUNCTION"
>gethostname()</TT
> function
	    sets the Bash internal variable <TT
CLASS="VARNAME"
>$HOSTNAME</TT
>.
	    See also <A
HREF="parameter-substitution.html#EX6"
>Example 9-11</A
>.</P
></DD
><DT
><TT
CLASS="VARNAME"
>$HOSTTYPE</TT
></DT
><DD
><P
>host type</P
><P
>Like <A
HREF="variables2.html#MACHTYPEREF"
>$MACHTYPE</A
>,
	      identifies the system hardware.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $HOSTTYPE</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>i686</TT
></PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="IFSREF"
></A
><TT
CLASS="VARNAME"
>$IFS</TT
></DT
><DD
><P
>input field separator</P
><P
>This defaults to <A
HREF="special-chars.html#WHITESPACEREF"
>whitespace</A
> (space,
	      tab, and newline), but may be changed, for example,
	      to parse a comma-separated data file.  Note that
	      <A
HREF="variables2.html#APPREF"
>$*</A
> uses the first
	      character held in <TT
CLASS="VARNAME"
>$IFS</TT
>.  See <A
HREF="quoting.html#WEIRDVARS"
>Example 6-1</A
>.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $IFS | cat -vte</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>$</TT
>
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>bash -c 'set w x y z; IFS=":-;"; echo "$*"'</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>w:x:y:z</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	  </P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><TT
CLASS="VARNAME"
>$IFS</TT
> does not handle whitespace
	    the same as it does other characters.

	  <DIV
CLASS="EXAMPLE"
><HR><A
NAME="IFSH"
></A
><P
><B
>Example 9-1. $IFS and whitespace</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# $IFS treats whitespace differently than other characters.
   3&nbsp;
   4&nbsp;output_args_one_per_line()
   5&nbsp;{
   6&nbsp;  for arg
   7&nbsp;  do echo "[$arg]"
   8&nbsp;  done
   9&nbsp;}
  10&nbsp;
  11&nbsp;echo; echo "IFS=\" \""
  12&nbsp;echo "-------"
  13&nbsp;
  14&nbsp;IFS=" "
  15&nbsp;var=" a  b c   "
  16&nbsp;output_args_one_per_line $var  # output_args_one_per_line `echo " a  b c   "`
  17&nbsp;#
  18&nbsp;# [a]
  19&nbsp;# [b]
  20&nbsp;# [c]
  21&nbsp;
  22&nbsp;
  23&nbsp;echo; echo "IFS=:"
  24&nbsp;echo "-----"
  25&nbsp;
  26&nbsp;IFS=:
  27&nbsp;var=":a::b:c:::"               # Same as above, but substitute ":" for " ".
  28&nbsp;output_args_one_per_line $var
  29&nbsp;#
  30&nbsp;# []
  31&nbsp;# [a]
  32&nbsp;# []
  33&nbsp;# [b]
  34&nbsp;# [c]
  35&nbsp;# []
  36&nbsp;# []
  37&nbsp;# []
  38&nbsp;
  39&nbsp;# The same thing happens with the "FS" field separator in awk.
  40&nbsp;
  41&nbsp;# Thank you, Stephane Chazelas.
  42&nbsp;
  43&nbsp;echo
  44&nbsp;
  45&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
>

	  </P
></TD
></TR
></TABLE
></DIV
><P
>(Thanks, S. C., for clarification and examples.)</P
></DD
><DT
><TT
CLASS="VARNAME"
>$IGNOREEOF</TT
></DT
><DD
><P
>ignore EOF: how many end-of-files (control-D)
	    the shell will ignore before logging out.</P
></DD
><DT
><TT
CLASS="VARNAME"
>$LC_COLLATE</TT
></DT
><DD
><P
>Often set in the <TT
CLASS="FILENAME"
>.bashrc</TT
> or
	    <TT
CLASS="FILENAME"
>/etc/profile</TT
> files, this
	    variable controls collation order in filename
	    expansion and pattern matching. If mishandled,
	    <TT
CLASS="VARNAME"
>LC_COLLATE</TT
> can cause unexpected results
	    in <A
HREF="globbingref.html"
>filename
	    globbing</A
>.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>As of version 2.05 of Bash,
	    filename globbing no longer distinguishes between lowercase
	    and uppercase letters in a character range between
	    brackets. For example, <B
CLASS="COMMAND"
>ls [A-M]*</B
>
	    would match both <TT
CLASS="FILENAME"
>File1.txt</TT
>
	    and <TT
CLASS="FILENAME"
>file1.txt</TT
>. To revert to
	    the customary behavior of bracket matching, set
	    <TT
CLASS="VARNAME"
>LC_COLLATE</TT
> to <TT
CLASS="OPTION"
>C</TT
>
	    by an <TT
CLASS="USERINPUT"
><B
>export LC_COLLATE=C</B
></TT
>
	    in <TT
CLASS="FILENAME"
>/etc/profile</TT
> and/or
	    <TT
CLASS="FILENAME"
>~/.bashrc</TT
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="VARNAME"
>$LC_CTYPE</TT
></DT
><DD
><P
>This internal variable controls character interpretation
	    in <A
HREF="globbingref.html"
>globbing</A
> and pattern
	    matching.</P
></DD
><DT
><TT
CLASS="VARNAME"
>$LINENO</TT
></DT
><DD
><P
>This variable is the line number of the shell
	    script in which this variable appears. It has significance only
	    within the script in which it appears, and is chiefly useful for
	    debugging purposes.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;last_cmd_arg=$_  # Save it.
   2&nbsp;
   3&nbsp;echo "At line number $LINENO, variable \"v1\" = $v1"
   4&nbsp;echo "Last command argument processed = $last_cmd_arg"</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><A
NAME="MACHTYPEREF"
></A
><TT
CLASS="VARNAME"
>$MACHTYPE</TT
></DT
><DD
><P
>machine type</P
><P
>Identifies the system hardware.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $MACHTYPE</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>i686-debian-linux-gnu</TT
></PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="OLDPWD"
></A
><TT
CLASS="VARNAME"
>$OLDPWD</TT
></DT
><DD
><P
>old working directory
	  (<SPAN
CLASS="QUOTE"
>"OLD-print-working-directory"</SPAN
>,
	    previous directory you were in)</P
></DD
><DT
><TT
CLASS="VARNAME"
>$OSTYPE</TT
></DT
><DD
><P
>operating system type</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $OSTYPE</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>linux-gnu</TT
></PRE
></TD
></TR
></TABLE
></DD
><DT
><A
NAME="PATHREF"
></A
><TT
CLASS="VARNAME"
>$PATH</TT
></DT
><DD
><P
>path to binaries, usually 
	      <TT
CLASS="FILENAME"
>/usr/bin/</TT
>, 
	      <TT
CLASS="FILENAME"
>/usr/X11R6/bin/</TT
>, 
	      <TT
CLASS="FILENAME"
>/usr/local/bin</TT
>, etc.</P
><P
>When given a command, the shell automatically does
	      a hash table search on the directories listed in the
	      <I
CLASS="EMPHASIS"
>path</I
> for the executable. The
	      path is stored in the environmental variable,
	      <TT
CLASS="VARNAME"
>$PATH</TT
>, a list of directories,
	      separated by colons. Normally, the system
	      stores the <TT
CLASS="VARNAME"
>$PATH</TT
> definition
	      in <TT
CLASS="FILENAME"
>/etc/profile</TT
> and/or
	      <TT
CLASS="FILENAME"
>~/.bashrc</TT
> (see <A
HREF="files.html"
>Chapter 27</A
>).</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><B
CLASS="COMMAND"
>echo $PATH</B
>
 <TT
CLASS="COMPUTEROUTPUT"
>/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:/sbin:/usr/sbin</TT
></PRE
></TD
></TR
></TABLE
>
              </P
><P
><TT
CLASS="USERINPUT"
><B
>PATH=${PATH}:/opt/bin</B
></TT
> appends
	      the <TT
CLASS="FILENAME"
>/opt/bin</TT
>
	      directory to the current path. In a script, it may be
	      expedient to temporarily add a directory to the path
	      in this way. When the script exits, this restores the
	      original <TT
CLASS="VARNAME"
>$PATH</TT
> (a child process, such
	      as a script, may not change the environment of the parent
	      process, the shell).</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The current <SPAN
CLASS="QUOTE"
>"working directory"</SPAN
>, 
	      <TT
CLASS="FILENAME"
>./</TT
>, is usually
	      omitted from the <TT
CLASS="VARNAME"
>$PATH</TT
> as a security
	      measure.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="VARNAME"
>$PIPESTATUS</TT
></DT
><DD
><P
>Exit status of last executed <A
HREF="special-chars.html#PIPEREF"
>pipe</A
>. Interestingly enough,
	    this does not give the same result as the <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
> of the last
	    executed command.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $PIPESTATUS</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>0</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ls -al | bogus_command</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>bash: bogus_command: command not found</TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $PIPESTATUS</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>141</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ls -al | bogus_command</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>bash: bogus_command: command not found</TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $?</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>127</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
></DD
><DT
><A
NAME="PPIDREF"
></A
><TT
CLASS="VARNAME"
>$PPID</TT
></DT
><DD
><P
></P
><P
>The <TT
CLASS="VARNAME"
>$PPID</TT
> of a process is
	    the process id (<TT
CLASS="VARNAME"
>pid</TT
>) of its parent process.

	      <A
NAME="AEN3322"
HREF="#FTN.AEN3322"
>[1]</A
>
	      </P
><P
>Compare this with the <A
HREF="system.html#PIDOFREF"
>pidof</A
> command.</P
></DD
><DT
><A
NAME="PS1REF"
></A
><TT
CLASS="VARNAME"
>$PS1</TT
></DT
><DD
><P
>This is the main prompt, seen at the command line.</P
></DD
><DT
><TT
CLASS="VARNAME"
>$PS2</TT
></DT
><DD
><P
>The secondary prompt, seen when additional input is
	    expected. It displays as <SPAN
CLASS="QUOTE"
>"&#62;"</SPAN
>.</P
></DD
><DT
><TT
CLASS="VARNAME"
>$PS3</TT
></DT
><DD
><P
>The tertiary prompt, displayed in a
	    <A
HREF="testbranch.html#SELECTREF"
>select</A
> loop (see <A
HREF="testbranch.html#EX31"
>Example 10-27</A
>).</P
></DD
><DT
><TT
CLASS="VARNAME"
>$PS4</TT
></DT
><DD
><P
>The quartenary prompt, shown at the beginning of
	    each line of output when invoking a script with the
	    <SPAN
CLASS="TOKEN"
>-x</SPAN
> <A
HREF="options.html#OPTIONSREF"
>option</A
>.
	    It displays as <SPAN
CLASS="QUOTE"
>"+"</SPAN
>.</P
></DD
><DT
><A
NAME="PWDREF"
></A
><TT
CLASS="VARNAME"
>$PWD</TT
></DT
><DD
><P
>working directory (directory you are in at the time)</P
><P
>This is the analog to the <A
HREF="internal.html#PWD2REF"
>pwd</A
>
	    builtin command.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;E_WRONG_DIRECTORY=73
   4&nbsp;
   5&nbsp;clear # Clear screen.
   6&nbsp;
   7&nbsp;TargetDirectory=/home/bozo/projects/GreatAmericanNovel
   8&nbsp;
   9&nbsp;cd $TargetDirectory
  10&nbsp;echo "Deleting stale files in $TargetDirectory."
  11&nbsp;
  12&nbsp;if [ "$PWD" != "$TargetDirectory" ]
  13&nbsp;then    # Keep from wiping out wrong directory by accident.
  14&nbsp;  echo "Wrong directory!"
  15&nbsp;  echo "In $PWD, rather than $TargetDirectory!"
  16&nbsp;  echo "Bailing out!"
  17&nbsp;  exit $E_WRONG_DIRECTORY
  18&nbsp;fi  
  19&nbsp;
  20&nbsp;rm -rf *
  21&nbsp;rm .[A-Za-z0-9]*    # Delete dotfiles.
  22&nbsp;# rm -f .[^.]* ..?*   to remove filenames beginning with multiple dots.
  23&nbsp;# (shopt -s dotglob; rm -f *)   will also work.
  24&nbsp;# Thanks, S.C. for pointing this out.
  25&nbsp;
  26&nbsp;# Filenames may contain all characters in the 0 - 255 range, except "/".
  27&nbsp;# Deleting files beginning with weird characters is left as an exercise.
  28&nbsp;
  29&nbsp;# Various other operations here, as necessary.
  30&nbsp;
  31&nbsp;echo
  32&nbsp;echo "Done."
  33&nbsp;echo "Old files deleted in $TargetDirectory."
  34&nbsp;echo
  35&nbsp;
  36&nbsp;
  37&nbsp;exit 0</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><TT
CLASS="VARNAME"
>$REPLY</TT
></DT
><DD
><P
>The default value when a variable is not
	    supplied to <A
HREF="internal.html#READREF"
>read</A
>. Also
	    applicable to <A
HREF="testbranch.html#SELECTREF"
>select</A
> menus,
	    but only supplies the item number of the variable chosen,
	    not the value of the variable itself.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;echo
   4&nbsp;echo -n "What is your favorite vegetable? "
   5&nbsp;read
   6&nbsp;
   7&nbsp;echo "Your favorite vegetable is $REPLY."
   8&nbsp;# REPLY holds the value of last "read" if and only if
   9&nbsp;# no variable supplied.
  10&nbsp;
  11&nbsp;echo
  12&nbsp;echo -n "What is your favorite fruit? "
  13&nbsp;read fruit
  14&nbsp;echo "Your favorite fruit is $fruit."
  15&nbsp;echo "but..."
  16&nbsp;echo "Value of \$REPLY is still $REPLY."
  17&nbsp;# $REPLY is still set to its previous value because
  18&nbsp;# the variable $fruit absorbed the new "read" value.
  19&nbsp;
  20&nbsp;echo
  21&nbsp;
  22&nbsp;exit 0</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><TT
CLASS="VARNAME"
>$SECONDS</TT
></DT
><DD
><P
>The number of seconds the script has been running.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;ENDLESS_LOOP=1
   4&nbsp;INTERVAL=1
   5&nbsp;
   6&nbsp;echo
   7&nbsp;echo "Hit Control-C to exit this script."
   8&nbsp;echo
   9&nbsp;
  10&nbsp;while [ $ENDLESS_LOOP ]
  11&nbsp;do
  12&nbsp;  if [ "$SECONDS" -eq 1 ]
  13&nbsp;  then
  14&nbsp;    units=second
  15&nbsp;  else  
  16&nbsp;    units=seconds
  17&nbsp;  fi
  18&nbsp;
  19&nbsp;  echo "This script has been running $SECONDS $units."
  20&nbsp;  sleep $INTERVAL
  21&nbsp;done
  22&nbsp;
  23&nbsp;
  24&nbsp;exit 0</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><TT
CLASS="VARNAME"
>$SHELLOPTS</TT
></DT
><DD
><P
>the list of enabled shell <A
HREF="options.html#OPTIONSREF"
>options</A
>, a readonly
	    variable</P
></DD
><DT
><TT
CLASS="VARNAME"
>$SHLVL</TT
></DT
><DD
><P
>Shell level, how deeply Bash is nested.  If,
	    at the command line, $SHLVL is 1, then in a script it will
	    increment to 2.</P
></DD
><DT
><TT
CLASS="VARNAME"
>$TMOUT</TT
></DT
><DD
><P
>If the <TT
CLASS="REPLACEABLE"
><I
>$TMOUT</I
></TT
>
	  environmental variable is set to a non-zero value
	  <I
CLASS="EMPHASIS"
>time</I
>, then the shell prompt will time out
	  after <I
CLASS="EMPHASIS"
>time</I
> seconds. This will cause a
	  logout.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Unfortunately, this works only while waiting
	    for input at the shell prompt console or in an xterm. While
	    it would be nice to speculate on the uses of this
	    internal variable for timed input, for example in
	    combination with <A
HREF="internal.html#READREF"
>read</A
>,
	    <TT
CLASS="REPLACEABLE"
><I
>$TMOUT</I
></TT
> does not work
	    in that context and is virtually useless for shell
	    scripting. (Reportedly the <I
CLASS="EMPHASIS"
>ksh</I
> version
	    of a timed <B
CLASS="COMMAND"
>read</B
> does work).</P
></TD
></TR
></TABLE
></DIV
><P
>Implementing timed input in a script is certainly
	    possible, but hardly seems worth the effort. One method is to
	    set up a timing loop to signal the script when it times out.
	    This also requires a signal handling routine to trap (see
	    <A
HREF="debugging.html#EX76"
>Example 30-4</A
>) the interrupt generated by the timing
	    loop (whew!).</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="TMDIN"
></A
><P
><B
>Example 9-2. Timed Input</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# timed-input.sh
   3&nbsp;
   4&nbsp;# TMOUT=3            useless in a script
   5&nbsp;
   6&nbsp;TIMELIMIT=3  # Three seconds in this instance, may be set to different value.
   7&nbsp;
   8&nbsp;PrintAnswer()
   9&nbsp;{
  10&nbsp;  if [ "$answer" = TIMEOUT ]
  11&nbsp;  then
  12&nbsp;    echo $answer
  13&nbsp;  else       # Don't want to mix up the two instances. 
  14&nbsp;    echo "Your favorite veggie is $answer"
  15&nbsp;    kill $!  # Kills no longer needed TimerOn function running in background.
  16&nbsp;             # $! is PID of last job running in background.
  17&nbsp;  fi
  18&nbsp;
  19&nbsp;}  
  20&nbsp;
  21&nbsp;
  22&nbsp;
  23&nbsp;TimerOn()
  24&nbsp;{
  25&nbsp;  sleep $TIMELIMIT &#38;&#38; kill -s 14 $$ &#38;
  26&nbsp;  # Waits 3 seconds, then sends sigalarm to script.
  27&nbsp;}  
  28&nbsp;
  29&nbsp;Int14Vector()
  30&nbsp;{
  31&nbsp;  answer="TIMEOUT"
  32&nbsp;  PrintAnswer
  33&nbsp;  exit 14
  34&nbsp;}  
  35&nbsp;
  36&nbsp;trap Int14Vector 14   # Timer interrupt (14) subverted for our purposes.
  37&nbsp;
  38&nbsp;echo "What is your favorite vegetable "
  39&nbsp;TimerOn
  40&nbsp;read answer
  41&nbsp;PrintAnswer
  42&nbsp;
  43&nbsp;
  44&nbsp;#  Admittedly, this is a kludgy implementation of timed input,
  45&nbsp;#+ but pretty much as good as can be done with Bash.
  46&nbsp;#  (Challenge: come up with something better.)
  47&nbsp;
  48&nbsp;# If you need something a bit more elegant...
  49&nbsp;# consider writing the application in C or C++,
  50&nbsp;# using appropriate library functions, such as 'alarm' and 'setitimer'.
  51&nbsp;
  52&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>An alternative is using <A
HREF="system.html#STTYREF"
>stty</A
>.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="TIMEOUT"
></A
><P
><B
>Example 9-3. Once more, timed input</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# timeout.sh
   3&nbsp;
   4&nbsp;# Written by Stephane Chazelas,
   5&nbsp;# and modified by the document author.
   6&nbsp;
   7&nbsp;INTERVAL=5                # timeout interval
   8&nbsp;
   9&nbsp;timedout_read() {
  10&nbsp;  timeout=$1
  11&nbsp;  varname=$2
  12&nbsp;  old_tty_settings=`stty -g`
  13&nbsp;  stty -icanon min 0 time ${timeout}0
  14&nbsp;  eval read $varname      # or just    read $varname
  15&nbsp;  stty "$old_tty_settings"
  16&nbsp;  # See man page for "stty".
  17&nbsp;}
  18&nbsp;
  19&nbsp;echo; echo -n "What's your name? Quick! "
  20&nbsp;timedout_read $INTERVAL your_name
  21&nbsp;
  22&nbsp;# This may not work on every terminal type.
  23&nbsp;# The maximum timeout depends on the terminal.
  24&nbsp;# (it is often 25.5 seconds).
  25&nbsp;
  26&nbsp;echo
  27&nbsp;
  28&nbsp;if [ ! -z "$your_name" ]  # If name input before timeout...
  29&nbsp;then
  30&nbsp;  echo "Your name is $your_name."
  31&nbsp;else
  32&nbsp;  echo "Timed out."
  33&nbsp;fi
  34&nbsp;
  35&nbsp;echo
  36&nbsp;
  37&nbsp;# The behavior of this script differs somewhat from "timed-input.sh".
  38&nbsp;# At each keystroke, the counter resets.
  39&nbsp;
  40&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><A
NAME="UIDREF"
></A
><TT
CLASS="VARNAME"
>$UID</TT
></DT
><DD
><P
>user id number</P
><P
>current user's user identification number, as
	      recorded in <TT
CLASS="FILENAME"
>/etc/passwd</TT
>
	    </P
><P
>This is the current user's real id, even if she has
	      temporarily assumed another identity through <A
HREF="system.html#SUREF"
>su</A
>. <TT
CLASS="VARNAME"
>$UID</TT
> is a
	      readonly variable, not subject to change from the command
	      line or within a script, and is the counterpart to the
	      <A
HREF="system.html#IDREF"
>id</A
> builtin.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="AMIROOT"
></A
><P
><B
>Example 9-4. Am I root?</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# am-i-root.sh:   Am I root or not?
   3&nbsp;
   4&nbsp;ROOT_UID=0   # Root has $UID 0.
   5&nbsp;
   6&nbsp;if [ "$UID" -eq "$ROOT_UID" ]  # Will the real "root" please stand up?
   7&nbsp;then
   8&nbsp;  echo "You are root."
   9&nbsp;else
  10&nbsp;  echo "You are just an ordinary user (but mom loves you just the same)."
  11&nbsp;fi
  12&nbsp;
  13&nbsp;exit 0
  14&nbsp;
  15&nbsp;
  16&nbsp;# ============================================================= #
  17&nbsp;# Code below will not execute, because the script already exited.
  18&nbsp;
  19&nbsp;# An alternate method of getting to the root of matters:
  20&nbsp;
  21&nbsp;ROOTUSER_NAME=root
  22&nbsp;
  23&nbsp;username=`id -nu`
  24&nbsp;if [ "$username" = "$ROOTUSER_NAME" ]
  25&nbsp;then
  26&nbsp;  echo "Rooty, toot, toot. You are root."
  27&nbsp;else
  28&nbsp;  echo "You are just a regular fella."
  29&nbsp;fi
  30&nbsp;
  31&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>See also <A
HREF="sha-bang.html#EX2"
>Example 2-2</A
>.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The variables <TT
CLASS="VARNAME"
>$ENV</TT
>,
	  <TT
CLASS="VARNAME"
>$LOGNAME</TT
>, <TT
CLASS="VARNAME"
>$MAIL</TT
>,
	  <TT
CLASS="VARNAME"
>$TERM</TT
>, <TT
CLASS="VARNAME"
>$USER</TT
>, and
	  <TT
CLASS="VARNAME"
>$USERNAME</TT
> are <I
CLASS="EMPHASIS"
>not</I
>
	  Bash <A
HREF="internal.html#BUILTINREF"
>builtins</A
>. These
	  are, however, often set as environmental variables
	  in one of the Bash <A
HREF="files.html#FILESREF"
>startup files</A
>.
	  <A
NAME="SHELLVARREF"
></A
><TT
CLASS="VARNAME"
>$SHELL</TT
>,
	  the name of the user's login shell, may be set from
	  <TT
CLASS="FILENAME"
>/etc/passwd</TT
> or in an <SPAN
CLASS="QUOTE"
>"init"</SPAN
>
	  script, and it is likewise not a Bash builtin.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>tcsh% </TT
><TT
CLASS="USERINPUT"
><B
>echo $LOGNAME</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>bozo</TT
>
 <TT
CLASS="PROMPT"
>tcsh% </TT
><TT
CLASS="USERINPUT"
><B
>echo $SHELL</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/bin/tcsh</TT
>
 <TT
CLASS="PROMPT"
>tcsh% </TT
><TT
CLASS="USERINPUT"
><B
>echo $TERM</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>rxvt</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $LOGNAME</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>bozo</TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $SHELL</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/bin/tcsh</TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $TERM</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>rxvt</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
></TD
></TR
></TABLE
></DIV
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
>Positional Parameters</B
></P
><DL
><DT
><A
NAME="POSPARAMREF"
></A
><TT
CLASS="VARNAME"
>$0</TT
>, <TT
CLASS="VARNAME"
>$1</TT
>,
	  <TT
CLASS="VARNAME"
>$2</TT
>, etc.</DT
><DD
><P
>positional parameters, passed from command
	      line to script, passed to a function, or <A
HREF="internal.html#SETREF"
>set</A
> to a variable (see <A
HREF="othertypesv.html#EX17"
>Example 5-5</A
> and <A
HREF="internal.html#EX34"
>Example 11-10</A
>)</P
></DD
><DT
><TT
CLASS="VARNAME"
>$#</TT
></DT
><DD
><P
>number of command line arguments
		<A
NAME="AEN3596"
HREF="#FTN.AEN3596"
>[2]</A
>
	    or positional parameters (see <A
HREF="wrapper.html#EX4"
>Example 34-2</A
>)</P
></DD
><DT
><A
NAME="APPREF"
></A
><TT
CLASS="VARNAME"
>$*</TT
></DT
><DD
><P
>All of the positional parameters, seen as a single
	    word</P
></DD
><DT
><TT
CLASS="VARNAME"
>$@</TT
></DT
><DD
><P
>Same as <SPAN
CLASS="TOKEN"
>$*</SPAN
>, but each parameter is a
	      quoted string, that is, the parameters are passed on
	      intact, without interpretation or expansion. This means,
	      among other things, that each parameter in the argument
	      list is seen as a separate word.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ARGLIST"
></A
><P
><B
>Example 9-5. <B
CLASS="COMMAND"
>arglist</B
>: Listing arguments with $* and $@</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# Invoke this script with several arguments, such as "one two three".
   3&nbsp;
   4&nbsp;E_BADARGS=65
   5&nbsp;
   6&nbsp;if [ ! -n "$1" ]
   7&nbsp;then
   8&nbsp;  echo "Usage: `basename $0` argument1 argument2 etc."
   9&nbsp;  exit $E_BADARGS
  10&nbsp;fi  
  11&nbsp;
  12&nbsp;echo
  13&nbsp;
  14&nbsp;index=1
  15&nbsp;
  16&nbsp;echo "Listing args with \"\$*\":"
  17&nbsp;for arg in "$*"  # Doesn't work properly if "$*" isn't quoted.
  18&nbsp;do
  19&nbsp;  echo "Arg #$index = $arg"
  20&nbsp;  let "index+=1"
  21&nbsp;done             # $* sees all arguments as single word. 
  22&nbsp;echo "Entire arg list seen as single word."
  23&nbsp;
  24&nbsp;echo
  25&nbsp;
  26&nbsp;index=1
  27&nbsp;
  28&nbsp;echo "Listing args with \"\$@\":"
  29&nbsp;for arg in "$@"
  30&nbsp;do
  31&nbsp;  echo "Arg #$index = $arg"
  32&nbsp;  let "index+=1"
  33&nbsp;done             # $@ sees arguments as separate words. 
  34&nbsp;echo "Arg list seen as separate words."
  35&nbsp;
  36&nbsp;echo
  37&nbsp;
  38&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Following a <B
CLASS="COMMAND"
>shift</B
>, the
	      <TT
CLASS="VARNAME"
>$@</TT
> holds the remaining command-line
	      parameters, lacking the previous <TT
CLASS="VARNAME"
>$1</TT
>,
	      which was lost.
	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# Invoke with ./scriptname 1 2 3 4 5
   3&nbsp;
   4&nbsp;echo "$@"    # 1 2 3 4 5
   5&nbsp;shift
   6&nbsp;echo "$@"    # 2 3 4 5
   7&nbsp;shift
   8&nbsp;echo "$@"    # 3 4 5
   9&nbsp;
  10&nbsp;# Each "shift" loses parameter $1.
  11&nbsp;# "$@" then contains the remaining parameters.</PRE
></TD
></TR
></TABLE
>
            </P
><P
>The <TT
CLASS="VARNAME"
>$@</TT
> special parameter finds
	      use as a tool for filtering input into shell scripts. The
	      <B
CLASS="COMMAND"
>cat "$@"</B
> construction accepts input
	      to a script either from <TT
CLASS="FILENAME"
>stdin</TT
> or
	      from files given as parameters to the script. See <A
HREF="textproc.html#ROT13"
>Example 12-17</A
> and <A
HREF="textproc.html#CRYPTOQUOTE"
>Example 12-18</A
>.</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="VARNAME"
>$*</TT
> and <TT
CLASS="VARNAME"
>$@</TT
>
	      parameters sometimes display inconsistent and
	      puzzling behavior, depending on the setting of <A
HREF="variables2.html#IFSREF"
>$IFS</A
>.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="INCOMPAT"
></A
><P
><B
>Example 9-6. Inconsistent <TT
CLASS="VARNAME"
>$*</TT
> and <TT
CLASS="VARNAME"
>$@</TT
> behavior</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# Erratic behavior of the "$*" and "$@" internal Bash variables,
   4&nbsp;# depending on whether these are quoted or not.
   5&nbsp;# Word splitting and linefeeds handled inconsistently.
   6&nbsp;
   7&nbsp;# This example script by Stephane Chazelas,
   8&nbsp;# and slightly modified by the document author.
   9&nbsp;
  10&nbsp;
  11&nbsp;set -- "First one" "second" "third:one" "" "Fifth: :one"
  12&nbsp;# Setting the script arguments, $1, $2, etc.
  13&nbsp;
  14&nbsp;echo
  15&nbsp;
  16&nbsp;echo 'IFS unchanged, using "$*"'
  17&nbsp;c=0
  18&nbsp;for i in "$*"               # quoted
  19&nbsp;do echo "$((c+=1)): [$i]"   # This line remains the same in every instance.
  20&nbsp;                            # Echo args.
  21&nbsp;done
  22&nbsp;echo ---
  23&nbsp;
  24&nbsp;echo 'IFS unchanged, using $*'
  25&nbsp;c=0
  26&nbsp;for i in $*                 # unquoted
  27&nbsp;do echo "$((c+=1)): [$i]"
  28&nbsp;done
  29&nbsp;echo ---
  30&nbsp;
  31&nbsp;echo 'IFS unchanged, using "$@"'
  32&nbsp;c=0
  33&nbsp;for i in "$@"
  34&nbsp;do echo "$((c+=1)): [$i]"
  35&nbsp;done
  36&nbsp;echo ---
  37&nbsp;
  38&nbsp;echo 'IFS unchanged, using $@'
  39&nbsp;c=0
  40&nbsp;for i in $@
  41&nbsp;do echo "$((c+=1)): [$i]"
  42&nbsp;done
  43&nbsp;echo ---
  44&nbsp;
  45&nbsp;IFS=:
  46&nbsp;echo 'IFS=":", using "$*"'
  47&nbsp;c=0
  48&nbsp;for i in "$*"
  49&nbsp;do echo "$((c+=1)): [$i]"
  50&nbsp;done
  51&nbsp;echo ---
  52&nbsp;
  53&nbsp;echo 'IFS=":", using $*'
  54&nbsp;c=0
  55&nbsp;for i in $*
  56&nbsp;do echo "$((c+=1)): [$i]"
  57&nbsp;done
  58&nbsp;echo ---
  59&nbsp;
  60&nbsp;var=$*
  61&nbsp;echo 'IFS=":", using "$var" (var=$*)'
  62&nbsp;c=0
  63&nbsp;for i in "$var"
  64&nbsp;do echo "$((c+=1)): [$i]"
  65&nbsp;done
  66&nbsp;echo ---
  67&nbsp;
  68&nbsp;echo 'IFS=":", using $var (var=$*)'
  69&nbsp;c=0
  70&nbsp;for i in $var
  71&nbsp;do echo "$((c+=1)): [$i]"
  72&nbsp;done
  73&nbsp;echo ---
  74&nbsp;
  75&nbsp;var="$*"
  76&nbsp;echo 'IFS=":", using $var (var="$*")'
  77&nbsp;c=0
  78&nbsp;for i in $var
  79&nbsp;do echo "$((c+=1)): [$i]"
  80&nbsp;done
  81&nbsp;echo ---
  82&nbsp;
  83&nbsp;echo 'IFS=":", using "$var" (var="$*")'
  84&nbsp;c=0
  85&nbsp;for i in "$var"
  86&nbsp;do echo "$((c+=1)): [$i]"
  87&nbsp;done
  88&nbsp;echo ---
  89&nbsp;
  90&nbsp;echo 'IFS=":", using "$@"'
  91&nbsp;c=0
  92&nbsp;for i in "$@"
  93&nbsp;do echo "$((c+=1)): [$i]"
  94&nbsp;done
  95&nbsp;echo ---
  96&nbsp;
  97&nbsp;echo 'IFS=":", using $@'
  98&nbsp;c=0
  99&nbsp;for i in $@
 100&nbsp;do echo "$((c+=1)): [$i]"
 101&nbsp;done
 102&nbsp;echo ---
 103&nbsp;
 104&nbsp;var=$@
 105&nbsp;echo 'IFS=":", using $var (var=$@)'
 106&nbsp;c=0
 107&nbsp;for i in $var
 108&nbsp;do echo "$((c+=1)): [$i]"
 109&nbsp;done
 110&nbsp;echo ---
 111&nbsp;
 112&nbsp;echo 'IFS=":", using "$var" (var=$@)'
 113&nbsp;c=0
 114&nbsp;for i in "$var"
 115&nbsp;do echo "$((c+=1)): [$i]"
 116&nbsp;done
 117&nbsp;echo ---
 118&nbsp;
 119&nbsp;var="$@"
 120&nbsp;echo 'IFS=":", using "$var" (var="$@")'
 121&nbsp;c=0
 122&nbsp;for i in "$var"
 123&nbsp;do echo "$((c+=1)): [$i]"
 124&nbsp;done
 125&nbsp;echo ---
 126&nbsp;
 127&nbsp;echo 'IFS=":", using $var (var="$@")'
 128&nbsp;c=0
 129&nbsp;for i in $var
 130&nbsp;do echo "$((c+=1)): [$i]"
 131&nbsp;done
 132&nbsp;
 133&nbsp;echo
 134&nbsp;
 135&nbsp;# Try this script with ksh or zsh -y.
 136&nbsp;
 137&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <B
CLASS="COMMAND"
>$@</B
> and <B
CLASS="COMMAND"
>$*</B
>
	      parameters differ only when between double quotes.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="IFSEMPTY"
></A
><P
><B
>Example 9-7. <TT
CLASS="VARNAME"
>$*</TT
> and <TT
CLASS="VARNAME"
>$@</TT
> when
	        <TT
CLASS="VARNAME"
>$IFS</TT
> is empty</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# If $IFS set, but empty,
   4&nbsp;# then "$*" and "$@" do not echo positional params as expected.
   5&nbsp;
   6&nbsp;mecho ()       # Echo positional parameters.
   7&nbsp;{
   8&nbsp;echo "$1,$2,$3";
   9&nbsp;}
  10&nbsp;
  11&nbsp;
  12&nbsp;IFS=""         # Set, but empty.
  13&nbsp;set a b c      # Positional parameters.
  14&nbsp;
  15&nbsp;mecho "$*"     # abc,,
  16&nbsp;mecho $*       # a,b,c
  17&nbsp;
  18&nbsp;mecho $@       # a,b,c
  19&nbsp;mecho "$@"     # a,b,c
  20&nbsp;
  21&nbsp;# The behavior of $* and $@ when $IFS is empty depends
  22&nbsp;# on whatever Bash or sh version being run.
  23&nbsp;# It is therefore inadvisable to depend on this "feature" in a script.
  24&nbsp;
  25&nbsp;
  26&nbsp;# Thanks, S.C.
  27&nbsp;
  28&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
>Other Special Parameters</B
></P
><DL
><DT
><A
NAME="FLPREF"
></A
><TT
CLASS="VARNAME"
>$-</TT
></DT
><DD
><P
>Flags passed to script</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This was originally a <I
CLASS="EMPHASIS"
>ksh</I
>
	      construct adopted into Bash, and unfortunately it does not
	      seem to work reliably in Bash scripts. One possible use
	      for it is to have a script <A
HREF="miscellany.html#IITEST"
>self-test
	      whether it is interactive</A
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><TT
CLASS="VARNAME"
>$!</TT
></DT
><DD
><P
>PID (process id) of last job run in background</P
></DD
><DT
><A
NAME="UNDERSCOREREF"
></A
><TT
CLASS="VARNAME"
>$_</TT
></DT
><DD
><P
>Special variable set to last argument of previous command
	        executed.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="USCREF"
></A
><P
><B
>Example 9-8. underscore variable</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;echo $_         # /bin/bash
   4&nbsp;# Just called /bin/bash to run the script.
   5&nbsp;
   6&nbsp;du &#62;/dev/null   # So no output from command.
   7&nbsp;echo $_         # du
   8&nbsp;
   9&nbsp;ls -al          # So no output from command.
  10&nbsp;echo $_         # -al  (last argument)
  11&nbsp;
  12&nbsp;:
  13&nbsp;echo $_         # :</PRE
></TD
></TR
></TABLE
><HR></DIV
></DD
><DT
><A
NAME="XSTATVARREF"
></A
><TT
CLASS="VARNAME"
>$?</TT
></DT
><DD
><P
><A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
>
	    of a command, <A
HREF="functions.html#FUNCTIONREF"
>function</A
>,
	    or the script itself (see <A
HREF="functions.html#MAX"
>Example 23-3</A
>)</P
></DD
><DT
><TT
CLASS="VARNAME"
>$$</TT
></DT
><DD
><P
>process id of script, often used in scripts
	    to construct temp file names (see <A
HREF="contributed-scripts.html#FTPGET"
>Example A-9</A
>,
	    <A
HREF="debugging.html#ONLINE"
>Example 30-5</A
>, and <A
HREF="filearchiv.html#DERPM"
>Example 12-23</A
>)</P
></DD
></DL
></DIV
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN3322"
HREF="variables2.html#AEN3322"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>The pid of the currently running script is
	      <TT
CLASS="VARNAME"
>$$</TT
>, of course.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN3596"
HREF="variables2.html#AEN3596"
>[2]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>The words <SPAN
CLASS="QUOTE"
>"argument"</SPAN
>
		and <SPAN
CLASS="QUOTE"
>"parameter"</SPAN
> are often used
		interchangeably. In the context of this document, they
		have the same precise meaning, that of a variable passed
		to a script or function.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="part3.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="string-manipulation.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Beyond the Basics</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="part3.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Manipulating Strings</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Why Shell Programming?</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.64
"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="Introduction"
HREF="part1.html"><LINK
REL="PREVIOUS"
TITLE="Introduction"
HREF="part1.html"><LINK
REL="NEXT"
TITLE="Starting Off With a Sha-Bang"
HREF="sha-bang.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-family: sans-serif;"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="part1.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="sha-bang.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="WHY-SHELL"
>Chapter 1. Why Shell Programming?</A
></H1
><P
>A working knowledge of shell scripting is essential to everyone
      wishing to become reasonably adept at system administration,
      even if they do not anticipate ever having to actually write a
      script. Consider that as a Linux machine boots up, it executes the
      shell scripts in <TT
CLASS="FILENAME"
>/etc/rc.d</TT
>
      to restore the system configuration and set up services. A detailed
      understanding of these startup scripts is important for analyzing
      the behavior of a system, and possibly modifying it.</P
><P
>Writing shell scripts is not hard to learn, since the scripts
      can be built in bite-sized sections and there is only a fairly
      small set of shell-specific operators and options
     
      <A
NAME="AEN70"
HREF="#FTN.AEN70"
>[1]</A
>

      to learn.  The syntax is simple and straightforward, similar to
      that of invoking and chaining together utilities at the command
      line, and there are only a few <SPAN
CLASS="QUOTE"
>"rules"</SPAN
> to learn.
      Most short scripts work right the first time, and debugging even
      the longer ones is straightforward.</P
><P
>A shell script is a <SPAN
CLASS="QUOTE"
>"quick and dirty"</SPAN
> method of
      prototyping a complex application.  Getting even a limited subset
      of the functionality to work in a shell script, even if slowly,
      is often a useful first stage in project development. This way,
      the structure of the application can be tested and played with,
      and the major pitfalls found before proceeding to the final coding
      in C, C++, Java, or Perl.</P
><P
>Shell scripting hearkens back to the classical UNIX philosophy
      of breaking complex projects into simpler subtasks, of chaining
      together components and utilities. Many consider this a better,
      or at least more esthetically pleasing approach to problem solving
      than using one of the new generation of high powered all-in-one
      languages, such as Perl, which attempt to be all things to all
      people, but at the cost of forcing you to alter your thinking
      processes to fit the tool.</P
><P
>When not to use shell scripts

      <UL
><LI
><P
>resource-intensive tasks, especially where speed is
	    a factor (sorting, hashing, etc.)</P
></LI
><LI
><P
>procedures involving heavy-duty math operations,
	    especially floating point arithmetic, arbitrary precision
	    calculations, or complex numbers (use C++ or FORTRAN
	    instead)</P
></LI
><LI
><P
>cross-platform portability required (use C instead)</P
></LI
><LI
><P
>complex applications, where structured programming is
	    a necessity (need typechecking of variables, function
	    prototypes, etc.)</P
></LI
><LI
><P
>mission-critical applications upon which you are betting the
	    ranch, or the future of the company</P
></LI
><LI
><P
>situations where security is important, where you need to
	    guarantee the integrity of your system and protect against
	    intrusion, cracking, and vandalism</P
></LI
><LI
><P
>project consists of subcomponents with interlocking
	    dependencies</P
></LI
><LI
><P
>extensive file operations required (Bash is limited to
	    serial file access, and that only in a particularly clumsy
	    and inefficient line-by-line fashion)</P
></LI
><LI
><P
>need multi-dimensional arrays</P
></LI
><LI
><P
>need data structures, such as linked lists or trees</P
></LI
><LI
><P
>need to generate or manipulate graphics or GUIs</P
></LI
><LI
><P
>need direct access to system hardware</P
></LI
><LI
><P
>need port or socket I/O</P
></LI
><LI
><P
>need to use libraries or interface with legacy code</P
></LI
><LI
><P
>proprietary, closed-source applications (shell scripts are
	    necessarily Open Source)</P
></LI
></UL
></P
><P
>If any of the above applies, consider a more powerful scripting
      language, perhaps Perl, Tcl, Python, or possibly a high-level
      compiled language such as C, C++, or Java. Even then, prototyping
      the application as a shell script might still be a useful
      development step.</P
><P
>We will be using Bash, an acronym for <SPAN
CLASS="QUOTE"
>"Bourne-Again
      Shell"</SPAN
> and a pun on Stephen Bourne's now classic Bourne
      Shell.  Bash has become a <I
CLASS="FOREIGNPHRASE"
>de facto</I
>
      standard for shell scripting on all flavors of UNIX. Most of
      the principles dealt with in this book apply equally well to
      scripting with other shells, such as the Korn Shell, from which
      Bash derives some of its features,

       <A
NAME="AEN113"
HREF="#FTN.AEN113"
>[2]</A
>

      and the C Shell and its variants.  (Note that C Shell programming
      is not recommended due to certain inherent problems, as pointed
      out in a <A
HREF="http://www.etext.org/Quartz/computer/unix/csh.harmful.gz"
TARGET="_top"
>news
      group posting</A
> by Tom Christiansen in October of 1993).
      </P
><P
>The following is a tutorial in shell scripting.  It relies
      heavily on examples to illustrate features of the shell.
      As far as possible, the example scripts have been tested, and
      some of them may actually be useful in real life.  The reader
      should use the actual examples in the the source archive
      (<TT
CLASS="FILENAME"
>something-or-other.sh</TT
>),

         <A
NAME="AEN120"
HREF="#FTN.AEN120"
>[3]</A
>

      give them execute permission (<TT
CLASS="USERINPUT"
><B
>chmod u+rx
      scriptname</B
></TT
>), then run them to see what happens.
      Should the source archive not be available, then cut-and-paste from
      the HTML, pdf, or text rendered versions.  Be aware that some of
      the scripts below introduce features before they are explained,
      and this may require the reader to temporarily skip ahead for
      enlightenment.</P
><P
>Unless otherwise noted, the book author wrote the example
      scripts that follow.</P
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN70"
HREF="why-shell.html#AEN70"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>These are referred to as <A
HREF="internal.html#BUILTINREF"
>builtins</A
>, features internal to the
        shell.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN113"
HREF="why-shell.html#AEN113"
>[2]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Many of the features of <I
CLASS="EMPHASIS"
>ksh88</I
>,
	 and even a few from the updated <I
CLASS="EMPHASIS"
>ksh93</I
>
	 have been merged into Bash.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN120"
HREF="why-shell.html#AEN120"
>[3]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>By convention, user-written shell scripts that are
	 Bourne shell compliant generally take a name with a
	 <TT
CLASS="FILENAME"
>.sh</TT
> extension.  System scripts, such as
	 those found in <TT
CLASS="FILENAME"
>/etc/rc.d</TT
>,
	 do not follow this guideline.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="part1.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sha-bang.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Introduction</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="part1.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Starting Off With a Sha-Bang</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
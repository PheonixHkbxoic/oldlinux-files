<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Special Characters</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.64
"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="Basics"
HREF="part2.html"><LINK
REL="PREVIOUS"
TITLE="Exit and Exit Status"
HREF="exit-status.html"><LINK
REL="NEXT"
TITLE="Introduction to Variables and Parameters"
HREF="variables.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-family: sans-serif;"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="exit-status.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="variables.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="SPECIAL-CHARS"
>Chapter 4. Special Characters</A
></H1
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="SCHARLIST1"
></A
>Special Characters Found In
          Scripts and Elsewhere</B
></P
><DL
><DT
><SPAN
CLASS="TOKEN"
>#</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Comments. </B
>Lines beginning with a <SPAN
CLASS="TOKEN"
>#</SPAN
>
	      (<A
HREF="sha-bang.html#MAGNUMREF"
>with the exception of
	      <SPAN
CLASS="TOKEN"
>#!</SPAN
></A
>) are comments.</P
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# This line is a comment.</PRE
></TD
></TR
></TABLE
></P
><P
>Comments may also occur at the end of a command.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo "A comment will follow." # Comment here.</PRE
></TD
></TR
></TABLE
></P
><P
>Comments may also follow <A
HREF="special-chars.html#WHITESPACEREF"
>whitespace</A
> at the beginning
	    of a line.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;	# A tab precedes this comment.</PRE
></TD
></TR
></TABLE
></P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A command may not follow a comment on the
	      same line. There is no method of terminating the comment,
	      in order for <SPAN
CLASS="QUOTE"
>"live code"</SPAN
> to begin on the same
	      line. Use a new line for the next command.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Of course, an escaped <SPAN
CLASS="TOKEN"
>#</SPAN
> in an
	    <B
CLASS="COMMAND"
>echo</B
> statement does
	    <I
CLASS="EMPHASIS"
>not</I
> begin a comment. Likewise, a
	    <SPAN
CLASS="TOKEN"
>#</SPAN
> appears in <A
HREF="parameter-substitution.html#PSUB2"
>certain
	    parameter substitution constructs</A
> and in <A
HREF="numerical-constants.html#NUMCONSTANTS"
>numerical constant expressions</A
>.

	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo "The # here does not begin a comment."
   2&nbsp;echo 'The # here does not begin a comment.'
   3&nbsp;echo The \# here does not begin a comment.
   4&nbsp;echo The # here begins a comment.
   5&nbsp;
   6&nbsp;echo ${PATH#*:}       # Parameter substitution, not a comment.
   7&nbsp;echo $(( 2#101011 ))  # Base conversion, not a comment.
   8&nbsp;
   9&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
>

	  The standard <A
HREF="quoting.html#QUOTINGREF"
>quoting and
	  escape</A
> characters (" ' \) escape the #.
	  </P
></TD
></TR
></TABLE
></DIV
><P
>Certain <A
HREF="parameter-substitution.html#PSOREX1"
>pattern matching
	    operations</A
> also use the <SPAN
CLASS="TOKEN"
>#</SPAN
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Command separator. </B
>[Semicolon]  Permits putting two or more commands on
	      the same line.</P
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo hello; echo there</PRE
></TD
></TR
></TABLE
></P
><P
>Note that the <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>;</SPAN
>"</SPAN
> sometimes
	      needs to be <A
HREF="quoting.html#ESCP"
>escaped</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>;;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Terminator in a <A
HREF="testbranch.html#CASEESAC1"
>case</A
> option. </B
>[Double semicolon]</P
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;case "$variable" in
   2&nbsp;abc)  echo "$variable = abc" ;;
   3&nbsp;xyz)  echo "$variable = xyz" ;;
   4&nbsp;esac</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>.</SPAN
></DT
><DD
><P
><A
NAME="DOTREF"
></A
></P
><DIV
CLASS="FORMALPARA"
><P
><B
><SPAN
CLASS="QUOTE"
>"dot"</SPAN
> command. </B
>[period]  Equivalent to <A
HREF="internal.html#SOURCEREF"
>source</A
> (see
		<A
HREF="internal.html#EX38"
>Example 11-14</A
>). This is a bash <A
HREF="internal.html#BUILTINREF"
>builtin</A
>.</P
></DIV
><P
><A
HREF="regexp.html#REGEXDOT"
>In a different
	        context</A
>, as part of a <A
HREF="regexp.html#REGEXREF"
>regular expression</A
>, a
	        <SPAN
CLASS="QUOTE"
>"dot"</SPAN
> matches a single character.</P
><P
>In yet another context, a dot is the filename prefix
                of a <SPAN
CLASS="QUOTE"
>"hidden"</SPAN
> file, a file that an
		<B
CLASS="COMMAND"
>ls</B
> will not normally show.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>touch .hidden-file</B
></TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ls -l</B
></TT
>	      
 <TT
CLASS="COMPUTEROUTPUT"
>total 10
 -rw-r--r--    1 bozo      4034 Jul 18 22:04 data1.addressbook
 -rw-r--r--    1 bozo      4602 May 25 13:58 data1.addressbook.bak
 -rw-r--r--    1 bozo       877 Dec 17  2000 employment.addressbook</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ls -al</B
></TT
>	      
 <TT
CLASS="COMPUTEROUTPUT"
>total 14
 drwxrwxr-x    2 bozo  bozo      1024 Aug 29 20:54 ./
 drwx------   52 bozo  bozo      3072 Aug 29 20:51 ../
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.addressbook
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.addressbook.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.addressbook
 -rw-rw-r--    1 bozo  bozo         0 Aug 29 20:54 .hidden-file</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><SPAN
CLASS="TOKEN"
>"</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="variables.html#DBLQUO"
>partial
	    quoting</A
>. </B
>[double quote]  <I
CLASS="EMPHASIS"
>"STRING"</I
>
		preserves (from interpretation) most of the special
		characters within <I
CLASS="EMPHASIS"
>STRING</I
>. See also
		<A
HREF="quoting.html"
>Chapter 6</A
>.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>'</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="variables.html#SNGLQUO"
>full
	    quoting</A
>. </B
>[single quote]  <I
CLASS="EMPHASIS"
>'STRING'</I
>
		preserves all special characters within
		<I
CLASS="EMPHASIS"
>STRING</I
>. This is a stronger form
		of quoting than using <SPAN
CLASS="TOKEN"
>"</SPAN
>.  See also <A
HREF="quoting.html"
>Chapter 6</A
>.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>,</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="operations.html#COMMAOP"
>comma
	    operator</A
>. </B
>The <B
CLASS="COMMAND"
>comma operator</B
> links together a
	        series of arithmetic operations. All are evaluated, but only
		the last one is returned.
               <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;let "t2 = ((a = 9, 15 / 3))"  # Set "a" and calculate "t2".</PRE
></TD
></TR
></TABLE
>
	      </P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>\</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="quoting.html#ESCP"
>escape</A
>. </B
>[backslash]  <TT
CLASS="USERINPUT"
><B
>\X</B
></TT
>
		<SPAN
CLASS="QUOTE"
>"escapes"</SPAN
> the character
		<I
CLASS="EMPHASIS"
>X</I
>. This has the effect of
		<SPAN
CLASS="QUOTE"
>"quoting"</SPAN
> <I
CLASS="EMPHASIS"
>X</I
>, equivalent
		to <I
CLASS="EMPHASIS"
>'X'</I
>.  The <SPAN
CLASS="TOKEN"
>\</SPAN
> may
		be used to quote <SPAN
CLASS="TOKEN"
>"</SPAN
> and <SPAN
CLASS="TOKEN"
>'</SPAN
>,
		so they are expressed literally.</P
></DIV
><P
>See <A
HREF="quoting.html"
>Chapter 6</A
> for an in-depth explanation
	        of escaped characters.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>/</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Filename path separator. </B
>[forward slash] Separates
	        the components of a filename (as in
	        <TT
CLASS="FILENAME"
>/home/bozo/projects/Makefile</TT
>).</P
></DIV
><P
>This is also the division <A
HREF="operations.html#AROPS1"
>arithmetic operator</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>`</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="commandsub.html#COMMANDSUBREF"
>command substitution</A
>. </B
>[backticks]  <I
CLASS="EMPHASIS"
>`command`</I
> makes
		available the output of <I
CLASS="EMPHASIS"
>command</I
>
		for setting a variable. This is also known as
		<A
HREF="commandsub.html#BACKQUOTESREF"
>backticks</A
> or
		backquotes.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>:</SPAN
></DT
><DD
><P
><A
NAME="NULLREF"
></A
></P
><DIV
CLASS="FORMALPARA"
><P
><B
>null command. </B
>[colon]  This is the shell equivalent of a
		<SPAN
CLASS="QUOTE"
>"NOP"</SPAN
> (<TT
CLASS="REPLACEABLE"
><I
>no op</I
></TT
>, a
		do-nothing operation). It may be considered a synonym for
		the shell builtin <A
HREF="internal.html#TRUEREF"
>true</A
>. The
		<SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>:</SPAN
>"</SPAN
> command is a Bash
		builtin, and its <A
HREF="exit-status.html#EXITSTATUSREF"
>exit
		status</A
> is <SPAN
CLASS="QUOTE"
>"true"</SPAN
>
		(<SPAN
CLASS="RETURNVALUE"
>0</SPAN
>).</P
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;:
   2&nbsp;echo $?   # 0</PRE
></TD
></TR
></TABLE
></P
><P
>Endless loop:</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;while :
   2&nbsp;do
   3&nbsp;   operation-1
   4&nbsp;   operation-2
   5&nbsp;   ...
   6&nbsp;   operation-n
   7&nbsp;done
   8&nbsp;
   9&nbsp;# Same as:
  10&nbsp;#    while true
  11&nbsp;#    do
  12&nbsp;#      ...
  13&nbsp;#    done</PRE
></TD
></TR
></TABLE
>
	    </P
><P
>Placeholder in if/then test:</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;if condition
   2&nbsp;then :   # Do nothing and branch ahead
   3&nbsp;else
   4&nbsp;   take-some-action
   5&nbsp;fi</PRE
></TD
></TR
></TABLE
>
	    </P
><P
>Provide a placeholder where a binary operation is
	      expected, see <A
HREF="operations.html#ARITHOPS"
>Example 8-2</A
> and <A
HREF="parameter-substitution.html#DEFPARAM"
>default parameters</A
>.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;: ${username=`whoami`}
   2&nbsp;# ${username=`whoami`}   without the leading : gives an error
   3&nbsp;#                        unless "username" is a command or builtin...</PRE
></TD
></TR
></TABLE
></P
><P
>Provide a placeholder where a command is expected in a
	      <A
HREF="here-docs.html#HEREDOCREF"
>here document</A
>. See <A
HREF="here-docs.html#ANONHEREDOC"
>Example 17-8</A
>.</P
><P
>Evaluate string of variables using
		<A
HREF="parameter-substitution.html#PARAMSUBREF"
>parameter substitution</A
>
		(as in <A
HREF="parameter-substitution.html#EX6"
>Example 9-11</A
>).

	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;: ${HOSTNAME?} ${USER?} ${MAIL?}
   2&nbsp;#Prints error message if one or more of essential environmental variables not set.</PRE
></TD
></TR
></TABLE
></P
><P
><B
CLASS="COMMAND"
><A
HREF="parameter-substitution.html#EXPREPL1"
>Variable expansion / substring
	      replacement</A
></B
>.</P
><P
>In combination with the <SPAN
CLASS="TOKEN"
>&#62;</SPAN
> <A
HREF="io-redirection.html#IOREDIRREF"
>redirection operator</A
>,
	      truncates a file to zero length, without changing its
	      permissions. If the file did not previously exist,
	      creates it.

	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;: &#62; data.xxx   # File "data.xxx" now empty.	      
   2&nbsp;
   3&nbsp;# Same effect as   cat /dev/null &#62;data.xxx
   4&nbsp;# However, this does not fork a new process, since ":" is a builtin.</PRE
></TD
></TR
></TABLE
>
              See also <A
HREF="textproc.html#EX12"
>Example 12-11</A
>.</P
><P
>In combination with the <SPAN
CLASS="TOKEN"
>&#62;&#62;</SPAN
>
	      redirection operator, updates a file access/modification
	      time (<TT
CLASS="USERINPUT"
><B
>: &#62;&#62; new_file</B
></TT
>).
	      If the file did not previously exist, creates it.  This is
	      equivalent to <A
HREF="timedate.html#TOUCHREF"
>touch</A
>.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This applies to regular files, not pipes,
	      symlinks, and certain special files.</P
></TD
></TR
></TABLE
></DIV
><P
>May be used to begin a comment line, although this is not
	      recommended. Using <SPAN
CLASS="TOKEN"
>#</SPAN
> for a comment turns
	      off error checking for the remainder of that line, so
	      almost anything may be appear in a comment. However,
	      this is not the case with
	      <SPAN
CLASS="TOKEN"
>:</SPAN
>.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;: This is a comment that generates an error, ( if [ $x -eq 3] ).</PRE
></TD
></TR
></TABLE
>
	    </P
><P
>The <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>:</SPAN
>"</SPAN
> also serves as a field
	      separator, in <TT
CLASS="FILENAME"
>/etc/passwd</TT
>, and in the <A
HREF="variables2.html#PATHREF"
>$PATH</A
> variable.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $PATH</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games</TT
></PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><SPAN
CLASS="TOKEN"
>!</SPAN
></DT
><DD
><P
><A
NAME="NOTREF"
></A
></P
><DIV
CLASS="FORMALPARA"
><P
><B
>reverse (or negate) the sense of
	  a test or exit status. </B
>The <SPAN
CLASS="TOKEN"
>!</SPAN
> operator inverts the <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
>
		of the command to which it is applied (see
		<A
HREF="exit-status.html#NEGCOND"
>Example 3-2</A
>). It also inverts
		the meaning of a test operator. This can, for
		example, change the sense of <SPAN
CLASS="QUOTE"
>"equal"</SPAN
>
		( <A
HREF="comparison-ops.html#EQUALSIGNREF"
>=</A
>
		) to <SPAN
CLASS="QUOTE"
>"not-equal"</SPAN
> ( != ). The
		<SPAN
CLASS="TOKEN"
>!</SPAN
> operator is a Bash <A
HREF="internal.html#KEYWORDREF"
>keyword</A
>.</P
></DIV
><P
>In a different context, the <SPAN
CLASS="TOKEN"
>!</SPAN
>
	        also appears in <A
HREF="ivr.html#IVR2"
>indirect variable
		references</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>*</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>wild card. </B
>[asterisk]	The <SPAN
CLASS="TOKEN"
>*</SPAN
> character serves
		as a <SPAN
CLASS="QUOTE"
>"wild card"</SPAN
> for filename expansion in
		<A
HREF="globbingref.html"
>globbing</A
>, as well as
		representing any number (or zero) characters in a <A
HREF="regexp.html#REGEXREF"
>regular expression</A
>.</P
></DIV
><P
>A double asterisk, <SPAN
CLASS="TOKEN"
>**</SPAN
>, is the <A
HREF="operations.html#EXPONENTIATIONREF"
>exponentiation
	        operator</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>?</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>wild card (single character). </B
>[question mark] The <SPAN
CLASS="TOKEN"
>?</SPAN
> character serves
		as a single-character <SPAN
CLASS="QUOTE"
>"wild
		card"</SPAN
> for filename expansion in <A
HREF="globbingref.html"
>globbing</A
>, as well as <A
HREF="regexp.html#QUEXREGEX"
>representing one character</A
>
		in an <A
HREF="regexp.html#EXTREGEX"
>extended regular
		expression</A
>.</P
></DIV
><P
>Within a <A
HREF="dblparens.html"
>double
	        parentheses construct</A
>, the <SPAN
CLASS="TOKEN"
>?</SPAN
> serves
		as a C-style trinary operator. See <A
HREF="dblparens.html#CVARS"
>Example 9-24</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>$</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="variables.html#VARSUBN"
>Variable
              substitution</A
>. </B
>	       <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;var1=5
   2&nbsp;var2=23skidoo
   3&nbsp;
   4&nbsp;echo $var1     # 5
   5&nbsp;echo $var2     # 23skidoo</PRE
></TD
></TR
></TABLE
>
	       </P
></DIV
><P
>In a <A
HREF="regexp.html#REGEXREF"
>regular
		 expression</A
>, a <SPAN
CLASS="TOKEN"
>$</SPAN
> <A
HREF="regexp.html#DOLLARSIGNREF"
>matches the end of a
		 line</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>${}</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="parameter-substitution.html#PARAMSUBREF"
>Parameter
              substitution</A
>. </B
></P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>$*</SPAN
>, <SPAN
CLASS="TOKEN"
>$@</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="variables2.html#APPREF"
>positional
	    parameters</A
>. </B
></P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>()</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>command group. </B
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;(a=hello; echo $a)</PRE
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="IMPORTANT"
><TABLE
CLASS="IMPORTANT"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/important.png"
HSPACE="5"
ALT="Important"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A listing of commands within
	      <TT
CLASS="REPLACEABLE"
><I
>parentheses</I
></TT
> starts a <A
HREF="subshells.html#SUBSHELLSREF"
>subshell</A
>.</P
><P
>Variables inside parentheses, within the subshell, are not
	      visible to the rest of the script. The parent process,
	      the script, <A
HREF="subshells.html#PARVIS"
>cannot read variables
	      created in the child process</A
>, the subshell.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;a=123
   2&nbsp;( a=321; )	      
   3&nbsp;
   4&nbsp;echo "a = $a"   # a = 123
   5&nbsp;# "a" within parentheses acts like a local variable.</PRE
></TD
></TR
></TABLE
></P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="FORMALPARA"
><P
><B
>array initialization. </B
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;Array=(element1 element2 element3)</PRE
></TD
></TR
></TABLE
></P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>{xxx,yyy,zzz,...}</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Brace expansion. </B
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;grep Linux file*.{txt,htm*}
   2&nbsp;# Finds all instances of the work "Linux"
   3&nbsp;# in the files "fileA.txt", "file2.txt", "fileR.html", "file-87.htm", etc.</PRE
></TD
></TR
></TABLE
></P
></DIV
><P
>A command may act upon a comma-separated list of file specs within
	  <TT
CLASS="REPLACEABLE"
><I
>braces</I
></TT
>.

	     <A
NAME="AEN762"
HREF="#FTN.AEN762"
>[1]</A
>
	  
	  Filename expansion (<A
HREF="globbingref.html"
>globbing</A
>)
	  applies to the file specs between the braces.</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>No spaces allowed within the braces
	    <I
CLASS="EMPHASIS"
>unless</I
> the spaces are quoted or escaped.</P
><P
><TT
CLASS="USERINPUT"
><B
>echo {file1,file2}\ :{\ A," B",' C'}</B
></TT
></P
><P
><TT
CLASS="COMPUTEROUTPUT"
>file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C</TT
></P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>{}</SPAN
></DT
><DD
><P
><A
NAME="CODEBLOCKREF"
></A
></P
><DIV
CLASS="FORMALPARA"
><P
><B
>Block of code. </B
>[curly brackets]	Also referred to as an
		<SPAN
CLASS="QUOTE"
>"inline group"</SPAN
>, this construct, in effect,
		creates an anonymous function. However, unlike a <A
HREF="functions.html#FUNCTIONREF"
>function</A
>, the variables
		in a code block remain visible to the remainder of the
		script.</P
></DIV
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>{ local a; a=123; }</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>bash: local: can only be used in a function</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;a=123
   2&nbsp;{ a=321; }
   3&nbsp;echo "a = $a"   # a = 321   (value inside code block)
   4&nbsp;
   5&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
></P
><P
>The code block enclosed in braces may have <A
HREF="io-redirection.html#IOREDIRREF"
>I/O redirected</A
> to and from
	      it.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX8"
></A
><P
><B
>Example 4-1. Code blocks and I/O redirection</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# Reading lines in /etc/fstab.
   3&nbsp;
   4&nbsp;File=/etc/fstab
   5&nbsp;
   6&nbsp;{
   7&nbsp;read line1
   8&nbsp;read line2
   9&nbsp;} &#60; $File
  10&nbsp;
  11&nbsp;echo "First line in $File is:"
  12&nbsp;echo "$line1"
  13&nbsp;echo
  14&nbsp;echo "Second line in $File is:"
  15&nbsp;echo "$line2"
  16&nbsp;
  17&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="RPMCHECK"
></A
><P
><B
>Example 4-2. Saving the results of a code block to a file</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# rpm-check.sh
   3&nbsp;
   4&nbsp;# Queries an rpm file for description, listing, and whether it can be installed.
   5&nbsp;# Saves output to a file.
   6&nbsp;# 
   7&nbsp;# This script illustrates using a code block.
   8&nbsp;
   9&nbsp;SUCCESS=0
  10&nbsp;E_NOARGS=65
  11&nbsp;
  12&nbsp;if [ -z "$1" ]
  13&nbsp;then
  14&nbsp;  echo "Usage: `basename $0` rpm-file"
  15&nbsp;  exit $E_NOARGS
  16&nbsp;fi  
  17&nbsp;
  18&nbsp;{ 
  19&nbsp;  echo
  20&nbsp;  echo "Archive Description:"
  21&nbsp;  rpm -qpi $1       # Query description.
  22&nbsp;  echo
  23&nbsp;  echo "Archive Listing:"
  24&nbsp;  rpm -qpl $1       # Query listing.
  25&nbsp;  echo
  26&nbsp;  rpm -i --test $1  # Query whether rpm file can be installed.
  27&nbsp;  if [ "$?" -eq $SUCCESS ]
  28&nbsp;  then
  29&nbsp;    echo "$1 can be installed."
  30&nbsp;  else
  31&nbsp;    echo "$1 cannot be installed."
  32&nbsp;  fi  
  33&nbsp;  echo
  34&nbsp;} &#62; "$1.test"       # Redirects output of everything in block to file.
  35&nbsp;
  36&nbsp;echo "Results of rpm test in file $1.test"
  37&nbsp;
  38&nbsp;# See rpm man page for explanation of options.
  39&nbsp;
  40&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Unlike a command group within (parentheses),
	      as above, a code block enclosed by {braces} will
	      <I
CLASS="EMPHASIS"
>not</I
> normally launch a <A
HREF="subshells.html#SUBSHELLSREF"
>subshell</A
>.

		<A
NAME="AEN811"
HREF="#FTN.AEN811"
>[2]</A
>

	      </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>{} \;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>pathname. </B
>Mostly used in <A
HREF="moreadv.html#FINDREF"
>find</A
>
		constructs.  This is <I
CLASS="EMPHASIS"
>not</I
> a shell
		<A
HREF="internal.html#BUILTINREF"
>builtin</A
>.</P
></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>;</SPAN
>"</SPAN
> ends
		the <TT
CLASS="OPTION"
>-exec</TT
> option of a
		<B
CLASS="COMMAND"
>find</B
> command sequence.  It needs
		to be escaped to protect it from interpretation by the
		shell.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>[ ]</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>test. </B
></P
></DIV
><P
><A
NAME="LEFTBRACKET"
></A
><A
HREF="tests.html#IFTHEN"
>Test</A
> expression between <B
CLASS="COMMAND"
>[
	       ]</B
>.  Note that <B
CLASS="COMMAND"
>[</B
> is part of
	       the shell builtin <B
CLASS="COMMAND"
>test</B
> (and a synonym
	       for it), <I
CLASS="EMPHASIS"
>not</I
> a link to the external
	       command <TT
CLASS="FILENAME"
>/usr/bin/test</TT
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>[[ ]]</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>test. </B
></P
></DIV
><P
>Test expression between <SPAN
CLASS="TOKEN"
>[[ ]]</SPAN
> (shell
	       <A
HREF="internal.html#KEYWORDREF"
>keyword</A
>).</P
><P
>See the discussion on the <A
HREF="tests.html#DBLBRACKETS"
>[[ ... ]] construct</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>(( ))</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>integer expansion. </B
></P
></DIV
><P
>Expand and evaluate integer expression between
	       <SPAN
CLASS="TOKEN"
>(( ))</SPAN
>.</P
><P
>See the discussion on the <A
HREF="dblparens.html"
>(( ... )) construct</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#62;</SPAN
> <SPAN
CLASS="TOKEN"
>&#62;&#38;</SPAN
> <SPAN
CLASS="TOKEN"
>&#62;&#62;</SPAN
> <SPAN
CLASS="TOKEN"
>&#60;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="io-redirection.html#IOREDIRREF"
>redirection</A
>. </B
></P
></DIV
><P
><TT
CLASS="USERINPUT"
><B
>scriptname &#62;filename</B
></TT
> redirects the output of
	      <TT
CLASS="FILENAME"
>scriptname</TT
> to file
	      <TT
CLASS="FILENAME"
>filename</TT
>. Overwrite
	      <TT
CLASS="FILENAME"
>filename</TT
> if it already exists.</P
><P
><TT
CLASS="USERINPUT"
><B
>command &#62;&#38;2</B
></TT
> redirects
	      output of <TT
CLASS="FILENAME"
>command</TT
> to
	      <TT
CLASS="FILENAME"
>stderr</TT
>.</P
><P
><TT
CLASS="USERINPUT"
><B
>scriptname &#62;&#62;filename</B
></TT
> appends
	    the output of <TT
CLASS="FILENAME"
>scriptname</TT
>
	    to file <TT
CLASS="FILENAME"
>filename</TT
>. If
	    <TT
CLASS="FILENAME"
>filename</TT
> does not already exist,
	    it will be created.</P
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="process-sub.html#PROCESSSUBREF"
>process substitution</A
>. </B
></P
></DIV
><P
><TT
CLASS="USERINPUT"
><B
>(command)&#62;</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>&#60;(command)</B
></TT
></P
><P
><A
HREF="comparison-ops.html#LTREF"
>In a different context</A
>,
	      the <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>&#60;</SPAN
>"</SPAN
> and
	      <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>&#62;</SPAN
>"</SPAN
> characters act
	      as <A
HREF="comparison-ops.html#SCOMPARISON1"
>string comparison
	      operators</A
>.</P
><P
><A
HREF="comparison-ops.html#INTLT"
>In yet another context</A
>,
	      the <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>&#60;</SPAN
>"</SPAN
> and
	      <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>&#62;</SPAN
>"</SPAN
> characters act
	      as <A
HREF="comparison-ops.html#ICOMPARISON1"
>integer comparison
	      operators</A
>. See also <A
HREF="moreadv.html#EX45"
>Example 12-6</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#60;&#60;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>redirection used in a <A
HREF="here-docs.html#HEREDOCREF"
>here document</A
>. </B
></P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>|</SPAN
></DT
><DD
><P
><A
NAME="PIPEREF"
></A
></P
><DIV
CLASS="FORMALPARA"
><P
><B
>pipe. </B
>Passes the output of previous command to the input
		of the next one, or to the shell. This is a method of
		chaining commands together.</P
></DIV
><P
>              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo ls -l | sh
   2&nbsp;#  Passes the output of "echo ls -l" to the shell,
   3&nbsp;#+ with the same result as a simple "ls -l".
   4&nbsp;
   5&nbsp;
   6&nbsp;cat *.lst | sort | uniq
   7&nbsp;# Merges and sorts all ".lst" files, then deletes duplicate lines.</PRE
></TD
></TR
></TABLE
>
	    </P
><TABLE
CLASS="SIDEBAR"
BORDER="1"
CELLPADDING="5"
><TR
><TD
><DIV
CLASS="SIDEBAR"
><A
NAME="AEN987"
></A
><P
>A pipe, as a classic method of interprocess
	      communication, sends the <TT
CLASS="FILENAME"
>stdout</TT
>
	      of one process to the <TT
CLASS="FILENAME"
>stdin</TT
>
	      of another.  In a typical case, a command, such
	      as <A
HREF="external.html#CATREF"
>cat</A
> or <A
HREF="internal.html#ECHOREF"
>echo</A
>, pipes a stream of data to
	      a filter for processing.</P
><P
>  
	      <TT
CLASS="USERINPUT"
><B
>cat $filename | grep $search_word</B
></TT
>
            </P
></DIV
></TD
></TR
></TABLE
><P
><A
NAME="UCREF"
></A
>The output of a command or commands
	      may be piped to a script.

	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# uppercase.sh : Changes input to uppercase.
   3&nbsp;
   4&nbsp;tr 'a-z' 'A-Z'
   5&nbsp;#  Letter ranges must be quoted
   6&nbsp;#+ to prevent filename generation from single-letter filenames.
   7&nbsp;
   8&nbsp;exit 0</PRE
></TD
></TR
></TABLE
>
              Now, let us pipe the output of <B
CLASS="COMMAND"
>ls -l</B
> to this
	      script.

	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ls -l | ./uppercase.sh</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>-RW-RW-R--    1 BOZO  BOZO       109 APR  7 19:49 1.TXT
 -RW-RW-R--    1 BOZO  BOZO       109 APR 14 16:48 2.TXT
 -RW-R--R--    1 BOZO  BOZO       725 APR 20 20:56 DATA-FILE</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="FILENAME"
>stdout</TT
> of each process in
	       a pipe must be read as the <TT
CLASS="FILENAME"
>stdin</TT
>
	       of the next. If this is not the case, the data stream
	       will <I
CLASS="EMPHASIS"
>block</I
>, and the pipe will not
	       behave as expected.
	         <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;cat file1 file2 | ls -l | sort
   2&nbsp;# The output from "cat file1 file2" disappears.</PRE
></TD
></TR
></TABLE
>
             </P
><P
>A pipe runs as a <A
HREF="othertypesv.html#CHILDREF"
>child
	       process</A
>, and therefore cannot alter script
	       variables.
	         <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;variable="initial_value"
   2&nbsp;echo "new_value" | read variable
   3&nbsp;echo "variable = $variable"     # variable = initial_value</PRE
></TD
></TR
></TABLE
>
             </P
><P
>If one of the commands in the pipe
	       aborts, this prematurely terminates execution of the
	       pipe. Called a <I
CLASS="EMPHASIS"
>broken pipe</I
>, this
	       condition sends a <I
CLASS="EMPHASIS"
>SIGPIPE</I
> <A
HREF="debugging.html#SIGNALD"
>signal</A
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#62;|</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>force redirection (even if
		the <A
HREF="options.html#NOCLOBBERREF"
>noclobber option</A
>
		is set). </B
>This will forcibly overwrite an existing file.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#38;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Run job in background. </B
>A command followed by an <SPAN
CLASS="TOKEN"
>&#38;</SPAN
>
	        will run in the background.</P
></DIV
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>sleep 10 &#38;</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>[1] 850</TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>[1]+  Done                    sleep 10</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A command run in the background within a
	      script may cause the script to hang, waiting
	      for a keystroke. Fortunately, there is a <A
HREF="internal.html#WAITHANG"
>remedy</A
> for this.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>-</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>redirection from/to <TT
CLASS="FILENAME"
>stdin</TT
> or <TT
CLASS="FILENAME"
>stdout</TT
>. </B
><A
NAME="COXEX"
></A
>[dash]</P
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;(cd /source/directory &#38;&#38; tar cf - . ) | (cd /dest/directory &#38;&#38; tar xpvf -)
   2&nbsp;# Move entire file tree from one directory to another
   3&nbsp;# [courtesy Alan Cox &#60;a.cox@swansea.ac.uk&#62;, with a minor change]
   4&nbsp;
   5&nbsp;# 1) cd /source/directory    Source directory, where the files to be moved are.
   6&nbsp;# 2) &#38;&#38;                     "And-list": if the 'cd' operation successful, then execute the next command.
   7&nbsp;# 3) tar cf - .              The 'c' option 'tar' archiving command creates a new archive,
   8&nbsp;#                            the 'f' (file) option, followed by '-' designates the target file as stdout,
   9&nbsp;#                            and do it in current directory tree ('.').
  10&nbsp;# 4) |                       Piped to...
  11&nbsp;# 5) ( ... )                 a subshell
  12&nbsp;# 6) cd /dest/directory      Change to the destination directory.
  13&nbsp;# 7) &#38;&#38;                     "And-list", as above
  14&nbsp;# 8) tar xpvf -              Unarchive ('x'), preserve ownership and file permissions ('p'),
  15&nbsp;#                            and send verbose messages to stdout ('v'),
  16&nbsp;#                            reading data from stdin ('f' followed by '-').
  17&nbsp;#
  18&nbsp;#                            Note that 'x' is a command, and 'p', 'v', 'f' are options.
  19&nbsp;# Whew!
  20&nbsp;
  21&nbsp;
  22&nbsp;
  23&nbsp;# More elegant than, but equivalent to:
  24&nbsp;#   cd source-directory
  25&nbsp;#   tar cf - . | (cd ../target-directory; tar xzf -)
  26&nbsp;#
  27&nbsp;# cp -a /source/directory /dest     also has same effect.</PRE
></TD
></TR
></TABLE
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;bunzip2 linux-2.4.3.tar.bz2 | tar xvf -
   2&nbsp;# --uncompress tar file--    | --then pass it to "tar"--
   3&nbsp;# If "tar" has not been patched to handle "bunzip2",
   4&nbsp;# this needs to be done in two discrete steps, using a pipe.
   5&nbsp;# The purpose of the exercise is to unarchive "bzipped" kernel source.</PRE
></TD
></TR
></TABLE
></P
><P
>Note that in this context the <SPAN
CLASS="QUOTE"
>"-"</SPAN
> is not
            itself a Bash operator, but rather an option recognized by
	    certain UNIX utilities that write to
	    <TT
CLASS="FILENAME"
>stdout</TT
>, such as <B
CLASS="COMMAND"
>tar</B
>,
	    <B
CLASS="COMMAND"
>cat</B
>, etc.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo "whatever" | cat -</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>whatever</TT
> </PRE
></TD
></TR
></TABLE
>
	    </P
><P
>Where a filename is expected,
	      <TT
CLASS="REPLACEABLE"
><I
>-</I
></TT
> redirects output to
	      <TT
CLASS="FILENAME"
>stdout</TT
> (sometimes seen with
	      <TT
CLASS="USERINPUT"
><B
>tar cf</B
></TT
>), or accepts input from
	      <TT
CLASS="FILENAME"
>stdin</TT
>, rather than from a file. This
	      is a method of using a file-oriented utility as a filter
	      in a pipe.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>file</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Usage: file [-bciknvzL] [-f namefile] [-m magicfiles] file...</TT
>
 	      </PRE
></TD
></TR
></TABLE
>

	    By itself on the command line, <A
HREF="filearchiv.html#FILEREF"
>file</A
> fails with an error message.
	    </P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>file -</B
></TT
>
 <TT
CLASS="USERINPUT"
><B
>#!/bin/bash</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>standard input:              Bourne-Again shell script text executable</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      This time, it accepts input from <TT
CLASS="FILENAME"
>stdin</TT
>
	        and filters it.
	    </P
><P
>The <SPAN
CLASS="TOKEN"
>-</SPAN
> can be used to pipe
	      <TT
CLASS="FILENAME"
>stdout</TT
> to other commands. This permits
	      such stunts as <A
HREF="assortedtips.html#PREPENDREF"
>prepending lines
	      to a file</A
>.</P
><P
>Using <A
HREF="textproc.html#DIFFREF"
>diff</A
> to
	      compare a file with a <I
CLASS="EMPHASIS"
>section</I
>
	      of another:</P
><P
><TT
CLASS="USERINPUT"
><B
>grep bash file1 | diff file2 -</B
></TT
></P
><P
>Finally, a real-world example using
	      <TT
CLASS="REPLACEABLE"
><I
>-</I
></TT
> with <A
HREF="filearchiv.html#TARREF"
>tar</A
>.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX58"
></A
><P
><B
>Example 4-3. Backup of all files changed in last day</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# Backs up all files in current directory modified within last 24 hours
   4&nbsp;# in a "tarball" (tarred and gzipped file).
   5&nbsp;
   6&nbsp;NOARGS=0
   7&nbsp;E_BADARGS=65
   8&nbsp;
   9&nbsp;if [ $# = $NOARGS ]
  10&nbsp;then
  11&nbsp;  echo "Usage: `basename $0` filename"
  12&nbsp;  exit $E_BADARGS
  13&nbsp;fi  
  14&nbsp;
  15&nbsp;tar cvf - `find . -mtime -1 -type f -print` &#62; $1.tar
  16&nbsp;gzip $1.tar
  17&nbsp;
  18&nbsp;
  19&nbsp;# Stephane Chazelas points out that the above code will fail
  20&nbsp;# if there are too many files found
  21&nbsp;# or if any filenames contain blank characters.
  22&nbsp;
  23&nbsp;# He suggests the following alternatives:
  24&nbsp;# -------------------------------------------------------------
  25&nbsp;#   find . -mtime -1 -type f -print0 | xargs -0 tar rvf "$1.tar"
  26&nbsp;#      using the GNU version of "find".
  27&nbsp;
  28&nbsp;#   find . -mtime -1 -type f -exec tar rvf "$1.tar" '{}' \;
  29&nbsp;#      portable to other UNIX flavors, but much slower.
  30&nbsp;
  31&nbsp;
  32&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Filenames beginning with
	      <TT
CLASS="REPLACEABLE"
><I
>-</I
></TT
> may cause problems when
	      coupled with the <TT
CLASS="REPLACEABLE"
><I
>-</I
></TT
> redirection
	      operator. A script should check for this and pass such
	      filenames as <TT
CLASS="REPLACEABLE"
><I
>./-FILENAME</I
></TT
> or
	      <TT
CLASS="REPLACEABLE"
><I
>$PWD/-FILENAME</I
></TT
>.</P
><P
>If the value of a variable begins with a
	        <TT
CLASS="REPLACEABLE"
><I
>-</I
></TT
>, this may likewise create
		problems.
		<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;var="-n"
   2&nbsp;echo $var		
   3&nbsp;# Has the effect of "echo -n", and outputs nothing.</PRE
></TD
></TR
></TABLE
>
              </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>-</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>previous working directory. </B
>[dash]  <B
CLASS="COMMAND"
>cd -</B
> changes to previous working
		directory. This uses the <A
HREF="variables2.html#OLDPWD"
>$OLDPWD</A
> environmental
		variable.</P
></DIV
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This is not to be confused with the
		<SPAN
CLASS="QUOTE"
>"-"</SPAN
> redirection operator just discussed. The
		interpretation of the <SPAN
CLASS="QUOTE"
>"-"</SPAN
> depends on the
		context in which it appears.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>-</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Minus. </B
>Minus sign in an <A
HREF="operations.html#AROPS1"
>arithmetic
	        operation</A
>.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>=</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Equals. </B
><A
HREF="varassignment.html#EQREF"
>Assignment operator</A
>
	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;a=28
   2&nbsp;echo $a   # 28</PRE
></TD
></TR
></TABLE
></P
></DIV
><P
>In a <A
HREF="comparison-ops.html#EQUALSIGNREF"
>different context</A
>,
	      the <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>=</SPAN
>"</SPAN
> is a <A
HREF="comparison-ops.html#SCOMPARISON1"
>string comparison</A
>
	      operator.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>+</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Plus. </B
>Addition  <A
HREF="operations.html#AROPS1"
>arithmetic
	        operator</A
>.</P
></DIV
><P
>In a <A
HREF="regexp.html#PLUSREF"
>different context</A
>,
	      the <SPAN
CLASS="TOKEN"
>+</SPAN
> is a <A
HREF="regexp.html"
>Regular
	      Expression</A
> operator.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>%</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="operations.html#MODULOREF"
>modulo</A
>. </B
>Modulo (remainder of a division) <A
HREF="operations.html#AROPS1"
>arithmetic
	        operation</A
>.</P
></DIV
><P
>In a <A
HREF="parameter-substitution.html#PCTPATREF"
>different context</A
>,
	      the <SPAN
CLASS="TOKEN"
>%</SPAN
> is a <A
HREF="parameter-substitution.html#PSUB2"
>pattern
	      matching</A
> operator.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>~</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>home directory. </B
>[tilde]  This corresponds to the <A
HREF="variables2.html#HOMEDIRREF"
>$HOME</A
> internal variable.

	      <I
CLASS="EMPHASIS"
>~bozo</I
> is bozo's home directory,
		and <B
CLASS="COMMAND"
>ls ~bozo</B
> lists the contents of it.
		<SPAN
CLASS="TOKEN"
>~/</SPAN
> is the current user's home directory,
		and <B
CLASS="COMMAND"
>ls ~/</B
> lists the contents of it.

	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo ~bozo</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/home/bozo</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo ~</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/home/bozo</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo ~/</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/home/bozo/</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo ~:</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/home/bozo:</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo ~nonexistent-user</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>~nonexistent-user</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>~+</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>current working directory. </B
>This corresponds to the <A
HREF="variables2.html#PWDREF"
>$PWD</A
> internal variable.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>~-</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>previous working directory. </B
>This corresponds to the <A
HREF="variables2.html#OLDPWD"
>$OLDPWD</A
> internal variable.</P
></DIV
></DD
><DT
>Control Characters</DT
><DD
><P
><A
NAME="CONTROLCHARREF"
></A
></P
><DIV
CLASS="FORMALPARA"
><P
><B
> change the behavior of the
	        terminal or text display. </B
>A control character is a <B
CLASS="KEYCAP"
>CONTROL</B
>
	      + <B
CLASS="KEYCAP"
>key</B
> combination.</P
></DIV
><UL
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-C</B
></TT
></P
><P
>Terminate a foreground job.</P
></LI
><LI
><P
><A
NAME="CTLDREF"
></A
></P
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-D</B
></TT
></P
><P
>Log out from a shell (similar to
		  <A
HREF="exit-status.html#EXITCOMMANDREF"
>exit</A
>).</P
><P
><SPAN
CLASS="QUOTE"
>"EOF"</SPAN
> (end of file). This also
		  terminates input from <TT
CLASS="FILENAME"
>stdin</TT
>.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-G</B
></TT
></P
><P
><SPAN
CLASS="QUOTE"
>"BEL"</SPAN
> (beep).</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-H</B
></TT
></P
><P
>Backspace.</P
><P
>		<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# Embedding Ctl-H in a string.
   3&nbsp;
   4&nbsp;a="^H^H"                  # Two Ctl-H's (backspaces).
   5&nbsp;echo "abcdef"             # abcdef
   6&nbsp;echo -n "abcdef$a "       # abcd f
   7&nbsp;#  Space at end  ^              ^ Backspaces twice.
   8&nbsp;echo -n "abcdef$a"        # abcdef
   9&nbsp;#  No space at end                Doesn't backspace (why?).
  10&nbsp;                          # Results may not be quite as expected.
  11&nbsp;echo; echo</PRE
></TD
></TR
></TABLE
>
                </P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-J</B
></TT
></P
><P
>Carriage return.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-L</B
></TT
></P
><P
>Formfeed (clear the terminal screen). This has
		  the same effect as the <A
HREF="terminalccmds.html#CLEARREF"
>clear</A
> command.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-M</B
></TT
></P
><P
>Newline.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-U</B
></TT
></P
><P
>Erase a line of input.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-Z</B
></TT
></P
><P
>Pause a foreground job.</P
></LI
></UL
></DD
><DT
>Whitespace</DT
><DD
><P
><A
NAME="WHITESPACEREF"
></A
></P
><DIV
CLASS="FORMALPARA"
><P
><B
>functions as a separator, separating commands or variables. </B
>Whitespace consists of either spaces, tabs, blank
		lines, or any combination thereof. In some contexts,
		such as <A
HREF="gotchas.html#WSBAD"
>variable assignment</A
>,
		whitespace is not permitted, and results in a syntax
		error.</P
></DIV
><P
>Blank lines have no effect on the action of a script,
	    and are therefore useful for visually separating functional
	    sections.</P
><P
><A
HREF="variables2.html#IFSREF"
>$IFS</A
>, the special variable
	    separating fields of input to certain commands, defaults
	    to whitespace.</P
></DD
></DL
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN762"
HREF="special-chars.html#AEN762"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>The shell does the <I
CLASS="EMPHASIS"
>brace
	       expansion</I
>. The command itself acts upon the
	       <I
CLASS="EMPHASIS"
>result</I
> of the expansion.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN811"
HREF="special-chars.html#AEN811"
>[2]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Exception: a code block in braces as
		  part of a pipe <I
CLASS="EMPHASIS"
>may</I
> be run as a
		  <A
HREF="subshells.html#SUBSHELLSREF"
>subshell</A
>.

		<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;ls | { read firstline; read secondline; }
   2&nbsp;# Error. The code block in braces runs as a subshell,
   3&nbsp;# so the output of "ls" cannot be passed to variables within the block.
   4&nbsp;echo "First line is $firstline; second line is $secondline"  # Will not work.
   5&nbsp;
   6&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
></P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="exit-status.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="variables.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Exit and Exit Status</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="part2.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Introduction to Variables and Parameters</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
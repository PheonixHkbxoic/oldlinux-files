<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on November, 11  2002 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>Debugging with GDB: Data</TITLE>

<META NAME="description" CONTENT="Debugging with GDB: Data">
<META NAME="keywords" CONTENT="Debugging with GDB: Data">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC53"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_8.html#SEC52"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC54"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_10.html#SEC73"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_10.html#SEC73"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 8. Examining Data </H1>
<!--docid::SEC53::-->
<P>

<A NAME="IDX295"></A>
<A NAME="IDX296"></A>
<A NAME="IDX297"></A>
<A NAME="IDX298"></A>
The usual way to examine data in your program is with the <CODE>print</CODE>
command (abbreviated <CODE>p</CODE>), or its synonym <CODE>inspect</CODE>.  It
evaluates and prints the value of an expression of the language your
program is written in (see section <A HREF="gdb_13.html#SEC92">Using GDB with Different Languages</A>).
</P><P>

<DL COMPACT>
<DT><CODE>print <VAR>expr</VAR></CODE>
<DD><DT><CODE>print /<VAR>f</VAR> <VAR>expr</VAR></CODE>
<DD><VAR>expr</VAR> is an expression (in the source language).  By default the
value of <VAR>expr</VAR> is printed in a format appropriate to its data type;
you can choose a different format by specifying <SAMP>`/<VAR>f</VAR>'</SAMP>, where
<VAR>f</VAR> is a letter specifying the format; see <A HREF="gdb_9.html#SEC57">Output formats</A>.
<P>

<DT><CODE>print</CODE>
<DD><DT><CODE>print /<VAR>f</VAR></CODE>
<DD>If you omit <VAR>expr</VAR>, GDB displays the last value again (from the
<EM>value history</EM>; see section <A HREF="gdb_9.html#SEC61">Value history</A>).  This allows you to
conveniently inspect the same value in an alternative format.
</DL>
<P>

A more low-level way of examining data is with the <CODE>x</CODE> command.
It examines data in memory at a specified address and prints it in a
specified format.  See section <A HREF="gdb_9.html#SEC58">Examining memory</A>.
</P><P>

If you are interested in information about types, or about how the
fields of a struct or a class are declared, use the <CODE>ptype <VAR>exp</VAR></CODE>
command rather than <CODE>print</CODE>.  See section <A HREF="gdb_14.html#SEC119">Examining the Symbol Table</A>.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_9.html#SEC54">8.1 Expressions</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_9.html#SEC55">8.2 Program variables</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_9.html#SEC56">8.3 Artificial arrays</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_9.html#SEC57">8.4 Output formats</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_9.html#SEC58">8.5 Examining memory</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_9.html#SEC59">8.6 Automatic display</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_9.html#SEC60">8.7 Print settings</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_9.html#SEC61">8.8 Value history</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_9.html#SEC62">8.9 Convenience variables</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_9.html#SEC63">8.10 Registers</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_9.html#SEC64">8.11 Floating point hardware</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_9.html#SEC65">8.12 Vector Unit</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_9.html#SEC66">8.13 Memory region attributes</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_9.html#SEC71">8.14 Copy between memory and a file</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="gdb_9.html#SEC72">8.15 Character Sets</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Debugging programs that use a different
                                character set than GDB does</TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Expressions"></A>
<HR SIZE="6">
<A NAME="SEC54"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC53"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC55"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC53"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC53"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_10.html#SEC73"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 8.1 Expressions </H2>
<!--docid::SEC54::-->
<P>

<A NAME="IDX299"></A>
<CODE>print</CODE> and many other GDB commands accept an expression and
compute its value.  Any kind of constant, variable or operator defined
by the programming language you are using is valid in an expression in
GDB.  This includes conditional expressions, function calls,
casts, and string constants.  It also includes preprocessor macros, if
you compiled your program to include this information; see
<A HREF="gdb_5.html#SEC17">4.1 Compiling for debugging</A>.
</P><P>

GDB supports array constants in expressions input by
the user.  The syntax is {<VAR>element</VAR>, <VAR>element</VAR><small>...</small>}.  For example,
you can use the command <CODE>print {1, 2, 3}</CODE> to build up an array in
memory that is <CODE>malloc</CODE>ed in the target program.
</P><P>

Because C is so widespread, most of the expressions shown in examples in
this manual are in C.  See section <A HREF="gdb_13.html#SEC92">Using GDB with Different Languages</A>, for information on how to use expressions in other
languages.
</P><P>

In this section, we discuss operators that you can use in GDB
expressions regardless of your programming language.
</P><P>

Casts are supported in all languages, not just in C, because it is so
useful to cast a number into a pointer in order to examine a structure
at that address in memory.
</P><P>

GDB supports these operators, in addition to those common
to programming languages:
</P><P>

<DL COMPACT>
<DT><CODE>@</CODE>
<DD><SAMP>`@'</SAMP> is a binary operator for treating parts of memory as arrays.
See section <A HREF="gdb_9.html#SEC56">Artificial arrays</A>, for more information.
<P>

<DT><CODE>::</CODE>
<DD><SAMP>`::'</SAMP> allows you to specify a variable in terms of the file or
function where it is defined.  See section <A HREF="gdb_9.html#SEC55">Program variables</A>.
<P>

<A NAME="IDX300"></A>
<A NAME="IDX301"></A>
<A NAME="IDX302"></A>
<A NAME="IDX303"></A>
<DT><CODE>{<VAR>type</VAR>} <VAR>addr</VAR></CODE>
<DD>Refers to an object of type <VAR>type</VAR> stored at address <VAR>addr</VAR> in
memory.  <VAR>addr</VAR> may be any expression whose value is an integer or
pointer (but parentheses are required around binary operators, just as in
a cast).  This construct is allowed regardless of what kind of data is
normally supposed to reside at <VAR>addr</VAR>.
</DL>
<P>

<A NAME="Variables"></A>
<HR SIZE="6">
<A NAME="SEC55"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC54"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC56"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC56"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC53"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_10.html#SEC73"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 8.2 Program variables </H2>
<!--docid::SEC55::-->
<P>

The most common kind of expression to use is the name of a variable
in your program.
</P><P>

Variables in expressions are understood in the selected stack frame
(see section <A HREF="gdb_7.html#SEC44">Selecting a frame</A>); they must be either:
</P><P>

<UL>
<LI>
global (or file-static)
</UL>
<P>

or
</P><P>

<UL>
<LI>
visible according to the scope rules of the
programming language from the point of execution in that frame
</UL>
<P>

This means that in the function
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>foo (a)
     int a;
{
  bar (a);
  {
    int b = test ();
    bar (b);
  }
}
</FONT></pre></td></tr></table></P><P>

you can examine and use the variable <CODE>a</CODE> whenever your program is
executing within the function <CODE>foo</CODE>, but you can only use or
examine the variable <CODE>b</CODE> while your program is executing inside
the block where <CODE>b</CODE> is declared.
</P><P>

<A NAME="IDX304"></A>
There is an exception: you can refer to a variable or function whose
scope is a single source file even if the current execution point is not
in this file.  But it is possible to have more than one such variable or
function with the same name (in different source files).  If that
happens, referring to that name has unpredictable effects.  If you wish,
you can specify a static variable in a particular function or file,
using the colon-colon notation:
</P><P>

<A NAME="IDX305"></A>
<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre><VAR>file</VAR>::<VAR>variable</VAR>
<VAR>function</VAR>::<VAR>variable</VAR>
</FONT></pre></td></tr></table></P><P>

Here <VAR>file</VAR> or <VAR>function</VAR> is the name of the context for the
static <VAR>variable</VAR>.  In the case of file names, you can use quotes to
make sure GDB parses the file name as a single word--for example,
to print a global value of <CODE>x</CODE> defined in <TT>`f2.c'</TT>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(gdb) p 'f2.c'::x
</FONT></pre></td></tr></table></P><P>

<A NAME="IDX306"></A>
This use of <SAMP>`::'</SAMP> is very rarely in conflict with the very similar
use of the same notation in C<TT>++</TT>.  GDB also supports use of the C<TT>++</TT>
scope resolution operator in GDB expressions.
</P><P>

<A NAME="IDX307"></A>
<A NAME="IDX308"></A>
<BLOCKQUOTE>
<EM>Warning:</EM> Occasionally, a local variable may appear to have the
wrong value at certain points in a function--just after entry to a new
scope, and just before exit.
</BLOCKQUOTE>
You may see this problem when you are stepping by machine instructions.
This is because, on most machines, it takes more than one instruction to
set up a stack frame (including local variable definitions); if you are
stepping by machine instructions, variables may appear to have the wrong
values until the stack frame is completely built.  On exit, it usually
also takes more than one machine instruction to destroy a stack frame;
after you begin stepping through that group of instructions, local
variable definitions may be gone.
<P>

This may also happen when the compiler does significant optimizations.
To be sure of always seeing accurate values, turn off all optimization
when compiling.
</P><P>

<A NAME="IDX309"></A>
Another possible effect of compiler optimizations is to optimize
unused variables out of existence, or assign variables to registers (as
opposed to memory addresses).  Depending on the support for such cases
offered by the debug info format used by the compiler, GDB
might not be able to display values for such local variables.  If that
happens, GDB will print a message like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>No symbol "foo" in current context.
</FONT></pre></td></tr></table></P><P>

To solve such problems, either recompile without optimizations, or use a
different debug info format, if the compiler supports several such
formats.  For example, GCC, the GNU C/C<TT>++</TT> compiler usually
supports the <SAMP>`-gstabs'</SAMP> option.  <SAMP>`-gstabs'</SAMP> produces debug info
in a format that is superior to formats such as COFF.  You may be able
to use DWARF2 (<SAMP>`-gdwarf-2'</SAMP>), which is also an effective form for
debug info.  See section `Options for Debugging Your Program or GNU CC' in <CITE>Using GNU CC</CITE>, for more
information.
</P><P>

<A NAME="Arrays"></A>
<HR SIZE="6">
<A NAME="SEC56"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC55"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC57"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC57"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC53"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_10.html#SEC73"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 8.3 Artificial arrays </H2>
<!--docid::SEC56::-->
<P>

<A NAME="IDX310"></A>
<A NAME="IDX311"></A>
It is often useful to print out several successive objects of the
same type in memory; a section of an array, or an array of
dynamically determined size for which only a pointer exists in the
program.
</P><P>

You can do this by referring to a contiguous span of memory as an
<EM>artificial array</EM>, using the binary operator <SAMP>`@'</SAMP>.  The left
operand of <SAMP>`@'</SAMP> should be the first element of the desired array
and be an individual object.  The right operand should be the desired length
of the array.  The result is an array value whose elements are all of
the type of the left argument.  The first element is actually the left
argument; the second element comes from bytes of memory immediately
following those that hold the first element, and so on.  Here is an
example.  If a program says
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>int *array = (int *) malloc (len * sizeof (int));
</FONT></pre></td></tr></table></P><P>

you can print the contents of <CODE>array</CODE> with
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>p *array@len
</FONT></pre></td></tr></table></P><P>

The left operand of <SAMP>`@'</SAMP> must reside in memory.  Array values made
with <SAMP>`@'</SAMP> in this way behave just like other arrays in terms of
subscripting, and are coerced to pointers when used in expressions.
Artificial arrays most often appear in expressions via the value history
(see section <A HREF="gdb_9.html#SEC61">Value history</A>), after printing one out.
</P><P>

Another way to create an artificial array is to use a cast.
This re-interprets a value as if it were an array.
The value need not be in memory:
<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(gdb) p/x (short[2])0x12345678
$1 = {0x1234, 0x5678}
</FONT></pre></td></tr></table></P><P>

As a convenience, if you leave the array length out (as in
<SAMP>`(<VAR>type</VAR>[])<VAR>value</VAR>'</SAMP>) GDB calculates the size to fill
the value (as <SAMP>`sizeof(<VAR>value</VAR>)/sizeof(<VAR>type</VAR>)'</SAMP>:
<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(gdb) p/x (short[])0x12345678
$2 = {0x1234, 0x5678}
</FONT></pre></td></tr></table></P><P>

Sometimes the artificial array mechanism is not quite enough; in
moderately complex data structures, the elements of interest may not
actually be adjacent--for example, if you are interested in the values
of pointers in an array.  One useful work-around in this situation is
to use a convenience variable (see section <A HREF="gdb_9.html#SEC62">Convenience variables</A>) as a counter in an expression that prints the first
interesting value, and then repeat that expression via <KBD>RET</KBD>.  For
instance, suppose you have an array <CODE>dtab</CODE> of pointers to
structures, and you are interested in the values of a field <CODE>fv</CODE>
in each structure.  Here is an example of what you might type:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>set $i = 0
p dtab[$i++]-&#62;fv
<KBD>RET</KBD>
<KBD>RET</KBD>
<small>...</small>
</FONT></pre></td></tr></table></P><P>

<A NAME="Output Formats"></A>
<HR SIZE="6">
<A NAME="SEC57"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC56"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC58"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC58"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC53"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_10.html#SEC73"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 8.4 Output formats </H2>
<!--docid::SEC57::-->
<P>

<A NAME="IDX312"></A>
<A NAME="IDX313"></A>
By default, GDB prints a value according to its data type.  Sometimes
this is not what you want.  For example, you might want to print a number
in hex, or a pointer in decimal.  Or you might want to view data in memory
at a certain address as a character string or as an instruction.  To do
these things, specify an <EM>output format</EM> when you print a value.
</P><P>

The simplest use of output formats is to say how to print a value
already computed.  This is done by starting the arguments of the
<CODE>print</CODE> command with a slash and a format letter.  The format
letters supported are:
</P><P>

<DL COMPACT>
<DT><CODE>x</CODE>
<DD>Regard the bits of the value as an integer, and print the integer in
hexadecimal.
<P>

<DT><CODE>d</CODE>
<DD>Print as integer in signed decimal.
<P>

<DT><CODE>u</CODE>
<DD>Print as integer in unsigned decimal.
<P>

<DT><CODE>o</CODE>
<DD>Print as integer in octal.
<P>

<DT><CODE>t</CODE>
<DD>Print as integer in binary.  The letter <SAMP>`t'</SAMP> stands for "two".
<A NAME="DOCF3" HREF="gdb_fot.html#FOOT3">(3)</A>
<P>

<DT><CODE>a</CODE>
<DD><A NAME="IDX314"></A>
<A NAME="IDX315"></A>
Print as an address, both absolute in hexadecimal and as an offset from
the nearest preceding symbol.  You can use this format used to discover
where (in what function) an unknown address is located:
<P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(gdb) p/a 0x54320
$3 = 0x54320 &#60;_initialize_vx+396&#62;
</FONT></pre></td></tr></table></P><P>

The command <CODE>info symbol 0x54320</CODE> yields similar results.
See section <A HREF="gdb_14.html#SEC119">info symbol</A>.
</P><P>

<DT><CODE>c</CODE>
<DD>Regard as an integer and print it as a character constant.
<P>

<DT><CODE>f</CODE>
<DD>Regard the bits of the value as a floating point number and print
using typical floating point syntax.
</DL>
<P>

For example, to print the program counter in hex (see section <A HREF="gdb_9.html#SEC63">8.10 Registers</A>), type
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>p/x $pc
</FONT></pre></td></tr></table></P><P>

Note that no space is required before the slash; this is because command
names in GDB cannot contain a slash.
</P><P>

To reprint the last value in the value history with a different format,
you can use the <CODE>print</CODE> command with just a format and no
expression.  For example, <SAMP>`p/x'</SAMP> reprints the last value in hex.
</P><P>

<A NAME="Memory"></A>
<HR SIZE="6">
<A NAME="SEC58"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC57"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC59"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC59"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC53"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_10.html#SEC73"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 8.5 Examining memory </H2>
<!--docid::SEC58::-->
<P>

You can use the command <CODE>x</CODE> (for "examine") to examine memory in
any of several formats, independently of your program's data types.
</P><P>

<A NAME="IDX316"></A>
<DL COMPACT>
<A NAME="IDX317"></A>
<DT><CODE>x/<VAR>nfu</VAR> <VAR>addr</VAR></CODE>
<DD><DT><CODE>x <VAR>addr</VAR></CODE>
<DD><DT><CODE>x</CODE>
<DD>Use the <CODE>x</CODE> command to examine memory.
</DL>
<P>

<VAR>n</VAR>, <VAR>f</VAR>, and <VAR>u</VAR> are all optional parameters that specify how
much memory to display and how to format it; <VAR>addr</VAR> is an
expression giving the address where you want to start displaying memory.
If you use defaults for <VAR>nfu</VAR>, you need not type the slash <SAMP>`/'</SAMP>.
Several commands set convenient defaults for <VAR>addr</VAR>.
</P><P>

<DL COMPACT>
<DT><VAR>n</VAR>, the repeat count
<DD>The repeat count is a decimal integer; the default is 1.  It specifies
how much memory (counting by units <VAR>u</VAR>) to display.
<P>

<DT><VAR>f</VAR>, the display format
<DD>The display format is one of the formats used by <CODE>print</CODE>,
<SAMP>`s'</SAMP> (null-terminated string), or <SAMP>`i'</SAMP> (machine instruction).
The default is <SAMP>`x'</SAMP> (hexadecimal) initially.
The default changes each time you use either <CODE>x</CODE> or <CODE>print</CODE>.
<P>

<DT><VAR>u</VAR>, the unit size
<DD>The unit size is any of
<P>

<DL COMPACT>
<DT><CODE>b</CODE>
<DD>Bytes.
<DT><CODE>h</CODE>
<DD>Halfwords (two bytes).
<DT><CODE>w</CODE>
<DD>Words (four bytes).  This is the initial default.
<DT><CODE>g</CODE>
<DD>Giant words (eight bytes).
</DL>
<P>

Each time you specify a unit size with <CODE>x</CODE>, that size becomes the
default unit the next time you use <CODE>x</CODE>.  (For the <SAMP>`s'</SAMP> and
<SAMP>`i'</SAMP> formats, the unit size is ignored and is normally not written.)
</P><P>

<DT><VAR>addr</VAR>, starting display address
<DD><VAR>addr</VAR> is the address where you want GDB to begin displaying
memory.  The expression need not have a pointer value (though it may);
it is always interpreted as an integer address of a byte of memory.
See section <A HREF="gdb_9.html#SEC54">Expressions</A>, for more information on expressions.  The default for
<VAR>addr</VAR> is usually just after the last address examined--but several
other commands also set the default address: <CODE>info breakpoints</CODE> (to
the address of the last breakpoint listed), <CODE>info line</CODE> (to the
starting address of a line), and <CODE>print</CODE> (if you use it to display
a value from memory).
</DL>
<P>

For example, <SAMP>`x/3uh 0x54320'</SAMP> is a request to display three halfwords
(<CODE>h</CODE>) of memory, formatted as unsigned decimal integers (<SAMP>`u'</SAMP>),
starting at address <CODE>0x54320</CODE>.  <SAMP>`x/4xw $sp'</SAMP> prints the four
words (<SAMP>`w'</SAMP>) of memory above the stack pointer (here, <SAMP>`$sp'</SAMP>;
see section <A HREF="gdb_9.html#SEC63">Registers</A>) in hexadecimal (<SAMP>`x'</SAMP>).
</P><P>

Since the letters indicating unit sizes are all distinct from the
letters specifying output formats, you do not have to remember whether
unit size or format comes first; either order works.  The output
specifications <SAMP>`4xw'</SAMP> and <SAMP>`4wx'</SAMP> mean exactly the same thing.
(However, the count <VAR>n</VAR> must come first; <SAMP>`wx4'</SAMP> does not work.)
</P><P>

Even though the unit size <VAR>u</VAR> is ignored for the formats <SAMP>`s'</SAMP>
and <SAMP>`i'</SAMP>, you might still want to use a count <VAR>n</VAR>; for example,
<SAMP>`3i'</SAMP> specifies that you want to see three machine instructions,
including any operands.  The command <CODE>disassemble</CODE> gives an
alternative way of inspecting machine instructions; see <A HREF="gdb_8.html#SEC52">Source and machine code</A>.
</P><P>

All the defaults for the arguments to <CODE>x</CODE> are designed to make it
easy to continue scanning memory with minimal specifications each time
you use <CODE>x</CODE>.  For example, after you have inspected three machine
instructions with <SAMP>`x/3i <VAR>addr</VAR>'</SAMP>, you can inspect the next seven
with just <SAMP>`x/7'</SAMP>.  If you use <KBD>RET</KBD> to repeat the <CODE>x</CODE> command,
the repeat count <VAR>n</VAR> is used again; the other arguments default as
for successive uses of <CODE>x</CODE>.
</P><P>

<A NAME="IDX318"></A>
The addresses and contents printed by the <CODE>x</CODE> command are not saved
in the value history because there is often too much of them and they
would get in the way.  Instead, GDB makes these values available for
subsequent use in expressions as values of the convenience variables
<CODE>$_</CODE> and <CODE>$__</CODE>.  After an <CODE>x</CODE> command, the last address
examined is available for use in expressions in the convenience variable
<CODE>$_</CODE>.  The contents of that address, as examined, are available in
the convenience variable <CODE>$__</CODE>.
</P><P>

If the <CODE>x</CODE> command has a repeat count, the address and contents saved
are from the last memory unit printed; this is not the same as the last
address printed if several units were printed on the last line of output.
</P><P>

<A NAME="Auto Display"></A>
<HR SIZE="6">
<A NAME="SEC59"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC58"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC60"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC60"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC53"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_10.html#SEC73"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 8.6 Automatic display </H2>
<!--docid::SEC59::-->
<P>

If you find that you want to print the value of an expression frequently
(to see how it changes), you might want to add it to the <EM>automatic
display list</EM> so that GDB prints its value each time your program stops.
Each expression added to the list is given a number to identify it;
to remove an expression from the list, you specify that number.
The automatic display looks like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>2: foo = 38
3: bar[5] = (struct hack *) 0x3804
</FONT></pre></td></tr></table></P><P>

This display shows item numbers, expressions and their current values.  As with
displays you request manually using <CODE>x</CODE> or <CODE>print</CODE>, you can
specify the output format you prefer; in fact, <CODE>display</CODE> decides
whether to use <CODE>print</CODE> or <CODE>x</CODE> depending on how elaborate your
format specification is--it uses <CODE>x</CODE> if you specify a unit size,
or one of the two formats (<SAMP>`i'</SAMP> and <SAMP>`s'</SAMP>) that are only
supported by <CODE>x</CODE>; otherwise it uses <CODE>print</CODE>.
</P><P>

<DL COMPACT>
<A NAME="IDX319"></A>
<DT><CODE>display <VAR>expr</VAR></CODE>
<DD>Add the expression <VAR>expr</VAR> to the list of expressions to display
each time your program stops.  See section <A HREF="gdb_9.html#SEC54">Expressions</A>.
<P>

<CODE>display</CODE> does not repeat if you press <KBD>RET</KBD> again after using it.
</P><P>

<DT><CODE>display/<VAR>fmt</VAR> <VAR>expr</VAR></CODE>
<DD>For <VAR>fmt</VAR> specifying only a display format and not a size or
count, add the expression <VAR>expr</VAR> to the auto-display list but
arrange to display it each time in the specified format <VAR>fmt</VAR>.
See section <A HREF="gdb_9.html#SEC57">Output formats</A>.
<P>

<DT><CODE>display/<VAR>fmt</VAR> <VAR>addr</VAR></CODE>
<DD>For <VAR>fmt</VAR> <SAMP>`i'</SAMP> or <SAMP>`s'</SAMP>, or including a unit-size or a
number of units, add the expression <VAR>addr</VAR> as a memory address to
be examined each time your program stops.  Examining means in effect
doing <SAMP>`x/<VAR>fmt</VAR> <VAR>addr</VAR>'</SAMP>.  See section <A HREF="gdb_9.html#SEC58">Examining memory</A>.
</DL>
<P>

For example, <SAMP>`display/i $pc'</SAMP> can be helpful, to see the machine
instruction about to be executed each time execution stops (<SAMP>`$pc'</SAMP>
is a common name for the program counter; see section <A HREF="gdb_9.html#SEC63">Registers</A>).
</P><P>

<DL COMPACT>
<A NAME="IDX320"></A>
<A NAME="IDX321"></A>
<DT><CODE>undisplay <VAR>dnums</VAR><small>...</small></CODE>
<DD><DT><CODE>delete display <VAR>dnums</VAR><small>...</small></CODE>
<DD>Remove item numbers <VAR>dnums</VAR> from the list of expressions to display.
<P>

<CODE>undisplay</CODE> does not repeat if you press <KBD>RET</KBD> after using it.
(Otherwise you would just get the error <SAMP>`No display number <small>...</small>'</SAMP>.)
</P><P>

<A NAME="IDX322"></A>
<DT><CODE>disable display <VAR>dnums</VAR><small>...</small></CODE>
<DD>Disable the display of item numbers <VAR>dnums</VAR>.  A disabled display
item is not printed automatically, but is not forgotten.  It may be
enabled again later.
<P>

<A NAME="IDX323"></A>
<DT><CODE>enable display <VAR>dnums</VAR><small>...</small></CODE>
<DD>Enable display of item numbers <VAR>dnums</VAR>.  It becomes effective once
again in auto display of its expression, until you specify otherwise.
<P>

<DT><CODE>display</CODE>
<DD>Display the current values of the expressions on the list, just as is
done when your program stops.
<P>

<A NAME="IDX324"></A>
<DT><CODE>info display</CODE>
<DD>Print the list of expressions previously set up to display
automatically, each one with its item number, but without showing the
values.  This includes disabled expressions, which are marked as such.
It also includes expressions which would not be displayed right now
because they refer to automatic variables not currently available.
</DL>
<P>

If a display expression refers to local variables, then it does not make
sense outside the lexical context for which it was set up.  Such an
expression is disabled when execution enters a context where one of its
variables is not defined.  For example, if you give the command
<CODE>display last_char</CODE> while inside a function with an argument
<CODE>last_char</CODE>, GDB displays this argument while your program
continues to stop inside that function.  When it stops elsewhere--where
there is no variable <CODE>last_char</CODE>---the display is disabled
automatically.  The next time your program stops where <CODE>last_char</CODE>
is meaningful, you can enable the display expression once again.
</P><P>

<A NAME="Print Settings"></A>
<HR SIZE="6">
<A NAME="SEC60"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC59"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC61"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC61"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC53"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_10.html#SEC73"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 8.7 Print settings </H2>
<!--docid::SEC60::-->
<P>

<A NAME="IDX325"></A>
<A NAME="IDX326"></A>
GDB provides the following ways to control how arrays, structures,
and symbols are printed.
</P><P>

These settings are useful for debugging programs in any language:
</P><P>

<DL COMPACT>
<A NAME="IDX327"></A>
<DT><CODE>set print address</CODE>
<DD><DT><CODE>set print address on</CODE>
<DD>GDB prints memory addresses showing the location of stack
traces, structure values, pointer values, breakpoints, and so forth,
even when it also displays the contents of those addresses.  The default
is <CODE>on</CODE>.  For example, this is what a stack frame display looks like with
<CODE>set print address on</CODE>:
<P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(gdb) f
#0  set_quotes (lq=0x34c78 "&#60;&#60;", rq=0x34c88 ">&#62;")
    at input.c:530
530         if (lquote != def_lquote)
</FONT></pre></td></tr></table></P><P>

<DT><CODE>set print address off</CODE>
<DD>Do not print addresses when displaying their contents.  For example,
this is the same stack frame displayed with <CODE>set print address off</CODE>:
<P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(gdb) set print addr off
(gdb) f
#0  set_quotes (lq="&#60;&#60;", rq=">&#62;") at input.c:530
530         if (lquote != def_lquote)
</FONT></pre></td></tr></table></P><P>

You can use <SAMP>`set print address off'</SAMP> to eliminate all machine
dependent displays from the GDB interface.  For example, with
<CODE>print address off</CODE>, you should get the same text for backtraces on
all machines--whether or not they involve pointer arguments.
</P><P>

<A NAME="IDX328"></A>
<DT><CODE>show print address</CODE>
<DD>Show whether or not addresses are to be printed.
</DL>
<P>

When GDB prints a symbolic address, it normally prints the
closest earlier symbol plus an offset.  If that symbol does not uniquely
identify the address (for example, it is a name whose scope is a single
source file), you may need to clarify.  One way to do this is with
<CODE>info line</CODE>, for example <SAMP>`info line *0x4537'</SAMP>.  Alternately,
you can set GDB to print the source file and line number when
it prints a symbolic address:
</P><P>

<DL COMPACT>
<A NAME="IDX329"></A>
<DT><CODE>set print symbol-filename on</CODE>
<DD>Tell GDB to print the source file name and line number of a
symbol in the symbolic form of an address.
<P>

<DT><CODE>set print symbol-filename off</CODE>
<DD>Do not print source file name and line number of a symbol.  This is the
default.
<P>

<A NAME="IDX330"></A>
<DT><CODE>show print symbol-filename</CODE>
<DD>Show whether or not GDB will print the source file name and
line number of a symbol in the symbolic form of an address.
</DL>
<P>

Another situation where it is helpful to show symbol filenames and line
numbers is when disassembling code; GDB shows you the line
number and source file that corresponds to each instruction.
</P><P>

Also, you may wish to see the symbolic form only if the address being
printed is reasonably close to the closest earlier symbol:
</P><P>

<DL COMPACT>
<A NAME="IDX331"></A>
<DT><CODE>set print max-symbolic-offset <VAR>max-offset</VAR></CODE>
<DD>Tell GDB to only display the symbolic form of an address if the
offset between the closest earlier symbol and the address is less than
<VAR>max-offset</VAR>.  The default is 0, which tells GDB
to always print the symbolic form of an address if any symbol precedes it.
<P>

<A NAME="IDX332"></A>
<DT><CODE>show print max-symbolic-offset</CODE>
<DD>Ask how large the maximum offset is that GDB prints in a
symbolic address.
</DL>
<P>

<A NAME="IDX333"></A>
<A NAME="IDX334"></A>
If you have a pointer and you are not sure where it points, try
<SAMP>`set print symbol-filename on'</SAMP>.  Then you can determine the name
and source file location of the variable where it points, using
<SAMP>`p/a <VAR>pointer</VAR>'</SAMP>.  This interprets the address in symbolic form.
For example, here GDB shows that a variable <CODE>ptt</CODE> points
at another variable <CODE>t</CODE>, defined in <TT>`hi2.c'</TT>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(gdb) set print symbol-filename on
(gdb) p/a ptt
$4 = 0xe008 &#60;t in hi2.c&#62;
</FONT></pre></td></tr></table></P><P>

<BLOCKQUOTE>
<EM>Warning:</EM> For pointers that point to a local variable, <SAMP>`p/a'</SAMP>
does not show the symbol name and filename of the referent, even with
the appropriate <CODE>set print</CODE> options turned on.
</BLOCKQUOTE>
<P>

Other settings control how different kinds of objects are printed:
</P><P>

<DL COMPACT>
<A NAME="IDX335"></A>
<DT><CODE>set print array</CODE>
<DD><DT><CODE>set print array on</CODE>
<DD>Pretty print arrays.  This format is more convenient to read,
but uses more space.  The default is off.
<P>

<DT><CODE>set print array off</CODE>
<DD>Return to compressed format for arrays.
<P>

<A NAME="IDX336"></A>
<DT><CODE>show print array</CODE>
<DD>Show whether compressed or pretty format is selected for displaying
arrays.
<P>

<A NAME="IDX337"></A>
<DT><CODE>set print elements <VAR>number-of-elements</VAR></CODE>
<DD>Set a limit on how many elements of an array GDB will print.
If GDB is printing a large array, it stops printing after it has
printed the number of elements set by the <CODE>set print elements</CODE> command.
This limit also applies to the display of strings.
When GDB starts, this limit is set to 200.
Setting  <VAR>number-of-elements</VAR> to zero means that the printing is unlimited.
<P>

<A NAME="IDX338"></A>
<DT><CODE>show print elements</CODE>
<DD>Display the number of elements of a large array that GDB will print.
If the number is 0, then the printing is unlimited.
<P>

<A NAME="IDX339"></A>
<DT><CODE>set print null-stop</CODE>
<DD>Cause GDB to stop printing the characters of an array when the first
NULL is encountered.  This is useful when large arrays actually
contain only short strings.
The default is off.
<P>

<A NAME="IDX340"></A>
<DT><CODE>set print pretty on</CODE>
<DD>Cause GDB to print structures in an indented format with one member
per line, like this:
<P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>$1 = {
  next = 0x0,
  flags = {
    sweet = 1,
    sour = 1
  },
  meat = 0x54 "Pork"
}
</FONT></pre></td></tr></table></P><P>

<DT><CODE>set print pretty off</CODE>
<DD>Cause GDB to print structures in a compact format, like this:
<P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>$1 = {next = 0x0, flags = {sweet = 1, sour = 1}, \
meat = 0x54 "Pork"}
</FONT></pre></td></tr></table></P><P>

This is the default format.
</P><P>

<A NAME="IDX341"></A>
<DT><CODE>show print pretty</CODE>
<DD>Show which format GDB is using to print structures.
<P>

<A NAME="IDX342"></A>
<DT><CODE>set print sevenbit-strings on</CODE>
<DD>Print using only seven-bit characters; if this option is set,
GDB displays any eight-bit characters (in strings or
character values) using the notation <CODE>\</CODE><VAR>nnn</VAR>.  This setting is
best if you are working in English (ASCII) and you use the
high-order bit of characters as a marker or "meta" bit.
<P>

<DT><CODE>set print sevenbit-strings off</CODE>
<DD>Print full eight-bit characters.  This allows the use of more
international character sets, and is the default.
<P>

<A NAME="IDX343"></A>
<DT><CODE>show print sevenbit-strings</CODE>
<DD>Show whether or not GDB is printing only seven-bit characters.
<P>

<A NAME="IDX344"></A>
<DT><CODE>set print union on</CODE>
<DD>Tell GDB to print unions which are contained in structures.  This
is the default setting.
<P>

<DT><CODE>set print union off</CODE>
<DD>Tell GDB not to print unions which are contained in structures.
<P>

<A NAME="IDX345"></A>
<DT><CODE>show print union</CODE>
<DD>Ask GDB whether or not it will print unions which are contained in
structures.
<P>

For example, given the declarations
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>typedef enum {Tree, Bug} Species;
typedef enum {Big_tree, Acorn, Seedling} Tree_forms;
typedef enum {Caterpillar, Cocoon, Butterfly}
              Bug_forms;

struct thing {
  Species it;
  union {
    Tree_forms tree;
    Bug_forms bug;
  } form;
};

struct thing foo = {Tree, {Acorn}};
</FONT></pre></td></tr></table></P><P>

with <CODE>set print union on</CODE> in effect <SAMP>`p foo'</SAMP> would print
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>$1 = {it = Tree, form = {tree = Acorn, bug = Cocoon}}
</FONT></pre></td></tr></table></P><P>

and with <CODE>set print union off</CODE> in effect it would print
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>$1 = {it = Tree, form = {...}}
</FONT></pre></td></tr></table></DL>
<P>

These settings are of interest when debugging C<TT>++</TT> programs:
</P><P>

<DL COMPACT>
<A NAME="IDX346"></A>
<A NAME="IDX347"></A>
<DT><CODE>set print demangle</CODE>
<DD><DT><CODE>set print demangle on</CODE>
<DD>Print C<TT>++</TT> names in their source form rather than in the encoded
("mangled") form passed to the assembler and linker for type-safe
linkage.  The default is on.
<P>

<A NAME="IDX348"></A>
<DT><CODE>show print demangle</CODE>
<DD>Show whether C<TT>++</TT> names are printed in mangled or demangled form.
<P>

<A NAME="IDX349"></A>
<DT><CODE>set print asm-demangle</CODE>
<DD><DT><CODE>set print asm-demangle on</CODE>
<DD>Print C<TT>++</TT> names in their source form rather than their mangled form, even
in assembler code printouts such as instruction disassemblies.
The default is off.
<P>

<A NAME="IDX350"></A>
<DT><CODE>show print asm-demangle</CODE>
<DD>Show whether C<TT>++</TT> names in assembly listings are printed in mangled
or demangled form.
<P>

<A NAME="IDX351"></A>
<A NAME="IDX352"></A>
<A NAME="IDX353"></A>
<DT><CODE>set demangle-style <VAR>style</VAR></CODE>
<DD>Choose among several encoding schemes used by different compilers to
represent C<TT>++</TT> names.  The choices for <VAR>style</VAR> are currently:
<P>

<DL COMPACT>
<DT><CODE>auto</CODE>
<DD>Allow GDB to choose a decoding style by inspecting your program.
<P>

<DT><CODE>gnu</CODE>
<DD>Decode based on the GNU C<TT>++</TT> compiler (<CODE>g++</CODE>) encoding algorithm.
This is the default.
<P>

<DT><CODE>hp</CODE>
<DD>Decode based on the HP ANSI C<TT>++</TT> (<CODE>aCC</CODE>) encoding algorithm.
<P>

<DT><CODE>lucid</CODE>
<DD>Decode based on the Lucid C<TT>++</TT> compiler (<CODE>lcc</CODE>) encoding algorithm.
<P>

<DT><CODE>arm</CODE>
<DD>Decode using the algorithm in the <CITE>C<TT>++</TT> Annotated Reference Manual</CITE>.
<STRONG>Warning:</STRONG> this setting alone is not sufficient to allow
debugging <CODE>cfront</CODE>-generated executables.  GDB would
require further enhancement to permit that.
<P>

</DL>
If you omit <VAR>style</VAR>, you will see a list of possible formats.
<P>

<A NAME="IDX354"></A>
<DT><CODE>show demangle-style</CODE>
<DD>Display the encoding style currently in use for decoding C<TT>++</TT> symbols.
<P>

<A NAME="IDX355"></A>
<DT><CODE>set print object</CODE>
<DD><DT><CODE>set print object on</CODE>
<DD>When displaying a pointer to an object, identify the <EM>actual</EM>
(derived) type of the object rather than the <EM>declared</EM> type, using
the virtual function table.
<P>

<DT><CODE>set print object off</CODE>
<DD>Display only the declared type of objects, without reference to the
virtual function table.  This is the default setting.
<P>

<A NAME="IDX356"></A>
<DT><CODE>show print object</CODE>
<DD>Show whether actual, or declared, object types are displayed.
<P>

<A NAME="IDX357"></A>
<DT><CODE>set print static-members</CODE>
<DD><DT><CODE>set print static-members on</CODE>
<DD>Print static members when displaying a C<TT>++</TT> object.  The default is on.
<P>

<DT><CODE>set print static-members off</CODE>
<DD>Do not print static members when displaying a C<TT>++</TT> object.
<P>

<A NAME="IDX358"></A>
<DT><CODE>show print static-members</CODE>
<DD>Show whether C<TT>++</TT> static members are printed, or not.
<P>

<A NAME="IDX359"></A>
<DT><CODE>set print vtbl</CODE>
<DD><DT><CODE>set print vtbl on</CODE>
<DD>Pretty print C<TT>++</TT> virtual function tables.  The default is off.
(The <CODE>vtbl</CODE> commands do not work on programs compiled with the HP
ANSI C<TT>++</TT> compiler (<CODE>aCC</CODE>).)
<P>

<DT><CODE>set print vtbl off</CODE>
<DD>Do not pretty print C<TT>++</TT> virtual function tables.
<P>

<A NAME="IDX360"></A>
<DT><CODE>show print vtbl</CODE>
<DD>Show whether C<TT>++</TT> virtual function tables are pretty printed, or not.
</DL>
<P>

<A NAME="Value History"></A>
<HR SIZE="6">
<A NAME="SEC61"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC60"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC62"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC62"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC53"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_10.html#SEC73"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 8.8 Value history </H2>
<!--docid::SEC61::-->
<P>

<A NAME="IDX361"></A>
Values printed by the <CODE>print</CODE> command are saved in the GDB
<EM>value history</EM>.  This allows you to refer to them in other expressions.
Values are kept until the symbol table is re-read or discarded
(for example with the <CODE>file</CODE> or <CODE>symbol-file</CODE> commands).
When the symbol table changes, the value history is discarded,
since the values may contain pointers back to the types defined in the
symbol table.
</P><P>

<A NAME="IDX362"></A>
<A NAME="IDX363"></A>
<A NAME="IDX364"></A>
The values printed are given <EM>history numbers</EM> by which you can
refer to them.  These are successive integers starting with one.
<CODE>print</CODE> shows you the history number assigned to a value by
printing <SAMP>`$<VAR>num</VAR> = '</SAMP> before the value; here <VAR>num</VAR> is the
history number.
</P><P>

To refer to any previous value, use <SAMP>`$'</SAMP> followed by the value's
history number.  The way <CODE>print</CODE> labels its output is designed to
remind you of this.  Just <CODE>$</CODE> refers to the most recent value in
the history, and <CODE>$$</CODE> refers to the value before that.
<CODE>$$<VAR>n</VAR></CODE> refers to the <VAR>n</VAR>th value from the end; <CODE>$$2</CODE>
is the value just prior to <CODE>$$</CODE>, <CODE>$$1</CODE> is equivalent to
<CODE>$$</CODE>, and <CODE>$$0</CODE> is equivalent to <CODE>$</CODE>.
</P><P>

For example, suppose you have just printed a pointer to a structure and
want to see the contents of the structure.  It suffices to type
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>p *$
</FONT></pre></td></tr></table></P><P>

If you have a chain of structures where the component <CODE>next</CODE> points
to the next one, you can print the contents of the next one with this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>p *$.next
</FONT></pre></td></tr></table></P><P>

You can print successive links in the chain by repeating this
command--which you can do by just typing <KBD>RET</KBD>.
</P><P>

Note that the history records values, not expressions.  If the value of
<CODE>x</CODE> is 4 and you type these commands:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>print x
set x=5
</FONT></pre></td></tr></table></P><P>

then the value recorded in the value history by the <CODE>print</CODE> command
remains 4 even though the value of <CODE>x</CODE> has changed.
</P><P>

<DL COMPACT>
<A NAME="IDX365"></A>
<DT><CODE>show values</CODE>
<DD>Print the last ten values in the value history, with their item numbers.
This is like <SAMP>`p $$9'</SAMP> repeated ten times, except that <CODE>show
values</CODE> does not change the history.
<P>

<DT><CODE>show values <VAR>n</VAR></CODE>
<DD>Print ten history values centered on history item number <VAR>n</VAR>.
<P>

<DT><CODE>show values +</CODE>
<DD>Print ten history values just after the values last printed.  If no more
values are available, <CODE>show values +</CODE> produces no display.
</DL>
<P>

Pressing <KBD>RET</KBD> to repeat <CODE>show values <VAR>n</VAR></CODE> has exactly the
same effect as <SAMP>`show values +'</SAMP>.
</P><P>

<A NAME="Convenience Vars"></A>
<HR SIZE="6">
<A NAME="SEC62"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC61"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC63"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC53"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC53"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_10.html#SEC73"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 8.9 Convenience variables </H2>
<!--docid::SEC62::-->
<P>

<A NAME="IDX366"></A>
GDB provides <EM>convenience variables</EM> that you can use within
GDB to hold on to a value and refer to it later.  These variables
exist entirely within GDB; they are not part of your program, and
setting a convenience variable has no direct effect on further execution
of your program.  That is why you can use them freely.
</P><P>

Convenience variables are prefixed with <SAMP>`$'</SAMP>.  Any name preceded by
<SAMP>`$'</SAMP> can be used for a convenience variable, unless it is one of
the predefined machine-specific register names (see section <A HREF="gdb_9.html#SEC63">Registers</A>).
(Value history references, in contrast, are <EM>numbers</EM> preceded
by <SAMP>`$'</SAMP>.  See section <A HREF="gdb_9.html#SEC61">Value history</A>.)
</P><P>

You can save a value in a convenience variable with an assignment
expression, just as you would set a variable in your program.
For example:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>set $foo = *object_ptr
</FONT></pre></td></tr></table></P><P>

would save in <CODE>$foo</CODE> the value contained in the object pointed to by
<CODE>object_ptr</CODE>.
</P><P>

Using a convenience variable for the first time creates it, but its
value is <CODE>void</CODE> until you assign a new value.  You can alter the
value with another assignment at any time.
</P><P>

Convenience variables have no fixed types.  You can assign a convenience
variable any type of value, including structures and arrays, even if
that variable already has a value of a different type.  The convenience
variable, when used as an expression, has the type of its current value.
</P><P>

<DL COMPACT>
<A NAME="IDX367"></A>
<DT><CODE>show convenience</CODE>
<DD>Print a list of convenience variables used so far, and their values.
Abbreviated <CODE>show conv</CODE>.
</DL>
<P>

One of the ways to use a convenience variable is as a counter to be
incremented or a pointer to be advanced.  For example, to print
a field from successive elements of an array of structures:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>set $i = 0
print bar[$i++]-&#62;contents
</FONT></pre></td></tr></table></P><P>

Repeat that command by typing <KBD>RET</KBD>.
</P><P>

Some convenience variables are created automatically by GDB and given
values likely to be useful.
</P><P>

<DL COMPACT>
<A NAME="IDX368"></A>
<DT><CODE>$_</CODE>
<DD>The variable <CODE>$_</CODE> is automatically set by the <CODE>x</CODE> command to
the last address examined (see section <A HREF="gdb_9.html#SEC58">Examining memory</A>).  Other
commands which provide a default address for <CODE>x</CODE> to examine also
set <CODE>$_</CODE> to that address; these commands include <CODE>info line</CODE>
and <CODE>info breakpoint</CODE>.  The type of <CODE>$_</CODE> is <CODE>void *</CODE>
except when set by the <CODE>x</CODE> command, in which case it is a pointer
to the type of <CODE>$__</CODE>.
<P>

<A NAME="IDX369"></A>
<DT><CODE>$__</CODE>
<DD>The variable <CODE>$__</CODE> is automatically set by the <CODE>x</CODE> command
to the value found in the last address examined.  Its type is chosen
to match the format in which the data was printed.
<P>

<DT><CODE>$_exitcode</CODE>
<DD><A NAME="IDX370"></A>
The variable <CODE>$_exitcode</CODE> is automatically set to the exit code when
the program being debugged terminates.
</DL>
<P>

On HP-UX systems, if you refer to a function or variable name that
begins with a dollar sign, GDB searches for a user or system
name first, before it searches for a convenience variable.
</P><P>

<A NAME="Registers"></A>
<HR SIZE="6">
<A NAME="SEC63"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC62"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC64"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC55"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC53"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_10.html#SEC73"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 8.10 Registers </H2>
<!--docid::SEC63::-->
<P>

<A NAME="IDX371"></A>
You can refer to machine register contents, in expressions, as variables
with names starting with <SAMP>`$'</SAMP>.  The names of registers are different
for each machine; use <CODE>info registers</CODE> to see the names used on
your machine.
</P><P>

<DL COMPACT>
<A NAME="IDX372"></A>
<DT><CODE>info registers</CODE>
<DD>Print the names and values of all registers except floating-point
and vector registers (in the selected stack frame).
<P>

<A NAME="IDX373"></A>
<A NAME="IDX374"></A>
<DT><CODE>info all-registers</CODE>
<DD>Print the names and values of all registers, including floating-point
and vector registers (in the selected stack frame).
<P>

<DT><CODE>info registers <VAR>regname</VAR> <small>...</small></CODE>
<DD>Print the <EM>relativized</EM> value of each specified register <VAR>regname</VAR>.
As discussed in detail below, register values are normally relative to
the selected stack frame.  <VAR>regname</VAR> may be any register name valid on
the machine you are using, with or without the initial <SAMP>`$'</SAMP>.
</DL>
<P>

GDB has four "standard" register names that are available (in
expressions) on most machines--whenever they do not conflict with an
architecture's canonical mnemonics for registers.  The register names
<CODE>$pc</CODE> and <CODE>$sp</CODE> are used for the program counter register and
the stack pointer.  <CODE>$fp</CODE> is used for a register that contains a
pointer to the current stack frame, and <CODE>$ps</CODE> is used for a
register that contains the processor status.  For example,
you could print the program counter in hex with
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>p/x $pc
</FONT></pre></td></tr></table></P><P>

or print the instruction to be executed next with
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>x/i $pc
</FONT></pre></td></tr></table></P><P>

or add four to the stack pointer<A NAME="DOCF4" HREF="gdb_fot.html#FOOT4">(4)</A> with
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>set $sp += 4
</FONT></pre></td></tr></table></P><P>

Whenever possible, these four standard register names are available on
your machine even though the machine has different canonical mnemonics,
so long as there is no conflict.  The <CODE>info registers</CODE> command
shows the canonical names.  For example, on the SPARC, <CODE>info
registers</CODE> displays the processor status register as <CODE>$psr</CODE> but you
can also refer to it as <CODE>$ps</CODE>; and on x86-based machines <CODE>$ps</CODE>
is an alias for the EFLAGS register.
</P><P>

GDB always considers the contents of an ordinary register as an
integer when the register is examined in this way.  Some machines have
special registers which can hold nothing but floating point; these
registers are considered to have floating point values.  There is no way
to refer to the contents of an ordinary register as floating point value
(although you can <EM>print</EM> it as a floating point value with
<SAMP>`print/f $<VAR>regname</VAR>'</SAMP>).
</P><P>

Some registers have distinct "raw" and "virtual" data formats.  This
means that the data format in which the register contents are saved by
the operating system is not the same one that your program normally
sees.  For example, the registers of the 68881 floating point
coprocessor are always saved in "extended" (raw) format, but all C
programs expect to work with "double" (virtual) format.  In such
cases, GDB normally works with the virtual format only (the format
that makes sense for your program), but the <CODE>info registers</CODE> command
prints the data in both formats.
</P><P>

Normally, register values are relative to the selected stack frame
(see section <A HREF="gdb_7.html#SEC44">Selecting a frame</A>).  This means that you get the
value that the register would contain if all stack frames farther in
were exited and their saved registers restored.  In order to see the
true contents of hardware registers, you must select the innermost
frame (with <SAMP>`frame 0'</SAMP>).
</P><P>

However, GDB must deduce where registers are saved, from the machine
code generated by your compiler.  If some registers are not saved, or if
GDB is unable to locate the saved registers, the selected stack
frame makes no difference.
</P><P>

<A NAME="Floating Point Hardware"></A>
<HR SIZE="6">
<A NAME="SEC64"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC63"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC65"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC55"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC53"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_10.html#SEC73"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 8.11 Floating point hardware </H2>
<!--docid::SEC64::-->
<P>

Depending on the configuration, GDB may be able to give
you more information about the status of the floating point hardware.
</P><P>

<DL COMPACT>
<A NAME="IDX375"></A>
<DT><CODE>info float</CODE>
<DD>Display hardware-dependent information about the floating
point unit.  The exact contents and layout vary depending on the
floating point chip.  Currently, <SAMP>`info float'</SAMP> is supported on
the ARM and x86 machines.
</DL>
<P>

<A NAME="Vector Unit"></A>
<HR SIZE="6">
<A NAME="SEC65"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC64"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC66"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC55"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC53"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_10.html#SEC73"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 8.12 Vector Unit </H2>
<!--docid::SEC65::-->
<P>

Depending on the configuration, GDB may be able to give you
more information about the status of the vector unit.
</P><P>

<DL COMPACT>
<A NAME="IDX376"></A>
<DT><CODE>info vector</CODE>
<DD>Display information about the vector unit.  The exact contents and
layout vary depending on the hardware.
</DL>
<P>

<A NAME="Memory Region Attributes"></A>
<HR SIZE="6">
<A NAME="SEC66"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC65"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC67"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC55"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC53"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC71"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 8.13 Memory region attributes </H2>
<!--docid::SEC66::-->
<P>

<EM>Memory region attributes</EM> allow you to describe special handling 
required by regions of your target's memory.  GDB uses attributes 
to determine whether to allow certain types of memory accesses; whether to
use specific width accesses; and whether to cache target memory.
</P><P>

Defined memory regions can be individually enabled and disabled.  When a
memory region is disabled, GDB uses the default attributes when
accessing memory in that region.  Similarly, if no memory regions have
been defined, GDB uses the default attributes when accessing
all memory.
</P><P>

When a memory region is defined, it is given a number to identify it; 
to enable, disable, or remove a memory region, you specify that number.
</P><P>

<DL COMPACT>
<A NAME="IDX377"></A>
<DT><CODE>mem <VAR>lower</VAR> <VAR>upper</VAR> <VAR>attributes</VAR><small>...</small></CODE>
<DD>Define memory region bounded by <VAR>lower</VAR> and <VAR>upper</VAR> with
attributes <VAR>attributes</VAR><small>...</small>.  Note that <VAR>upper</VAR> == 0 is a
special case: it is treated as the the target's maximum memory address.
(0xffff on 16 bit targets, 0xffffffff on 32 bit targets, etc.)
<P>

<A NAME="IDX378"></A>
<DT><CODE>delete mem <VAR>nums</VAR><small>...</small></CODE>
<DD>Remove memory regions <VAR>nums</VAR><small>...</small>.
<P>

<A NAME="IDX379"></A>
<DT><CODE>disable mem <VAR>nums</VAR><small>...</small></CODE>
<DD>Disable memory regions <VAR>nums</VAR><small>...</small>.
A disabled memory region is not forgotten.  
It may be enabled again later.
<P>

<A NAME="IDX380"></A>
<DT><CODE>enable mem <VAR>nums</VAR><small>...</small></CODE>
<DD>Enable memory regions <VAR>nums</VAR><small>...</small>.
<P>

<A NAME="IDX381"></A>
<DT><CODE>info mem</CODE>
<DD>Print a table of all defined memory regions, with the following columns
for each region.
<P>

<DL COMPACT>
<DT><EM>Memory Region Number</EM>
<DD><DT><EM>Enabled or Disabled.</EM>
<DD>Enabled memory regions are marked with <SAMP>`y'</SAMP>.  
Disabled memory regions are marked with <SAMP>`n'</SAMP>.
<P>

<DT><EM>Lo Address</EM>
<DD>The address defining the inclusive lower bound of the memory region.
<P>

<DT><EM>Hi Address</EM>
<DD>The address defining the exclusive upper bound of the memory region.
<P>

<DT><EM>Attributes</EM>
<DD>The list of attributes set for this memory region.
</DL>
</DL>
<P>

<HR SIZE="6">
<A NAME="SEC67"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC66"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC68"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC55"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC66"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC71"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 8.13.1 Attributes </H3>
<!--docid::SEC67::-->
<P>

<HR SIZE="6">
<A NAME="SEC68"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC67"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC69"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC55"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC67"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC71"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 8.13.1.1 Memory Access Mode </H4>
<!--docid::SEC68::-->
The access mode attributes set whether GDB may make read or
write accesses to a memory region.
<P>

While these attributes prevent GDB from performing invalid
memory accesses, they do nothing to prevent the target system, I/O DMA,
etc. from accessing memory.
</P><P>

<DL COMPACT>
<DT><CODE>ro</CODE>
<DD>Memory is read only.
<DT><CODE>wo</CODE>
<DD>Memory is write only.
<DT><CODE>rw</CODE>
<DD>Memory is read/write.  This is the default.
</DL>
<P>

<HR SIZE="6">
<A NAME="SEC69"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC68"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC70"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC70"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC67"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC71"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 8.13.1.2 Memory Access Size </H4>
<!--docid::SEC69::-->
The acccess size attributes tells GDB to use specific sized
accesses in the memory region.  Often memory mapped device registers
require specific sized accesses.  If no access size attribute is
specified, GDB may use accesses of any size.
<P>

<DL COMPACT>
<DT><CODE>8</CODE>
<DD>Use 8 bit memory accesses.
<DT><CODE>16</CODE>
<DD>Use 16 bit memory accesses.
<DT><CODE>32</CODE>
<DD>Use 32 bit memory accesses.
<DT><CODE>64</CODE>
<DD>Use 64 bit memory accesses.
</DL>
<P>

<HR SIZE="6">
<A NAME="SEC70"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC69"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC71"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC55"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC67"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC71"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 8.13.1.3 Data Cache </H4>
<!--docid::SEC70::-->
The data cache attributes set whether GDB will cache target
memory.  While this generally improves performance by reducing debug
protocol overhead, it can lead to incorrect results because GDB
does not know about volatile variables or memory mapped device
registers.
<P>

<DL COMPACT>
<DT><CODE>cache</CODE>
<DD>Enable GDB to cache target memory. 
<DT><CODE>nocache</CODE>
<DD>Disable GDB from caching target memory.  This is the default.
</DL>
<P>

<A NAME="Dump/Restore Files"></A>
<HR SIZE="6">
<A NAME="SEC71"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC70"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC72"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC55"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC53"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_10.html#SEC73"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 8.14 Copy between memory and a file </H2>
<!--docid::SEC71::-->
<P>

The commands <CODE>dump</CODE>, <CODE>append</CODE>, and <CODE>restore</CODE> are used
for copying data between target memory and a file.  Data is written
into a file using <CODE>dump</CODE> or <CODE>append</CODE>, and restored from a 
file into memory by using <CODE>restore</CODE>.  Files may be binary, srec,
intel hex, or tekhex (but only binary files can be appended).
</P><P>

<DL COMPACT>
<A NAME="IDX382"></A>
<A NAME="IDX383"></A>
<DT><CODE>dump binary memory <VAR>filename</VAR> <VAR>start_addr</VAR> <VAR>end_addr</VAR></CODE>
<DD>Dump contents of memory from <VAR>start_addr</VAR> to <VAR>end_addr</VAR> into 
raw binary format file <VAR>filename</VAR>.
<P>

<DT><CODE>append binary memory <VAR>filename</VAR> <VAR>start_addr</VAR> <VAR>end_addr</VAR></CODE>
<DD>Append contents of memory from <VAR>start_addr</VAR> to <VAR>end_addr</VAR> to
raw binary format file <VAR>filename</VAR>.
<P>

<DT><CODE>dump binary value <VAR>filename</VAR> <VAR>expression</VAR></CODE>
<DD>Dump value of <VAR>expression</VAR> into raw binary format file <VAR>filename</VAR>.
<P>

<DT><CODE>append binary memory <VAR>filename</VAR> <VAR>expression</VAR></CODE>
<DD>Append value of <VAR>expression</VAR> to raw binary format file <VAR>filename</VAR>.
<P>

<A NAME="IDX384"></A>
<DT><CODE>dump ihex memory <VAR>filename</VAR> <VAR>start_addr</VAR> <VAR>end_addr</VAR></CODE>
<DD>Dump contents of memory from <VAR>start_addr</VAR> to <VAR>end_addr</VAR> into 
intel hex format file <VAR>filename</VAR>.
<P>

<DT><CODE>dump ihex value <VAR>filename</VAR> <VAR>expression</VAR></CODE>
<DD>Dump value of <VAR>expression</VAR> into intel hex format file <VAR>filename</VAR>.
<P>

<A NAME="IDX385"></A>
<DT><CODE>dump srec memory <VAR>filename</VAR> <VAR>start_addr</VAR> <VAR>end_addr</VAR></CODE>
<DD>Dump contents of memory from <VAR>start_addr</VAR> to <VAR>end_addr</VAR> into 
srec format file <VAR>filename</VAR>.
<P>

<DT><CODE>dump srec value <VAR>filename</VAR> <VAR>expression</VAR></CODE>
<DD>Dump value of <VAR>expression</VAR> into srec format file <VAR>filename</VAR>.
<P>

<A NAME="IDX386"></A>
<DT><CODE>dump tekhex memory <VAR>filename</VAR> <VAR>start_addr</VAR> <VAR>end_addr</VAR></CODE>
<DD>Dump contents of memory from <VAR>start_addr</VAR> to <VAR>end_addr</VAR> into 
tekhex format file <VAR>filename</VAR>.
<P>

<DT><CODE>dump tekhex value <VAR>filename</VAR> <VAR>expression</VAR></CODE>
<DD>Dump value of <VAR>expression</VAR> into tekhex format file <VAR>filename</VAR>.
<P>

<DT><CODE>restore <VAR>filename</VAR> [<VAR>binary</VAR>] <VAR>bias</VAR> <VAR>start</VAR> <VAR>end</VAR></CODE>
<DD>Restore the contents of file <VAR>filename</VAR> into memory.  The <CODE>restore</CODE>
command can automatically recognize any known bfd file format, except for
raw binary.  To restore a raw binary file you must use the optional argument
<VAR>binary</VAR> after the filename.
<P>

If <VAR>bias</VAR> is non-zero, its value will be added to the addresses 
contained in the file.  Binary files always start at address zero, so
they will be restored at address <VAR>bias</VAR>.  Other bfd files have
a built-in location; they will be restored at offset <VAR>bias</VAR>
from that location.
</P><P>

If <VAR>start</VAR> and/or <VAR>end</VAR> are non-zero, then only data between
file offset <VAR>start</VAR> and file offset <VAR>end</VAR> will be restored.
These offsets are relative to the addresses in the file, before 
the <VAR>bias</VAR> argument is applied.
</P><P>

</DL>
<P>

<A NAME="Character Sets"></A>
<HR SIZE="6">
<A NAME="SEC72"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC71"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_10.html#SEC73"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC55"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC53"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_10.html#SEC73"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 8.15 Character Sets </H2>
<!--docid::SEC72::-->
<P>

If the program you are debugging uses a different character set to
represent characters and strings than the one GDB uses itself,
GDB can automatically translate between the character sets for
you.  The character set GDB uses we call the <EM>host
character set</EM>; the one the inferior program uses we call the
<EM>target character set</EM>.
</P><P>

For example, if you are running GDB on a GNU/Linux system, which
uses the ISO Latin 1 character set, but you are using GDB's
remote protocol (see section <A HREF="gdb_17.html#SEC134">Remote Debugging</A>) to debug a program
running on an IBM mainframe, which uses the EBCDIC character set,
then the host character set is Latin-1, and the target character set is
EBCDIC.  If you give GDB the command <CODE>set
target-charset ebcdic-us</CODE>, then GDB translates between
EBCDIC and Latin 1 as you print character or string values, or use
character and string literals in expressions.
</P><P>

GDB has no way to automatically recognize which character set
the inferior program uses; you must tell it, using the <CODE>set
target-charset</CODE> command, described below.
</P><P>

Here are the commands for controlling GDB's character set
support:
</P><P>

<DL COMPACT>
<DT><CODE>set target-charset <VAR>charset</VAR></CODE>
<DD><A NAME="IDX387"></A>
Set the current target character set to <VAR>charset</VAR>.  We list the
character set names GDB recognizes below, but if you invoke the
<CODE>set target-charset</CODE> command with no argument, GDB lists
the character sets it supports.
</DL>
<P>

<DL COMPACT>
<DT><CODE>set host-charset <VAR>charset</VAR></CODE>
<DD><A NAME="IDX388"></A>
Set the current host character set to <VAR>charset</VAR>.
<P>

By default, GDB uses a host character set appropriate to the
system it is running on; you can override that default using the
<CODE>set host-charset</CODE> command.
</P><P>

GDB can only use certain character sets as its host character
set.  We list the character set names GDB recognizes below, and
indicate which can be host character sets, but if you invoke the
<CODE>set host-charset</CODE> command with no argument, GDB lists the
character sets it supports, placing an asterisk (<SAMP>`*'</SAMP>) after those
it can use as a host character set.
</P><P>

<DT><CODE>set charset <VAR>charset</VAR></CODE>
<DD><A NAME="IDX389"></A>
Set the current host and target character sets to <VAR>charset</VAR>.  If you
invoke the <CODE>set charset</CODE> command with no argument, it lists the
character sets it supports.  GDB can only use certain character
sets as its host character set; it marks those in the list with an
asterisk (<SAMP>`*'</SAMP>).
<P>

<DT><CODE>show charset</CODE>
<DD><DT><CODE>show host-charset</CODE>
<DD><DT><CODE>show target-charset</CODE>
<DD><A NAME="IDX390"></A>
<A NAME="IDX391"></A>
<A NAME="IDX392"></A>
Show the current host and target charsets.  The <CODE>show host-charset</CODE>
and <CODE>show target-charset</CODE> commands are synonyms for <CODE>show
charset</CODE>.
<P>

</DL>
<P>

GDB currently includes support for the following character
sets:
</P><P>

<DL COMPACT>

<DT><CODE>ASCII</CODE>
<DD><A NAME="IDX393"></A>
Seven-bit U.S. ASCII.  GDB can use this as its host
character set.
<P>

<DT><CODE>ISO-8859-1</CODE>
<DD><A NAME="IDX394"></A>
<A NAME="IDX395"></A>
The ISO Latin 1 character set.  This extends ASCII with accented
characters needed for French, German, and Spanish.  GDB can use
this as its host character set.
<P>

<DT><CODE>EBCDIC-US</CODE>
<DD><DT><CODE>IBM1047</CODE>
<DD><A NAME="IDX396"></A>
<A NAME="IDX397"></A>
Variants of the EBCDIC character set, used on some of IBM's
mainframe operating systems.  (GNU/Linux on the S/390 uses U.S. ASCII.)
GDB cannot use these as its host character set.
<P>

</DL>
<P>

Note that these are all single-byte character sets.  More work inside
GDB is needed to support multi-byte or variable-width character
encodings, like the UTF-8 and UCS-2 encodings of Unicode.
</P><P>

Here is an example of GDB's character set support in action.
Assume that the following source code has been placed in the file
<TT>`charset-test.c'</TT>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>#include &#60;stdio.h&#62;

char ascii_hello[]
  = {72, 101, 108, 108, 111, 44, 32, 119,
     111, 114, 108, 100, 33, 10, 0};
char ibm1047_hello[]
  = {200, 133, 147, 147, 150, 107, 64, 166,
     150, 153, 147, 132, 90, 37, 0};

main ()
{
  printf ("Hello, world!\n");
}
</FONT></pre></td></tr></table></P><P>

In this program, <CODE>ascii_hello</CODE> and <CODE>ibm1047_hello</CODE> are arrays
containing the string <SAMP>`Hello, world!'</SAMP> followed by a newline,
encoded in the ASCII and IBM1047 character sets.
</P><P>

We compile the program, and invoke the debugger on it:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>$ gcc -g charset-test.c -o charset-test
$ gdb -nw charset-test
GNU gdb 2001-12-19-cvs
Copyright 2001 Free Software Foundation, Inc.
<small>...</small>
(gdb) 
</FONT></pre></td></tr></table></P><P>

We can use the <CODE>show charset</CODE> command to see what character sets
GDB is currently using to interpret and display characters and
strings:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(gdb) show charset
The current host and target character set is `iso-8859-1'.
(gdb) 
</FONT></pre></td></tr></table></P><P>

For the sake of printing this manual, let's use ASCII as our
initial character set:
<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(gdb) set charset ascii
(gdb) show charset
The current host and target character set is `ascii'.
(gdb) 
</FONT></pre></td></tr></table></P><P>

Let's assume that ASCII is indeed the correct character set for our
host system -- in other words, let's assume that if GDB prints
characters using the ASCII character set, our terminal will display
them properly.  Since our current target character set is also
ASCII, the contents of <CODE>ascii_hello</CODE> print legibly:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(gdb) print ascii_hello
$1 = 0x401698 "Hello, world!\n"
(gdb) print ascii_hello[0]
$2 = 72 'H'
(gdb) 
</FONT></pre></td></tr></table></P><P>

GDB uses the target character set for character and string
literals you use in expressions:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(gdb) print '+'
$3 = 43 '+'
(gdb) 
</FONT></pre></td></tr></table></P><P>

The ASCII character set uses the number 43 to encode the <SAMP>`+'</SAMP>
character.
</P><P>

GDB relies on the user to tell it which character set the
target program uses.  If we print <CODE>ibm1047_hello</CODE> while our target
character set is still ASCII, we get jibberish:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(gdb) print ibm1047_hello
$4 = 0x4016a8 "\310\205\223\223\226k@\246\226\231\223\204Z%"
(gdb) print ibm1047_hello[0]
$5 = 200 '\310'
(gdb) 
</FONT></pre></td></tr></table></P><P>

If we invoke the <CODE>set target-charset</CODE> command without an argument,
GDB tells us the character sets it supports:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(gdb) set target-charset
Valid character sets are:
  ascii *
  iso-8859-1 *
  ebcdic-us  
  ibm1047  
* - can be used as a host character set
</FONT></pre></td></tr></table></P><P>

We can select IBM1047 as our target character set, and examine the
program's strings again.  Now the ASCII string is wrong, but
GDB translates the contents of <CODE>ibm1047_hello</CODE> from the
target character set, IBM1047, to the host character set,
ASCII, and they display correctly:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(gdb) set target-charset ibm1047
(gdb) show charset
The current host character set is `ascii'.
The current target character set is `ibm1047'.
(gdb) print ascii_hello
$6 = 0x401698 "\110\145%%?\054\040\167?\162%\144\041\012"
(gdb) print ascii_hello[0]
$7 = 72 '\110'
(gdb) print ibm1047_hello
$8 = 0x4016a8 "Hello, world!\n"
(gdb) print ibm1047_hello[0]
$9 = 200 'H'
(gdb)
</FONT></pre></td></tr></table></P><P>

As above, GDB uses the target character set for character and
string literals you use in expressions:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=smallexample><FONT SIZE=-1><pre>(gdb) print '+'
$10 = 78 '+'
(gdb) 
</FONT></pre></td></tr></table></P><P>

The IBM1047 character set uses the number 78 to encode the <SAMP>`+'</SAMP>
character.
</P><P>

<A NAME="Macros"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_9.html#SEC55"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_10.html#SEC73"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_35.html#SEC643">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="gdb_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">

<address>

<p>Please send FSF &amp; GNU inquiries &amp; questions to <a
href="mailto:gnu@gnu.org">gnu@gnu.org</a>.  There are also <a
href="http://www.gnu.org/home.html#ContactInfo">other ways to
contact</a> the FSF.</p>

<p>These pages are maintained by <a
href="http://www.gnu.org/software/gdb/">the GDB developers</a>.</p>

<p>Copyright Free Software Foundation, Inc., 59 Temple Place - Suite
330, Boston, MA 02111, USA.</p>

<p>Verbatim copying and distribution of this entire article is
permitted in any medium, provided this notice is preserved.</p>

</address>

This document was generated
by <I>GDB Administrator</I> on <I>November, 11  2002</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>

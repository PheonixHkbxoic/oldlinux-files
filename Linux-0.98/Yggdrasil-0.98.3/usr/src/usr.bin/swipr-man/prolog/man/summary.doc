\chapter{Predicate Summary}

\begin{tabbing}
xxxxxxxxxxxxxxxxxxxxxxxxxxx\=\kill
\verb$!/0$		\> Cut.  Discard choicepoints \\
\verb$*/2$		\> Arithmetic: multiplication \\
\verb$+/2$		\> Arithmetic: addition \\
\verb$,/2$		\> Conjuction of goals \\
\verb$-/1$		\> Arithmetic: unary minus \\
\verb$-/2$		\> Arithmetic: subtraction \\
\verb$->/2$		\> If-then-else \\
\verb$./2$		\> List operator. Also consult \\
\verb$///2$		\> Arithmetic: Integer division \\
\verb$//2$		\> Arithmetic: division \\
\verb$/\/2$		\> Arithmetic: bitwise and \\
\verb$;/2$		\> Disjunction of goals \\
\verb$</2$		\> Arithmetic smaller \\
\verb$<</2$		\> Arithmetic: bitwise left shift \\
\verb$=../2$		\> Univ.  Term to list conversion \\
\verb$=/2$		\> Unification \\
\verb$=:=/2$		\> Arithmetic equal \\
\verb$=</2$		\> Arithmetic smaller or equal \\
\verb$==/2$		\> Identical \\
\verb$=@=/2$		\> Structural identical \\
\verb$=\=/2$		\> Arithmetic not equal \\
\verb$>/2$		\> Arithmetic larger \\
\verb$>=/2$		\> Arithmetic larger or equal \\
\verb$>>/2$		\> Arithmetic: bitwise right shift \\
\verb$@</2$		\> Standard order smaller \\
\verb$@=</2$		\> Standard order smaller or equal \\
\verb$@>/2$		\> Standard order larger \\
\verb$@>=/2$		\> Standard order larger or equal \\
\verb$\/1$		\> Bitwise negation \\
\verb$\//2$		\> Arithmetic: bitwise or \\
\verb$\+/1$		\> Negation by failure (not provable) \\ 
\verb$\=/2$		\> Not unifyable \\
\verb$\==/2$		\> Not identical \\
\verb$\=@=/2$		\> Not structural identical \\
\verb$^/2$		\> Existential quantification (bagof/3, setof/3) \\
\verb$abolish/2$	\> Remove predicate definition from the database \\
\verb$abort/0$		\> Abort execution, return to top level \\
\verb$abs/1$		\> Arithmetic: absolute value \\
\verb$absolute_file_name/2$	\> Get absolute Unix path name \\
\verb$access_file/2$	\> Check access permissions of a file \\
\verb$acos/1$		\> Arithmetic: inverse (arc) cosine \\
\verb$append/1$		\> Append to a file \\
\verb$append/3$		\> Concatenate lists \\
\verb$apply/2$		\> Call goal with additional arguments \\
\verb$apropos/1$	\> Show related predicates and manual sections \\
\verb$arithmetic_function/1$	\> Register an evaluable function \\
\verb$arg/3$		\> Access argument of a term \\
\verb$asin/1$		\> Arithmetic: inverse (arc) sine \\
\verb$assert/1$		\> Add a clause to the database \\
\verb$assert/2$		\> Add a clause to the database \\
\verb$asserta/1$	\> Add a clause to the database (first) \\
\verb$asserta/2$	\> Add a clause to the database (first) \\
\verb$assertz/1$	\> Add a clause to the database (last) \\
\verb$assertz/2$	\> Add a clause to the database (last) \\
\verb$atan/1$		\> Arithmetic: inverse (arc) tangent \\
\verb$atom/1$		\> Type check for an atom \\
\verb$atom_length/2$	\> Determine length of an atom \\
\verb$atom_to_term/3$	\> Convert between atom and term \\
\verb$atomic/1$		\> Type check for primitive \\
\verb$bagof/3$		\> Find all solutions to a goal \\
\verb$between/3$	\> Integer range checking/generating \\
\verb$break/0$		\> Start interactive toplevel \\
\verb$call/1$		\> Call a goal \\
\verb$ceil/1$		\> Arithmetic: smallest integer larger than argument \\
\verb$character_count/2$	\> Get character index on a stream \\
\verb$chdir/1$		\> Change working directory \\
\verb$checklist/2$	\> Invoke goal on all members of a list \\
\verb$clause/2$		\> Get clauses of a predicate \\
\verb$clause/3$		\> Get clauses of a predicate \\
\verb$close/1$		\> Close stream \\
\verb$compiling/0$	\> Is this a compilation run? \\
\verb$concat/3$		\> Append two atoms \\
\verb$concat_atom/2$	\> Append a list of atoms \\
\verb$consult/1$	\> Read (compile) a Prolog source file \\
\verb$context_module/1$	\> Get context module of current goal \\
\verb$convert_time/8$	\> Convert time stamp \\
\verb$copy_term/2$	\> Make a copy of a term \\
\verb$cos/1$		\> Arithmetic: cosine \\
\verb$cputime/0$	\> Arithmetic: get CPU time \\
\verb$current_atom/1$	\> Examine existing atoms \\
\verb$current_arithmetic_function/1$ \> Examine evaluable functions \\
\verb$current_flag/1$	\> Examine existing flags \\
\verb$current_functor/2$	\> Examine existing name/arity pairs \\
\verb$current_input/1$	\> Get current input stream \\
\verb$current_key/1$	\> Examine existing database keys \\
\verb$current_op/3$	\> Examine current operator declaractions \\
\verb$current_output/1$	\> Get the current output stream \\
\verb$current_predicate/2$	\> Examine existing predicates \\
\verb$current_stream/3$	\> Examine open streams \\
\verb$debug/0$		\> Test for debugging mode \\
\verb$debugging/0$	\> Show debugger status \\
\verb$delete/3$		\> Delete all matching members from a list \\
\verb$delete_file/1$	\> Unlink a file from the Unix file system \\
\verb$discontiguous/1$	\> Indicate distributed definition of a predicate \\
\verb$display/1$	\> Write a term, ignore operators \\
\verb$display/2$	\> Write a term, ignore operators on a stream \\
\verb$displayq/1$	\> Write a term with quotes, ignore operators \\
\verb$displayq/2$	\> Write a term with quotes, ignore operators on a stream \\
\verb$dwim_match/2$	\> Atoms match in ``Do What I Mean'' sense \\
\verb$dwim_match/3$	\> Atoms match in ``Do What I Mean'' sense \\
\verb$dwim_predicate/2$	\> Find predicate in ``Do What I Mean'' sense \\
\verb$dynamic/1$	\> Indicate predicate definition may change \\ 
\verb$e/0$		\> Arithmetic: mathematical constant \\
\verb$ed/0$		\> Edit last edited predicate \\
\verb$ed/1$		\> Edit a predicate \\
\verb$edit/0$		\> Edit last edited file \\
\verb$edit/1$		\> Edit a file \\
\verb$ensure_loaded/1$	\> Consult a file if that has not yet been done \\
\verb$erase/1$		\> Erase a database record or clause \\
\verb$exception/3$	\> Handle runtime exceptions \\
\verb$exists_directory/1$	\> Check existence of Unix directory \\
\verb$exists_file/1$	\> Check existence of Unix file \\
\verb$exp/1$		\> Arithmetic: exponent (base $e$) \\
\verb$expand_file_name/2$	\> Wildcard expansion of file names \\
\verb$export/1$		\> Export a predicate from a module \\
\verb$fail/0$		\> Always false \\
\verb$fileerrors/2$	\> Do/Don't warn on file errors \\
\verb$findall/3$	\> Find all solutions to a goal \\
\verb$flag/3$		\> Simple global variable system \\
\verb$flatten/2$	\> Transform nested list into flat list \\
\verb$float/1$		\> Type check for a floating point number \\
\verb$floor/1$		\> Arithmetic: largest integer below argument \\
\verb$flush/0$		\> Output pending characters on current stream \\
\verb$flush_output/1$	\> Output pending characters on specified stream \\
\verb$forall/2$		\> Prove goal for all solutions of another goal \\
\verb$foreign_file/1$	\> Examine loaded foreign files \\
\verb$format/1$		\> Produce formatted output \\
\verb$format/2$		\> Produce formatted output on a stream \\
\verb$format_predicate/2$	\> Program format/[1,2] \\
\verb$free_variables/2$	\> Find unbound variables in a term \\
\verb$functor/3$	\> Get name and arity of a term or construct a term  \\
\verb$garbage_collect/0$	\> Invoke the garbage collector \\
\verb$gensym/2$		\> Generate unique atoms from a base \\
\verb$get/1$		\> Read first non-blank character \\
\verb$get/2$		\> Read first non-blank character from a stream \\
\verb$get0/1$		\> Read next character \\
\verb$get0/2$		\> Read next character from a stream \\
\verb$get_single_char/1$	\> Read next character from the terminal \\
\verb$get_time/1$	\> Get current time \\
\verb$getenv/2$		\> Get Unix environment variable \\
\verb$ground/1$		\> Verify term holds no unbound variables \\
\verb$halt/0$		\> Exit from Prolog \\
\verb$help/0$		\> Give help on help \\
\verb$help/1$		\> Give help on predicates and show parts of manual \\
\verb$history_depth/1$	\> Number of remembered queries \\
\verb$read_history/6$	\> Read using history substitution \\
\verb$ignore/1$		\> Call the argument, but always succeed \\
\verb$import/1$		\> Import a predicate from a module \\
\verb$index/1$		\> Change clause indexing \\
\verb$int_to_atom/2$	\> Convert from integer to atom \\
\verb$int_to_atom/3$	\> Convert from integer to atom (non-decimal) \\
\verb$integer/1$	\> Arithmetic: round to nearest integer \\
\verb$integer/1$	\> Type check for integer \\
\verb$intersection/3$	\> Set intersection \\
\verb$is/2$		\> Evaluate arithmetic expression \\
\verb$is_list/1$	\> Type check for a list \\
\verb$is_set/1$		\> Type check for a set \\
\verb$keysort/2$	\> Sort, unsing a key \\
\verb$last/2$		\> Last element of a list \\
\verb$leash/1$		\> Change ports visited by the tracer \\
\verb$length/2$		\> Length of a list \\
\verb$library_directory/1$	\> Directories holding Prolog libraries \\
\verb$limit_stack/2$	\> Limit stack expansion \\
\verb$line_count/2$	\> Line number on stream \\
\verb$line_position/2$	\> Character position in line on stream \\
\verb$list_to_set/2$	\> Remove duplicates \\
\verb$listing/0$	\> List program in current module \\
\verb$listing/1$	\> List predicate \\
\verb$load_foreign/2$	\> Load foreign (C) module \\
\verb$load_foreign/5$	\> Load foreign (C) module \\
\verb$log/1$		\> Arithmetic: natural logarithm \\
\verb$log10/1$		\> Arithmetic: 10 base logarithm \\
\verb$make/0$		\> Reconsult all changed source files \\
\verb$maplist/3$	\> Transform all elements of a list \\
\verb$member/2$		\> Element is member of a list \\
\verb$memberchk/2$	\> Deterministic member/2 \\
\verb$merge/3$		\> Merge two sorted lists \\
\verb$merge_set/3$	\> Merge two sorted sets \\
\verb$mod/2$		\> Arithmetic: remainder of division \\
\verb$module/2$		\> Declare a module \\
\verb$module_transparent/1$	\> Indicate module based meta predicate \\
\verb$msort/2$		\> Sort, do not remove duplicates \\
\verb$multifile/1$	\> Indicate distributed definition of predicate \\
\verb$name/2$		\> Convert between atom and list of ASCII characters \\
\verb$nl/0$		\> Generate a newline \\
\verb$nl/1$		\> Generate a newline on a stream \\
\verb$nodebug/0$	\> Disable debugging \\
\verb$nonvar/1$		\> Type check for bound term \\
\verb$noprotocol/0$	\> Disable logging of user interaction \\
\verb$nospy/1$		\> Remove spy point \\
\verb$nospyall/0$	\> Remove all spy points \\
\verb$not/1$		\> Negation by failure (not provable) \\ 
\verb$notrace/0$	\> Stop tracing \\
\verb$nth0/3$		\> N-th element of a list (0-based) \\
\verb$nth1/3$		\> N-th element of a list (1-based) \\
\verb$number/1$		\> Type check for integer or float \\
\verb$numbervars/4$	\> Enumerate unbound variables of a term \\
\verb$once/1$		\> Call a goal deterministicaly \\
\verb$op/3$		\> Declare an operator \\
\verb$open/3$		\> Open a file (creating a stream) \\
\verb$open_null_stream/1$	\> Open a stream to discard output \\
\verb$pi/0$		\> Arithmetic: mathematical constant \\
\verb$please/3$		\> Query/change environment parameters \\
\verb$plus/3$		\> Logical integer addition \\
\verb$portray/1$	\> Modify behaviour of print/1 \\
\verb$portray_clause/1$	\> Pretty print a clause \\
\verb$predicate_property/2$	\> Query predicate attributes \\
\verb$predsort/3$	\> Sort, using a predicate to determine the order \\
\verb$preprocessor/2$	\> Install a preprocessor before the compiler \\
\verb$print/1$		\> Print a term \\
\verb$print/2$		\> Print a term on a stream \\
\verb$profile/3$	\> Obtain execution statistics \\
\verb$profile_count/3$	\> Obtain profile results on a predicate \\
\verb$profiler/2$	\> Obtain/change status of the profiler \\
\verb$prolog/0$		\> Run interactive toplevel \\
\verb$prolog_current_frame/1$	\> Reference to goal's environment stack \\
\verb$prolog_frame_attribute/3$	\> Obtain information on a goal environment \\
\verb$prolog_skip_level/2$	\> Indicate deepest recursion to trace \\
\verb$prolog_trace_interception/3$	\> Intercept the Prolog tracer \\
\verb$prompt/2$		\> Change the prompt used by read/1 \\
\verb$proper_list/1$	\> Type check for list \\
\verb$protocol/1$	\> Make a log of the user interaction \\
\verb$protocola/1$	\> Append log of the user interaction to file \\
\verb$protocolling/1$	\> On what file is user interaction logged \\
\verb$put/1$		\> Write a character \\
\verb$put/2$		\> Write a character on a stream \\
\verb$random/1$		\> Arithmetic: generate random number \\
\verb$read/1$		\> Read Prolog term \\
\verb$read/2$		\> Read Prolog term from stream \\
\verb$read_clause/1$	\> Read clause \\
\verb$read_clause/2$	\> Read clause from stream \\
\verb$read_variables/2$	\> Read clause including variable names \\
\verb$read_variables/3$	\> Read clause including variable names from stream  \\
\verb$recorda/2$	\> Record term in the database (first) \\
\verb$recorda/3$	\> Record term in the database (first) \\
\verb$recorded/2$	\> Obtain term from the database \\
\verb$recorded/3$	\> Obtain term from the database \\
\verb$recordz/2$	\> Record term in the database (last) \\
\verb$recordz/3$	\> Record term in the database (last) \\
\verb$rename_file/2$	\> Change name of Unix file \\
\verb$repeat/0$		\> Succeed, leaving infinite backtrackpoints \\
\verb$reset_profiler/0$	\> Clear statistics obtained by the profiler \\
\verb$retract/1$	\> Remove clause from the database \\
\verb$retractall/1$	\> Remove unifying clauses from the database \\
\verb$reverse/2$	\> Inverse the order of the elements in a list \\
\verb$save_program/1$	\> Save the current program on a file \\
\verb$save_program/2$	\> Save the current program on a file \\
\verb$see/1$		\> Change the current input stream \\
\verb$seeing/1$		\> Query the current input stream \\
\verb$seen/0$		\> Close the current input stream \\
\verb$select/3$		\> Select element of a list \\
\verb$set_input/1$	\> Set current input stream from a stream \\
\verb$set_output/1$	\> Set current output stream from a stream \\
\verb$set_tty/2$	\> Set `tty' stream \\
\verb$setenv/2$		\> Set Unix environment variable \\
\verb$setof/3$		\> Find all unique solutions to a goal \\
\verb$sformat/2$	\> Format on a string \\
\verb$sformat/3$	\> Format on a string \\
\verb$shell/0$		\> Execute interactive Unix subshell \\
\verb$shell/1$		\> Execute Unix command \\
\verb$shell/2$		\> Execute Unix command \\
\verb$show_profile/1$	\> Show results of the profiler \\
\verb$sin/1$		\> Arithmetic: sine \\
\verb$size_file/2$	\> Get size of a file in characters \\
\verb$sleep/1$		\> Suspend execution for specified time \\
\verb$sort/2$		\> Sort elements in a list \\
\verb$source_file/1$	\> Examine currently loaded source files \\
\verb$source_file/2$	\> Obtain source file of predicate \\
\verb$spy/1$		\> Force tracer on specified predicate \\
\verb$sqrt/1$		\> Arithmetic: square root \\
\verb$statistics/0$	\> Show execution statistics \\
\verb$statistics/2$	\> Obtain collected statistics \\
\verb$stream_position/3$	\> Get/seek to position in file \\
\verb$string/1$		\> Type check for string \\
\verb$string_length/2$	\> Determine length of a string \\
\verb$string_to_atom/2$	\> Conversion between string and atom \\
\verb$string_to_list/2$	\> Conversion between string and list of ASCII \\
\verb$style_check/1$	\> Change level of warnings \\
\verb$sublist/3$	\> Determine elements that meet condition \\
\verb$subset/2$		\> Generate/check subset relation \\
\verb$substring/4$	\> Get part of a string \\
\verb$subtract/3$	\> Delete elements that do not meet condition \\
\verb$succ/2$		\> Logical integer successor relation \\
\verb$swritef/2$	\> Formatted write on a string \\
\verb$swritef/3$	\> Formatted write on a string \\
\verb$tab/1$		\> Output number of spaces \\
\verb$tab/2$		\> Output number of spaces on a stream \\
\verb$tan/1$		\> Arithmetic: tangent \\
\verb$tell/1$		\> Change current output stream \\
\verb$telling/1$	\> Query current output stream \\
\verb$term_expansion/2$	\> Convert term before compilation \\
\verb$term_to_atom/2$	\> Convert between term and atom \\
\verb$time/1$		\> Determine time needed to execute goal \\
\verb$time_file/2$	\> Get last modification time of file \\
\verb$told/0$		\> Close current output \\
\verb$trace/0$		\> Start the tracer \\
\verb$tracing/0$	\> Query status of the tracer \\
\verb$trim_stacks/0$	\> Release unused memory resources \\
\verb$true/0$		\> Succeed \\
\verb$tty_fold/2$	\> Make terminal fold long lines in output \\
\verb$tty_get_capability/3$	\> Get terminal parameter \\
\verb$tty_goto/2$	\> Goto position on screen \\
\verb$tty_put/2$	\> Write control string to terminal \\
\verb$ttyflush/0$	\> Flush output on terminal \\
\verb$union/3$		\> Union of two sets \\
\verb$unknown/2$	\> Trap undefined predicates \\
\verb$unsetenv/1$	\> Delete Unix environment variable \\
\verb$use_module/1$	\> Import a module \\
\verb$use_module/2$	\> Import predicates from a module \\
\verb$var/1$		\> Type check for unbound variable \\
\verb$visible/1$	\> Set ports that are visible in the tracer \\
\verb$wait_for_input/3$	\> Wait for input with optional timeout \\
\verb$wildcard_match/2$	\> Csh(1) style wildcard match \\
\verb$write/1$		\> Write term \\
\verb$write/2$		\> Write term to stream \\
\verb$write_ln/1$	\> Write term, followed by a newline \\
\verb$writef/1$		\> Formatted write \\
\verb$writef/2$		\> Formatted write \\
\verb$writeq/1$		\> Write term, insert quotes \\
\verb$writeq/2$		\> Write term, insert quotes on stream \\
\verb$xor/2$		\> Arithmetic: exclusive or \\
\verb$|/2$		\> Disjunction of goals \\
\end{tabbing}

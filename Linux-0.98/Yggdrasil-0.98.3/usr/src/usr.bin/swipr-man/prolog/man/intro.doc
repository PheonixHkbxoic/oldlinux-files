\chapter{Introduction}

SWI-Prolog has been designed and implemented to get a Prolog
implementation which can be used for experiments with logic programming
and the relation to other programming paradigms. The intention was to
build a Prolog environment which offers enough power and flexibility to
write substantial applications, but is straightforward enough to be
modified for experiments with debugging, optimisation or the
introduction of non-standard data types. Performance optimisation is
limited due to the main objectives:  portability (SWI-Prolog is
entirely written in C and Prolog) and modifiability.

SWI-Prolog is based on a very restrickted form of the WAM (Warren
Abstract Machine) described in \cite{Bowen:83}, which defines only 7
instructions. Prolog can easily be compiled into this language and the
abstract machine code is easily decompiled back into Prolog.  As it is
also possible to wire a standard 4-port debugger in the WAM
interpreter there is no need for a distinction between compiled and
interpreted code.  Besides simplifying the design of the Prolog system
itself this approach has advantages for program development: the
compiler is simple and fast, the user does not have to decide in
advance whether s/he wants to debug and the system only runs slightly
slower when in debug mode.  The price we have to pay is some
performance degradation (taking out the debugger from the WAM
interpreter improves performance by about 20\%) and somewhat
additional memory usage to help the decompiler and debugger.

SWI-Prolog extends the minimal set of instructions described in
\cite{Bowen:83} to improve performance.  While extending this set care
has been taken to maintain the advantages of decompilation and tracing
of compiled code.  The extensions include specialised instructions for
unification and predicate invocation.  The current set also includes
some frequently used built-in predicates, arithmetic, or
(\verb$;/2$, \verb$|/2$), if-then (\verb$->/2$) and not (\verb$\+/1$).

This manual does not describe the full syntax and semantics of
SWI-Prolog, nor how one should write a program in Prolog.  These
subjects have been described extensively in the literature.  See
\cite{Bratko:86}, \cite{Sterling:86} and \cite{Clocksin:81}.  For more
advanced Prolog material see \cite{Keefe:90}. Syntax and standard
operator declarations confirm to the `Edinburgh standard'.  Most built
in predicates are compatible with those described in
\cite{Clocksin:81}.  SWI-Prolog also offers a number of primitive
predicates compatible with Quintus Prolog%
    \footnote{Quintus is a trademark of Quintus Computer Systems Inc., USA}, 
\cite{QUINTUS:manual} and BIM_Prolog%
    \footnote{BIM is a trademark of BIM sa/nv., Belgium}
\cite{BIMPROLOG:manual}.

\section*{Status}

This manual describes version 1.5.0 of SWI-Prolog.  The kernel of the
system has been tested on quite a few programs and is likely to be
stable.  A number of new features probably still have some bugs.
Suspect areas are `Do What I Mean', the foreign language interface,
string manipulation, garbage collection and the predicates described in
the `Hackers Corner' of this manual.  Please report bugs, if possible
together with a small program demonstrating the problem, to the author.
Bugs that can be repeated will usually be fixed.

Some bugs are known to the author. They are described as footnotes in
this manual.

\section*{Should you be Using SWI-Prolog?}

There are a number of reasons why you better choose a commercial Prolog
system, or another academic product:

\begin{itemize}
    \tick{SWI-Prolog is not supported}
Although I usually fix bugs shortly after a bug report arrives, I cannot
promise anything.  Now that the sources are provided, you can always
dig into them yourself.
    \tick{Memory requirements and performance are your first concerns}
A number of commercial compilers are more keen on memory and performance
than SWI-Prolog.  I do not wish to offer some of the nice features of
the system, nor its portability to compete on raw performance.
    \tick{You need features not offered by SWI-Prolog}
In this case you may wish to give me suggestions for extensions. If
you have great plans, contact me (you might have to implement them
yourself however).
\end{itemize}

On the other hand, SWI-Prolog offers some nice facilities:

\begin{itemize}
    \tick{Nice environment}
This includes `Do What I Mean', automatic completion of atom names,
history mechanism and a tracer that operates on single key-strokes.
Interfaces to standard Unix editors are provided, as well as a facility
to maintain programs (see make/0).
    \tick{Very fast compiler}
The compiler handles about 5K bytes per second per MIPS (i.e. 35K bytes
per second on SUN-4/110).
    \tick{Transparent compiled code}
SWI-Prolog compiled code can be treated just as interpreted code: you
can list it, trace it, assert from or retract to it, etc. This implies
you do not have to decide beforehand whether a module should be loaded
for debugging or not. Also, performance is much better than the
performance of most interpreters.
    \tick{Profiling}
SWI-Prolog offers tools for performance analysis, which can be very
useful to optimise programs. Unless you are very familiar with Prolog
and Prolog performance considerations this might be more helpful than a
better compiler without these facilities.
    \tick{Flexibility}
SWI-Prolog allows for easy and flexible integration with C, both
Prolog calling C functions as C calling Prolog predicates.  SWI-Prolog
is provided in source form, which implies SWI-Prolog can be linked in
with another package.  Command line options and predicates to obtain
information from the system and feedback into the system are provided.
    \tick{Integration with PCE}
SWI-Prolog offers a tight integration to the Object Oriented Package
for User Interface Development, called PCE (\cite{P1098:C1.6}).  PCE
is now also available for X-windows.
\end{itemize}


\section{Version 1.5 Release Notes}

There are not many changes between version 1.4 and 1.5.  The C-sources
have been cleaned and comments have been updated.  The stack memory 
management based on using the MMU has been changed to run on a number
of system-V Unix systems offering shared memory.  Handling dates has
been changed.  All functions handling dates now return a floating
point number, expressing the time in seconds since january 1, 1970.
A predicate convert_time/8 is available to get the year, month, etc.
The predicate time/6 has been deleted.  get_time/1 and convert_time/8
together do the same.

\section*{Portability}

The table below shows which machine dependent features have been
ported to which architectures.  Some of the minus signs could be taken
away by spending more effort to the port (notably for the IBM
RISC-6000), others are due to fundamental omisions or bugs in the
operating system. Note that the column `C-interface' implies object
code can be linked dynamically from a running Prolog environment.  For
systems that have a minus here C-code can still be added by relinking
SWI-Prolog itself together with the C-extensions to form an extended
version of SWI-Prolog.

\begin{center}
\begin{tabular}{|ll|cccc|}
\hline
\bf Machine & \bf OS & \bf Dynamic & \bf C         & \bf Saved  & \bf Profile\\
            &        & \bf Stacks  & \bf Interface & \bf States & \\
\hline
SUN-3 and 4 & SunOs 4    & +  & +  & +  & +  \\
SUN-3	    & SunOs 3    & -- & +  & +  & +  \\
HP 9000s300 & HP-UX 6.5  & -- & +  & +  & +  \\
DEC MIPS    & Ultrix 3.1 & -- & -- & +  & +  \\
Gould PN    & UTX-2.1    & +  & -- & -- & +  \\
IBM PS2     & AIX 2.0    & -- & -- & +  & +  \\
IBM RISC-6000 & AIX 2.1  & -- & -- & -- & -- \\
VAX	    & Ultrix     & -- & +  & +  & +  \\
ATARI	    & TOS 1.3    & -- & -- & -- & -- \\
\hline
\end{tabular}
\end{center}


\section*{Acknowledgements}

Some small parts of the Prolog code of SWI-Prolog are modified
versions of the corresponding Edinburgh C-Prolog code: grammar rule
compilation and writef/2.  Also some of the C-code originates from
C-Prolog: finding the path of the currently running executable and the
code underlying absolute_file_name/2.  Ideas on programming style and
techniques originate from C-Prolog and Richard O'Keefe's {\em thief}
editor.  An important source of inspiration are the programming
techniques introduced by Anjo Anjewierden in PCE version~1 and~2.

I also would like to thank those who had the fade of using the early
versions of this system, suggested extensions or reported bugs.  Among
them are Anjo Anjewierden, Huub Knops, Bob Wielinga, Wouter Jansweijer,
Luc Peerdeman, Eric Nombden, Frank van Harmelen, Bert Rengel.

\chapter{Overview}

\section{Starting SWI-Prolog from the Unix Shell}

It is advised to install SWI-Prolog as `pl' in the local binary
directory.%
    \footnote{On the Atari-ST, \tty{pl.ttp} can be installed anywhere.
	      The resource folder \tty{pl} should be below the root
	      directory of a disk and is searched for in the order
	      \tty{cde...ab} (e.i. hard disk first, followed by floppy)}
SWI-Prolog can then be started from the Unix shell by typing
`\tty{pl}'.  The system will boot from the system's default boot file, 
perform the necessary initialisations and then enter the interactive top
level.

After the necessary system initialisation the system consults (see
consult/1) the user's initialisation file.  This initialisation file
should be named `\tty{.plrc}'%
    \footnote{Atari-ST: `\tty{pl.rc}' as files cannot be named `\tty{.plrc}'}
and reside either in the current directory or in the user's home
directory.  If both exist the initialisation file from the current
directory is loaded.  The name of the initialisation file can be changed
with the `\tty{-f file}' option.  After loading the initialisation file
SWI-Prolog executes a user initialisation goal.  The default goal is a
system predicate that prints the banner message.  The default can be
modified with the `\tty{-g goal}' option.  Next the toplevel goal is
started.  Default is the interactive Prolog loop (see prolog/0).  The
user can overwrite this default with the `\tty{-t toplevel}' option.

\subsection{Command Line Options}

The full set of command line options is given below:

\begin{quote}
\begin{description}
\setlength{\itemsep}{-2pt}
\newcommand{\option}[1]{\item[\tt #1]\mbox{}\\}
    \option{-Lsize}
Give local stack size in K bytes (200 K default). Note that there is no
space between the size option and its argument.  For machines with
dynamic stack allocation this flag sets the maximum value to which the
stack is allowed to grow (2 Mbytes default).  A maximum is useful to
stop buggy programs from claiming all memory resources.  \tty{-L0} sets
the limit to the highest possible value.
    \option{-Gsize}
Give global stack size in K bytes (100 K default).  For machines with
dynamic stack allocation the default is 4 Mbytes. See \tty{-L} for more
details.
    \option{-Tsize}
Give trail stack size in K bytes (50 K default).  For machines with
dynamic stack allocation the default is 4 Mbytes. See \tty{-L} for more
details.
    \option{-Asize}
Give argument stack size in K bytes (5 K default).  For machines with
dynamic stack allocation the default is 1 Mbytes. See \tty{-L} for more
details.
    \option{-c file ...}
Compile files into an `intermediate code file'. See section~\ref{compilation}.
    \option{-o output}
Used in combination with \tty{-c} or \tty{-b} to determine output file
for compilation.
    \option{-O}
Optimised compilation. See please/3.
    \option{-f file}
Use {\em file} as initialisation file instead of `\tty{.plrc}'. `\tty{-f
none}' stops SWI-Prolog from searching for an initialisation file.
    \option{-g goal}
{\em Goal} is executed just before entering the top level. Default is a
predicate which prints the welcome message. The welcome message can
thus be suppressed by giving \tty{-g true}. {\em goal} can be a complex
term. In this case quotes are normally needed to protect it from
being expanded by the Unix shell. 
    \option{-t goal}
Use {\em goal} as interactive toplevel instead of the default goal
prolog/0. {\em goal} can be a complex term. If the toplevel goal
succeeds SWI-Prolog exits with status 0. If it fails the exit status is 1.
This flag also determines the goal started by break/0 and abort/0. If
you want to stop the user from entering interactive mode start the
application with `\tty{-g goal}' and give `halt' as toplevel.
    \option{+/-tty}
Switches tty control (using ioctl(2)) on (\verb$+tty$) or off
(\verb$-tty$). Normally tty control is switched on. This default
depends on the installation.  You may wish to switch tty control off if
Prolog is used from an editor such as GNU EMACS.  If switched off
get_single_char/1 and the tracer will wait for a return.
    \option{-x bootfile}
Boot from {\em bootfile} instead of the system's default boot file. A
bootfile is a file resulting from a Prolog compilation using the
\tty{-b} or \tty{-c} option.
\end{description}
\end{quote}

The following options are for system maintenance. They are given
for reference only.

\begin{quote}
\begin{description}
\setlength{\itemsep}{-2pt}
\newcommand{\option}[1]{\item[\tt #1]\mbox{}\\}
    \option{-b initfile ... -c file ...}
Boot compilation.  \tty{initfile ...} are compiled by the C-written boot
compiler, \tty{file ...} by the normal Prolog compiler.  System
maintenance only.
    \option{-d level}
Set debug level to {\em level}. System maintenance only.
\end{description}
\end{quote}

\section{Online Help}

Online help provides a fast lookup and browsing facility to this
manual. The online manual can show predicate definitions as well as
entire sections of the manual.

.BD
.C help 0
Equivalent to \tty{help(help/1)}.
.C help 1 +What
Show specified part of the manual.  {\em What} is one of:
\begin{center}\begin{tabular}{lp{3.5in}}
Name/Arity	& give help on specified predicate \\
Name		& give help on named predicate with any arity
		  or C interface function with that name \\
Section		& display specified section. section numbers are
		  dash-separated numbers: \tty{2-3} refers to
		  section 2.3 of the manual.  Section numbers are
		  obtained using apropos/1.
\end{tabular}\end{center}

Examples
\begin{center}\begin{tabular}{lp{3.5in}}
\tt ?- help(assert).	& give help on predicate assert \\
\tt ?- help(3-4).	& display section 3.4 of the manual \\
\tt ?- help('PL_retry').& give help on interface function PL_retry() \\
\end{tabular}\end{center}
.C apropos 1 +Pattern
Display all predicates, functions and sections that have {\em
Pattern} in their name or summary description.  Lowercase letters in
{\em Pattern} also match a corresponding uppercase letter. Example:
\begin{center}\begin{tabular}{lp{3.5in}}
\tt ?- apropos(file).	& Display predicates, functions and sections
			  that have `file' (or `File', etc.) in their
			  summary description. \\
\end{tabular}\end{center}
.ED

\section{Query Substitutions}
\label{sec:history}

SWI-Prolog offers a query substitution mechanism similar to that
of Unix csh (csh(1)), called `history'. It allows the user to compose
new queries from those typed before and remembered by the system. It
also allows to correct queries and syntax errors. SWI-Prolog does not
offer the Unix csh capabilities to include arguments. This is omitted
as it is unclear how the first, second, etc.\ argument should be
defined.%
    \footnote{One could choose words, defining words as a sequence of
	      alpha-numeric characters and the word separators as
	      anything else, but one could also choose Prolog
	      arguments}

The available history commands are shown in table~\ref{tab:history}.
Figure~\ref{fig:history} gives some examples.

\begin{table}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\verb+!!.+            & Repeat last query \\
\verb+!nr.+           & Repeat query numbered \verb+<nr>+ \\
\verb+!str.+          & Repeat last query starting with \verb+<str>+ \\
\verb+!?str.+         & Repeat last query holding \verb+<str>+ \\
\verb+^old^new.+      & Substitute \verb+<old>+ into \verb+<new>+ of
		        last query \\
\verb+!nr^old^new.+   & Substitute in query numbered \verb+<nr>+ \\
\verb+!str^old^new.+  & Substitute in query starting with \verb+<str>+ \\
\verb+!?str^old^new.+ & Substitute in query holding \verb+<str>+ \\
\verb+h.+             & Show history list \\
\verb+!h.+            & Show this list \\
\hline
\end{tabular}
\end{center}
    \caption{History commands}
    \label{tab:history}
\end{table}

\begin{figure}
\begin{boxed}
\begin{code}
/u4/staff/jan/.plrc consulted, 0.066667 seconds, 591 bytes
\version
Copyright (c) 1990, University of Amsterdam. All rights reserved.

1 ?- append("Hello ", "World", L).

L = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100] 

Yes
2 ?- !!, writef('L = %s\n', [L]).
append("Hello ", "World", L), writef('L = %s\n', [L]).
L = Hello World

L = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100] 

Yes
3 ?- sublist(integer, [3, f, 3.4], L).

L = [3] 

Yes
4 ?- ^integer^number.
sublist(number, [3, f, 3.4], L).

L = [3, 3.400000] 

Yes
5 ?- h.
    1	append("Hello ", "World", L).
    2	append("Hello ", "World", L), writef('L = %s\n', [L]).
    3	sublist(integer, [3, f, 3.4], L).
    4	sublist(number, [3, f, 3.4], L).

5 ?- !2^World^Universe.
append("Hello ", "Universe", L), writef('L = %s\n', [L]).
L = Hello Universe

L = [72, 101, 108, 108, 111, 32, 85, 110, 105, 118, 101, 114, 115, 101] 

Yes
6 ?- halt.
\end{code}
\end{boxed}

    \caption{Some examples of the history facility}
    \label{fig:history}
\end{figure}

\subsection*{Limitations of the History System}

When in top level SWI-Prolog reads the user's queries using
history_read/6 rather than read/1.  This predicate first reads the
current input stream up to a full stop.  While doing so it maps all
contiguous blank space onto a single space and deletes \verb+/* ... */+
and \verb+% ... <cr>+ comments.  Parts between double
quotes (\tty{"}) or single quotes (\tty{'}) are left unaltered.%
    \footnote{With the limitations of style checking on long atoms and
	      strings (see style_check/2)}
Note that a Prolog full stop consists of a `non-symbol' character,
followed by a period (\tty{.}), followed by a blank character.  `Symbol'
characters are: \verb!#$&*+-./:<=>?@^`~!. A single quote immediately
preceded by a digit (\tty{0-9}) is not considered a quote character.%
    \footnote{It is considered part of the \verb+<digit>'<digit>...+
	      (e.g. \verb+2'101+; binary number 101) sequence}

After this initial parsing the result is first checked for the special
\verb+^old^new.+ construction. If this fails the string is checked for
all occurrences of the \tty{!}, followed by a \tty{!}, \tty{?}, a
digit, a letter or an underscore. These special sequences are analysed
and the appropriate substitution from the history list is made.

From the above it follows that it is hard or impossible to
correct quotation with single or double quotes, comment delimiters and
spacing.

\section{Overview of the Debugger}

SWI-Prolog has a standard 4-port tracer \cite{Clocksin:81} with an
optional fifth port.  This fifth port, called {\em unify} allows the
user to inspect the result after unification of the head.  The ports are
called {\em call}, {\em exit}, {\em redo}, {\em fail} and {\em unify}.
The tracer is started by the trace/0 command, when a spy point is
reached and the system is in debugging mode (see spy/1 and debug/1) or
when an error is detected at run time.  Note that in the interactive
toplevel goal trace/0 means ``trace the next query''.  The tracer
shows the port, displaying the port name, the current depth of the
recursion and the goal.  The goal is printed using the Prolog predicate
print/1 (default), write/1 or display/1.  An example using all five
ports is shown in figure~\ref{fig:tracer}.

\begin{figure}
\begin{boxed}
\begin{code}
Yes
2 ?- visible(+all), leash(-exit).

Yes
3 ?- trace, min([3, 2], X).
  Call:  ( 3) min([3, 2], G235) ? creep
  Unify: ( 3) min([3, 2], G235)
  Call:  ( 4) min([2], G244) ? creep
  Unify: ( 4) min([2], 2)
  Exit:  ( 4) min([2], 2)
  Call:  ( 4) min(3, 2, G235) ? creep
  Unify: ( 4) min(3, 2, G235)
  Call:  ( 5) 3 < 2 ? creep
  Fail:  ( 5) 3 < 2 ? creep
  Redo:  ( 4) min(3, 2, G235) ? creep
  Exit:  ( 4) min(3, 2, 2)
  Exit:  ( 3) min([3, 2], 2)
\end{code}
\end{boxed}
    \caption{Example trace}
    \label{fig:tracer}
\end{figure}

On {\em leashed ports} (set with the predicate leash/1, default are {\em
call}, {\em exit}, {\em redo} and {\em fail}) the user is prompted for
an action.  All actions are single character commands which are executed
{\sc without} waiting for a return (Unix `cbreak' mode), unless the
command line option \verb$-tty$ is active.  Tracer options:

{\parskip 0pt
\begin{description}
\newcommand{\option}[4]{\item[{%
		\makebox[1cm][l]{\tt #1}%
		\makebox[3cm][l]{\it #2}%
		\makebox[3cm][c]{\rm #3}}]\mbox{}\\ #4}
    \option{$+$}{Spy}{all}{
Set a spy point (see spy/1) on the current predicate.} 
    \option{$-$}{No spy}{all}{
Remove the spy point (see nospy/1) from the current predicate.} 
    \option{/}{Find}{all}{
Search for a port.  After the `/', the user can enter a line
to specify the port to search for.  This line consists of a set of
letters indicating the port type, followed by an optional term,
that should unify with the goal run by the port.  If no term is
specified it is taken as a variable, searching for any port of the
specified type.  If an atom is given, any goal whose functor has a
name equal to that atom matches.  Examples:
\begin{center}\begin{tabular}{lp{3in}}
\tt /f			& Search for any fail port \\
\tt /fe solve		& Search for a fail or exit port of any goal with
			  name {\tt solve} \\
\tt /c solve(a, _)	& Search for a call to solve/2 whose first argument
			  is a variable or the atom {\tt a} \\
\tt /a member(_, _)	& Search for any port on member/2. This is equivalent
			  to setting a spy point on member/2. \\
\end{tabular}\end{center}}
    \option{.}{Repeat find}{all}{
Repeat the last find command (see `/')}
    \option{A}{Alternatives}{all}{
Show all goals that have alternatives.} 
    \option{C}{Context}{all}{
Toggle `Show Context'. If {\em on} the context module of the goal is
displayed between square brackets (see section~\ref{sec:modules}).
Default is {\em off}.} 
    \option{L}{Listing}{all}{
List the current predicate with listing/1.} 
    \option{a}{Abort}{all}{
Abort Prolog execution (see abort/0).} 
    \option{b}{Break}{all}{
Enter a Prolog break environment (see break/0).} 
    \option{c}{Creep}{all}{
Continue execution, stop at next port. (Also return, space).} 
    \option{d}{Display}{all}{
Write goals using the Prolog predicate display/1.} 
    \option{e}{Exit}{all}{
Terminate Prolog (see halt/0).} 
    \option{f}{Fail}{call, redo, exit}{
Force failure of the current goal} 
    \option{g}{Goals}{all}{
Show the list of parent goals (the execution stack). Note that due to tail
recursion optimization a number of parent goals might not exist any more.} 
    \option{h}{Help}{all}{
Show available options (also `?').} 
    \option{i}{Ignore}{call, redo, fail}{
Ignore the current goal, pretending it succeeded.} 
    \option{l}{Leap}{all}{
Continue execution, stop at next spy point.} 
    \option{n}{No debug}{all}{
Continue execution in `no debug' mode.} 
    \option{p}{Print}{all}{
Write goals using the Prolog predicate print/1 (default).} 
    \option{r}{Retry}{redo, exit, fail}{
Undo all actions (except for database and i/o actions) back to the call
port of the current goal and resume execution at the call port.} 
    \option{s}{Skip}{call, redo}{
Continue execution, stop at the next port of {\em this} goal (thus skipping
all calls to children of this goal).} 
    \option{u}{Up}{all}{
Continue execution, stop at the next port of {\em the parent} goal (thus
skipping this goal and all calls to children of this goal). This option
is useful to stop tracing a failure driven loop.} 
    \option{w}{Write}{all}{
Write goals using the Prolog predicate write/1.} 
\end{description}}

The ideal 4 port model as described in many Prolog books
\cite{Clocksin:81} is not visible in many Prolog implementations because
code optimisation removes part of the choice- and exit points.
Backtrack points are not shown if either the goal succeeded
deterministically or its alternatives were removed using the cut.  When
running in debug mode (debug/0) choice points are only destroyed when
removed by the cut.  In debug mode tail recursion optimisation is
switched off.%
    \footnote{This implies the system can run out of local stack in debug
	      mode, while no problems arise when running in non-debug mode.}

\section{Compilation}
\label{compilation}

Collections of SWI-Prolog source files can be compiled into an {\em
intermediate code file}.  An intermediate code file is a data file from
which SWI-Prolog can be started.  The command to compile a bundle of
source files is:

\begin{code}
pl [options] [-o output] -c file ...
\end{code}

The individual source files may include other files using the standard
list notation, consult/1, ensure_loaded/1 and use_module/[1,2].  When
the \tty{-o file} option is omitted a file named \tty{a.out} is created
that holds the intermediate code file.

Intermediate code files start with the BSD Unix magic code \verb$#!$
and are executable. This implies they can be started as a command:

\begin{code}
sun% pl -o my_program -c ...
...
sun% my_program [options]
\end{code}

Alternatively, {\tt my_program} can be started with
\begin{code}
sun% pl -x my_program [options]
\end{code}

The following restrictions apply to source file that are to be
compiled with `\tty{-c}':

\begin{itemize}
    \item
term_expansion/2 should not use assert/1 and or retract/1 other than
for local computational purposes.
    \item
Files can only be included by the standard include directives: [...],
consult/1, ensure_loaded/1 and use_module/[1,2].  User defined loading
predicate invocations will not be compiled.
\end{itemize}

Directives are executed both when compiling the program and when
loading the intermediate code file.

\section{Environment Control}

.BD
.C please 3 +Key, -Old, +New
The predicate please/3%
    \footnote{The idea comes from BIM_Prolog. The options supported by
	      this predicate are not compatible with those for
	      BIM_Prolog however.}
is a solution to avoid large numbers of environment control
predicates. Later versions will support other environment control as
now provided via the predicates style_check/2, leash/1, unknown/2, the
tracer predicates, etc. These predicates are then moved into a library
for backwards compatibility. The currently available options are:

\begin{description}
\newcommand{\option}[3]{\item[#1 \it#2 \rm(default: \it #3)]\mbox{}\\}
    \option{optimise}{on/off}{off}
Switch optimise mode for the compiler \tty{on} or \tty{off} (see also
the command line option \tty{-O}). Currently optimised compilation only
implies compilation of arithmetic, making it fast, but invisible to the
tracer.  Later versions might imply various other optimisations such as
incorporating a number of basic predicates in the virtual machine
(var/1, fail/0, =/2, etc.)  to gain speed at the cost of crippling the
debugger.  Also source level optimisations such as integrating small
predicates into their callers, eliminating constant expressions and
other predictable constructs.  Source code optimisation is never
applied to predicates that are declared dynamic (see dynamic/1).
    \option{autoload}{on/off}{on}
If \tty{on} autoloading of library functions is enabled. If
\tty{off} autoloading is disabled. See section~\ref{sec:autoload}.
    \option{verbose_autoload}{on/off}{off}
If \tty{on} the normal consult message will be printed if a library is
autoloaded.  By default this message is suppressed.  Intended to be used
for debugging purposes (e.g.\ where does this predicate come from?).
\end{description}
.ED

\section{Stand Alone Executables}

The introduction of a foreign language interface raised the problem of
incorporating the compiled foreign code into SWI-Prolog to create a new
stand alone executable.%
    \footnote{Note that this facility has not been ported to all
	      machines. The introduction summarises portability issues.}
The current also allows one to create applications that do not need any
of the SWI-Prolog system files.

.BD
.C save_program 2 +NewProgram, +ListOfOptions
Create a new executable wich will be named {\em NewProgram}.  {\em
ListOfOptions} is a list of \mbox{\em Key = Value} pairs that specify
the default command line options that will be saved into the new
program.  If a default is not specified the default compiled into the
currently running Prolog executable is used.%
    \footnote{These are NOT the defaults compiled into an intermediate
	      code file created with pl -c ...}
The available keys are given in table~\ref{tab:save-options}

\begin{table}
\begin{center}
\begin{tabular}{|l|c|c|l|}
\hline
\bf Key	& \bf Option	& \bf Type	& \bf Description \\
\hline
local	& \bf -L	& K-bytes	& Size (Limit) of local stack \\
global	& \bf -G	& K-bytes	& Size (Limit) of global stack \\
trail	& \bf -T	& K-bytes	& Size (Limit) of trail stack \\
argument& \bf -A	& K-bytes	& Size (Limit) of argument stack \\
goal	& \bf -g	& atom		& Initialisation goal \\
toplevel& \bf -t	& atom		& Prolog toplevel goal \\
init_file& \bf -f	& atom		& Personal initialisation file \\
tty	& \bf +/--tty	& on/off	& Use ioctl(2) calls \\
\hline
\end{tabular}
\end{center}

    \caption{Key = Value pairs for save_program/2}
    \label{tab:save-options}
\end{table}

As the entire data image of the current process will be saved on the new
executable it is desirable to keep this small.  Notably the Prolog
machine stacks should be kept small.  The best way to do this is first
to compile the program using the \tty{-c} option.  If this is not
possible try to find the smallest possible stack sizes to compile the
program.  On machines with dynamic stack allocation the stacks are {\bf
not} written to file and so their size does not matter.
Figure~\ref{fig:create-stand} shows a possible session.  Note the use of
`initialise', which is supposed to be a predicate of the application
doing time consuming initialisation.

\begin{figure}
\begin{boxed}
\begin{code}
sun% pl -c load
foreign file dbase loaded 0.066667 seconds, 1578 bytes.
setup consulted, 0.500000 seconds, 5091 bytes.
main consulted, 0.333333 seconds, 3352 bytes.
load consulted, 1.000000 seconds, 9867 bytes.
sun% a.out -f none -L10 -G10 -T5
foreign file dbase loaded 0.066667 seconds, 1578 bytes.
\version
Copyright (c) 1990, University of Amsterdam. All rights reserved.

1 ?- initialise.

Yes
2 ?- save_program(my_program,
	[ local     = 500
	, goal      = go
	, init_file = none
	]).
Running executable: /usr/local/bin/pl
Saving to my_program; text: 204800 ... data: 357000 ... symbols ... done.
Yes
2 ?- halt.
sun%
\end{code}
\end{boxed}
    \caption{Create a stand-alone executable}
    \label{fig:create-stand}
\end{figure}

The resulting program can be used for incremental compilation using
\tty{-c} or another save_program/2.
.C save_program 1 +NewProgram
Equivalent to `\verb$save_program(NewProgram, [])$'.
.ED

\section{Automatic loading of libraries}
\label{sec:autoload}

If ---at runtime--- an undefined predicate is trapped the system will
first try to import the predicate from the module \tty{user}.  If this
fails the {\em auto loader} is activated.  On first activation a index
to all library files in all library directories is loaded in core (see
library_directory/1).  If the undefined predicate can be located in the
one of the libraries that library file is automatically loaded and the
call to the (previously undefined) predicate is resumed.  By default this
mechanism loads the file silently.  The please/3 option
\tty{verbose_autoload} is provided to get verbose loading. The
please option \tty{autoload} can be used to enable/disable the entire
auto load system.

Autoloading only handles (library) source files that use the module
mechanism described in chapter~\ref{sec:modules}.  The files are loaded
with use_module/2 and only the trapped undefined predicate will be imported
to the module where the undefined predicate was called.  Each library
directory must hold a file \tty{INDEX.pl} that contains an index to all
library files in the directory.  This file consists of lines of the 
following format:

\begin{code}
index(Name, Arity, Module, File).
\end{code}

The predicate make/0 scans the autoload libraries and updates the
index if it exists, is writable and out-of-date.  It is adviced to
create an empty file called \tty{INDEX.pl} in a library directory
meant for auto loading before doing anything else.  This index file
can then be updated by running the prolog predicate make/0 (`\%' is
the Unix prompt):

\begin{boxed}\begin{code}
% mkdir ~/lib/prolog
% cd !$
% touch INDEX.pl
%     <create library files>
% pl -g true -t make
 index for library . ... ok.
%
\end{code}\end{boxed}

If there are more than one library files containing the desired predicate
the following search schema is followed:

\begin{enumerate}
  \item If a there is a library file that defines the module in which
        the undefined predicate is trapped, this file is used.
  \item Otherwise library files are considered in the order they appear
        in the library_directory/1 predicate and within the directory
	alphabetically.
\end{enumerate}

\subsection*{Notes on Automatic Loading}

The autoloader is a new feature to SWI-Prolog.  Its aim is to simplify
program development and program management.  Common lisp has a similar
feature, but here the user has to specify which library is to be
loaded if a specific function is called which is not defined.  The
advantage of the SWI-Prolog scheme is that the user does not have to
specify this.  The disadvantage however is that the user might be
wondering ``where the hell this predicate comes from''.  Only
experience can learn whether the functionality of the autoloader is
appropriate.  Comments are welcome.

The autoloader only works if the unknown flag (see unknown/2) is set to
\tty{trace} (default).  A more appropriate interaction with this flag
will be considered.

\section{Garbage Collection}

SWI-Prolog version 1.4 was the first release to support garbage
collection.  Together with tail-recursion optimisation this guaranties
forward chaining programs do not waste indefinite amounts of memory.
Previous releases of this manual stressed on using failure-driven
loops in those cases that no information needed to be passed to the
next iteration via arguments.  This to avoid large amounts of garbage.
This is no longer stricktly necessary, but it should be noticed that
garbage collection is a time consuming activity.  Failure driven loops
tend to be faster for this reason.

Figure~\ref{fig:loop} shows an example which processes a file and stores
the result in the database.  Note the use of the cut to cut away the
alternatives of process_term/1 and repeat/0.  The construct shown in
this figure is advisable for Prolog machines which do not have garbage
collection, and also considerably speeds up the program when run on
machines that do have this facility.


\begin{figure}
\begin{boxed}
\begin{code}

process_file(File) :-
        seeing(Old), 
        see(File), 
        repeat, 
            read(Term), 
            process_term(Term), !, 
        seen, 
        see(Old).

process_term(end_of_file).
process_term(Term) :-
        ..., 
        ..., !, 
        fail.
...
\end{code}
\end{boxed}
    \caption{Failure driven control loop to read a file}
    \label{fig:loop}
\end{figure}


\section{Syntax Notes}

SWI-Prolog uses standard `Edinburgh' syntax. A description of this
syntax can be found in the Prolog books referenced in the introduction.
Below are some non-standard or non-common constructs that are accepted
by SWI-Prolog:

\begin{itemize}
    \item \verb+0'<char>+\mbox{}\\%
This construct is not accepted by all Prolog systems that claim to have
Edinburgh compatible syntax. It describes the ASCII value of \verb+<char>+.
To test whether {\em C} is a lower case character one can use
`\verb+between(0'a, 0'z, C)+'.
    \item \verb+/* ... /* .... */ ... */+\mbox{}\\%
The \verb+/* ... */+ comment statement can be nested. This is useful
if some code with \verb+/* ... */+ comment statements in it should be
commented out.
\end{itemize}

\section{System Limits}

\subsection{Limits on Memory Areas}

SWI-Prolog has a number of memory areas which are not enlarged at run
time, unless you have a version with dynamic stack allocation.  The
default sizes for these areas should suffice for small applications, but
most serious application require larger ones.  They all can be modified
by command line options.  The table below shows these areas.  The first
column gives the option name to modify the size of the area.  This
option character should be followed immediately by a number and
expresses the number of kilo bytes to use for the area.  There are no
other limits than the available memory of the machine to the sizes of
the areas.  The areas are described in table~\ref{tab:areas}.

The heap is a memory area to store atoms, clauses, records, flags, etc.
This area is dynamically enlarged at runtime on all versions of SWI-Prolog.

\begin{table}
\begin{center}
\begin{minipage}{\textwidth}
\begin{tabular}{|c|c|l|p{3in}|}
\hline
Option & Default\footnote{Defaults may depend on local installation.
The value between brackets is the default limit for machines that allow
for dynamic stack allocation.}
 & Area name & Description \\
\hline
-L & 200K (2M) & \bf local stack & The local stack is used to store
		       the execution environments of procedure
		       invocations. The space for an environment is
		       reclaimed when it fails, exits without leaving
		       choice points, the alternatives are cut of with
		       the \tty{!} predicate or no choice points have
		       been created since the invocation and the last
		       subclause is started (tail recursion optimisation). \\
-G & 100K (4M) & \bf global stack & The global stack is used
		       to store terms created during Prolog's
		       execution. Terms on this stack will be reclaimed
		       by backtracking to a point before the term
		       was created or by garbage collection (provided the
		       term is no longer referenced). \\
-T & 50K (4M) & \bf trail stack & The trail stack is used to store
		       assignments during execution.  Entries on this
		       stack remain alive until backtracking before the
		       point of creation or the garbage collector 
		       determines they are nor needed any longer. \\
-A & 5K (1M) & \bf argument stack & The argument stack is used to
		       store one of the intermediate code interpreter's 
		       registers. The amount of space needed on this
		       stack is determined entirely by the depth in
		       which terms are nested in the clauses that
		       constitute the program. Overflow is most likely
		       when using long strings in a clause. \\
\hline
\end{tabular}
\end{minipage}
\end{center}
    \caption{Memory areas}
    \label{tab:areas}
\end{table}

\subsection{Other Limits}

\begin{description}
    \item[Clauses]
Currently the following limitations apply to clauses.  The arity may
not be more than 128, the number of links to the `outside world'
(predicates, atoms, (large) integers, etc) may not exceed 512 and
the number of variables should be less than 256.%
    \footnote{I plan to raise all these limits to 65536, the maximum
	      addressable range by the 16 bits virtual machine codes.}
    \item[Atoms and Strings]
SWI-Prolog has no limits on the sizes of atoms and strings.  read/1 and
its derivates however normally limit the number of newlines in an atom
or string to 5 to improve error detection and recovery.  This can be
switched off with style_check/1.
    \item[Address space]
SWI-Prolog uses tagged pointers internally. This limits the number of
available bits for addressing memory to 29 (512 Mb).  Currently none of
the machines SWI-Prolog has been ported to can address more than 512 Mb
    \item[Integers]
Integers are tagged values. Their value is limited between
$-2^{26}$ and $2^{26} - 1$.
    \item[Floats]
Floating point numbers are C-doubles with a 12 bit reduction of the
mantisse.  For machines using IEEE floating point format, this implies
the range is about $\pm 10^{308}$ and the accurracy about 10 digits.
\end{description}

\subsection{Reserved Names}

The boot compiler (see \tty{-b} option) does not support the module
system (yet).  As large parts of the system are written in Prolog itself
we need some way to avoid name clashes with the user's predicates, 
database keys, etc.  Like Edinburgh C-Prolog \cite{CPROLOG:manual} all
predicates, database keys, etc.\ that should be hidden from the user
start with a dollar ({\tt \$}) sign (see style_check/2).

The compiler uses the special functor {\tt \$VAR\$/1} while analysing the
clause to compile.  Using this functor in a program causes unpredictable
behaviour of the compiler and resulting program.

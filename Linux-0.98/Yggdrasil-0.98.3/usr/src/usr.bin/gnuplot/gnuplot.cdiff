diff +context +recursive +new-file gnuplot.orig//Makefile gnuplot//Makefile
*** gnuplot.orig//Makefile
--- gnuplot//Makefile	Sun May 24 10:36:53 1992
***************
*** 0 ****
--- 1,727 ----
+ ############################################################
+ #
+ # GNUPLOT 3.0 Makefile (Unix X11 Motif/Athena support) for
+ #  Linux/Apollo/Sun/Dec5000/IBMrs6000/HP9000/SGI/3B1/386IX/Cray
+ #
+ # Original version by:
+ #   oliveria@caen.engin.umich.edu (ROQUE DONIZETE DE OLIVEIRA)
+ #   Wed, 3 Jul 91 14:31:37 -0400
+ #
+ # LINUX modifications by:
+ #   Tommy Frandsen (frandsen@diku.dk)
+ #
+ #>>> Customizing: You must customize part of this makefile for your site.
+ #>>> Then type 'make' for further instructions.
+ #>>> Customization instructions look like these lines do (#>>>).
+ #
+ 
+ TARGET = All # What to make by default
+ 
+ ############################################################
+ #>>> Decide where the binaries and manuals will go. 
+ # directory where to install executables on 'make install'
+ DEST=/usr/local/bin
+ # directory for installing man page on 'make man_install'.
+ MANDEST=/usr/local/man/manl
+ # where to install help file gnuplot.gih
+ HELPDEST=/usr/local/lib/gnuplot.gih
+ #HELPDEST=docs/gnuplot.gih
+ # Where to send email about bugs and comments (locally)
+ EMAIL=bug-gnuplot%pixar.uucp@sun.com
+ 
+ ############################################################
+ #>>> Choose your C compiler and basic compiler flags.
+ CC     = gcc # the C compiler
+ COPTS  = -static -O2 # C options
+ LD     =$(CC) $(CFLAGS)	    # default loading command
+ 
+ ############################################################
+ #>>> Choose some optional features. 
+ #>>> At this point there are only two optional features:
+ # READLINE:
+ #   If READLINE is defined, then command-line editing is supported.
+ #   Otherwise, your normal terminal editing is all you get.
+ #   Some machines will not support this, and they will turn this
+ #   option off (for example, apollos running SR10.2 or SR10.3 and
+ #   loaded with BSD4.3 instead of SYS5). 
+ # NOCWDRC:
+ #   If NOCWDRC is defined, then any .gnuplot in the current directory
+ #   is not read on startup. This is a security consideration
+ #   especially for root users ( we recommend you define -DNOCWDRC ).
+ OPTIONS = -DREADLINE -DNOCWDRC
+ 
+ #>>> Optionally install the lasergnu script.
+ # Lasergnu is a handy shell script for creating a plot from the
+ # command line and sending it directly to the printer. It currently
+ # supports postscript and imagen printers, and probably would need
+ # tailoring to your site.
+ # Use lasergnu_install to install lasergnu.
+ # Use lasergnu_noinstall to not install lasergnu (default).
+ LASERGNU = lasergnu_noinstall
+ 
+ ############################################################
+ # X11 support
+ #
+ 
+ #>>> List your X11 libraries#
+ # standard MIT X11 R4:                      -lXaw -lXmu -lXt -lXext -lX11
+ # Apollo DomainOS 10.3 (R3/Athena):         -L/usr/lib/X11 -lXaw -lXmu -lXt -lX11
+ # Apollo DomainOS 10.3 (R3/Motif):          -L/usr/lib/X11 -lXm -lXtm -lX11
+ # IBM RS/6000 AIX 3.1 (R3/Athena):          -L/usr/lpp/X11/Xamples/lib/Xmu \
+ #                                           -L/usr/lpp/X11/Xamples/lib/Xaw \
+ #                                           -lXaw -lXmu -lXt -lXext -lX11
+ # IBM RS/6000 AIX 3.1 (R3/Motif):           -lXm -lXt -lX11
+ # HP 9000/375 HP-UX 6.5 and 7.0 (R3/Motif): -lXm -lXt -lX11
+ # Interactive 386/ix with T.Roell X386 and network support:
+ #                                           -lXaw -lXm -lXt -lXext -lX11 -linet -lpt
+ X11LIBS = -lXaw -lXmu -lXt -lXext -lX11
+ 
+ #>>> List your X11 include directories
+ # standard MIT X11 R4: -I/usr/include/X11   -I/usr/include/X11/Xaw 
+ # Apollo DomainOS 10.3 (R3/Athena):         -I/usr/include/X11
+ # Apollo DomainOS 10.3 (R3/Motif):          -I/usr/include/Xm
+ # IBM RS/6000 AIX 3.1 (R3/Athena):          -I/usr/include/X11 \
+ #                                           -I/usr/lpp/X11/Xamples/lib/Xaw \
+ #                                           -I/usr/lpp/X11/Xamples/lib/Xaw/X11
+ # IBM RS/6000 AIX 3.1 (R3/Motif):           -I/usr/include/Xm
+ # HP 9000/375 HP-UX 6.5 and 7.0 (R3/Motif): -I/usr/include/Xm
+ # HP 9000/700 HP-UX 8.0 (R4):               -I/usr/include/X11R4 \
+ #                                           -I/usr/include/X11R4/X11/Xaw
+ X11INCLUDES = -I/usr/include/X11 -I/usr/include/X11/Xaw
+ 
+ #>>> You shouldn't have to change these, since they are controlled by
+ #>>> Machine dependent definitions below.
+ #       Compile option for plot.c and TERMFLAGS, to include X11 support
+ PLOTXFLAG = -DX11
+ #   	   this can add to CFLAGS for X11 compilations. Probably needs no change.
+ X11FLAGS = 
+ #       make gnuplot_x11 by default
+ GNUPLOT_X11 = gnuplot_x11
+ #       install gnuplot_x11 by default
+ X11INSTALL = x11_install
+ 
+ ############################################################
+ #>>> Okay, you've changed enough. Now type 'make'.
+ 
+ ############################################################
+ # This is used to pass many of the above definitions to make
+ # subprocesses. Don't change this.
+ MY_FLAGS  = CC="$(CC)" 	COPTS="$(COPTS)" DEST="$(DEST)" \
+ 		MANDEST="$(MANDEST)" HELPDEST="$(HELPDEST)" \
+ 		EMAIL="$(EMAIL)" LASERGNU="$(LASERGNU)"
+ 
+ ############################################################
+ # Explanations of CFLAGS definitions.
+ #  These should not need to be changed by you.
+ # They are set correctly for each machine below. If your machine
+ # doesn't fit the one of the patterns, override on the make command
+ # line or make a new target for it and a new _FLAGS definition. 
+ #  -DNOVFORK if you're unix and you have don't have vfork()
+ #  -DMEMSET if you need to use memset() instead of bzero() 
+ #  -DMEMCPY if your bcopy() is called memcpy()
+ #  -DNOCOPY if you don't have a memcpy() by any name
+ #  -DGAMMA=foo if your gamma function is called foo(). Apollos have
+ #    lgamma(3m). If you don't have gamma(), use -DNOGAMMA.
+ #    The default is -DGAMMA=gamma.
+ #  -DGETCWD if your unix uses getcwd() instead of getcd()
+ #    this is needed by HP-UX and Cray Unicos systems.
+ #  -DULTRIX_KLUDGE if you run X windows on Ultrix and experience the
+ #    "every other plot" problem.
+ #  -Dunix is required to explicitly define "unix" for SCO and IBM
+ #   	   RS/6000 running AIX 3.1 
+ #  -fswitch if you are compiling on a Sun3 (or even -f68881)
+ #    (but -fswitch is buggy on some systems, so watch out)
+ 
+ # Defaults in case the user types 'make All' directly
+ # Should match X11R4_FLAGS's CFLAGS definition
+ CFLAGS = $(COPTS) $(OPTIONS)
+ 
+  
+ ############################################################
+ # Terminal (device) support
+ #
+ # All devices available to a given machine are compiled in by default.
+ # This documents the flags available in TERMFLAGS, although TERMFLAGS
+ # is usually controlled by the machine-dependent definitions below.
+ # See other terminal defines in term.h.
+ # Define ULTRIX_KLUDGE if you have the every-other plot problem in Ultrix X11.
+ #
+ # -DAPOLLO      Apollo Graphics Primitive Resource (window resize after replot)
+ # -DGPR         Apollo Graphics Primitive Resource (fixed-size window)
+ # -DCGI         SCO CGI
+ # -DIRIS4D      IRIS4D series computer
+ # -DSUN         Sun Microsystems Workstation
+ # -DUNIXPC      unixpc (ATT 3b1 or ATT 7300)
+ # -DUNIXPLOT    unixplot
+ # -DX11         X11 Window System (This is $(PLOTXFLAG))
+ TERMFLAGS = -Iterm -DUNIXPLOT $(PLOTXFLAG)
+ 
+ ############################################################
+ # Library explanations. 
+ #  You shouldn't need to adjust this; again, it is handled by the
+ # machine-dependent definitions below.
+ #
+ #  -lplot if you have -DUNIXPLOT in TERMFLAGS
+ #  -lsuntool -lsunwindow -lpixrect  if you have -DSUN in TERMFLAGS
+ #  -lgl_s if -DIRIS4D in TERMFLAGS
+ #  -lccgi if -DCGI in TERMFLAGS
+ LIBS = -lm -lplot
+ 
+ ############################################################
+ # Machine-dependent settings.
+ #
+ X11R4_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS)" \
+     	   LIBS="$(LIBS)" X11FLAGS="$(X11FLAGS)" X11INCLUDES="$(X11INCLUDES)" \
+     	   X11LIBS="$(X11LIBS)" \
+     	   PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
+     	   X11INSTALL="$(X11INSTALL)" \
+     	   TERMFLAGS="$(TERMFLAGS)"
+ 
+ X11R4_M_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS)" \
+     	   LIBS="$(LIBS)" X11FLAGS="-DMOTIF -D_NO_PROTO" \
+     	   X11INCLUDES="-I/usr/include/Xm" \
+     	   X11LIBS="-lXm -lXt -lX11" \
+     	   PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
+     	   X11INSTALL="$(X11INSTALL)" \
+     	   TERMFLAGS="$(TERMFLAGS)"
+ 
+ DEC_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS) " \
+     	   LIBS="$(LIBS)" X11FLAGS="$(X11FLAGS)" X11INCLUDES="$(X11INCLUDES)" \
+     	   X11LIBS="$(X11LIBS)" \
+     	   PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
+     	   X11INSTALL="$(X11INSTALL)" \
+     	   TERMFLAGS="$(TERMFLAGS) -DULTRIX_KLUDGE"
+ 
+ DEC_M_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS)" \
+     	   LIBS="$(LIBS)" X11FLAGS="-DMOTIF -D_NO_PROTO" \
+     	   X11INCLUDES="-I/usr/include/Xm" \
+     	   X11LIBS="-lXm -lXt -lX11" \
+     	   PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
+     	   X11INSTALL="$(X11INSTALL)" \
+     	   TERMFLAGS="$(TERMFLAGS)  -DULTRIX_KLUDGE"
+ 
+ APOLLO_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS)  -DGAMMA=lgamma" \
+     	   LIBS="$(LIBS)" X11FLAGS="$(X11FLAGS)" \
+     	   X11INCLUDES="$(X11INCLUDES)" \
+     	   X11LIBS="-L/usr/lib/X11 -lXaw -lXmu -lXt -lX11" \
+     	   PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
+     	   X11INSTALL="$(X11INSTALL)" \
+     	   TERMFLAGS="$(TERMFLAGS) -DAPOLLO -DGPR"
+ 
+ APOLLO_M_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS)  -DGAMMA=lgamma" \
+     	   LIBS="$(LIBS)" X11FLAGS="-DMOTIF" X11INCLUDES="-I/usr/include/Xm" \
+     	   X11LIBS="-L/usr/lib/X11 -lXm -lXt -lX11" \
+     	   PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
+     	   TERMFLAGS="$(TERMFLAGS) -DAPOLLO -DGPR"
+ 
+ HP_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS) -DMEMSET -DMEMCPY  -DGETCWD" \
+     	   LIBS="-lm" X11FLAGS="$(X11FLAGS)" \
+     	   X11INCLUDES="-I/usr/include/X11R4 -I/usr/include/X11R4/X11/Xaw" \
+     	   X11LIBS="-L/usr/lib/X11R4 -lXaw -lXmu -lXt -lXext -lX11" \
+     	   PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
+     	   X11INSTALL="$(X11INSTALL)" \
+     	   TERMFLAGS="-Iterm -DX11"
+ 
+ HP_M_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS) -DMEMSET -DMEMCPY -DGETCWD" \
+     	   LIBS="-lm" X11FLAGS="-DMOTIF -D_NO_PROTO" \
+     	   X11INCLUDES="-I/usr/include/Motif1.1 -I/usr/include/Motif1.1/Xm -I/usr/include/X11R4" \
+     	   X11LIBS="-L/usr/lib/Motif1.1 -L/usr/lib/X11R4 -lXm -lXt -lX11" \
+     	   PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
+     	   X11INSTALL="$(X11INSTALL)" \
+     	   TERMFLAGS=" -Iterm -DX11"
+ 
+ SUN_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS)" \
+     	   LIBS="-lsuntool -lsunwindow -lpixrect $(LIBS)" \
+     	   X11FLAGS=" " X11INCLUDES=" " \
+     	   X11LIBS=" " \
+     	   PLOTXFLAG=" " GNUPLOT_X11=" " X11INSTALL=x11_noinstall \
+     	   TERMFLAGS="-Iterm -DUNIXPLOT -DSUN"
+ 
+ SUN_X11_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS)" \
+     	   LIBS="-lsuntool -lsunwindow -lpixrect $(LIBS)" \
+     	   X11FLAGS="$(X11FLAGS)" X11INCLUDES="$(X11INCLUDES)" \
+     	   X11LIBS="$(X11LIBS)" \
+     	   PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
+     	   X11INSTALL="$(X11INSTALL)" \
+     	   TERMFLAGS="$(TERMFLAGS) -DSUN"
+ 
+ SGI_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS)" \
+     	   LIBS="-lgl_s -lm" X11FLAGS=" " X11INCLUDES=" " \
+     	   X11LIBS=" " \
+     	   PLOTXFLAG=" " GNUPLOT_X11=" " X11INSTALL=x11_noinstall \
+     	   TERMFLAGS="-Iterm -DIRIS4D"
+ 
+ SGIX11_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS)" \
+     	   LIBS="-lgl_s -lm -lc_s" X11FLAGS="$(X11FLAGS)" \
+     	   X11INCLUDES="-I/usr/include/X11 -I/usr/include/X11/Xaw" \
+     	   X11LIBS="-L/usr/lib/X11 -lXaw -lXmu -lXt -lXext -lX11" \
+      	   PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
+      	   X11INSTALL="$(X11INSTALL)" \
+     	   TERMFLAGS="-Iterm -DX11 -DIRIS4D"
+ 
+ CGI_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS) -Dunix" \
+     	   LIBS="-lccgi $(LIBS)" X11FLAGS=" " X11INCLUDES=" " \
+     	   X11LIBS=" " PLOTXFLAG=" " GNUPLOT_X11=" " X11INSTALL=x11_noinstall \
+     	   TERMFLAGS="-Iterm -DUNIXPLOT -DCGI"
+ 
+ 3B1_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS) -DGETCWD -DMEMSET -DMEMCPY -DNOVFORK" \
+     	   LIBS="$(LIBS)" X11FLAGS=" " X11INCLUDES=" " \
+     	   X11LIBS=" " \
+     	   PLOTXFLAG=" " GNUPLOT_X11=" " X11INSTALL=x11_noinstall \
+     	   LD="ld /lib/crt0s.o /lib/shlib.ifile" \
+     	   TERMFLAGS="-Iterm -DUNIXPC"
+ 
+ 386IX_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS) -DGETCWD -DMEMSET -DMEMCPY -DNOVFORK -DTCSETSW -DTCGETS" \
+     	   LIBS="$(LIBS) -lcposix" X11FLAGS=" " X11INCLUDES=" " \
+     	   X11LIBS=" " PLOTXFLAG=" " GNUPLOT_X11=" " \
+     	   X11INSTALL=x11_noinstall \
+     	   TERMFLAGS="-Iterm -DUNIXPLOT"
+ 386IX_X11_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS) -DGETCWD -DMEMSET -DMEMCPY -DNOVFORK -DTCSETSW -DTCGETS" \
+     	   LIBS="$(LIBS) -lcposix" X11FLAGS="$(X11FLAGS)" X11INCLUDES="$(X11INCLUDES)" \
+     	   X11LIBS="$(X11LIBS)" PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11="$(GNUPLOT_X11)" \
+     	   X11INSTALL= "$(X11INSTALL)" \
+     	   TERMFLAGS="-Iterm -DUNIXPLOT -DX11"
+  	
+ AIX_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS) -Dunix -DNOVFORK" \
+     	   LIBS="$(LIBS)" X11FLAGS="$(X11FLAGS)" \
+     	   X11INCLUDES="-I/usr/include/X11 -I/usr/lpp/X11/Xamples/lib/Xaw -I/usr/lpp/X11/Xamples/lib/Xaw/X11" \
+     	   X11LIBS="-L/usr/lpp/X11/Xamples/lib/Xmu -L/usr/lpp/X11/Xamples/lib/Xaw -lXaw -lXmu -lXt -lXext -lX11" \
+     	   PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
+     	   X11INSTALL="$(X11INSTALL)" \
+     	   TERMFLAGS="$(TERMFLAGS)"
+ 
+ AIX_M_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS) -Dunix -DNOVFORK" \
+     	   LIBS="$(LIBS)" X11FLAGS="-DMOTIF" X11INCLUDES="-I/usr/include/Xm" \
+     	   X11LIBS="-lXm -lXt -lX11" \
+     	   PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
+     	   X11INSTALL="$(X11INSTALL)" \
+     	   TERMFLAGS="$(TERMFLAGS)"
+ 
+ NEXT_FLAGS = \
+     	   CFLAGS="$(COPTS) -DGAMMA=lgamma -DNEXT" \
+     	   LIBS="-lm" X11FLAGS="$(X11FLAGS)" \
+     	   X11INCLUDES=" " X11LIBS=" " PLOTXFLAG=" " \
+     	   GNUPLOT_X11=" " X11INSTALL=x11_noinstall \
+     	   TERMFLAGS="-Iterm"
+ 
+ NEXT_X11_FLAGS = \
+     	   CFLAGS="$(COPTS) -DGAMMA=lgamma -DNEXT" \
+     	   LIBS="-lm" \
+            X11LIBS="-L/usr/lib/X11 -lXaw -lXmu -lXt -lX11" \
+     	   X11INCLUDES="$(X11INCLUDES)" X11FLAGS="$(X11FLAGS)" \
+     	   PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
+     	   X11INSTALL="$(X11INSTALL)" \
+     	   TERMFLAGS="-Iterm -DX11"
+ 
+ CRAY_FLAGS = \
+ 	   CFLAGS="$(COPTS) $(OPTIONS) -DGETCWD -DNOVFORK" \
+ 	   LIBS="-lm" X11FLAGS=" " \
+ 	   X11INCLUDES=" " \
+ 	   X11LIBS=" " \
+ 	   PLOTXFLAG=" " GNUPLOT_X11=" " \
+ 	   X11INSTALL=x11_noinstall \
+ 	   TERMFLAGS="-Iterm"
+ CRAY_X11_FLAGS = \
+ 	   CFLAGS="$(COPTS) $(OPTIONS) -DGETCWD -DNOVFORK" \
+ 	   LIBS="-lm" X11FLAGS="$(X11FLAGS)" \
+ 	   X11INCLUDES="$(X11INCLUDES)" \
+ 	   X11LIBS="$(X11LIBS)" \
+ 	   PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11="$(GNUPLOT_X11)" \
+ 	   X11INSTALL=$(X11INSTALL) \
+ 	   TERMFLAGS="-Iterm -DX11"
+ 
+ LINUX_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS) -DMEMCPY -DGETCWD -DGAMMA=lgamma \
+ 	   -DNOVFORK" LIBS="-lsoft" X11FLAGS=" " X11INCLUDES=" " \
+     	   X11LIBS=" " PLOTXFLAG=" " GNUPLOT_X11=" " X11INSTALL=x11_noinstall \
+     	   TERMFLAGS="-Iterm -DLINUX"
+ 
+ ####################################################################
+ # List of object files except version.o
+ OBJS = bitmap.o command.o contour.o eval.o graphics.o graph3d.o help.o \
+ 	   internal.o misc.o parse.o plot.o readline.o scanner.o \
+ 	   setshow.o standard.o term.o util.o  
+ ####################################################################
+ # List of source files
+ # Used for makeing shar files, lint, and some dependencies.
+ DIRS = term demo docs docs/latextut
+ 
+ CSOURCE1 = command.c setshow.c 
+ CSOURCE2 = help.c graphics.c graph3d.c internal.c 
+ CSOURCE3 = misc.c eval.c parse.c plot.c readline.c scanner.c standard.c 
+ CSOURCE4 = bitmap.c term.c util.c version.c
+ CSOURCE5 = term/amiga.trm term/aed.trm term/cgi.trm term/dumb.trm term/dxf.trm \
+ 	term/dxy.trm term/eepic.trm term/epson.trm term/fig.trm \
+ 	term/hp26.trm term/hp2648.trm term/hpgl.trm term/hpljii.trm \
+ 	term/apollo.trm term/gpr.trm
+ CSOURCE6 = term/impcodes.h term/imagen.trm term/object.h \
+ 	term/iris4d.trm term/kyo.trm term/latex.trm term/pc.trm 
+ CSOURCE7 = term/post.trm term/qms.trm term/regis.trm term/sun.trm \
+ 	term/t410x.trm term/tek.trm term/unixpc.trm term/unixplot.trm \
+ 	term/v384.trm term/x11.trm term/bigfig.trm term/vws.trm \
+         gnuplot_x11.c term/linux.trm
+ CSOURCE8 = contour.c
+ # not C code, but still needed
+ 
+ DEMOS = demo/1.dat demo/2.dat demo/3.dat demo/contours.demo demo/controls.demo \
+ 	demo/electron.demo demo/glass.dat demo/param.demo demo/polar.demo \
+ 	demo/simple.demo demo/surface1.demo demo/surface2.demo demo/using.dat \
+ 	demo/using.demo demo/world.cor demo/world.dat demo/world.demo \
+ 	demo/err.dat demo/poldat.demo demo/polar.dat demo/errorbar.demo \
+ 	demo/antenna.dat demo/all.demo demo/bivariat.demo
+ 
+ ETC = Copyright README README.gnutex README.amiga makefile.unx makefile.vms  \
+ 	linkopt.amg makefile.amg makefile.ami linkopt.vms buildvms.com \
+ 	plot.h help.h setshow.h bitmap.h term.h lasergnu \
+ 	term/README History gnuplot.el Intergraph.x11 README.Install
+ 
+ #BETA files (not standard distribution files)
+ BETA = BETA10
+ # PC-specific files
+ PC = corgraph.asm corplot.c header.mac hrcgraph.asm lineproc.mac \
+ 	linkopt.msc linkopt.tc linkopt.tco makefile.msc makefile.tc \
+ 	pcgraph.asm 
+ 
+ # Documentation and help files
+ DOCS1 = docs/Makefile docs/README docs/checkdoc.c docs/doc2gih.c \
+ 	docs/doc2hlp.c docs/doc2hlp.com docs/doc2ms.c docs/doc2tex.c \
+ 	docs/gnuplot.1 docs/lasergnu.1 docs/toc_entry.sty \
+ 	docs/titlepage.ms docs/titlepage.tex docs/Makefile.ami
+ DOCS2 = docs/gnuplot.doc
+ DOCS3 = docs/latextut/Makefile docs/latextut/eg1.plt \
+ 	docs/latextut/eg2.plt docs/latextut/eg3.dat docs/latextut/eg3.plt \
+ 	docs/latextut/eg4.plt docs/latextut/eg5.plt docs/latextut/eg6.plt \
+ 	docs/latextut/header.tex docs/latextut/tutorial.tex \
+ 	docs/latextut/linepoint.plt
+ 
+ #########################################################################
+ # Default target (informational)
+ info:
+ 	@echo "Please do a 'make <MACHINE>' where <MACHINE> is one of the following:"
+ 	@echo 
+ 	@echo "apollo, apollo_motif       for Apollo running SR10.3 with Apollo's X11R3"
+ 	@echo "dec, dec_motif             for Dec3100/5000 running Ultrix 3.1d with MIT's X11R4"
+ 	@echo "hp, hp_motif               for HP/9000 700 series running HP/UX 8.0 with MIT's X11R4"
+ 	@echo "sun                        for Sun sparcstation running SunOS 4.1 with suntools (no X11R4) "
+ 	@echo "sun_x11                    for Sun sparcstation running SunOS 4.1 with suntools and X11R4 "
+ 	@echo "sgi                        for Silicon Graphics IRIS4D machines (no X11R4) "
+ 	@echo "sgix11                     for Silicon Graphics IRIS4D machines (X11R4) "
+ 	@echo "next                       for NeXT Cube and Slab running NeXTOS 2.0+ (no X11R4) "
+ 	@echo "3b1                        for ATT 3b1 machines (no X11R4) "
+ 	@echo "386ix                      for 386 machines running 386/ix (no X11)"
+ 	@echo "386ix_x11                  for 386 machines running 386/ix with T.Roell X386"
+ 	@echo "ibmrs6000, ibmrs6000_motif for IBM RS/6000 running Aix 3.1 with IBM's X11R3"
+ 	@echo "x11r4, x11r4_motif         for a generic machine (like a sun or dec) with MIT's X11R4"
+ 	@echo "cray            for Cray Y-MP or Cray-2 running Unicos 6.0 or 6.1 (no X11R4)"
+ 	@echo "cray_x11        for Cray Y-MP or Cray-2 running Unicos 6.0 or 6.1 with X11R4"
+ 	@echo "linux                      for PC's running Linux "
+ 	@echo 
+ 	@echo "Examples:"
+ 	@echo
+ 	@echo "         make x11r4"
+ 	@echo "         make x11r4_motif"
+ 	@echo "         make apollo"
+ 	@echo "         make apollo       OPTIONS='-DNOCWDRC' "
+ 	@echo "         make apollo_motif DEST='/usr/um/misc/bin' "
+ 	@echo "         make dec"
+ 	@echo "         make hp"
+ 	@echo "         make next"
+ 	@echo "         make sun          HELPDEST='/usr/um/misc/lib/gnuplot.gih' "
+ 	@echo "         make sun          X11INCLUDES='-I/usr/local/include -I/usr/local/include/X11 -I/usr/local/include/X11/Xaw' "
+ 	@echo "         make sun_x11"
+ 	@echo "         make sgi"
+ 	@echo "         make 3b1"
+ 	@echo "         make 386ix"
+ 	@echo "         make ibmrs6000    MANDEST='/usr/um/misc/man/man1' COPTS='-O' "
+ 	@echo "         make cray"
+ 	@echo "         make cray_x11"
+ 	@echo "         make linux"
+ 	@echo 
+ 	@echo "If you just type 'make All' , it will build gnuplot for Unix X11R4/Athena"
+ 	@echo "and the following variables will be used as default:"
+ 	@echo 
+ 	@echo " DEST                     " $(DEST)
+ 	@echo " MANDEST                  " $(MANDEST)
+ 	@echo " HELPDEST                 " $(HELPDEST)
+ 	@echo " EMAIL                    " $(EMAIL)
+ 	@echo " CC                       " $(CC)
+ 	@echo " COPTS                    " $(COPTS)
+ 	@echo " OPTIONS                  " $(OPTIONS)
+ 	@echo " CFLAGS                   " $(CFLAGS)
+ 	@echo " LIBS                     " $(LIBS)
+ 	@echo " X11FLAGS                 " $(X11FLAGS)
+ 	@echo " X11LIBS                  " $(X11LIBS)
+ 	@echo " X11INCLUDES              " $(X11INCLUDES)
+ 	@echo " TERMFLAGS                " $(TERMFLAGS)
+ 	@echo " LASERGNU                 " $(LASERGNU)
+ 	@echo 
+ 	@echo "If you are not familiar with makefiles or just want to know what"
+ 	@echo " 'make <MACHINE>' would  do without actually doing anything, then type"
+ 	@echo " 'make <MACHINE> -n' "
+ 	@echo 
+ 
+ ###############################################################
+ # Targets for each machine
+ 
+ x11r4:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(X11R4_FLAGS)    $(TARGET)
+ 
+ x11r4_motif:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(X11R4_M_FLAGS)  $(TARGET)
+ 
+ dec:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(DEC_FLAGS)      $(TARGET)
+ 
+ dec_motif:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(DEC_M_FLAGS)    $(TARGET)
+ 
+ apollo:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(APOLLO_FLAGS)   $(TARGET)
+ 
+ apollo_motif:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(APOLLO_M_FLAGS) $(TARGET)
+ 
+ hp:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(HP_FLAGS)       $(TARGET)
+ 
+ hp_motif:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(HP_M_FLAGS)       $(TARGET)
+ 
+ next:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(NEXT_FLAGS)     $(TARGET)
+ 
+ next_x11:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(NEXT_X11_FLAGS)     $(TARGET)
+ 
+ sun:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(SUN_FLAGS)      $(TARGET)
+ 
+ sun_x11:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(SUN_X11_FLAGS)  $(TARGET)
+ 
+ sgi:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(SGI_FLAGS)      $(TARGET)
+ 
+ sgix11:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(SGIX11_FLAGS)   $(TARGET)
+ 
+ cgi:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(CGI_FLAGS)      $(TARGET)
+ 
+ 3b1:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(3B1_FLAGS)      $(TARGET)
+ 
+ 386ix:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(386IX_FLAGS)    $(TARGET)
+ 
+ 386ix_x11: 
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(386IX_X11_FLAGS) $(TARGET)
+ 
+ ibmrs6000:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(AIX_FLAGS)      $(TARGET)
+ 
+ ibmrs6000_motif:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(AIX_M_FLAGS)    $(TARGET)
+ cray:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(CRAY_FLAGS)     $(TARGET)
+ cray_x11:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(CRAY_X11_FLAGS) $(TARGET)
+ 
+ linux:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(LINUX_FLAGS)    $(TARGET)
+ 
+ 
+ #############################################################
+ # Targets that really do something
+ 
+ all:
+ 	@echo "Please just type  'make'  in order to get some information on "
+ 	@echo "how to build gnuplot under Unix and the X Window System."
+ 
+ All:	gnuplot $(GNUPLOT_X11) doc
+ 
+ gnuplot: $(OBJS) version.o
+ 	$(LD) $(OBJS) version.o $(LIBS) -o gnuplot
+ 
+ doc:
+ 	( cd docs; $(MAKE) $(MFLAGS) gnuplot.gih )
+ 
+ gnuplot_x11: gnuplot_x11.c
+ 	$(CC) $(CFLAGS) $(X11FLAGS) $(X11INCLUDES) -o gnuplot_x11 gnuplot_x11.c $(X11LIBS)
+ 
+ ################################################################
+ # Installation instructions
+ 
+ install:
+ 	@echo 
+ 	@echo "Please do a 'make <MACHINE> TARGET=Install' where <MACHINE> is one of the following:"
+ 	@echo 
+ 	@echo "apollo, apollo_motif, dec, dec_motif, hp, sun, sun_x11, sgi, sgix11"
+ 	@echo "next, 3b1, 386ix, ibmrs6000, ibmrs6000_motif, x11r4, x11r4_motif"
+ 	@echo "linux"
+ 	@echo 
+ 	@echo "Examples:"
+ 	@echo
+ 	@echo "         make x11r4        TARGET=Install "
+ 	@echo "         make apollo       TARGET=Install "
+ 	@echo "         make apollo_motif TARGET=Install DEST='/usr/um/misc/bin' "
+ 	@echo "         make dec          TARGET=Install "
+ 	@echo "         make hp           TARGET=Install "
+ 	@echo "         make sun          TARGET=Install HELPDEST='/usr/um/misc/lib/gnuplot.gih' "
+ 	@echo "         make ibmrs6000    TARGET=Install MANDEST='/usr/um/misc/man/man1' COPTS='-O' "
+ 	@echo "         make linux        TARGET=Install "
+ 	@echo 
+ ################################################################
+ # Installation targets
+ 
+ Install: All man_install $(X11INSTALL) $(LASERGNU)
+ 	cp gnuplot     $(DEST)
+ 	strip $(DEST)/gnuplot
+ 	( cd docs; $(MAKE) $(MFLAGS) install-unix HELPDEST=$(HELPDEST) )
+ 
+ x11_install: gnuplot_x11
+ 	cp gnuplot_x11 $(DEST)
+ 	strip $(DEST)/gnuplot_x11
+ 
+ x11_noinstall: 
+ 	@echo "X11 not requested, so gnuplot_x11 program not installed"
+ 
+ man_install: docs/gnuplot.1
+ 	cp docs/gnuplot.1 $(MANDEST)
+ 
+ lasergnu_install: lasergnu docs/lasergnu.1
+ 	cp lasergnu $(DEST)
+ 	chmod 755 $(DEST)/lasergnu
+ 	cp docs/lasergnu.1 $(MANDEST)
+ 
+ lasergnu_noinstall:
+ 	@echo 
+ 	@echo "Lasergnu will not be installed by default."
+ 	@echo "If you think you need the lasergnu script to print"
+ 	@echo " files on the imagen or postscript printers, then"
+ 	@echo " type"
+ 	@echo "      'make <MACHINE> TARGET=Install LASERGNU='lasergnu_install' "
+ 	@echo
+ 	@echo "Lasergnu is really not needed since within gnuplot you can"
+ 	@echo " can create files (in impress or postscript language) and"
+ 	@echo " print them through your favorite print command (lpr, lp, prf, ipr)."
+ 	@echo 
+ 
+ ################################################################
+ # Dependencies
+ 
+ plot.o: plot.c
+ 	$(CC) $(CFLAGS) $(PLOTXFLAG) -c plot.c
+ 
+ term.o: term.h term.c $(CSOURCE5) $(CSOURCE6) $(CSOURCE7)
+ 	$(CC) $(CFLAGS) $(TERMFLAGS) -c term.c
+ 
+ version.o:
+ 	$(CC) $(CFLAGS) -DCONTACT=\"$(EMAIL)\" -c version.c
+ 
+ $(OBJS): plot.h
+ 
+ command.o:
+ 	$(CC) $(CFLAGS) -c command.c -DHELPFILE=\"$(HELPDEST)\"
+ 
+ command.o help.o misc.o: help.h
+ 
+ command.o graphics.o graph3d.o misc.o plot.o setshow.o term.o: setshow.h
+ 
+ bitmap.o term.o: bitmap.h
+ 
+ ################################################################
+ # Miscellaneous targets
+ 
+ SOURCES=plot.h help.h setshow.h bitmap.h term.h $(CSOURCE1) $(CSOURCE2) \
+ 	$(CSOURCE3) $(CSOURCE4) $(CSOURCE5) $(CSOURCE6) $(CSOURCE7) $(CSOURCE8)
+ 
+ lint:
+ 	lint -hx $(SOURCES)
+ 
+ clean:
+ 	rm -f *.o *~ *.bak term/*~ term/*.bak
+ 	( cd docs; $(MAKE) $(MFLAGS) clean )
+ 	( cd docs/latextut; $(MAKE) $(MFLAGS) clean )
+ 
+ spotless:
+ 	rm -f *.o *~ *.bak term/*~ term/*.bak TAGS gnuplot gnuplot_x11
+ 	( cd docs; $(MAKE) $(MFLAGS) clean )
+ 	( cd docs/latextut; $(MAKE) $(MFLAGS) spotless )
+ 
+ ################################################################
+ # Making shar files for mailing gnuplot
+ 
+ shar: gnuplot.sh00 gnuplot.sh01 gnuplot.sh02 gnuplot.sh03 gnuplot.sh04 \
+ 	gnuplot.sh05 gnuplot.sh06 gnuplot.sh07 gnuplot.sh08 \
+ 	gnuplot.sh09 gnuplot.sh10 gnuplot.sh11 gnuplot.sh12 \
+ 	gnuplot.sh13 gnuplot.sh14 gnuplot.sh15 
+ 
+ gnuplot.sh00:
+ 	echo '#!/bin/sh' > gnuplot.sh00
+ 	echo '# This is a shell file to make directories' >> gnuplot.sh00
+ 	echo mkdir $(DIRS) >> gnuplot.sh00
+ 
+ gnuplot.sh01: $(ETC)
+ 	shar $(ETC) > gnuplot.sh01
+ 
+ gnuplot.sh02: $(DOCS1)
+ 	shar $(DOCS1) > gnuplot.sh02
+ 
+ gnuplot.sh03: $(DOCS2)
+ 	shar $(DOCS2) > gnuplot.sh03
+ 
+ gnuplot.sh04: $(DOCS3)
+ 	shar $(DOCS3) > gnuplot.sh04
+ 
+ gnuplot.sh05: $(CSOURCE1)
+ 	shar $(CSOURCE1) > gnuplot.sh05
+ 
+ gnuplot.sh06: $(CSOURCE2)
+ 	shar $(CSOURCE2) > gnuplot.sh06
+ 
+ gnuplot.sh07: $(CSOURCE3)
+ 	shar $(CSOURCE3) > gnuplot.sh07
+ 
+ gnuplot.sh08: $(CSOURCE4)
+ 	shar $(CSOURCE4) > gnuplot.sh08
+ 
+ gnuplot.sh09: $(CSOURCE5)
+ 	shar $(CSOURCE5) > gnuplot.sh09
+ 
+ gnuplot.sh10: $(CSOURCE6)
+ 	shar $(CSOURCE6) > gnuplot.sh10
+ 
+ gnuplot.sh11: $(CSOURCE7)
+ 	shar $(CSOURCE7) > gnuplot.sh11
+ 
+ gnuplot.sh12: $(PC)
+ 	shar $(PC) > gnuplot.sh12
+ 
+ gnuplot.sh13: $(CSOURCE8)
+ 	shar $(CSOURCE8) > gnuplot.sh13
+ 
+ gnuplot.sh14: $(DEMOS)
+ 	shar $(DEMOS) > gnuplot.sh14
+ 
+ gnuplot.sh15: $(BETA)
+ 	shar $(BETA) > gnuplot.sh15
+ 
diff +context +recursive +new-file gnuplot.orig//graph3d.c gnuplot//graph3d.c
*** gnuplot.orig//graph3d.c	Fri Sep 20 16:36:53 1991
--- gnuplot//graph3d.c	Thu May 21 22:58:32 1992
***************
*** 471,476 ****
--- 471,477 ----
  {
  int len,x1,y1,x2,y2;
  register double xr,xnorm,tics,tic,l10;
+ int exp;
  
  	xr = fabs(tmin-tmax);
  
***************
*** 494,511 ****
  	    sqr(3L * term_tbl[term].h_char))
  		return -1.0;                  			/* No tics! */
  
! 	l10 = log10(xr);
! 	if (logscale) {
! 		tic = dbl_raise(10.0,(l10 >= 0.0 ) ? (int)l10 : ((int)l10-1));
! 		if (tic < 1.0)
! 			tic = 1.0;
! 	} else {
! 		xnorm = pow(10.0,l10-(double)((l10 >= 0.0 ) ? (int)l10 : ((int)l10-1)));
! 		if (xnorm <= 5)
! 			tics = 0.5;
! 		else tics = 1.0;
! 		tic = tics * dbl_raise(10.0,(l10 >= 0.0 ) ? (int)l10 : ((int)l10-1));
! 	}
  	return(tic);
  }
  
--- 495,516 ----
  	    sqr(3L * term_tbl[term].h_char))
  		return -1.0;                  			/* No tics! */
  
!         l10 = log10(xr);
!         if (l10 >= 0.0) 
!             exp = (int)l10;
!         else
!             exp = (int)l10-1;
!         if (logscale) {
!                 tic = dbl_raise(10.0, exp);
!                 if (tic < 1.0)
!                         tic = 1.0;
!         } else {
!                 xnorm = pow(10.0,l10-(double)exp);
!                 if (xnorm <= 5)
!                         tics = 0.5;
!                 else tics = 1.0;
!                 tic = tics * dbl_raise(10.0, exp);
!         }
  	return(tic);
  }
  
diff +context +recursive +new-file gnuplot.orig//graphics.c gnuplot//graphics.c
*** gnuplot.orig//graphics.c	Mon Sep  9 20:13:20 1991
--- gnuplot//graphics.c	Thu May 21 22:41:46 1992
***************
*** 173,196 ****
  BOOLEAN logscale;
  {
  register double xr,xnorm,tics,tic,l10;
  
! 	xr = fabs(tmin-tmax);
! 	
! 	l10 = log10(xr);
! 	if (logscale) {
! 		tic = dbl_raise(10.0,(l10 >= 0.0 ) ? (int)l10 : ((int)l10-1));
! 		if (tic < 1.0)
! 			tic = 1.0;
! 	} else {
! 		xnorm = pow(10.0,l10-(double)((l10 >= 0.0 ) ? (int)l10 : ((int)l10-1)));
! 		if (xnorm <= 2)
! 			tics = 0.2;
! 		else if (xnorm <= 5)
! 			tics = 0.5;
! 		else tics = 1.0;	
! 		tic = tics * dbl_raise(10.0,(l10 >= 0.0 ) ? (int)l10 : ((int)l10-1));
! 	}
! 	return(tic);
  }
  
  
--- 173,201 ----
  BOOLEAN logscale;
  {
  register double xr,xnorm,tics,tic,l10;
+ int exp;
  
!         xr = fabs(tmin-tmax); 
!         
!         l10 = log10(xr);
!         if (l10 >= 0.0) 
!             exp = (int)l10;
!         else
!             exp = (int)l10-1;
!         if (logscale) {
!                 tic = dbl_raise(10.0, exp);
!                 if (tic < 1.0)
!                         tic = 1.0;
!         } else {
!                 xnorm = pow(10.0, l10-(double)exp);
!                 if (xnorm <= 2)
!                         tics = 0.2;
!                 else if (xnorm <= 5)
!                         tics = 0.5;
!                 else tics = 1.0;        
!                 tic = tics * dbl_raise(10.0, exp); 
!         } 
!         return(tic); 
  }
  
  
diff +context +recursive +new-file gnuplot.orig//makefile.unx gnuplot//makefile.unx
*** gnuplot.orig//makefile.unx	Mon Jan  6 05:33:20 1992
--- gnuplot//makefile.unx	Sun May 24 12:38:48 1992
***************
*** 1,12 ****
  ############################################################
  #
  # GNUPLOT 3.0 Makefile (Unix X11 Motif/Athena support) for
! #  Apollo/Sun/Dec5000/IBMrs6000/HP9000/SGI/3B1/386IX/Cray
  #
  # Original version by:
  #   oliveria@caen.engin.umich.edu (ROQUE DONIZETE DE OLIVEIRA)
  #   Wed, 3 Jul 91 14:31:37 -0400
  #
  #>>> Customizing: You must customize part of this makefile for your site.
  #>>> Then type 'make' for further instructions.
  #>>> Customization instructions look like these lines do (#>>>).
--- 1,15 ----
  ############################################################
  #
  # GNUPLOT 3.0 Makefile (Unix X11 Motif/Athena support) for
! #  Linux/Apollo/Sun/Dec5000/IBMrs6000/HP9000/SGI/3B1/386IX/Cray
  #
  # Original version by:
  #   oliveria@caen.engin.umich.edu (ROQUE DONIZETE DE OLIVEIRA)
  #   Wed, 3 Jul 91 14:31:37 -0400
  #
+ # LINUX modifications by:
+ #   Tommy Frandsen (frandsen@diku.dk)
+ #
  #>>> Customizing: You must customize part of this makefile for your site.
  #>>> Then type 'make' for further instructions.
  #>>> Customization instructions look like these lines do (#>>>).
***************
*** 19,25 ****
  # directory where to install executables on 'make install'
  DEST=/usr/local/bin
  # directory for installing man page on 'make man_install'.
! MANDEST=/usr/man/manl
  # where to install help file gnuplot.gih
  HELPDEST=/usr/local/lib/gnuplot.gih
  #HELPDEST=docs/gnuplot.gih
--- 22,28 ----
  # directory where to install executables on 'make install'
  DEST=/usr/local/bin
  # directory for installing man page on 'make man_install'.
! MANDEST=/usr/local/man/manl
  # where to install help file gnuplot.gih
  HELPDEST=/usr/local/lib/gnuplot.gih
  #HELPDEST=docs/gnuplot.gih
***************
*** 28,35 ****
  
  ############################################################
  #>>> Choose your C compiler and basic compiler flags.
! CC     = cc # the C compiler
! COPTS  = -O # -O if you trust your compiler's optimizer
  LD     =$(CC) $(CFLAGS)	    # default loading command
  
  ############################################################
--- 31,38 ----
  
  ############################################################
  #>>> Choose your C compiler and basic compiler flags.
! CC     = gcc # the C compiler
! COPTS  = -static -O2 # C options
  LD     =$(CC) $(CFLAGS)	    # default loading command
  
  ############################################################
***************
*** 133,138 ****
--- 136,142 ----
  # Should match X11R4_FLAGS's CFLAGS definition
  CFLAGS = $(COPTS) $(OPTIONS)
  
+  
  ############################################################
  # Terminal (device) support
  #
***************
*** 343,348 ****
--- 347,359 ----
  	   PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11="$(GNUPLOT_X11)" \
  	   X11INSTALL=$(X11INSTALL) \
  	   TERMFLAGS="-Iterm -DX11"
+ 
+ LINUX_FLAGS = \
+     	   CFLAGS="$(COPTS) $(OPTIONS) -DMEMCPY -DGETCWD -DGAMMA=lgamma \
+ 	   -DNOVFORK" LIBS="-lsoft" X11FLAGS=" " X11INCLUDES=" " \
+     	   X11LIBS=" " PLOTXFLAG=" " GNUPLOT_X11=" " X11INSTALL=x11_noinstall \
+     	   TERMFLAGS="-Iterm -DLINUX"
+ 
  ####################################################################
  # List of object files except version.o
  OBJS = bitmap.o command.o contour.o eval.o graphics.o graph3d.o help.o \
***************
*** 365,371 ****
  	term/iris4d.trm term/kyo.trm term/latex.trm term/pc.trm 
  CSOURCE7 = term/post.trm term/qms.trm term/regis.trm term/sun.trm \
  	term/t410x.trm term/tek.trm term/unixpc.trm term/unixplot.trm \
! 	term/v384.trm term/x11.trm term/bigfig.trm term/vws.trm gnuplot_x11.c
  CSOURCE8 = contour.c
  # not C code, but still needed
  
--- 376,383 ----
  	term/iris4d.trm term/kyo.trm term/latex.trm term/pc.trm 
  CSOURCE7 = term/post.trm term/qms.trm term/regis.trm term/sun.trm \
  	term/t410x.trm term/tek.trm term/unixpc.trm term/unixplot.trm \
! 	term/v384.trm term/x11.trm term/bigfig.trm term/vws.trm \
!         gnuplot_x11.c term/linux.trm
  CSOURCE8 = contour.c
  # not C code, but still needed
  
***************
*** 420,425 ****
--- 432,438 ----
  	@echo "x11r4, x11r4_motif         for a generic machine (like a sun or dec) with MIT's X11R4"
  	@echo "cray            for Cray Y-MP or Cray-2 running Unicos 6.0 or 6.1 (no X11R4)"
  	@echo "cray_x11        for Cray Y-MP or Cray-2 running Unicos 6.0 or 6.1 with X11R4"
+ 	@echo "linux                      for PC's running Linux "
  	@echo 
  	@echo "Examples:"
  	@echo
***************
*** 440,445 ****
--- 453,459 ----
  	@echo "         make ibmrs6000    MANDEST='/usr/um/misc/man/man1' COPTS='-O' "
  	@echo "         make cray"
  	@echo "         make cray_x11"
+ 	@echo "         make linux"
  	@echo 
  	@echo "If you just type 'make All' , it will build gnuplot for Unix X11R4/Athena"
  	@echo "and the following variables will be used as default:"
***************
*** 531,536 ****
--- 545,554 ----
  cray_x11:
  	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(CRAY_X11_FLAGS) $(TARGET)
  
+ linux:
+ 	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(LINUX_FLAGS)    $(TARGET)
+ 
+ 
  #############################################################
  # Targets that really do something
  
***************
*** 558,563 ****
--- 576,582 ----
  	@echo 
  	@echo "apollo, apollo_motif, dec, dec_motif, hp, sun, sun_x11, sgi, sgix11"
  	@echo "next, 3b1, 386ix, ibmrs6000, ibmrs6000_motif, x11r4, x11r4_motif"
+ 	@echo "linux"
  	@echo 
  	@echo "Examples:"
  	@echo
***************
*** 568,573 ****
--- 587,593 ----
  	@echo "         make hp           TARGET=Install "
  	@echo "         make sun          TARGET=Install HELPDEST='/usr/um/misc/lib/gnuplot.gih' "
  	@echo "         make ibmrs6000    TARGET=Install MANDEST='/usr/um/misc/man/man1' COPTS='-O' "
+ 	@echo "         make linux        TARGET=Install "
  	@echo 
  ################################################################
  # Installation targets
diff +context +recursive +new-file gnuplot.orig//parse.c gnuplot//parse.c
*** gnuplot.orig//parse.c	Mon Jan  6 05:33:21 1992
--- gnuplot//parse.c	Fri May 22 15:03:41 1992
***************
*** 70,76 ****
  void fpe(an_int)
  int an_int;
  #else
! #ifdef NEXT
  void fpe(int an_int)
  #else
  fpe()
--- 70,76 ----
  void fpe(an_int)
  int an_int;
  #else
! #if defined(NEXT) || defined(linux)
  void fpe(int an_int)
  #else
  fpe()
***************
*** 81,87 ****
  #ifdef PC	/* thanks to lotto@wjh12.UUCP for telling us about this  */
  	_fpreset();
  #endif
! 	(void) signal(SIGFPE, fpe);
  	undefined = TRUE;
  	longjmp(fpe_env, TRUE);
  }
--- 81,87 ----
  #ifdef PC	/* thanks to lotto@wjh12.UUCP for telling us about this  */
  	_fpreset();
  #endif
! 	(void) signal(SIGFPE, fpe); 
  	undefined = TRUE;
  	longjmp(fpe_env, TRUE);
  }
diff +context +recursive +new-file gnuplot.orig//plot.c gnuplot//plot.c
*** gnuplot.orig//plot.c	Mon Jan  6 05:33:22 1992
--- gnuplot//plot.c	Sat May 23 10:29:51 1992
***************
*** 168,174 ****
  void inter(an_int)
  int an_int;
  #else
! #ifdef NEXT
  void inter(int an_int)
  #else
  inter()
--- 168,174 ----
  void inter(an_int)
  int an_int;
  #else
! #if defined(linux) || defined(NEXT)
  void inter(int an_int)
  #else
  inter()
diff +context +recursive +new-file gnuplot.orig//plot.h gnuplot//plot.h
*** gnuplot.orig//plot.h	Mon Jan  6 05:33:23 1992
--- gnuplot//plot.h	Fri May 22 20:24:24 1992
***************
*** 131,136 ****
--- 131,139 ----
  #include <float.h>
  #define VERYLARGE FLT_MAX
  #else
+ #if defined(linux) 
+ #define VERYLARGE 1.797693E+308
+ #else
  #if defined( vms ) || defined( _CRAY ) || defined( NEXT )
  #include <float.h>
  #if defined ( NEXT )  /* bug in NeXT OS 2.0 */
***************
*** 143,148 ****
--- 146,152 ----
  #define VERYLARGE HUGE
  #else
  #define VERYLARGE HUGE
+ #endif
  #endif
  #endif
  #endif
diff +context +recursive +new-file gnuplot.orig//term/linux.trm gnuplot//term/linux.trm
*** gnuplot.orig//term/linux.trm
--- gnuplot//term/linux.trm	Sat May 23 17:20:49 1992
***************
*** 0 ****
--- 1,158 ----
+ /* GNUPLOT - linux.trm */
+ /*
+  * Copyright (C) 1990
+  *
+  * Permission to use, copy, and distribute this software and its
+  * documentation for any purpose with or without fee is hereby granted, 
+  * provided that the above copyright notice appear in all copies and 
+  * that both that copyright notice and this permission notice appear 
+  * in supporting documentation.
+  *
+  * Permission to modify the software is granted, but not the right to
+  * distribute the modified code.  Modifications are to be distributed 
+  * as patches to released version.
+  *
+  * This software  is provided "as is" without express or implied warranty.
+  *
+  * This file is included by ../term.c.
+  *
+  * This terminal driver supports:
+  *  VGA 640x480x16 for PC's running the Linux Operating System 
+  *
+  * AUTHOR
+  *  Tommy Frandsen (frandsen@diku.dk)
+  *
+  * send your comments or suggestions to (pixar!info-gnuplot@sun.com).
+  *
+  */
+ 
+ #define _STRING_H_
+ #include "../vgalinux.c"
+ 
+ #define LINUX_XMAX 640
+ #define LINUX_YMAX 480
+ 
+ #define LINUX_XLAST (LINUX_XMAX - 1)
+ #define LINUX_YLAST (LINUX_YMAX - 1)
+ 
+ #define LINUX_VCHAR FNT5X9_VCHAR
+ #define LINUX_HCHAR FNT5X9_HCHAR
+ 
+ #define LINUX_VTIC 5
+ #define LINUX_HTIC 5
+ 
+ static int graphics_on = FALSE;
+ 
+ int startx, starty;
+ int linux_angle;
+ 
+ static int vgacolor[] = {7,8,2,3,4,5,9,14,12,15,13,10,11,1,6};
+ 
+ 
+ LINUX_text()
+ {
+ 	int c;
+ 
+ 	if (graphics_on) {
+ 		graphics_on = FALSE;
+ 		vga_getch();
+ 	}
+ 	vga_setmode(TEXT);
+ }
+ 
+ 
+ LINUX_reset()
+ {
+ 	vga_setmode(TEXT);
+ }
+ 
+ 
+ LINUX_putc(x,y,c,ang,line_func)
+ unsigned int x,y;
+ char c;
+ int ang;
+ FUNC_PTR line_func;
+ {
+ int i, j, k;
+ unsigned int pixelon;
+ 	i = (int)(c) - 32;
+ 	for (j=0; j<FNT5X9_VBITS; j++) {
+ 		for (k=0; k<FNT5X9_HBITS; k++) {
+ 			pixelon = (((unsigned int)(fnt5x9[i][j])) >> k & 1);
+ 			if (pixelon) {
+ 				switch(ang) {
+ 					case 0 : (*line_func)(x+k+1,y-j,x+k+1,y-j);
+ 							break;
+ 					case 1 : (*line_func)(x-j,y-k-1,x-j,y-k-1);
+ 							break;
+ 				}
+ 			}
+ 		}
+ 	}
+ }
+ 
+ 
+ int LINUX_text_angle(ang)
+ int ang;
+ {
+ 	linux_angle=ang;
+ 	return TRUE;
+ }
+ 
+ 
+ LINUX_init()
+ {
+ }
+ 
+ 
+ LINUX_graphics()
+ {
+ 	graphics_on = TRUE;
+ 	vga_setmode(G640x480x16);
+ }
+ 
+ 
+ LINUX_linetype(linetype)
+ {
+ 	if (linetype >= 13)
+ 		linetype %= 13;
+ 	vga_setcolor(vgacolor[linetype+2]); 
+ }
+ 
+ LINUX_move(x,y)
+ {
+ 	startx = x;
+ 	starty = y;
+ }
+ 
+ 
+ LINUX_vector(x,y)
+ {
+ 	vga_drawline(startx,LINUX_YLAST-starty,x,LINUX_YLAST-y); 
+ 	startx = x;
+ 	starty = y;
+ }
+ 
+ 
+ LINUX_put_text(x,y,str)
+ unsigned int x, y;
+ char *str;
+ {
+ int i;
+ 	switch(linux_angle) {
+ 		case 0 : y -= LINUX_VCHAR/2;
+ 				break;
+ 		case 1 : x += LINUX_VCHAR/2;
+ 				break;
+ 	}
+ 	for (i=0;str[i];i++) {
+ 		LINUX_putc(x,LINUX_YLAST-y,str[i],linux_angle,vga_drawline); 
+ 		switch(linux_angle) {
+ 			case 0 : x+=LINUX_HCHAR ;
+ 					break;
+ 			case 1 : y+=LINUX_HCHAR ;
+ 					break;
+ 		}
+ 	}
+ }
+ 
diff +context +recursive +new-file gnuplot.orig//term.c gnuplot//term.c
*** gnuplot.orig//term.c	Mon Jan  6 05:33:26 1992
--- gnuplot//term.c	Sat May 23 10:30:01 1992
***************
*** 428,433 ****
--- 428,436 ----
  #include "term/amiga.trm"
  #endif
  
+ #ifdef LINUX
+ #include "term/linux.trm"
+ #endif /* LINUX */
  
  /* Dummy functions for unavailable features */
  
***************
*** 1054,1059 ****
--- 1057,1071 ----
  	   X11_linetype, X11_put_text, null_text_angle, 
  	   X11_justify_text, do_point, do_arrow}
  #endif
+ 
+ #ifdef LINUX
+     ,{"linux", "PC with VGA adaptor running Linux",
+            LINUX_XMAX, LINUX_YMAX, LINUX_VCHAR, LINUX_HCHAR, 
+            LINUX_VTIC, LINUX_HTIC, options_null, LINUX_init, LINUX_reset, 
+            LINUX_text, null_scale, LINUX_graphics, LINUX_move, LINUX_vector,
+            LINUX_linetype, LINUX_put_text, LINUX_text_angle, 
+            null_justify_text, do_point, do_arrow}
+ #endif
  };
  
  #define TERMCOUNT (sizeof(term_tbl)/sizeof(struct termentry))
***************
*** 1208,1213 ****
--- 1220,1229 ----
  	   if (getenv("CGIDISP") || getenv("CGIPRNT"))
  	     term_name = "cgi";
  #endif /*CGI */
+ 
+ #ifdef LINUX
+            term_name = "linux";
+ #endif /* LINUX */
      }
  
      /* We have a name, try to set term type */
diff +context +recursive +new-file gnuplot.orig//util.c gnuplot//util.c
*** gnuplot.orig//util.c	Mon Jan  6 05:33:28 1992
--- gnuplot//util.c	Sun May 24 15:25:31 1992
***************
*** 45,50 ****
--- 45,51 ----
  		send some other output to screen.  If FALSE, the command line
  		will be echoed to the screen before the ^ error message. */
  
+ #ifndef linux
  #ifndef vms
  #ifndef __ZTC__
  extern int errno;
***************
*** 52,57 ****
--- 53,59 ----
  extern char *sys_errlist[];
  #endif
  #endif /* vms */
+ #endif /* linux */
  
  extern char input_line[];
  extern struct lexical_unit token[];
diff +context +recursive +new-file gnuplot.orig//vgalinux.c gnuplot//vgalinux.c
*** gnuplot.orig//vgalinux.c
--- gnuplot//vgalinux.c	Sun May 24 10:25:54 1992
***************
*** 0 ****
--- 1,962 ----
+ #include "vgalinux.h"
+ #include <stdio.h>
+ #include <fcntl.h>
+ #include <termios.h>
+ #include <string.h>
+ #include <unistd.h>
+ #include <sys/mman.h>
+ #include <linux/mm.h>
+ 
+ #define GRAPH_BASE 0xA0000
+ #define GRAPH_SIZE 0x10000
+ #define TEXT_BASEC 0xB8000
+ #define TEXT_BASEM 0xB0000
+ #define TEXT_SIZE  0x08000
+ #define FONT_BASE  0xA0000
+ #define FONT_SIZE  0x2000
+ #define NULL_SIZE  0x1000
+ 
+ /* VGA index register ports */
+ #define CRT_IC  0x3D4   /* CRT Controller Index - color emulation */
+ #define CRT_IM  0x3B4   /* CRT Controller Index - mono emulation */
+ #define ATT_IW  0x3C0   /* Attribute Controller Index & Data Write Register */
+ #define GRA_I   0x3CE   /* Graphics Controller Index */
+ #define SEQ_I   0x3C4   /* Sequencer Index */
+ #define PEL_IW  0x3C8   /* PEL Write Index */
+ #define PEL_IR  0x3C7   /* PEL Read Index */
+ 
+ /* VGA data register ports */
+ #define CRT_DC  0x3D5   /* CRT Controller Data Register - color emulation */
+ #define CRT_DM  0x3B5   /* CRT Controller Data Register - mono emulation */
+ #define ATT_R   0x3C1   /* Attribute Controller Data Read Register */
+ #define GRA_D   0x3CF   /* Graphics Controller Data Register */
+ #define SEQ_D   0x3C5   /* Sequencer Data Register */
+ #define MIS_R   0x3CC   /* Misc Output Read Register */
+ #define MIS_W   0x3C2   /* Misc Output Write Register */
+ #define IS1_RC  0x3DA   /* Input Status Register 1 - color emulation */
+ #define IS1_RM  0x3BA   /* Input Status Register 1 - mono emulation */
+ #define PEL_D   0x3C9   /* PEL Data Register */
+ 
+ /* VGA indexes max counts */
+ #define CRT_C   24      /* 24 CRT Controller Registers */
+ #define ATT_C   21      /* 21 Attribute Controller Registers */
+ #define GRA_C   9       /* 9  Graphics Controller Registers */
+ #define SEQ_C   5       /* 5  Sequencer Registers */
+ #define MIS_C   1       /* 1  Misc Output Register */
+  
+ /* VGA registers saving indexes */
+ #define CRT     0               /* CRT Controller Registers start */
+ #define ATT     CRT+CRT_C       /* Attribute Controller Registers start */
+ #define GRA     ATT+ATT_C       /* Graphics Controller Registers start */
+ #define SEQ     GRA+GRA_C       /* Sequencer Registers */
+ #define MIS     SEQ+SEQ_C       /* General Registers */
+ #define END     MIS+MIS_C       /* last */
+ 
+ #define ABS(a) (((a)<0) ? -(a) : (a))
+ 
+ /* variables used to shift between monchrome and color emulation */
+ static int TEXT_BASE;		/* current text memory base address */
+ static int CRT_I;		/* current CRT index register address */
+ static int CRT_D;		/* current CRT data register address */
+ static int IS1_R;		/* current input status register address */
+ static int color_text;		/* true if color text emulation */
+ 
+ 
+ /* graphics mode information */
+ struct info {
+     int xdim;
+     int ydim;
+     int colors;
+     int xbytes;
+ };
+ 
+ 
+ /* BIOS mode 0Dh - 320x200x16 */
+ static char g320x200x16_regs[60] = {
+   0x2D,0x27,0x28,0x90,0x2B,0x80,0xBF,0x1F,0x00,0xC0,0x00,0x00, 
+   0x00,0x00,0x00,0x00,0x9C,0x8E,0x8F,0x14,0x00,0x96,0xB9,0xE3, 
+   0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B, 
+   0x0C,0x0D,0x0E,0x0F,0x01,0x00,0x0F,0x00,0x00, 
+   0x00,0x0F,0x00,0x20,0x00,0x00,0x05,0x0F,0xFF, 
+   0x03,0x09,0x0F,0x00,0x06, 
+   0x63
+ };
+ static struct info g320x200x16_info = { 320, 200, 16, 40 };
+ 
+ 
+ /* BIOS mode 0Eh - 640x200x16 */
+ static char g640x200x16_regs[60] = {
+   0x5F,0x4F,0x50,0x82,0x54,0x80,0xBF,0x1F,0x00,0xC0,0x00,0x00, 
+   0x00,0x00,0x00,0x00,0x9C,0x8E,0x8F,0x28,0x00,0x96,0xB9,0xE3, 
+   0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B, 
+   0x0C,0x0D,0x0E,0x0F,0x01,0x00,0x0F,0x00,0x00, 
+   0x00,0x0F,0x00,0x20,0x00,0x00,0x05,0x0F,0xFF, 
+   0x03,0x01,0x0F,0x00,0x06, 
+   0x63
+ };
+ static struct info g640x200x16_info = { 640, 200, 16, 80 };
+ 
+ 
+ /* BIOS mode 10h - 640x350x16 */
+ static char g640x350x16_regs[60] = {
+   0x5F,0x4F,0x50,0x82,0x54,0x80,0xBF,0x1F,0x00,0x40,0x00,0x00, 
+   0x00,0x00,0x00,0x00,0x83,0x85,0x5D,0x28,0x0F,0x63,0xBA,0xE3, 
+   0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B, 
+   0x0C,0x0D,0x0E,0x0F,0x01,0x00,0x0F,0x00,0x00, 
+   0x00,0x0F,0x00,0x20,0x00,0x00,0x05,0x0F,0xFF, 
+   0x03,0x01,0x0F,0x00,0x06, 
+   0xA3
+ };
+ static struct info g640x350x16_info = { 640, 350, 16, 80 };
+ 
+ 
+ /* BIOS mode 12h - 640x480x16 */
+ static char g640x480x16_regs[60] = {
+   0x5F,0x4F,0x50,0x82,0x54,0x80,0x0B,0x3E,0x00,0x40,0x00,0x00,
+   0x00,0x00,0x00,0x00,0xEA,0x8C,0xDF,0x28,0x00,0xE7,0x04,0xE3,
+   0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,
+   0x0C,0x0D,0x0E,0x0F,0x01,0x00,0x0F,0x00,0x00,
+   0x00,0x0F,0x00,0x20,0x00,0x00,0x05,0x0F,0xFF,
+   0x03,0x01,0x0F,0x00,0x06,
+   0xE3
+ };
+ static struct info g640x480x16_info = { 640, 480, 16, 80 };
+ 
+ 
+ /* BIOS mode 13h - 320x200x256 */
+ static char g320x200x256_regs[60] = {
+   0x5F,0x4F,0x50,0x82,0x54,0x80,0xBF,0x1F,0x00,0x41,0x00,0x00, 
+   0x00,0x00,0x00,0x00,0x9C,0x8E,0x8F,0x28,0x40,0x96,0xB9,0xA3, 
+   0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B, 
+   0x0C,0x0D,0x0E,0x0F,0x41,0x00,0x0F,0x00,0x00, 
+   0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0F,0xFF, 
+   0x03,0x01,0x0F,0x00,0x0E, 
+   0x63
+ };
+ static struct info g320x200x256_info = { 320, 200, 256, 320 };
+ 
+ 
+ /* non-BIOS mode - 320x240x256 */
+ static char g320x240x256_regs[60] = {
+   0x5F,0x4F,0x50,0x82,0x54,0x80,0x0D,0x3E,0x00,0x41,0x00,0x00, 
+   0x00,0x00,0x00,0x00,0xEA,0xAC,0xDF,0x28,0x00,0xE7,0x06,0xE3, 
+   0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B, 
+   0x0C,0x0D,0x0E,0x0F,0x41,0x00,0x0F,0x00,0x00, 
+   0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0F,0xFF, 
+   0x03,0x01,0x0F,0x00,0x06, 
+   0xE3
+ };
+ static struct info g320x240x256_info = { 320, 240, 256, 80 };
+ 
+ 
+ /* non-BIOS mode - 320x400x256 */
+ static char g320x400x256_regs[60] = {
+   0x5F,0x4F,0x50,0x82,0x54,0x80,0xBF,0x1F,0x00,0x40,0x00,0x00, 
+   0x00,0x00,0x00,0x00,0x9C,0x8E,0x8F,0x28,0x00,0x96,0xB9,0xE3, 
+   0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B, 
+   0x0C,0x0D,0x0E,0x0F,0x41,0x00,0x0F,0x00,0x00, 
+   0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0F,0xFF, 
+   0x03,0x01,0x0F,0x00,0x06, 
+   0x63
+ };
+ static struct info g320x400x256_info = { 320, 400, 256, 80 };
+ 
+ 
+ /* non-BIOS mode - 360x480x256 */
+ static char g360x480x256_regs[60] = {
+   0x6B,0x59,0x5A,0x8E,0x5E,0x8A,0x0D,0x3E,0x00,0x40,0x00,0x00, 
+   0x00,0x00,0x00,0x00,0xEA,0xAC,0xDF,0x2D,0x00,0xE7,0x06,0xE3, 
+   0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B, 
+   0x0C,0x0D,0x0E,0x0F,0x41,0x00,0x0F,0x00,0x00, 
+   0x00,0x00,0x00,0x00,0x00,0x40,0x05,0x0F,0xFF, 
+   0x03,0x01,0x0F,0x00,0x06, 
+   0xE7
+ };
+ static struct info g360x480x256_info = { 360, 480, 256, 90 };
+ 
+ 
+ /* default palette values */
+ static char default_red[256]   
+              = { 0, 0, 0, 0,42,42,42,42,21,21,21,21,63,63,63,63,
+ 		 0, 5, 8,11,14,17,20,24,28,32,36,40,45,50,56,63,
+ 		 0,16,31,47,63,63,63,63,63,63,63,63,63,47,31,16,
+ 		 0, 0, 0, 0, 0, 0, 0, 0,31,39,47,55,63,63,63,63,
+ 		63,63,63,63,63,55,47,39,31,31,31,31,31,31,31,31,
+ 		45,49,54,58,63,63,63,63,63,63,63,63,63,58,54,49,
+ 		45,45,45,45,45,45,45,45, 0, 7,14,21,28,28,28,28,
+ 		28,28,28,28,28,21,14, 7, 0, 0, 0, 0, 0, 0, 0, 0,
+ 		14,17,21,24,28,28,28,28,28,28,28,28,28,24,21,17,
+ 		14,14,14,14,14,14,14,14,20,22,24,26,28,28,28,28,
+ 		28,28,28,28,28,26,24,22,20,20,20,20,20,20,20,20,
+ 		 0, 4, 8,12,16,16,16,16,16,16,16,16,16,12, 8, 4,
+ 		 0, 0, 0, 0, 0, 0, 0, 0, 8,10,12,14,16,16,16,16,
+ 		16,16,16,16,16,14,12,10, 8, 8, 8, 8, 8, 8, 8, 8,
+ 		11,12,13,15,16,16,16,16,16,16,16,16,16,15,13,12,
+ 		11,11,11,11,11,11,11,11, 0, 0, 0, 0, 0, 0, 0, 0};
+ static char default_green[256] 
+ 	     = { 0, 0,42,42, 0, 0,21,42,21,21,63,63,21,21,63,63,
+ 		 0, 5, 8,11,14,17,20,24,28,32,36,40,45,50,56,63,
+ 		 0, 0, 0, 0, 0, 0, 0, 0, 0,16,31,47,63,63,63,63,
+ 		63,63,63,63,63,47,31,16,31,31,31,31,31,31,31,31,
+ 		31,39,47,55,63,63,63,63,63,63,63,63,63,55,47,39,
+ 		45,45,45,45,45,45,45,45,45,49,54,58,63,63,63,63,
+ 		63,63,63,63,63,58,54,49, 0, 0, 0, 0, 0, 0, 0, 0,
+ 		 0, 7,14,21,29,28,28,28,28,28,28,28,28,21,14, 7,
+ 		14,14,14,14,14,14,14,14,14,17,21,24,28,28,28,28,
+ 		28,28,28,28,28,24,21,17,20,20,20,20,20,20,20,20,
+ 		20,22,24,26,28,28,28,28,28,28,28,28,28,26,24,22,
+ 		 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8,12,16,16,16,16,
+ 		16,16,16,16,16,12, 8, 4, 8, 8, 8, 8, 8, 8, 8, 8,
+ 		 8,10,12,14,16,16,16,16,16,16,16,16,16,14,12,10,
+ 		11,11,11,11,11,11,11,11,11,12,13,15,16,16,16,16,
+ 		16,16,16,16,16,15,13,12, 0, 0, 0, 0, 0, 0, 0, 0};
+ static char default_blue[256]  
+              = { 0,42, 0,42, 0,42, 0,42,21,63,21,63,21,63,21,63,
+ 		 0, 5, 8,11,14,17,20,24,28,32,36,40,45,50,56,63,
+ 		63,63,63,63,63,47,31,16, 0, 0, 0, 0, 0, 0, 0, 0,
+ 		 0,16,31,47,63,63,63,63,63,63,63,63,63,55,47,39,
+ 		31,31,31,31,31,31,31,31,31,39,47,55,63,63,63,63,
+ 		63,63,63,63,63,58,54,49,45,45,45,45,45,45,45,45,
+ 		45,49,54,58,63,63,63,63,28,28,28,28,28,21,14, 7,
+ 		 0, 0, 0, 0, 0, 0, 0, 0, 0, 7,14,21,28,28,28,28,
+ 		28,28,28,28,28,24,21,17,14,14,14,14,14,14,14,14,
+ 		14,17,21,24,28,28,28,28,28,28,28,28,28,26,24,22,
+ 		20,20,20,20,20,20,20,20,20,22,24,26,28,28,28,28,
+ 		16,16,16,16,16,12, 8, 4, 0, 0, 0, 0, 0, 0, 0, 0,
+ 		 0, 4, 8,12,16,16,16,16,16,16,16,16,16,14,12,10,
+ 		 8, 8, 8, 8, 8, 8, 8, 8, 8,10,12,14,16,16,16,16,
+ 		16,16,16,16,16,15,13,12,11,11,11,11,11,11,11,11,
+ 		11,12,13,15,16,16,16,16, 0, 0, 0, 0, 0, 0, 0, 0};
+ 
+ 
+ /* used to decompose color value into bits (for fast scanline drawing) */
+ union bits {
+     struct {
+         char bit3;
+         char bit2;
+         char bit1;
+         char bit0;
+     } b;
+     unsigned int i;
+ };
+ 
+ /* color decompositions */
+ static union bits color16[16] = { {0,0,0,0},
+ 			           {0,0,0,1},
+ 			      	   {0,0,1,0},
+ 			           {0,0,1,1},
+ 			           {0,1,0,0},
+ 			           {0,1,0,1},
+ 			           {0,1,1,0},
+ 			           {0,1,1,1},
+ 			           {1,0,0,0},
+ 			           {1,0,0,1},
+ 			           {1,0,1,0},
+ 			           {1,0,1,1},
+ 			           {1,1,0,0},
+ 			           {1,1,0,1},
+ 			           {1,1,1,0},
+ 			           {1,1,1,1} };
+ 
+ /* display plane buffers (for fast scanline drawing) */
+ static char plane0[256];
+ static char plane1[256];
+ static char plane2[256];
+ static char plane3[256];
+ 
+ 
+ static char text_regs[60];   /* VGA registers for saved text mode */   
+ 
+ /* saved text mode palette values */ 
+ static char saved_red[256];  
+ static char saved_green[256];  
+ static char saved_blue[256];  
+ 
+ static int         cur_mode = TEXT;   /* current video mode       */
+ static struct info cur_info;          /* current video parameters */
+ static int         cur_color;         /* current color            */
+ 
+ static int initialized = 0;   /* flag: initialize() called ? */
+ 
+ static int   mem_fd;     /* /dev/mem file descriptor		     */
+ static char* graph_mem;  /* dummy buffer for mmapping grahics memory */
+ static char* text_mem;   /* dummy buffer for mmapping text memory    */
+ 
+ static char text_buf[TEXT_SIZE];   /* saved text mode memory */  
+ static char font_buf1[FONT_SIZE];  /* saved font data - plane 2 */
+ static char font_buf2[FONT_SIZE];  /* saved font data - plane 3 */
+ static char null_buf[NULL_SIZE];   /* used to speed up clear */
+ 
+ static struct termios text_termio;  /* text mode termio parameters     */
+ static struct termios graph_termio; /* graphics mode termio parameters */
+ 
+ 
+ static void inline port_out(char value, unsigned short port)
+ {
+ __asm__ volatile ("outb %0,%1"
+ 		::"a" ((char) value),"d" ((unsigned short) port));
+ }
+ 
+ 
+ static unsigned char inline port_in(unsigned short port)
+ {
+ 	unsigned char _v;
+ __asm__ volatile ("inb %1,%0"
+ 		:"=a" (_v):"d" ((unsigned short) port));
+ 	return _v;
+ }
+ 
+ 
+ static void set_graphtermio()
+ {
+         /* flush all terminal streams (just to be sure) */
+ 	fflush(stdin);
+         fflush(stdout);
+ 	fflush(stderr);
+ 
+         /* save text mode termio parameters */
+         ioctl(0, TCGETS, &text_termio);
+ 
+         graph_termio = text_termio;
+ 
+         /* change termio parameters to allow our own I/O processing */
+         graph_termio.c_iflag &= ~(BRKINT|PARMRK|INPCK|IUCLC|IXON|IXOFF);
+         graph_termio.c_iflag |=  (IGNBRK|IGNPAR);
+ 
+         graph_termio.c_oflag &= ~(ONOCR);
+ 
+         graph_termio.c_lflag &= ~(ICANON|ECHO|ECHOE|ECHOK|ECHONL|NOFLSH);
+         graph_termio.c_lflag |=  (ISIG);
+ 
+         graph_termio.c_cc[VMIN] = 1;
+         graph_termio.c_cc[VTIME] = 0;
+         graph_termio.c_cc[VSUSP] = 0;
+ 
+         /* set graphics mode termio parameters */
+         ioctl(0, TCSETSW, &graph_termio);
+ }
+ 
+ 
+ static void set_texttermio()
+ {
+     /* restore text mode termio parameters */
+     ioctl(0, TCSETSW, &text_termio);
+ }
+ 
+ 
+ static void initialize()
+ {
+     int i, j;
+ 
+     /* get I/O permissions for VGA registers */
+     if (ioperm(CRT_IC, 1, 1)) {
+         printf("initialize: can't get I/O permissions \n");
+         exit (-1);
+     }
+     ioperm(CRT_IM,  1, 1);
+     ioperm(ATT_IW, 1, 1);
+     ioperm(GRA_I,  1, 1);
+     ioperm(SEQ_I,  1, 1);
+     ioperm(PEL_IW, 1, 1);
+     ioperm(PEL_IR, 1, 1);
+     ioperm(CRT_DC,  1, 1);
+     ioperm(CRT_DM,  1, 1);
+     ioperm(ATT_R,  1, 1);
+     ioperm(GRA_D,  1, 1);
+     ioperm(SEQ_D,  1, 1);
+     ioperm(MIS_R,  1, 1);
+     ioperm(MIS_W,  1, 1);
+     ioperm(IS1_RC,  1, 1);
+     ioperm(IS1_RM,  1, 1);
+     ioperm(PEL_D,  1, 1);
+ 
+     /* color or monochrome text emulation? */
+     color_text = port_in(MIS_R)&0x01;
+ 
+     /* chose registers for color/monochrome emulation */
+     if (color_text) {
+ 	TEXT_BASE = TEXT_BASEC;
+         CRT_I = CRT_IC;
+         CRT_D = CRT_DC;
+         IS1_R = IS1_RC;
+     } else {
+ 	TEXT_BASE = TEXT_BASEM;
+         CRT_I = CRT_IM;
+         CRT_D = CRT_DM;
+         IS1_R = IS1_RM;
+     }
+ 
+     /* open /dev/mem */
+     if ((mem_fd = open("/dev/mem", O_RDWR) ) < 0) {
+         printf("initialize: can't open /dev/mem \n");
+         exit (-1);
+     }
+ 
+     /* mmap graphics memory */
+     if ((graph_mem = malloc(GRAPH_SIZE + (PAGE_SIZE-1))) == NULL) {
+         printf("initialize: allocation error \n");
+         exit (-1);
+     }
+     if ((unsigned long)graph_mem % PAGE_SIZE)
+ 	graph_mem += PAGE_SIZE - ((unsigned long)graph_mem % PAGE_SIZE);
+     graph_mem = (unsigned char *)mmap(
+         (caddr_t)graph_mem, 
+         GRAPH_SIZE,
+ 	PROT_READ|PROT_WRITE,
+ 	MAP_SHARED|MAP_FIXED,
+ 	mem_fd, 
+         GRAPH_BASE
+     );
+     if ((long)graph_mem < 0) {
+         printf("initialize: mmap error \n");
+         exit (-1);
+     }
+ 
+     /* mmap text memory */
+     if ((text_mem = malloc(TEXT_SIZE + (PAGE_SIZE-1))) == NULL) {
+         printf("initialize: allocation error \n");
+         exit (-1);
+     }
+     if ((unsigned long)text_mem % PAGE_SIZE)
+ 	text_mem += PAGE_SIZE - ((unsigned long)text_mem % PAGE_SIZE);
+     text_mem = (unsigned char *)mmap(
+         (caddr_t)text_mem, 
+         TEXT_SIZE,
+ 	PROT_READ|PROT_WRITE,
+ 	MAP_SHARED|MAP_FIXED,
+ 	mem_fd, 
+         TEXT_BASE
+     );
+     if ((long)text_mem < 0) {
+         printf("initialize: mmap error \n");
+         exit (-1);
+     }
+ 
+     /* save text mode palette - first select palette index 0 */
+     port_out(0, PEL_IR); 
+ 
+     /* read RGB components - index is autoincremented */
+     for(i = 0; i < 256; i++) {
+         for(j = 0; j < 10; j++) ;   /* delay (minimum 240ns) */ 
+         saved_red[i] = port_in(PEL_D);
+     	for(j = 0; j < 10; j++) ;   /* delay (minimum 240ns) */ 
+         saved_green[i] = port_in(PEL_D);
+     	for(j = 0; j < 10; j++) ;   /* delay (minimum 240ns) */ 
+         saved_blue[i] = port_in(PEL_D);
+     }
+ 
+     /* initialize buffer used when clearing in 256 color modes */
+     for(i = 0; i < NULL_SIZE; i++)
+         null_buf[i] = 0;
+ 
+     initialized = 1;
+ }
+ 
+ 
+ static int set_regs(char regs[])
+ {
+     int i;
+ 
+     /* update misc output register */
+     port_out(regs[MIS], MIS_W); 	
+ 
+     /* synchronous reset on */
+     port_out(0x00,SEQ_I); 
+     port_out(0x01,SEQ_D); 		
+   
+     /* write sequencer registers */
+     for (i = 1; i < SEQ_C; i++) {	
+         port_out(i, SEQ_I); 
+         port_out(regs[SEQ+i], SEQ_D); 
+     }
+ 
+     /* synchronous reset off */
+     port_out(0x00, SEQ_I); 
+     port_out(0x03, SEQ_D);   		
+   
+     /* deprotect CRT registers 0-7 */
+     port_out(0x11, CRT_I); 		  
+     port_out(port_in(CRT_D)&0x7F, CRT_D);   
+   
+     /* write CRT registers */
+     for (i = 0; i < CRT_C; i++) { 	
+         port_out(i, CRT_I); 
+         port_out(regs[CRT+i], CRT_D); 
+     }
+ 
+     /* write graphics controller registers */
+     for (i = 0; i < GRA_C; i++) { 	
+         port_out(i, GRA_I); 
+         port_out(regs[GRA+i], GRA_D); 
+     }
+      
+     /* write attribute controller registers */
+     for (i = 0; i < ATT_C; i++) {       
+         port_in(IS1_R);   /* reset flip-flop */
+         port_out(i, ATT_IW);
+         port_out(regs[ATT+i],ATT_IW);
+     }
+ 
+     return 0;
+ }
+ 
+ 
+ int vga_setmode(int mode) 
+ {
+     int old_mode, i;
+ 
+     if (mode == cur_mode)
+         return 0; 
+     
+     old_mode = cur_mode;
+     cur_mode = mode;
+ 
+     if (!initialized)
+         initialize();
+ 
+     /* disable video */
+     port_in(IS1_R); 		
+     port_out(0x00, ATT_IW);	
+   
+     if (mode == TEXT) {    
+         /* restore font data - first select a 16 color graphics mode */
+         set_regs(g640x480x16_regs);
+ 
+ 	/* disable Set/Reset Register */
+     	port_out(0x01, GRA_I ); 
+     	port_out(0x00, GRA_D );   
+ 
+         /* restore font data in plane 2 - necessary for all VGA's */
+     	port_out(0x02, SEQ_I ); 
+     	port_out(0x04, SEQ_D );   
+ 	memcpy(graph_mem, font_buf1, FONT_SIZE);
+ 
+         /* restore font data in plane 3 - necessary for Trident VGA's */
+     	port_out(0x02, SEQ_I ); 
+     	port_out(0x08, SEQ_D );   
+ 	memcpy(graph_mem, font_buf2, FONT_SIZE);
+ 
+         /* change register adresses if monochrome text mode */
+         if (!color_text) {
+             CRT_I = CRT_IM;
+             CRT_D = CRT_DM;
+             IS1_R = IS1_RM;
+             port_out(port_in(MIS_R)&0xFE, MIS_W); 
+         }
+ 
+ 	/* restore text mode VGA registers */
+     	set_regs(text_regs);
+ 
+     	/* restore contents of text mode memory */
+         memcpy(text_mem, text_buf, TEXT_SIZE);
+ 
+         /* restore saved palette */
+         for(i = 0; i < 256; i++)
+             vga_setpalette(
+                 i, saved_red[i], saved_green[i], saved_blue[i]
+             );
+  
+         /* restore text mode termio */
+    	set_texttermio();
+     } else {
+         if (old_mode == TEXT) {
+             /* set graphics mode termio */
+ 	    set_graphtermio();
+ 
+ 	    /* save contents of text mode memory */
+             memcpy(text_buf, text_mem, TEXT_SIZE);
+ 
+    	    /* save text mode VGA registers */
+     	    for (i = 0; i < CRT_C; i++) {
+     	        port_out(i, CRT_I); 
+                 text_regs[CRT+i] = port_in(CRT_D); 
+             }
+     	    for (i = 0; i < ATT_C; i++) {
+         	port_in(IS1_R);
+         	port_out(i, ATT_IW); 
+         	text_regs[ATT+i] = port_in(ATT_R); 
+     	    }
+     	    for (i = 0; i < GRA_C; i++) {
+         	port_out(i, GRA_I); 
+         	text_regs[GRA+i] = port_in(GRA_D); 
+     	    }
+    	    for (i = 0; i < SEQ_C; i++) {
+         	port_out(i, SEQ_I); 
+         	text_regs[SEQ+i] = port_in(SEQ_D); 
+     	    }
+     	    text_regs[MIS] = port_in(MIS_R); 
+ 
+             /* shift to color emulation */
+             CRT_I = CRT_IC;
+             CRT_D = CRT_DC;
+             IS1_R = IS1_RC;
+             port_out(port_in(MIS_R)|0x01, MIS_W); 
+ 
+             /* save font data - first select a 16 color graphics mode */
+             set_regs(g640x480x16_regs);
+ 
+             /* save font data in plane 2 */
+             port_out(0x04, GRA_I); 
+             port_out(0x02, GRA_D); 
+             memcpy(font_buf1, graph_mem, FONT_SIZE);
+ 
+             /* save font data in plane 3 */
+             port_out(0x04, GRA_I); 
+             port_out(0x03, GRA_D); 
+             memcpy(font_buf2, graph_mem, FONT_SIZE);
+ 	}
+ 
+         switch (mode) {
+             case G320x200x16:
+                 set_regs(g320x200x16_regs);
+                 cur_info = g320x200x16_info;
+                 break;
+             case G640x200x16:
+                 set_regs(g640x200x16_regs);
+                 cur_info = g640x200x16_info;
+                 break;
+             case G640x350x16:
+                 set_regs(g640x350x16_regs);
+                 cur_info = g640x350x16_info;
+                 break;
+             case G640x480x16:
+                 set_regs(g640x480x16_regs);
+                 cur_info = g640x480x16_info;
+                 break;
+ 	    case G320x200x256:
+                 set_regs(g320x200x256_regs);
+                 cur_info = g320x200x256_info;
+                 break;
+ 	    case G320x240x256:
+                 set_regs(g320x240x256_regs);
+                 cur_info = g320x240x256_info;
+                 break;
+ 	    case G320x400x256:
+                 set_regs(g320x400x256_regs);
+                 cur_info = g320x400x256_info;
+                 break;
+ 	    case G360x480x256:
+                 set_regs(g360x480x256_regs);
+                 cur_info = g360x480x256_info;
+                 break;
+         }
+ 
+         /* set default palette */
+         for(i = 0; i < 256; i++)
+             vga_setpalette(
+                 i, default_red[i], default_green[i], default_blue[i]
+             );
+  
+         /* clear screen (sets current color to 15) */
+         clear();
+     }
+ 
+     /* enable video */
+     port_in(IS1_R); 
+     port_out(0x20, ATT_IW); 
+   
+     return 0;  
+ }
+ 
+ 
+ int clear()
+ {
+     int i;
+ 
+     vga_screenoff();
+ 
+     switch (cur_mode) {
+         case G320x200x16:
+         case G640x200x16:
+         case G640x350x16:
+         case G640x480x16:
+             vga_setcolor(0);
+ 
+ 	    /* write to all bits */
+     	    port_out(0x08, GRA_I ); 
+             port_out(0xFF, GRA_D );   
+ 
+     	    /* write dummy values to clear video memory */
+             memcpy(graph_mem          , text_buf, TEXT_SIZE);
+             memcpy(graph_mem+TEXT_SIZE, text_buf, TEXT_SIZE);
+ 
+             break;
+ 	case G320x200x256:
+ 	case G320x240x256:
+ 	case G320x400x256:
+ 	case G360x480x256:
+             /* write to all planes */ 
+             port_out(0x02, SEQ_I ); 
+             port_out(0x0F, SEQ_D );
+    
+     	    /* clear video memory */
+             for(i = 0; i < 16; i++)
+ 		memcpy(graph_mem + i*NULL_SIZE, null_buf, NULL_SIZE);
+ 
+             break;
+     }
+ 
+     vga_setcolor(15);
+         
+     vga_screenon();
+ 
+     return 0;
+ }
+ 
+ 
+ int vga_setcolor(int color)
+ {
+     switch (cur_mode) {
+         case G320x200x16:
+         case G640x200x16:
+         case G640x350x16:
+         case G640x480x16:
+             /* update set/reset register */
+ 	    port_out(0x00, GRA_I ); 
+ 	    port_out(color, GRA_D );   
+             break;
+ 	case G320x200x256:
+ 	case G320x240x256:
+ 	case G320x400x256:
+ 	case G360x480x256:
+ 	    cur_color = color;
+             break;
+     }
+         
+     return 0;
+ }
+ 
+ 
+ int vga_setpalette(int index, int red, int green, int blue)
+ {
+     int i;
+ 
+     /* select palette register */
+     port_out(index, PEL_IW); 
+ 
+     /* write RGB components */
+     for(i = 0; i < 10; i++) ;   /* delay (minimum 240ns) */ 
+     port_out(red, PEL_D);
+     for(i = 0; i < 10; i++) ;   /* delay (minimum 240ns) */ 
+     port_out(green, PEL_D);
+     for(i = 0; i < 10; i++) ;   /* delay (minimum 240ns) */ 
+     port_out(blue, PEL_D);
+ 
+     return 0;
+ }
+ 
+ 
+ int vga_drawpixel(int x, int y)
+ {
+     unsigned long offset;
+ 
+     switch (cur_mode) {
+         case G320x200x16:
+         case G640x200x16:
+         case G640x350x16:
+         case G640x480x16:
+ 	    /* select bit */
+ 	    port_out(8, GRA_I);
+ 	    port_out(0x80 >> (x & 7), GRA_D);   
+ 
+             /* read into latch and write dummy back */
+ 	    offset = y*cur_info.xbytes + (x>>3);   
+             graph_mem[offset] = graph_mem[offset];   
+             break;
+ 	case G320x200x256:
+             /* write color to pixel */
+ 	    graph_mem[y*320 + x] = cur_color;  
+             break;
+ 	case G320x240x256:
+ 	case G320x400x256:
+ 	case G360x480x256:
+ 	    /* select plane */ 
+ 	    port_out(0x02, SEQ_I); 
+     	    port_out(1 << (x & 3), SEQ_D);   
+ 
+             /* write color to pixel */
+ 	    graph_mem[y*cur_info.xbytes + (x>>2)] = cur_color;  
+             break;
+     }
+         
+     return 0;
+ }
+ 
+ 
+ int vga_drawscanline(int line, char* colors)
+ {
+     switch (cur_mode) {
+         case G320x200x16:
+         case G640x200x16:
+         case G640x350x16:
+         case G640x480x16:
+ 	    {
+        		int i, j, k, first, last;
+ 		union bits bytes;
+                 char* address;
+ 
+                 k = 0;
+                 for(i = 0; i < cur_info.xdim; i += 8) {
+                     bytes.i = 0;
+                     first = i;
+                     last  = i+8;
+                     for(j = first; j < last; j++)
+                        bytes.i = (bytes.i<<1) | color16[colors[j]].i;
+ 		    plane0[k]   = bytes.b.bit0;
+ 		    plane1[k]   = bytes.b.bit1;
+ 		    plane2[k]   = bytes.b.bit2;
+ 		    plane3[k++] = bytes.b.bit3;
+                 }
+ 
+                 address = graph_mem + line*cur_info.xbytes;
+ 
+ 		/* disable Set/Reset Register */
+ 	    	port_out(0x01, GRA_I ); 
+     		port_out(0x00, GRA_D ); 
+ 
+ 		/* write to all bits */
+ 	        port_out(0x08, GRA_I ); 
+     		port_out(0xFF, GRA_D );   
+ 
+ 		/* select map mask register */
+ 	    	port_out(0x02, SEQ_I ); 
+ 
+                 /* write plane 0 */
+     		port_out(0x01, SEQ_D ); 
+ 	        memcpy(address, plane0, cur_info.xbytes);
+ 
+                 /* write plane 1 */
+     		port_out(0x02, SEQ_D ); 
+ 	        memcpy(address, plane1, cur_info.xbytes);
+ 
+                 /* write plane 2 */
+     		port_out(0x04, SEQ_D ); 
+ 	        memcpy(address, plane2, cur_info.xbytes);
+ 
+                 /* write plane 3 */
+     		port_out(0x08, SEQ_D ); 
+ 	        memcpy(address, plane3, cur_info.xbytes);
+ 
+                 /* restore map mask register */
+     		port_out(0x0F, SEQ_D ); 
+   
+ 		/* enable Set/Reset Register */
+ 	    	port_out(0x01, GRA_I ); 
+     		port_out(0x0F, GRA_D );   
+             }
+             break;
+ 	case G320x200x256:
+             /* linear addressing - easy and fast */
+ 	    memcpy(graph_mem + line*cur_info.xbytes, colors, cur_info.xbytes);
+             break;
+ 	case G320x240x256:
+ 	case G320x400x256:
+ 	case G360x480x256: 
+             {
+                 int first, last, offset, pixel, plane;
+ 
+ 	        /* select map mask register */ 
+ 	        port_out(0x02, SEQ_I); 
+ 
+                 for(plane = 0; plane < 4; plane++) {
+                     /* select plane */
+     	            port_out(1 << plane, SEQ_D);   
+ 
+                     pixel = plane;
+                     first = cur_info.xbytes * line;
+                     last  = cur_info.xbytes * (line+1);
+                     for(offset = first; offset < last; offset++) {
+ 		        graph_mem[offset] = colors[pixel];  
+                         pixel += 4;
+                     }
+ 	        }
+             }
+             break;
+     }
+         
+     return 0;
+ }
+ 
+ 
+ int vga_drawline(int x1, int y1, int x2, int y2)
+ {
+     int dx = x2 - x1;
+     int dy = y2 - y1;
+     int ax = ABS(dx) << 1;
+     int ay = ABS(dy) << 1;
+     int sx = (dx >= 0) ? 1 : -1;
+     int sy = (dy >= 0) ? 1 : -1;
+  
+     int x  = x1;
+     int y  = y1;
+ 
+     if (ax == 0 && ay == 0)
+         vga_drawpixel(x1, y1);
+     else if (ax > ay) {
+         int d = ay - (ax >> 1);
+         while (x != x2) {
+ 	    vga_drawpixel(x, y);
+ 
+             if (d > 0 || d == 0 && sx == 1) {
+                 y += sy;
+                 d -= ax;
+             }
+             x += sx;
+             d += ay;
+         }
+     } else {
+         int d = ax - (ay >> 1);
+         while (y != y2) {
+ 	    vga_drawpixel(x, y);
+ 
+             if (d > 0 || d == 0 && sy == 1) {
+                 x += sx;
+                 d -= ay;
+             }
+             y += sy;
+             d += ax;
+         }
+     }
+      
+     return 0;
+ }
+ 
+ 
+ int vga_screenoff()
+ {
+     /* turn off screen for faster VGA memory acces */
+     port_out(0x01, SEQ_I); 		  
+     port_out(port_in(SEQ_D)|0x20, SEQ_D);   
+ }
+ 
+ 
+ int vga_screenon()
+ {
+     /* turn screen back on */
+     port_out(0x01, SEQ_I); 		  
+     port_out(port_in(SEQ_D)&0xDF, SEQ_D);   
+ }
+ 
+ 
+ int vga_getxdim()
+ {
+     return cur_info.xdim;
+ }
+ 
+ 
+ int vga_getydim()
+ {
+     return cur_info.ydim;
+ }
+ 
+ 
+ int vga_getcolors()
+ {
+     return cur_info.colors;
+ }
+ 
+ int vga_getch()
+ {
+     return getc(stdin);
+ }
+ 
diff +context +recursive +new-file gnuplot.orig//vgalinux.h gnuplot//vgalinux.h
*** gnuplot.orig//vgalinux.h
--- gnuplot//vgalinux.h	Sun May 24 10:25:56 1992
***************
*** 0 ****
--- 1,32 ----
+ #ifndef VGALINUX_H
+ #define VGALINUX_H
+ 
+ #define TEXT 	     0
+ #define G320x200x16  1
+ #define G640x200x16  2
+ #define G640x350x16  3
+ #define G640x480x16  4
+ #define G320x200x256 5
+ #define G320x240x256 6
+ #define G320x400x256 7
+ #define G360x480x256 8
+ 
+ int vga_setmode(int mode);
+ int vga_clear();
+ int vga_getxdim();
+ int vga_getydim();
+ int vga_getcolors();
+ 
+ int vga_screenoff();
+ int vga_screenon();
+ 
+ int vga_setcolor(int color);
+ int vga_setpalette(int index, int red, int green, int blue);
+ int vga_drawpixel(int x, int y);
+ int vga_drawline(int x1, int y1, int x2, int y2);
+ int vga_drawscanline(int line, char* colors);
+ 
+ int vga_getch();
+ 
+ #endif /* VGALINUX_H */
+ 

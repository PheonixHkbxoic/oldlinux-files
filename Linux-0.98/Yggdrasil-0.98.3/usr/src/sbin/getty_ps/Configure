#! /bin/sh
#
# If these # comments don't work, trim them.  Don't worry about any other
# shell scripts, Configure will trim # comments from them for you.
#
# (If you are trying to port this package to a machine without sh, I would
# suggest you cut out the prototypical config.h from the end of Configure
# and edit it to reflect your system.  Some packages may include samples
# of config.h for certain machines, so you might look for one of those.)
#
# $Id: Configure,v 2.0 90/09/19 19:23:44 paul Rel $
#
# Yes, you may rip this off to use in other distribution packages.
# (Note: this Configure script was generated automatically.  Rather than
# working with this copy of Configure, you may wish to get metaconfig.)
#
# $Log:	Configure,v $
# Revision 2.0  90/09/19  19:23:44  paul
# Initial 2.0 release
# 
#

: sanity checks
PATH=".:/bin:/usr/bin:/usr/local/bin:/usr/ucb:/usr/local:/usr/lbin:/etc:/usr/new:/usr/new/bin:/usr/nbin:$PATH"
export PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh $0; kill $$)

if test ! -t 0; then
    echo "Say 'sh Configure', not 'sh <Configure'"
    exit 1
fi

(alias) >/dev/null 2>&1 && \
    echo "(I see you are using the Korn shell.  Some ksh's blow up on Configure," && \
    echo "especially on exotic machines.  If yours does, try the Bourne shell instead.)"

if test ! -d ../UU; then
    if test ! -d UU; then
	mkdir UU
    fi
    cd UU
fi

case "$1" in
-d) shift; fastread='yes';;
esac

d_getutent=''
d_strdup=''
d_putenv=''
d_ttytype=''
ttytype=''
gettytab=''
utmp=''
wtmp=''
uucpid=''
lock=''
d_asciipid=''
mailer=''
hostname=''
phostname=''
d_douname=''
d_phostname=''
d_portable=''
termlib=''
llib_termlib=''
xenix=''
d_eunice=''
define=''
undef=''
eunicefix=''
loclist=''
expr=''
sed=''
echo=''
cat=''
rm=''
mv=''
cp=''
tr=''
sort=''
uniq=''
grep=''
trylist=''
test=''
egrep=''
Mcc=''
cpp=''
mail=''
mailx=''
sendmail=''
uname=''
uuname=''
Log=''
Id=''
bin=''
contains=''
cppstdin=''
cppminus=''
d_fcntl=''
d_index=''
d_ioctl=''
d_varargs=''
d_voidsig=''
gidtype=''
i_fcntl=''
i_pwd=''
i_sysioctl=''
i_time=''
i_systime=''
d_systimekernel=''
i_varargs=''
libc=''
models=''
split=''
small=''
medium=''
large=''
huge=''
optimize=''
ccflags=''
cppflags=''
ldflags=''
cc=''
libs=''
n=''
c=''
package=''
spitshell=''
shsharp=''
sharpbang=''
startsh=''
stdchar=''
uidtype=''
voidflags=''
defvoidused=''
lib=''
CONFIG=''
: set package name
package=getty

echo " "
echo "Beginning of configuration questions for $package kit."
: Eunice requires " " instead of "", can you believe it
echo " "

define='define'
undef='undef'
: change the next line if compiling for Xenix/286 on Xenix/386
xlibpth='/usr/lib/386 /lib/386'
libpth='/usr/lib /usr/local/lib /usr/lib/large /lib '$xlibpth' /lib/large /usr/lib/small /lib/small'
#  SMR - additions for linux's gcc:
libpth='/usr/lib/shared /usr/lib/static '$libpth
echo The lib path is $libpth
smallmach='pdp11 i8086 z8000 i80286 iAPX286'
rmlist='kit[1-9]isdone kit[1-9][0-9]isdone'
trap 'echo " "; rm -f $rmlist; exit 1' 1 2 3

: We must find out about Eunice early
eunicefix=':'
if test -f /etc/unixtovms; then
    eunicefix=/etc/unixtovms
fi
if test -f /etc/unixtovms.exe; then
    eunicefix=/etc/unixtovms.exe
fi

: Now test for existence of everything in MANIFEST

echo "First let's make sure your kit is complete.  Checking..."
(cd ..; cat `awk 'NR>4{print $1}' MANIFEST` >/dev/null || kill $$)
echo "Looks good..."

attrlist="mc68000 sun gcos unix ibm gimpel interdata tss os mert pyr"
attrlist="$attrlist vax pdp11 i8086 z8000 u3b2 u3b5 u3b20 u3b200"
attrlist="$attrlist hpux hp9000s300 hp9000s500 hp9000s800"
attrlist="$attrlist ns32000 ns16000 iAPX286 mc300 mc500 mc700 sparc"
attrlist="$attrlist nsc32000 sinix xenix venix posix ansi M_XENIX"
attrlist="$attrlist $mc68k __STDC__ UTS M_I8086 M_I186 M_I286 M_I386"
attrlist="$attrlist i186 __m88k__ m88k DGUX __DGUX__"
pth="/usr/ucb /bin /usr/bin /usr/local /usr/local/bin /usr/lbin /usr/plx /usr/5bin /vol/local/bin /etc /usr/lib /lib /usr/local/lib /sys5.3/bin /sys5.3/usr/bin /bsd4.3/bin /bsd4.3/usr/bin /bsd4.3/usr/ucb"
defvoidused=7
libswanted="x c_s"
inclwanted=''

: some greps do not return status, grrr.
echo "grimblepritz" >grimble
if grep blurfldyick grimble >/dev/null 2>&1 ; then
    contains=contains
elif grep grimblepritz grimble >/dev/null 2>&1 ; then
    contains=grep
else
    contains=contains
fi
rm -f grimble
: the following should work in any shell
case "$contains" in
contains*)
    echo " "
    echo "AGH!  Grep doesn't return a status.  Attempting remedial action."
    cat >contains <<'EOSS'
grep "$1" "$2" >.greptmp && cat .greptmp && test -s .greptmp
EOSS
chmod +x contains
esac

: see if sh knows # comments
echo " "
echo "Checking your sh to see if it knows about # comments..."
if sh -c '#' >/dev/null 2>&1 ; then
    echo "Your sh handles # comments correctly."
    shsharp=true
    spitshell=cat
    echo " "
    echo "Okay, let's see if #! works on this system..."
    echo "#!/bin/echo hi" > try
    $eunicefix try
    chmod +x try
    ./try > today
    if $contains hi today >/dev/null 2>&1; then
	echo "It does."
	sharpbang='#!'
    else
	echo "#! /bin/echo hi" > try
	$eunicefix try
	chmod +x try
	./try > today
	if test -s today; then
	    echo "It does."
	    sharpbang='#! '
	else
	    echo "It doesn't."
	    sharpbang=': use '
	fi
    fi
else
    echo "Your sh doesn't grok # comments--I will strip them later on."
    shsharp=false
    echo "exec grep -v '^#'" >spitshell
    chmod +x spitshell
    $eunicefix spitshell
    spitshell=`pwd`/spitshell
    echo "I presume that if # doesn't work, #! won't work either!"
    sharpbang=': use '
fi

: figure out how to guarantee sh startup
echo " "
echo "Checking out how to guarantee sh startup..."
startsh=$sharpbang'/bin/sh'
echo "Let's see if '$startsh' works..."
cat >try <<EOSS
$startsh
set abc
test "$?abc" != 1
EOSS

chmod +x try
$eunicefix try
if ./try; then
    echo "Yup, it does."
else
    echo "Nope.  You may have to fix up the shell scripts to make sure sh runs them."
fi
rm -f try today

: first determine how to suppress newline on echo command
echo "Checking echo to see how to suppress newlines..."
(echo "hi there\c" ; echo " ") >.echotmp
if $contains c .echotmp >/dev/null 2>&1 ; then
    echo "...using -n."
    n='-n'
    c=''
else
    cat <<'EOM'
...using \c
EOM
    n=''
    c='\c'
fi
echo $n "Type carriage return to continue.  Your cursor should be here-->$c"
read ans
rm -f .echotmp

: now set up to do reads with possible shell escape and default assignment
cat <<EOSC >myread
case "\$fastread" in
yes) ans=''; echo " " ;;
*) ans='!';;
esac
while expr "X\$ans" : "X!" >/dev/null; do
    read ans
    case "\$ans" in
    !)
	sh
	echo " "
	echo $n "\$rp $c"
	;;
    !*)
	set \`expr "X\$ans" : "X!\(.*\)\$"\`
	sh -c "\$*"
	echo " "
	echo $n "\$rp $c"
	;;
    esac
done
rp='Your answer:'
case "\$ans" in
'') ans="\$dflt";;
esac
EOSC

: general instructions
cat <<EOH
 
This installation shell script will examine your system and ask you questions
to determine how the $package package should be installed.  If you get stuck
on a question, you may use a ! shell escape to start a subshell or execute
a command.  Many of the questions will have default answers in square
brackets--typing carriage return will give you the default.

On some of the questions which ask for file or directory names you are
allowed to use the ~name construct to specify the login directory belonging
to "name", even if you don't have a shell which knows about that.  Questions
where this is allowed will be marked "(~name ok)".

EOH
rp="[Type carriage return to continue]"
echo $n "$rp $c"
. myread
cat <<EOH

Much effort has been expended to ensure that this shell script will run
on any Unix system.  If despite that it blows up on you, your best bet is
to edit Configure and run it again. Also, let me (paul@devon.lns.pa.us)
know how I blew it.  If you can't run Configure for some reason, you'll have
to generate a config.sh file by hand.

This installation script affects things in two ways: 1) it may do direct
variable substitutions on some of the files included in this kit, and
2) it builds a config.h file for inclusion in C programs.  You may edit
any of these files as the need arises after running this script.

If you make a mistake on a question, there is no easy way to back up to it
currently.  The easiest thing to do is to edit config.sh and rerun all the
SH files.  Configure will offer to let you do this before it runs the SH files.

EOH
rp="[Type carriage return to continue]"
echo $n "$rp $c"
. myread

: get old answers, if there is a config file out there
if test -f ../config.sh; then
    echo " "
    dflt=y
    rp="I see a config.sh file.  Did Configure make it on THIS system? [$dflt]"
    echo $n "$rp $c"
    . myread
    case "$ans" in
    n*) echo "OK, I'll ignore it.";;
    *)  echo "Fetching default answers from your old config.sh file..."
	tmp="$n"
	ans="$c"
        . ../config.sh
	n="$tmp"
	c="$ans"
	;;
    esac
fi

: find out where common programs are
echo " "
echo "Locating common programs..."
cat <<EOSC >loc
$startsh
case \$# in
0) exit 1;;
esac
thing=\$1
shift
dflt=\$1
shift
for dir in \$*; do
    case "\$thing" in
    .)
	if test -d \$dir/\$thing; then
	    echo \$dir
	    exit 0
	fi
	;;
    *)
	if test -f \$dir/\$thing; then
	    echo \$dir/\$thing
	    exit 0
	elif test -f \$dir/\$thing.exe; then
	    : on Eunice apparently
	    echo \$dir/\$thing
	    exit 0
	fi
	;;
    esac
done
echo \$dflt
exit 1
EOSC
chmod +x loc
$eunicefix loc
loclist="
cat
cp
echo
expr
grep
mv
rm
sed
sort
tr
uniq
"
trylist="
Mcc
cpp
egrep
mail
mailx
sendmail
test
"
for file in $loclist; do
    xxx=`loc $file $file $pth`
    eval $file=$xxx
    eval _$file=$xxx
    case "$xxx" in
    /*)
	echo $file is in $xxx.
	;;
    *)
	echo "I don't know where $file is.  I hope it's in everyone's PATH."
	;;
    esac
done
echo " "
echo "Don't worry if any of the following aren't found..."
ans=offhand
for file in $trylist; do
    xxx=`loc $file $file $pth`
    eval $file=$xxx
    eval _$file=$xxx
    case "$xxx" in
    /*)
	echo $file is in $xxx.
	;;
    *)
	echo "I don't see $file out there, $ans."
	ans=either
	;;
    esac
done
case "$egrep" in
egrep)
    echo "Substituting grep for egrep."
    egrep=$grep
    ;;
esac
case "$test" in
test)
    echo "Hopefully test is built into your sh."
    ;;
/bin/test)
    if sh -c "PATH= test true" >/dev/null 2>&1; then
	echo "Using the test built into your sh."
	test=test
    fi
    ;;
*)
    test=test
    ;;
esac
case "$echo" in
echo)
    echo "Hopefully echo is built into your sh."
    ;;
/bin/echo)
    echo " "
    echo "Checking compatibility between /bin/echo and builtin echo (if any)..."
    $echo $n "hi there$c" >foo1
    echo $n "hi there$c" >foo2
    if cmp foo1 foo2 >/dev/null 2>&1; then
	echo "They are compatible.  In fact, they may be identical."
    else
	case "$n" in
	'-n') n='' c='\c' ans='\c' ;;
	*) n='-n' c='' ans='-n' ;;
	esac
	cat <<FOO
They are not compatible!  You are probably running ksh on a non-USG system.
I'll have to use /bin/echo instead of the builtin, since Bourne shell doesn't
have echo built in and we may have to run some Bourne shell scripts.  That
means I'll have to use $ans to suppress newlines now.  Life is ridiculous.

FOO
	rp="Your cursor should be here-->"
	$echo $n "$rp$c"
	. myread
    fi
    $rm -f foo1 foo2
    ;;
*)
    : cross your fingers
    echo=echo
    ;;
esac
rmlist="$rmlist loc"

: set up shell script to do ~ expansion
cat >filexp <<EOSS
$startsh
: expand filename
case "\$1" in
 ~/*|~)
    echo \$1 | $sed "s|~|\${HOME-\$LOGDIR}|"
    ;;
 ~*)
    if $test -f /bin/csh; then
	/bin/csh -f -c "glob \$1"
	echo ""
    else
	name=\`$expr x\$1 : '..\([^/]*\)'\`
	dir=\`$sed -n -e "/^\${name}:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\).*"'\$'"/\1/" -e p -e q -e '}' </etc/passwd\`
	if $test ! -d "\$dir"; then
	    me=\`basename \$0\`
	    echo "\$me: can't locate home directory for: \$name" >&2
	    exit 1
	fi
	case "\$1" in
	*/*)
	    echo \$dir/\`$expr x\$1 : '..[^/]*/\(.*\)'\`
	    ;;
	*)
	    echo \$dir
	    ;;
	esac
    fi
    ;;
*)
    echo \$1
    ;;
esac
EOSS
chmod +x filexp
$eunicefix filexp

: determine where public executables go
case "$bin" in
'')
    dflt=`loc . /etc /bin /usr/local/bin /usr/lbin /usr/local /usr/bin`
    ;;
*)  dflt="$bin"
    ;;
esac
cont=true
while $test "$cont" ; do
    echo " "
    rp="Where do you want to put the public executables? (~name ok) [$dflt]"
    $echo $n "$rp $c"
    . myread
    bin="$ans"
    bin=`./filexp "$bin"`
    if test -d $bin; then
	cont=''
    else
	case "$fastread" in
	yes) dflt=y;;
	*) dflt=n;;
	esac
	rp="Directory $bin doesn't exist.  Use that name anyway? [$dflt]"
	$echo $n "$rp $c"
	. myread
	dflt=''
	case "$ans" in
	y*) cont='';;
	esac
    fi
done

: make some quick guesses about what we are up against
echo " "
$echo $n "Hmm...  $c"
cat /usr/include/signal.h /usr/include/sys/signal.h >foo
if test `echo abc | tr a-z A-Z` = Abc ; then
    echo "Looks kind of like a USG system, but we'll see..."
    echo exit 1 >bsd
    echo exit 0 >usg
    echo exit 1 >v7
elif $contains SIGTSTP foo >/dev/null 2>&1 ; then
    echo "Looks kind of like a BSD system, but we'll see..."
    echo exit 0 >bsd
    echo exit 1 >usg
    echo exit 1 >v7
else
    echo "Looks kind of like a version 7 system, but we'll see..."
    echo exit 1 >bsd
    echo exit 1 >usg
    echo exit 0 >v7
fi
case "$eunicefix" in
*unixtovms*)
    cat <<'EOI'
There is, however, a strange, musty smell in the air that reminds me of
something...hmm...yes...I've got it...there's a VMS nearby, or I'm a Blit.
EOI
    echo "exit 0" >eunice
    d_eunice="$define"
    ;;
*)
    echo " "
    echo "Congratulations.  You aren't running Eunice."
    d_eunice="$undef"
    echo "exit 1" >eunice
    ;;
esac
if test -f /xenix; then
    echo "Actually, this looks more like a XENIX system..."
    echo "exit 0" >xenix
    xenix="$define"
else
    echo " "
    echo "It's not Xenix..."
    echo "exit 1" >xenix
    xenix="$undef"
fi
chmod +x xenix
$eunicefix xenix
if test -f /venix; then
    echo "Actually, this looks more like a VENIX system..."
    echo "exit 0" >venix
else
    echo " "
    if xenix; then
	: null
    else
	echo "Nor is it Venix..."
    fi
    echo "exit 1" >venix
fi
chmod +x bsd usg v7 eunice venix
$eunicefix bsd usg v7 eunice venix
rm -rf foo
rmlist="$rmlist bsd usg v7 eunice venix xenix"

: Warnings
if v7; then
    cat <<'EOM'

NOTE: many V7 systems do not have a way to do a non-blocking read.  If you
don't have any of FIONREAD, O_NDELAY, or rdchk(), the $package package
may not work as well as it might.  It might not work at all.
EOM
fi

: see what memory models we can support
case "$models" in
'')
    : We may not use Cppsym or we get a circular dependency through cc.
    : But this should work regardless of which cc we eventually use.
    cat >pdp11.c <<'EOP'
main() {
#ifdef pdp11
    exit(0);
#else
    exit(1);
#endif
}
EOP
    cc -o pdp11 pdp11.c >/dev/null 2>&1
    if pdp11 2>/dev/null; then
	dflt='unsplit split'
    else
	ans=`loc . X /lib/small /lib/large /usr/lib/small /usr/lib/large /lib/medium /usr/lib/medium /lib/huge`
	case "$ans" in
	X) dflt='none';;
	*)  if $test -d /lib/small || $test -d /usr/lib/small; then
		dflt='small'
	    else
		dflt=''
	    fi
	    if $test -d /lib/medium || $test -d /usr/lib/medium; then
		dflt="$dflt medium"
	    fi
	    if $test -d /lib/large || $test -d /usr/lib/large; then
		dflt="$dflt large"
	    fi
	    if $test -d /lib/huge || $test -d /usr/lib/huge; then
		dflt="$dflt huge"
	    fi
	esac
    fi
    ;;
*)  dflt="$models" ;;
esac
$cat <<EOM
 
Some systems have different model sizes.  On most systems they are called
small, medium, large, and huge.  On the PDP11 they are called unsplit and
split.  If your system doesn't support different memory models, say "none".
If you wish to force everything to one memory model, say "none" here and
put the appropriate flags later when it asks you for other cc and ld flags.
Venix systems may wish to put "none" and let the compiler figure things out.
(In the following question multiple model names should be space separated.)

EOM
rp="Which models are supported? [$dflt]"
$echo $n "$rp $c"
. myread
models="$ans"

case "$models" in
none)
    small=''
    medium=''
    large=''
    huge=''
    unsplit=''
    split=''
    ;;
*split)
    case "$split" in
    '') dflt='-i';;
    *) dflt="$split";;
    esac
    rp="What flag indicates separate I and D space? [$dflt]"
    $echo $n "$rp $c"
    . myread
    case "$ans" in
    none) ans='';;
    esac
    split="$ans"
    unsplit=''
    ;;
*large*|*small*|*medium*|*huge*)
    case "$models" in
    *large*)
	case "$large" in
	'') dflt='-Ml';;
	*) dflt="$large";;
	esac
	rp="What flag indicates large model? [$dflt]"
	$echo $n "$rp $c"
	. myread
	case "$ans" in
	none) ans='';
	esac
	large="$ans"
	;;
    *) large='';;
    esac
    case "$models" in
    *huge*)
	case "$huge" in
	'') dflt='-Mh';;
	*) dflt="$huge";;
	esac
	rp="What flag indicates huge model? [$dflt]"
	$echo $n "$rp $c"
	. myread
	case "$ans" in
	none) ans='';
	esac
	huge="$ans"
	;;
    *) huge="$large";;
    esac
    case "$models" in
    *medium*)
	case "$medium" in
	'') dflt='-Mm';;
	*) dflt="$medium";;
	esac
	rp="What flag indicates medium model? [$dflt]"
	$echo $n "$rp $c"
	. myread
	case "$ans" in
	none) ans='';
	esac
	medium="$ans"
	;;
    *) medium="$large";;
    esac
    case "$models" in
    *small*)
	case "$small" in
	'') dflt='none';;
	*) dflt="$small";;
	esac
	rp="What flag indicates small model? [$dflt]"
	$echo $n "$rp $c"
	. myread
	case "$ans" in
	none) ans='';
	esac
	small="$ans"
	;;
    *) small='';;
    esac
    ;;
*)
    echo "Unrecognized memory models--you may have to edit Makefile.SH"
    ;;
esac

: see if we need a special compiler
echo " "
if usg; then
    case "$cc" in
    '') case "$Mcc" in
	/*) dflt='Mcc';;
	*) dflt='cc';;
	esac
	;;
    *)  dflt="$cc";;
    esac
    $cat <<'EOM'
  
On some systems the default C compiler will not resolve multiple global
references that happen to have the same name.  On some such systems the
"Mcc" command may be used to force these to be resolved.  On other systems
a "cc -M" command is required.  (Note that the -M flag on other systems
indicates a memory model to use!)  If you have the Gnu C compiler, you
might wish to use that instead.  What command will force resolution on
EOM
    $echo $n "this system? [$dflt] $c"
    rp="Command to resolve multiple refs? [$dflt]"
    . myread
    cc="$ans"
else
    case "$cc" in
    '') dflt=cc;;
    *) dflt="$cc";;
    esac
    rp="Use which C compiler? [$dflt]"
    $echo $n "$rp $c"
    . myread
    cc="$ans"
fi
case "$cc" in
gcc*) cpp=`loc gcc-cpp $cpp $pth`;;
esac

: determine optimize, if desired, or use for debug flag also
case "$optimize" in
' ') dflt="none"
     ;;
'') dflt="-O";
    ;;
*)  dflt="$optimize"
    ;;
esac
cat <<EOH

Some C compilers have problems with their optimizers, by default, $package
compiles with the -O flag to use the optimizer.  Alternately, you might
want to use the symbolic debugger, which uses the -g flag (on traditional
Unix systems).  Either flag can be specified here.  To use neither flag,
specify the word "none".
  
EOH
rp="What optimizer/debugger flag should be used? [$dflt]"
$echo $n "$rp $c"
. myread
optimize="$ans"
case "$optimize" in
'none') optimize=" "
     ;;
esac

case "$ccflags" in
'') case "$cc" in
    *gcc*) dflt='-fpcc-struct-return';;
    *) dflt='';;
    esac
    ;;
*) dflt="$ccflags";;
esac
for thisincl in $inclwanted; do
    if test -d $thisincl; then
	case "$dflt" in
	*$thisincl*);;
	*) dflt="$dflt -I$thisincl";;
	esac
    fi
done
case "$optimize" in
-g*)
    case "$dflt" in
    *DEBUGGING*);;
    *) dflt="$dflt -DDEBUGGING";;
    esac
    ;;
esac
if $contains 'LANGUAGE_C' /usr/include/signal.h >/dev/null 2>&1; then
    case "$dflt" in
    *LANGUAGE_C*);;
    *) dflt="$dflt -DLANGUAGE_C";;
    esac
fi
case "$dflt" in
'') dflt=none;;
esac
cat <<EOH

Your C compiler may want other flags.  For this question you should
include -I/whatever and -DWHATEVER flags and any other flags used by
the C compiler, but you should NOT include libraries or ld flags like
-lwhatever.  To use no flags, specify the word "none".
  
EOH
rp="Any additional cc flags? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
none) ans='';
esac
ccflags="$ans"

: the following weeds options from ccflags that are of no interest to cpp
cppflags="$ccflags"
case "$cc" in
*gcc*) cppflags="$cppflags -D__GNUC__";;
esac
case "$cppflags" in
'');;
*)  set X $cppflags
    cppflags=''
    for flag do
	case $flag in
	-D*|-I*) cppflags="$cppflags $flag";;
	esac
    done
    case "$cppflags" in
    *-*)  echo "(C preprocessor flags: $cppflags)";;
    esac
    ;;
esac

case "$ldflags" in
'') if venix; then
	dflt='-i -z'
    else
	dflt='none'
    fi
    ;;
*) dflt="$ldflags";;
esac
echo " "
rp="Any additional ld flags (NOT including libraries)? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
none) ans='';
esac
ldflags="$ans"
rmlist="$rmlist pdp11"

: where do we get termlib routines from
echo " "
ans=`loc libcurses.a x $libpth`
case "$ans" in
/*)
    ar t $ans >grimble
    if $contains tputs.o grimble >/dev/null 2>&1; then
	termlib='-lcurses'
	echo "Terminfo library found."
    else
	ans=x
    fi
    rm -f grimble
    ;;
esac
case "$ans" in
x)
    ans=`loc libtermlib.a x $libpth`
    case "$ans" in
    /usr/lib*|/lib*)
	termlib='-ltermlib'
	echo "Termlib library found."
	;;
    /*)
	termlib="$ans"
	echo "Termlib library found."
	;;
    *)
	ans=`loc libtermcap.a x $libpth`
	case "$ans" in
	/usr/lib*|/lib*)
	    termlib='-ltermcap'
	    echo "Termcap library found."
	    ;;
	/*)
	    termlib="$ans"
	    echo "Termcap library found."
	    ;;
	*)
	    case "$termlib" in
	    '')
		dflt=y
		rp="Your system appears to NOT have termlib-style routines.  Is this true? [$dflt]"
		$echo $n "$rp $c"
		. myread
		case "$ans" in
		    n*|f*)
			  echo "Then where are the termlib-style routines kept (specify either -llibname"
			  $echo $n " or full pathname (~name ok))? $c"
			  rp='Specify termlib:'
			  . myread
			  termlib=`filexp $ans`
			  ;;
		    *)    termlib=''
			  echo "You will have to play around with main.c then."
			  ;;
		esac
		echo " "
		;;
	    *)  echo "You said termlib was $termlib before."
		;;
	    esac
	    ;;
	esac
	;;
    esac
    ;;
esac
ans=`loc llib${termlib}.ln x $libpth`
case "$ans" in
/usr/lib*|/lib*)
    echo "Termlib lint library found."
    llib_termlib="$termlib"
    ;;
esac

echo " "
echo "Checking for optional libraries..."
dflt=''
case "$libswanted" in
'') libswanted='c_s';;
esac
for thislib in $libswanted; do
    case "$thislib" in
    dbm) thatlib=ndbm;;
    *_s) thatlib=NONE;;
    *) thatlib="${thislib}_s";;
    *) thatlib=NONE;;
    esac
    xxx=`loc lib$thislib.a X /usr/lib /usr/local/lib /lib`
    if test -f $xxx; then
	echo "Found -l$thislib."
	case "$dflt" in
	*-l$thislib*|*-l$thatlib*);;
	*) dflt="$dflt -l$thislib";;
	esac
    else
	xxx=`loc lib$thislib.a X $libpth`
	if test -f $xxx; then
	    echo "Found $xxx."
	    case "$dflt" in
	    *$xxx*);;
	    *) dflt="$dflt $xxx";;
	    esac
	else
	    xxx=`loc Slib$thislib.a X $xlibpth`
	    if test -f $xxx; then
		echo "Found -l$thislib."
		case "$dflt" in
		*-l$thislib*|*-l$thatlib*);;
		*) dflt="$dflt -l$thislib";;
		esac
	    else
		echo "No -l$thislib."
	    fi
	fi
    fi
done
set X $termlib $dflt
shift
dflt="$*"
case "$libs" in
'') dflt="$dflt";;
*) dflt="$libs";;
esac
case "$dflt" in
'') dflt='none';;
esac

$cat <<EOM
 
Some versions of Unix support shared libraries, which make
executables smaller but make load time slightly longer.

On some systems, mostly newer Unix System V's, the shared library
is included by putting the option "-lc_s" as the last thing on the
cc command line when linking.  Other systems use shared libraries
by default.  There may be other libraries needed to compile $package
on your machine as well.  If your system needs the "-lc_s" option,
include it here.  Include any other special libraries here as well.
Say "none" for none.
EOM

echo " "
rp="Any additional libraries? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
none) ans='';
esac
libs="$ans"

: see how we invoke the C preprocessor
echo " "
echo "Now, how can we feed standard input to your C preprocessor..."
cat <<'EOT' >testcpp.c
#define ABC abc
#define XYZ xyz
ABC.XYZ
EOT
echo 'Maybe "'"$cc"' -E" will work...'
$cc -E <testcpp.c >testcpp.out 2>&1
: try to force gcc preprocessor if that is the compiler they are using
case $? in
0) cppstdin="$cc -E";;
*) case "$cc" in
    *gcc*)
	cd ..
	echo 'Trying (cat >/tmp/$$.c; '"$cc"' -E /tmp/$$.c; rm /tmp/$$.c)'
	echo 'cat >/tmp/$$.c; '"$cc"' -E /tmp/$$.c; rm /tmp/$$.c' >cppstdin
	chmod 755 cppstdin
	cppstdin=`pwd`/cppstdin
	cppminus='';
	cd UU
	$cppstdin <testcpp.c >testcpp.out 2>&1
	;;
    esac
    ;;
esac
if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
    echo "Yup, it does."
    cppstdin="$cc -E"
    cppminus='';
else
    echo 'Nope, maybe "'$cpp'" will work...'
    $cpp <testcpp.c >testcpp.out 2>&1
    if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, it does."
	cppstdin="$cpp"
	cppminus='';
    else
	echo 'No such luck...maybe "'$cpp' -" will work...'
	$cpp - <testcpp.c >testcpp.out 2>&1
	if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	    echo "It works!"
	    cppstdin="$cpp"
	    cppminus='-';
	else
	    echo 'Nixed again...maybe "'"$cc"' -E -" will work...'
	    $cc -E - <testcpp.c >testcpp.out 2>&1
	    if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
		echo "Hooray, it works!  I was beginning to wonder."
		cppstdin="$cc -E"
		cppminus='-';
	    else
		echo 'Nope...maybe "'"$cc"' -P" will work...'
		$cc -P <testcpp.c >testcpp.out 2>&1
		if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
		    echo "Yup, that does."
		    cppstdin="$cc -P"
		    cppminus='';
		else
		    echo 'Nope...maybe "'"$cc"' -P -" will work...'
		    $cc -P - <testcpp.c >testcpp.out 2>&1
		    if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
			echo "Yup, that does."
			cppstdin="$cc -P"
			cppminus='-';
		    else
			echo 'Hmm...perhaps you already told me...'
			case "$cppstdin" in
			'') ;;
			*) $cppstdin $cppminus <testcpp.c >testcpp.out 2>&1;;
			esac
			if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
			    echo "Hooray, you did!  I was beginning to wonder."
			else
			    echo 'Uh-uh.  Time to get fancy...'
			    cd ..
			    echo 'Trying (cat >/tmp/$$.c; '"$cc"' -E /tmp/$$.c; rm /tmp/$$.c)'
			    echo 'cat >/tmp/$$.c; '"$cc"' -E /tmp/$$.c; rm /tmp/$$.c' >cppstdin
			    chmod 755 cppstdin
			    cppstdin=`pwd`/cppstdin
			    cppminus='';
			    cd UU
			    $cppstdin <testcpp.c >testcpp.out 2>&1
			    if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
				echo "Eureka!."
			    else
				dflt=blurfl
				$echo $n "No dice.  I can't find a C preprocessor.  Name one: $c"
				rp='Name a C preprocessor:'
				. myread
				cppstdin="$ans"
				$cppstdin <testcpp.c >testcpp.out 2>&1
				if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
				    echo "OK, that will do."
				else
				    echo "Sorry, I can't get that to work.  Go find one."
				    exit 1
				fi
			    fi
			fi
		    fi
		fi
	    fi
	fi
    fi
fi
rm -f testcpp.c testcpp.out

: get list of predefined functions in a handy place
echo " "
case "$libc" in
'') libc=unknown;;
esac
case "$libpth" in
'') libpth='/lib /usr/lib /usr/local/lib';;
esac
case "$libs" in
*-lc_s*) libc=`loc libc_s.a $libc $libpth`
esac
libnames='';
case "$libs" in
'') ;;
*)  for thislib in $libs; do
	case "$thislib" in
	-l*) thislib=`expr X$thislib : 'X-l\(.*\)'`
	    try=`loc lib$thislib.a blurfl/dyick $libpth`
	    if test ! -f $try; then
		try=`loc lib$thislib blurfl/dyick $libpth`
		if test ! -f $try; then
		    try=`loc $thislib blurfl/dyick $libpth`
		    if test ! -f $try; then
			try=`loc Slib$thislib.a blurfl/dyick $xlibpth`
			if test ! -f $try; then
			    try=''
			fi
		    fi
		fi
	    fi
	    libnames="$libnames $try"
	    ;;
	*) libnames="$libnames $thislib" ;;
	esac
    done
    ;;
esac
set /usr/lib/libc.so.[0-9]*
eval set \$$#
if test -f "$1"; then
    echo "Your shared C library is in $1."
    libc="$1"
elif test -f $libc; then
    echo "Your C library is in $libc, like you said before."
elif test -f /lib/libc.a; then
    echo "Your C library is in /lib/libc.a.  You're normal."
    libc=/lib/libc.a
else
    ans=`loc libc.a blurfl/dyick $libpth`
    if test ! -f "$ans"; then
	ans=`loc libc blurfl/dyick $libpth`
    fi
    if test ! -f "$ans"; then
	ans=`loc clib blurfl/dyick $libpth`
    fi
    if test ! -f "$ans"; then
	ans=`loc Slibc.a blurfl/dyick $xlibpth`
    fi
    if test ! -f "$ans"; then
	ans=`loc Mlibc.a blurfl/dyick $xlibpth`
    fi
    if test ! -f "$ans"; then
	ans=`loc Llibc.a blurfl/dyick $xlibpth`
    fi
    if test -f "$ans"; then
	echo "Your C library is in $ans, of all places."
	libc=$ans
    else
	cat <<EOM
 
I can't seem to find your C library.  I've looked in the following places:

	$libpth

None of these seems to contain your C library.  What is the full name
EOM
	dflt=None
	$echo $n "of your C library? $c"
	rp='C library full name?'
	. myread
	libc="$ans"
    fi
fi
echo " "
set `echo $libc $libnames | tr ' ' '\012' | sort | uniq`
$echo $n "Extracting names from $* for later perusal...$c"
nm $* 2>/dev/null >libc.tmp
$sed -n -e 's/^.* [AT]  *_[_.]*//p' -e 's/^.* [AT] //p' <libc.tmp >libc.list
if $contains '^printf$' libc.list >/dev/null 2>&1; then
    echo "done"
else
    $sed -n -e 's/^__*//' -e 's/^\([a-zA-Z_0-9$]*\).*xtern.*/\1/p' <libc.tmp >libc.list
    $contains '^printf$' libc.list >/dev/null 2>&1 || \
	$sed -n -e '/|UNDEF/d' -e '/FUNC..GL/s/^.*|__*//p' <libc.tmp >libc.list
    $contains '^printf$' libc.list >/dev/null 2>&1 || \
	$sed -n -e 's/^.* D __*//p' -e 's/^.* D //p' <libc.tmp >libc.list
    $contains '^printf$' libc.list >/dev/null 2>&1 || \
       $sed -n -e 's/^_//' \
	      -e 's/^\([a-zA-Z_0-9]*\).*xtern.*text.*/\1/p' <libc.tmp >libc.list
    $contains '^printf$' libc.list >/dev/null 2>&1 || \
	$sed -n -e 's/^.*|FUNC |GLOB .*|//p' <libc.tmp >libc.list
    if $contains '^printf$' libc.list >/dev/null 2>&1; then
	echo "done"
    else
	echo " "
	echo "nm didn't seem to work right."
	echo "Trying ar instead..."
	if ar t $libc > libc.tmp; then
	    for thisname in $libnames; do
		ar t $thisname >>libc.tmp
	    done
	    $sed -e 's/\.o$//' < libc.tmp > libc.list
	    echo "Ok."
	else
	    echo "ar didn't seem to work right."
	    echo "Maybe this is a Cray...trying bld instead..."
	    if bld t $libc | $sed -e 's/.*\///' -e 's/\.o:.*$//' > libc.list; then
		for thisname in $libnames; do
		    bld t $libnames | \
			$sed -e 's/.*\///' -e 's/\.o:.*$//' >>libc.list
		    ar t $thisname >>libc.tmp
		done
		echo "Ok."
	    else
	    	echo "That didn't work either.  Giving up."
	    	exit 1
	    fi
	fi
    fi
fi
rmlist="$rmlist libc.tmp libc.list"

: see if this is an fcntl system
echo " "
if $test -r /usr/include/fcntl.h ; then
    d_fcntl="$define"
    i_fcntl="$define"
    echo "fcntl.h found."
else
    d_fcntl="$undef"
    i_fcntl="$undef"
    echo "No fcntl.h found, but that's ok."
fi

: index or strcpy
echo " "
case "$d_index" in
n) dflt=n;;
*) dflt=y;;
esac
if $contains '^index$' libc.list >/dev/null 2>&1 ; then
    if $contains '^strchr$' libc.list >/dev/null 2>&1 ; then
	echo "Your system has both index() and strchr().  Shall I use"
	rp="index() rather than strchr()? [$dflt]"
	$echo $n "$rp $c"
	. myread
	case "$ans" in
	    n*) d_index="$define" ;;
	    *)  d_index="$undef" ;;
	esac
    else
	d_index="$undef"
	echo "index() found."
    fi
else
    if $contains '^strchr$' libc.list >/dev/null 2>&1 ; then
	d_index="$define"
	echo "strchr() found."
    else
	d_index="$undef"
	echo "No index() or strchr() found!"
    fi
fi

: see if ioctl defs are in termio or sys/ioctl
echo " "
if $test -r /usr/include/sys/ioctl.h ; then
    d_ioctl="$define"
    i_sysioctl="$define"
    echo "sys/ioctl.h found."
else
    d_ioctl="$undef"
    i_sysioctl="$undef"
    echo "sys/ioctl.h not found, assuming ioctl args are defined in termio.h."
fi

: see if this is a pwd system
echo " "
if $test -r /usr/include/pwd.h ; then
    i_pwd="$define"
    echo "pwd.h found."
else
    i_pwd="$undef"
    echo "No pwd.h found."
fi

: see if we should include time.h, sys/time.h, or both
cat <<'EOM'
  
Testing to see if we should include <time.h>, <sys/time.h> or both.
I'm now running the test program...
EOM
$cat >try.c <<'EOCP'
#ifdef I_TIME
#include <time.h>
#endif
#ifdef I_SYSTIME
#ifdef SYSTIMEKERNEL
#define KERNEL
#endif
#include <sys/time.h>
#endif
main()
{
    struct tm foo;
#ifdef S_TIMEVAL
    struct timeval bar;
#endif
    if (foo.tm_sec == foo.tm_sec)
	exit(0);
#ifdef S_TIMEVAL
    if (bar.tv_sec == bar.tv_sec)
	exit(0);
#endif
    exit(1);
}
EOCP
flags=''
for s_timeval in '-DS_TIMEVAL' ''; do
    for d_systimekernel in '' '-DSYSTIMEKERNEL'; do
	for i_time in '' '-DI_TIME'; do
	    for i_systime in '-DI_SYSTIME' ''; do
		case "$flags" in
		'') echo Trying $i_time $i_systime $d_systimekernel $s_timeval
		    if $cc $ccflags \
			    $i_time $i_systime $d_systimekernel $s_timeval \
			    try.c -o try >/dev/null 2>&1 ; then
			set X $i_time $i_systime $d_systimekernel $s_timeval
			shift
			flags="$*"
			echo Succeeded with $flags
		    fi
		    ;;
		esac
	    done
	done
    done
done
case "$flags" in
*SYSTIMEKERNEL*) d_systimekernel="$define";;
*) d_systimekernel="$undef";;
esac
case "$flags" in
*I_TIME*) i_time="$define";;
*) i_time="$undef";;
esac
case "$flags" in
*I_SYSTIME*) i_systime="$define";;
*) i_systime="$undef";;
esac
$rm -f try.c try

: see if this is a varargs system
echo " "
if $test -r /usr/include/varargs.h ; then
    d_varargs="$define"
    echo "varargs.h found."
else
    d_varargs="$undef"
    echo "No varargs.h found, but that's ok (I hope)."
fi

: see if signal is declared as pointer to function returning int or void
echo " "
$cppstdin $cppflags < /usr/include/signal.h >$$.tmp
if $contains 'void.*signal' $$.tmp >/dev/null 2>&1 ; then
    echo "You have void (*signal())() instead of int."
    d_voidsig="$define"
else
    echo "You have int (*signal())() instead of void."
    d_voidsig="$undef"
fi
rm -f $$.tmp

: check for void type
echo " "
$cat <<EOM
Checking to see how well your C compiler groks the void type...

  Support flag bits are:
    1: basic void declarations.
    2: arrays of pointers to functions returning void.
    4: operations between pointers to and addresses of void functions.

EOM
case "$voidflags" in
'')
    $cat >try.c <<'EOCP'
#if TRY & 1
void main() {
#else
main() {
#endif
	extern void moo();	/* function returning void */
	void (*goo)();		/* ptr to func returning void */
#if TRY & 2
	void (*foo[10])();
#endif

#if TRY & 4
	if(goo == moo) {
		exit(0);
	}
#endif
	exit(0);
}
EOCP
    if $cc $ccflags -c -DTRY=$defvoidused try.c >.out 2>&1 ; then
	voidflags=$defvoidused
	echo "It appears to support void."
	if $contains warning .out >/dev/null 2>&1; then
	    echo "However, you might get some warnings that look like this:"
	    $cat .out
	fi
    else
	echo "Hmm, your compiler has some difficulty with void.  Checking further..."
	if $cc $ccflags -c -DTRY=1 try.c >/dev/null 2>&1 ; then
	    echo "It supports 1..."
	    if $cc $ccflags -c -DTRY=3 try.c >/dev/null 2>&1 ; then
		voidflags=3
		echo "And it supports 2 but not 4."
	    else
		echo "It doesn't support 2..."
		if $cc $ccflags -c -DTRY=5 try.c >/dev/null 2>&1 ; then
		    voidflags=5
		    echo "But it supports 4."
		else
		    voidflags=1
		    echo "And it doesn't support 4."
		fi
	    fi
	else
	    echo "There is no support at all for void."
	    voidflags=0
	fi
    fi
esac
dflt="$voidflags";
rp="Your void support flags add up to what? [$dflt]"
$echo $n "$rp $c"
. myread
voidflags="$ans"
$rm -f try.* .out

: see what type uids are declared as in the kernel
case "$uidtype" in
'')
    if $contains 'uid_t;' /usr/include/sys/types.h >/dev/null 2>&1 ; then
	dflt='uid_t'
    else
	set `grep 'u_uid;' /usr/include/sys/user.h 2>/dev/null` unsigned short
	case $1 in
	unsigned) dflt="$1 $2" ;;
	*) dflt="$1" ;;
	esac
    fi
    ;;
*)  dflt="$uidtype"
    ;;
esac
cont=true
echo " "
rp="What type are user ids returned by getuid(), etc.? [$dflt]"
$echo $n "$rp $c"
. myread
uidtype="$ans"

: see what type gids are declared as in the kernel
case "$gidtype" in
'')
    if $contains 'gid_t;' /usr/include/sys/types.h >/dev/null 2>&1 ; then
	dflt='gid_t'
    else
	set `grep 'u_gid;' /usr/include/sys/user.h 2>/dev/null` unsigned short
	case $1 in
	unsigned) dflt="$1 $2" ;;
	*) dflt="$1" ;;
	esac
    fi
    ;;
*)  dflt="$gidtype"
    ;;
esac
cont=true
echo " "
rp="What type are group ids returned by getgid(), etc.? [$dflt]"
$echo $n "$rp $c"
. myread
gidtype="$ans"

: see if this is a varargs system
echo " "
if $test -r /usr/include/varargs.h ; then
    i_varargs="$define"
    echo "varargs.h found."
else
    i_varargs="$undef"
    echo "No varargs.h found, but that's ok (I hope)."
fi

: see what type of char stdio uses.
echo " "
if $contains 'unsigned.*char.*_ptr.*;' /usr/include/stdio.h >/dev/null 2>&1 ; then
    echo "Your stdio uses unsigned chars."
    stdchar="unsigned char"
else
    echo "Your stdio uses signed chars."
    stdchar="char"
fi

: see if there is the getut family
echo " "
if $contains '^getut' libc.list >/dev/null 2>&1 ; then
    echo "getutent() found."
    d_getutent="$define"
else
    echo "No getutent() found--will use my own."
    d_getutent="$undef"
fi

: see if there is a strdup
if $contains '^strdup$' libc.list >/dev/null 2>&1 ; then
    echo "strdup() found."
    d_strdup="$define"
else
    echo "No strdup() found--will use my own."
    d_strdup="$undef"
fi

: see if there is a putenv
if $contains '^putenv$' libc.list >/dev/null 2>&1 ; then
    echo "putenv() found."
    d_putenv="$define"
else
    echo "No putenv() found--will use my own."
    d_putenv="$undef"
fi

: now get the host name
echo " "
echo "Figuring out host name..."
echo 'Maybe "hostname" will work...'
if ans=`sh -c hostname 2>&1` ; then
    hostname=$ans
    phostname=hostname
else
    echo 'Oh, dear.  Maybe "/etc/systemid" is the key...'
    if ans=`cat /etc/systemid 2>&1` ; then
	hostname=$ans
	phostname='cat /etc/systemid'
	if xenix; then
	    echo "Whadyaknow.  Xenix always was a bit strange..."
	else
	    echo "What is a non-Xenix system doing with /etc/systemid?"
	fi
    else
	echo 'No, maybe "uuname -l" will work...'
	if ans=`sh -c 'uuname -l' 2>&1` ; then
	    hostname=$ans
	    phostname='uuname -l'
	else
	    echo 'Strange.  Maybe "uname -n" will work...'
	    if ans=`sh -c 'uname -n' 2>&1` ; then
		hostname=$ans
		phostname='uname -n'
	    else
		echo 'Oh well, maybe I can mine it out of whoami.h...'
		if ans=`sh -c $contains' sysname /usr/include/whoami.h' 2>&1` ; then
		    hostname=`echo "$ans" | $sed 's/^.*"\(.*\)"/\1/'`
		    phostname="sed -n -e '"'/sysname/s/^.*\"\\(.*\\)\"/\1/{'"' -e p -e q -e '}' </usr/include/whoami.h"
		else
		    case "$hostname" in
		    '') echo "Does this machine have an identity crisis or something?"
			phostname=''
			;;
		    *)  echo "Well, you said $hostname before...";;
		    esac
		fi
	    fi
	fi
    fi
fi
: you do not want to know about this
set $hostname
hostname=$1

: translate upper to lower if necessary
case "$hostname" in
    *[A-Z]*)
	hostname=`echo $hostname | $tr '[A-Z]' '[a-z]'`
	echo "(Normalizing case in your host name)"
	;;
esac

: verify guess
if $test "$hostname" ; then
    dflt=y
    echo 'Your host name appears to be "'$hostname'".'
    $echo $n "Is this correct? [$dflt] $c"
    rp="Sitename is $hostname? [$dflt]"
    . myread
    case "$ans" in
      y*)  ;;
      *)      hostname='' ;;
    esac
fi

: bad guess or no guess
while $test "X$hostname" = X ; do
    dflt=''
    rp="Please type the (one word) name of your host:"
    $echo $n "$rp $c"
    . myread
    hostname="$ans"
done

: a little sanity check here
case "$phostname" in
'') ;;
*)  case `$phostname` in
    $hostname) ;;
    *)
	case "$phostname" in
	sed*)
	    echo "(That doesn't agree with your whoami.h file, by the way.)"
	    ;;
	*)
	    echo "(That doesn't agree with your $phostname command, by the way.)"
	    ;;
	esac
	phostname=''
	;;
    esac
    ;;
esac

: see how we will look up host name
d_douname="$undef"
d_phostname="$undef"

# if xenix; then
#     echo " "
#     echo "(Assuming Xenix uname() is broken.)"
# el
if $contains '^uname$' libc.list >/dev/null 2>&1 ; then
    echo "uname() found."
    d_douname="$define"
    ans=uname
fi

case "$d_douname" in
*define*)
    dflt=n
    cat <<EOM
 
Every now and then someone has a $ans() that lies about the hostname
but can't be fixed for political or economic reasons.  Would you like to
EOM
    rp="pretend $ans() isn't there and maybe compile in the hostname? [$dflt]"
    $echo $n "$rp $c"
    . myread
    case "$ans" in
    y*) d_douname="$undef"
	$echo $n "Okay... $c"
	;;
    esac
    ;;
esac

case "$d_douname" in
*define*) ;;
*)
    case "$phostname" in
      '') ;;
      *)
	$cat <<EOT
 
There is no uname() on this system.  You have two possibilities at this point:

1)  You can have your host name ($hostname) compiled into $package, which
    lets $package start up faster, but makes your binaries non-portable, or
2)  you can have $package use a
	
	popen("$phostname","r")

    which will start slower but be more portable.

Option 1 will give you the option of using whoami.h if you have one.  If you
want option 2 but with a different command, you can edit config.sh at the
end of this shell script.

EOT
	case "$d_phostname" in
	"$define") dflt=n;;
	"$undef")  dflt=y;;
	'')
	    case "$d_portable" in
	    "$define") dflt=n ;;
	    *)      dflt=y ;;
	    esac
	    ;;
	esac
	rp="Do you want your host name compiled in? [$dflt]"
	$echo $n "$rp $c"
	. myread
	case "$ans" in
	  n*) d_phostname="$define" ;;
	  *)  phostname=''
	      d_phostname="$undef"
	      ;;
	esac
	;;
    esac
    case "$phostname" in
      '')
	case "$d_whoami" in
	  "$define")
	    dflt=y
	    $cat <<EOM
 
No hostname function--you can either use the whoami.h file, which has this line:

	`grep sysname /usr/include/whoami.h`

or you can have the name we came up with earlier ($hostname) hardwired in.
EOM
	    rp="Use whoami.h to get hostname? [$dflt]"
	    $echo $n "$rp $c"
	    . myread
	    case "$ans" in
	    n*) d_whoami="$undef";;
	    esac
	    ;;
	  "$undef")
	    echo 'No hostname function and no whoami.h--hardwiring "'$hostname'".'
	    ;;
	esac
	;;
    esac
    ;;
esac

: see if there is a ttytype file
echo " "
if ttytype=`loc ttytype x /etc`; then
    echo "Found $ttytype."
    d_ttytype="$define"
else
    d_ttytype="$undef"
fi

: see if there is a gettydefs file
if gettytab=`loc gettydefs x /etc`; then
    echo "Found $gettytab."
else
    dflt=/etc/gettydefs
    echo " "
    $echo "No /etc/gettydefs found.  I'll let you create your own."
    $echo $n "What do you want to call your gettytab file? [$dflt] $c"
    rp='Specify gettytab:'
    . myread
    gettytab=$ans
    echo " "
fi

: find the utmp file
if utmp=`loc utmp utmp /etc /usr/adm`; then
    echo "Found $utmp."
else
    dflt=/etc/utmp
    echo " "
    $echo $n "Where is your utmp file? [$dflt] $c"
    rp="Utmp filename? [$dflt]"
    . myread
    utmp="$ans"
    echo " "
fi

: find the wtmp file
if wtmp=`loc wtmp wtmp /etc /usr/adm`; then
    echo "Found $wtmp."
else
    dflt=/etc/wtmp
    echo " "
    $echo $n "Where is your wtmp file? [$dflt] $c"
    rp="Wtmp filename? [$dflt]"
    . myread
    wtmp="$ans"
    echo " "
fi

: decide how portable to be
case "$d_portable" in
"$define") dflt=y;;
*)	dflt=n;;
esac
$cat <<EOH
 
I can set things up so that your $package binaries are more portable,
at what may be a noticable cost in performance.  In particular, if you
ask to be portable, the system name will be determined at run time,
if at all possible.

EOH
rp="Do you expect to run the $package binaries on multiple machines? [$dflt]"
$echo $n "$rp $c"
. myread
case "$ans" in
    y*) d_portable="$define" ;;
    *)  d_portable="$undef" ;;
esac

: determine uucp id
echo " "
uucpid=`$sed -e "/uucp:/{s/^[^:]*:[^:]*:\([^:]*\).*"'$'"/\1/" -e "q" -e "}" -e "d" </etc/passwd`
case "$uucpid" in
  '') uucpid=0 ;;
  *)  echo "uucp uid = $uucpid" ;;
esac

: determine uucp lock files scheme
case "$lock" in
'')
    if $test -d /usr/spool/locks; then
	dflt=/usr/spool/locks
    else
	dflt=/usr/spool/uucp
    fi
    ;;
*)  dflt="$lock";;
esac
cont=true
while $test "$cont" ; do
    echo " "
    $echo $n "Directory where UUCP lock files live: [$dflt] $c"
    rp="Directory for UUCP lock files: [$dflt]"
    . myread
    lock="$ans"
    if test -d $ans; then
	cont=''
    else
	dflt=n
	rp="Directory $ans doesn't exist.  Use that name anyway? [$dflt]"
	$echo $n "$rp $c"
	. myread
	dflt=''
	case "$ans" in
	y*) cont='';;
	esac
    fi
done

echo " "
case "$d_asciipid" in
"$define") dflt=y;;
*)	dflt=n;;
esac
echo "The PID of the locking process is kept in the lock file."
$echo $n "Does your UUCP store the PID in ASCII format? [$dflt] $c"
rp="PID stored in ASCII? [$dflt]"
. myread
case "$ans" in
y*) d_asciipid="$define";;
*) d_asciipid="$undef";;
esac

: determine mailer to use
case "$mailer" in
'')
    if $test -f $sendmail; then
	dflt=$sendmail
    elif Cppsym M_XENIX; then
	dflt=/usr/lib/mail/execmail
    elif $test -f $mailx; then
	dflt="$mailx"
    else
	dflt=$mail
    fi
    ;;
*)  dflt="$mailer";;
esac
cont=true
while $test "$cont" ; do
    echo " "
    echo "Give the full path name of the program used to deliver mail on your"
    $echo $n "system: [$dflt] $c"
    rp="Preferred mailer: [$dflt]"
    . myread
    mailer="$ans"
    if test -f $ans; then
	cont=''
    else
	dflt=n
	rp="File $ans doesn't exist.  Use that name anyway? [$dflt]"
	$echo $n "$rp $c"
	. myread
	dflt=''
	case "$ans" in
	y*) cont='';;
	esac
    fi
done

: preserve RCS keywords in files with variable substitution, grrr
Id='$Id'
Header='$Header'

echo " "
echo "End of configuration questions."
echo " "

: create config.sh file
echo " "
if test -d ../UU; then
    cd ..
fi
echo "Creating config.sh..."
$spitshell <<EOT >config.sh
$startsh
# config.sh
# This file was produced by running the Configure script.

d_getutent='$d_getutent'
d_strdup='$d_strdup'
d_putenv='$d_putenv'
d_ttytype='$d_ttytype'
ttytype='$ttytype'
gettytab='$gettytab'
utmp='$utmp'
wtmp='$wtmp'
uucpid='$uucpid'
lock='$lock'
d_asciipid='$d_asciipid'
mailer='$mailer'
hostname='$hostname'
phostname='$phostname'
d_douname='$d_douname'
d_phostname='$d_phostname'
d_portable='$d_portable'
termlib='$termlib'
llib_termlib='$llib_termlib'
xenix='$xenix'
d_eunice='$d_eunice'
define='$define'
undef='$undef'
eunicefix='$eunicefix'
loclist='$loclist'
expr='$expr'
sed='$sed'
echo='$echo'
cat='$cat'
rm='$rm'
mv='$mv'
cp='$cp'
tr='$tr'
sort='$sort'
uniq='$uniq'
grep='$grep'
trylist='$trylist'
test='$test'
egrep='$egrep'
Mcc='$Mcc'
cpp='$cpp'
mail='$mail'
mailx='$mailx'
sendmail='$sendmail'
uname='$uname'
uuname='$uuname'
Log='$Log'
Id='$Id'
bin='$bin'
contains='$contains'
cppstdin='$cppstdin'
cppminus='$cppminus'
d_fcntl='$d_fcntl'
d_index='$d_index'
d_ioctl='$d_ioctl'
d_varargs='$d_varargs'
d_voidsig='$d_voidsig'
gidtype='$gidtype'
i_fcntl='$i_fcntl'
i_pwd='$i_pwd'
i_sysioctl='$i_sysioctl'
i_time='$i_time'
i_systime='$i_systime'
d_systimekernel='$d_systimekernel'
i_varargs='$i_varargs'
libc='$libc'
models='$models'
split='$split'
small='$small'
medium='$medium'
large='$large'
huge='$huge'
optimize='$optimize'
ccflags='$ccflags'
cppflags='$cppflags'
ldflags='$ldflags'
cc='$cc'
libs='$libs'
n='$n'
c='$c'
package='$package'
spitshell='$spitshell'
shsharp='$shsharp'
sharpbang='$sharpbang'
startsh='$startsh'
stdchar='$stdchar'
uidtype='$uidtype'
voidflags='$voidflags'
defvoidused='$defvoidused'
lib='$lib'
CONFIG=true
EOT

CONFIG=true

echo " "
dflt=''
fastread=''
echo "If you didn't make any mistakes, then just type a carriage return here."
rp="If you need to edit config.sh, do it as a shell escape here:"
$echo $n "$rp $c"
. UU/myread
case "$ans" in
'') ;;
*) : in case they cannot read
    eval $ans;;
esac
: if this fails, just run all the .SH files by hand
. ./config.sh

echo " "
echo "Doing variable substitutions on .SH files..."
set x `awk '{print $1}' <MANIFEST | $grep '\.SH'`
shift
case $# in
0) set x *.SH; shift;;
esac
if test ! -f $1; then
    shift
fi
for file in $*; do
    case "$file" in
    */*)
	dir=`$expr X$file : 'X\(.*\)/'`
	file=`$expr X$file : 'X.*/\(.*\)'`
	(cd $dir && . $file)
	;;
    *)
	. $file
	;;
    esac
done
if test -f config.h.SH; then
    if test ! -f config.h; then
	: oops, they left it out of MANIFEST, probably, so do it anyway.
	. config.h.SH
    fi
fi

if $contains '^depend:' Makefile >/dev/null 2>&1; then
    dflt=n
    $cat <<EOM

Now you need to generate make dependencies by running "make depend".
You might prefer to run it in background: "make depend > makedepend.out &"
It can take a while, so you might not want to run it right now.

EOM
    rp="Run make depend now? [$dflt]"
    $echo $n "$rp $c"
    . UU/myread
    case "$ans" in
    y*) make depend && echo "Now you must run a make."
	;;
    *)  echo "You must run 'make depend' then 'make'."
	;;
    esac
elif test -f Makefile; then
    echo " "
    echo "Now you must run a make."
else
    echo "Done."
fi

$rm -f kit*isdone
: the following is currently useless
cd UU && $rm -f $rmlist
: since this removes it all anyway
cd .. && $rm -rf UU
: end of Configure

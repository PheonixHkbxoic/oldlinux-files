		      Release 5 Public Patch #7
			   MIT X Consortium

This patch comes in two parts: this file, and the file "sunGX.uu".
(If you obtained this patch via the xstuff mail daemon, and you do not have
"sunGX.uu", get it with the request "send fixes sunGX.uu".)

[Note: Patch #1 also used "sunGX.uu"; it used an older version, now superseded.
Even though you have already applied patch #1, you still need to get sunGX.uu
again and install it as specified below.]

To apply this patch:

cd to the top of the source tree (to the directory containing the "mit"
and "contrib" subdirectories) and do:
	patch -p -s < ThisFile
Patch will work silently unless an error occurs.  You will likely get
the following warning messages, which can be ignored:
	mkdir: mit: File exists
	mkdir: mit/server: File exists
	mkdir: mit/server/ddx: File exists
	mkdir: mit/server/ddx/ibm: File exists
	mkdir: mit/server/ddx/ibm/skyway: File exists
If you want to watch patch do its thing, leave out the "-s" argument to patch.

This patch creates one new file, mit/server/ddx/ibm/skyway/skyBitBlt.c.
If you are using a symbolic link tree, you will need to create a new link.

Next, from the same top-level directory do:
	uudecode sunGX.uu
	rm -f mit/server/ddx/sun/sunGX.o.dist
	uncompress mit/server/ddx/sun/sunGX.o.dist

Finally, to rebuild after applying this patch, cd to the "mit" subdirectory
and do (if you are on an IBM RS/6000):
	make Everything >& every.log
or (if you are not on an IBM RS/6000):
	make -k >& make.log
Note: this will *not* "clean" your tree.

Brief notes on what this patch fixes:

Xlib: XcmsAddColorSpace generates wrong format id
Xlib: XcmsFormatOfPrefix is not case-insensitive
Xlib: XcmsAddFunctionSet has extraneous 't'
Xlib: XcmsFormatOfPrefix does string comparisons wrong, yields wrong values
Xlib: XDM-AUTHORIZATION-1 fails on IBM RS/6000
Xt: XtRemoveCallback could remove wrong entry from the callback list
Xt: MotionNotify events can be dispatched incorrectly
fontserver: treatment of catalogues needs clarification
server: use of None for Drawable or GC in graphics request can crash server
server: SIGIO in server can cause xinit to exit under SVR4
server: wide on-off self join lines can crash server
ibmddx: xterm writes outside window on skyway
sunddx: server crash when Sunview interaction occurs
sunddx: sunCursorInitialize doesn't return a value on GX
sunddx: a variety of GX problems, plus some performance boost

Prereq: public-patch-6

*** /tmp/,RCSt1000440	Thu Nov 14 18:07:57 1991
--- mit/bug-report	Thu Nov 14 18:07:18 1991
***************
*** 2,8 ****
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-6
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:
--- 2,8 ----
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-7
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:

*** /tmp/,RCSt1000280	Thu Nov 14 17:23:14 1991
--- mit/lib/X/Xcmsint.h	Tue Nov  5 11:07:08 1991
***************
*** 1,4 ****
! /* $XConsortium: Xcmsint.h,v 1.15 91/07/25 01:06:00 rws Exp $ */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: Xcmsint.h,v 1.17 91/11/05 11:06:51 rws Exp $ */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 57,64 ****
           */
  #define       XCMS_DD_ID(id)          ((id) & (XcmsColorFormat)0x80000000)
  #define       XCMS_DI_ID(id)          (!((id) & (XcmsColorFormat)0x80000000))
! #define       XCMS_REG_ID(id)         ((id) & (XcmsColorFormat)0x40000000)
! #define       XCMS_UNREG_ID(id)       (!((id) & (XcmsColorFormat)0x40000000))
  #define       XCMS_FIRST_REG_DI_ID    (XcmsColorFormat)0x00000001
  #define       XCMS_FIRST_UNREG_DI_ID  (XcmsColorFormat)0x40000000
  #define       XCMS_FIRST_REG_DD_ID    (XcmsColorFormat)0x80000000
--- 57,64 ----
           */
  #define       XCMS_DD_ID(id)          ((id) & (XcmsColorFormat)0x80000000)
  #define       XCMS_DI_ID(id)          (!((id) & (XcmsColorFormat)0x80000000))
! #define       XCMS_UNREG_ID(id)       ((id) & (XcmsColorFormat)0x40000000)
! #define       XCMS_REG_ID(id)         (!((id) & (XcmsColorFormat)0x40000000))
  #define       XCMS_FIRST_REG_DI_ID    (XcmsColorFormat)0x00000001
  #define       XCMS_FIRST_UNREG_DI_ID  (XcmsColorFormat)0x40000000
  #define       XCMS_FIRST_REG_DD_ID    (XcmsColorFormat)0x80000000
***************
*** 191,199 ****
  #define XCMS_COS(x)		_XcmsCosine(x)
  #define XCMS_CUBEROOT(x)	_XcmsCubeRoot(x)
  #define XCMS_FABS(x)		((x) < 0.0 ? -(x) : (x))
- #define XCMS_MOD(x)		_XcmsModulo(x)
- #define XCMS_MODF(x)		_XcmsModuloF(x)
- #define XCMS_POLY(x)		_XcmsPolynomial(x)
  #define XCMS_SIN(x)		_XcmsSine(x)
  #define XCMS_SQRT(x)		_XcmsSquareRoot(x)
  #define XCMS_TAN(x)		(XCMS_SIN(x) / XCMS_COS(x))
--- 191,196 ----
***************
*** 202,210 ****
  double _XcmsArcTangent(double a);
  double _XcmsCosine(double a);
  double _XcmsCubeRoot(double a);
- double _XcmsModulo(double a, double b);
- double _XcmsModuloF(double a, double b);
- double _XcmsPolynomial(int a, double b, double c);
  double _XcmsSine(double a);
  double _XcmsSquareRoot(double a);
  #else
--- 199,204 ----
***************
*** 211,219 ****
  double _XcmsArcTangent();
  double _XcmsCosine();
  double _XcmsCubeRoot();
- double _XcmsModulo();
- double _XcmsModuloF();
- double _XcmsPolynomial();
  double _XcmsSine();
  double _XcmsSquareRoot();
  #endif
--- 205,210 ----

*** /tmp/,RCSt1004606	Tue Nov  5 13:05:27 1991
--- mit/lib/X/XcmsTrig.c	Tue Nov  5 11:02:30 1991
***************
*** 1,4 ****
! /* $XConsortium: XcmsTrig.c,v 1.3 91/08/17 16:57:35 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: XcmsTrig.c,v 1.4 91/11/05 11:02:20 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 53,61 ****
   *	FORWARD DECLARATIONS
   */
  double _XcmsCosine();
! double _XcmsModulo();
! double _XcmsModuloF();
! double _XcmsPolynomial();
  double _XcmsSine();
  double _XcmsArcTangent();
  
--- 53,61 ----
   *	FORWARD DECLARATIONS
   */
  double _XcmsCosine();
! static double _XcmsModulo();
! static double _XcmsModuloF();
! static double _XcmsPolynomial();
  double _XcmsSine();
  double _XcmsArcTangent();
  
***************
*** 284,290 ****
   *	Fred Fish
   *
   */
! double _XcmsModulo (value, base)
  double value;
  double base;
  {
--- 284,290 ----
   *	Fred Fish
   *
   */
! static double _XcmsModulo (value, base)
  double value;
  double base;
  {
***************
*** 306,312 ****
   * "math.c" instantiates a copy of the inline function
   * defined in "math.h".
   */
! double
  _XcmsModuloF(val, dp)
  double val;
  register double *dp;
--- 306,312 ----
   * "math.c" instantiates a copy of the inline function
   * defined in "math.h".
   */
! static double
  _XcmsModuloF(val, dp)
  double val;
  register double *dp;
***************
*** 368,374 ****
   *
   */
  
! double _XcmsPolynomial (order, coeffs, x)
  register int order;
  double *coeffs;
  double x;
--- 368,374 ----
   *
   */
  
! static double _XcmsPolynomial (order, coeffs, x)
  register int order;
  double *coeffs;
  double x;

*** /tmp/,RCSt1000289	Thu Nov 14 17:24:44 1991
--- mit/lib/X/XcmsColNm.c	Wed Nov  6 17:55:34 1991
***************
*** 1,4 ****
! /* $XConsortium: XcmsColNm.c,v 1.22 91/07/25 01:08:32 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: XcmsColNm.c,v 1.24 91/11/06 17:55:19 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 55,60 ****
--- 55,61 ----
  #endif
  extern XcmsColorSpace **_XcmsDIColorSpaces;
  static Status LoadColornameDB();
+ void _XcmsCopyISOLatin1Lowered();
  
  /*
   *      LOCAL DEFINES
***************
*** 151,157 ****
      papColorSpaces = _XcmsDIColorSpaces;
      if (papColorSpaces != NULL) {
  	while (*papColorSpaces != NULL) {
! 	    if (strncmp((*papColorSpaces)->prefix, color_string, n) == 0) {
  		return(*papColorSpaces);
  	    }
  	    papColorSpaces++;
--- 152,159 ----
      papColorSpaces = _XcmsDIColorSpaces;
      if (papColorSpaces != NULL) {
  	while (*papColorSpaces != NULL) {
! 	    if (strncmp((*papColorSpaces)->prefix, color_string, n) == 0 &&
! 		!((*papColorSpaces)->prefix)[n]) {
  		return(*papColorSpaces);
  	    }
  	    papColorSpaces++;
***************
*** 164,170 ****
      papColorSpaces = ((XcmsFunctionSet *)ccc->pPerScrnInfo->functionSet)->DDColorSpaces;
      if (papColorSpaces != NULL) {
  	while (*papColorSpaces != NULL) {
! 	    if (strncmp((*papColorSpaces)->prefix, color_string, n) == 0) {
  		return(*papColorSpaces);
  	    }
  	    papColorSpaces++;
--- 166,173 ----
      papColorSpaces = ((XcmsFunctionSet *)ccc->pPerScrnInfo->functionSet)->DDColorSpaces;
      if (papColorSpaces != NULL) {
  	while (*papColorSpaces != NULL) {
! 	    if (strncmp((*papColorSpaces)->prefix, color_string, n) == 0 &&
! 		!((*papColorSpaces)->prefix)[n]) {
  		return(*papColorSpaces);
  	    }
  	    papColorSpaces++;
***************
*** 177,228 ****
  
  /*
   *	NAME
-  *		_XcmsCopyISOLatin1Lowered
-  *
-  *	SYNOPSIS
-  */
- static void
- _XcmsCopyISOLatin1Lowered(dst, src)
-     char *dst, *src;
- /*
-  *	DESCRIPTION
-  *		ISO Latin-1 case conversion routine
-  *		Identical to XmuCopyISOLatin1Lowered() but provided here
-  *		to eliminate need to link with libXmu.a.
-  *
-  *		IMPLEMENTORS NOTE:
-  *		    This routine is currently used by _XcmsParseColorString
-  *		    and _XcmsLookupColorName.  When _XcmsLookupColorName is
-  *		    replaced by the appropriate i18n database support
-  *		    routine, the contents of this routine can be placed
-  *		    directly into _XcmsParseColorString.
-  *
-  *	RETURNS
-  *		Void
-  *
-  */
- {
-     register unsigned char *dest, *source;
- 
-     for (dest = (unsigned char *)dst, source = (unsigned char *)src;
- 	 *source;
- 	 source++, dest++)
-     {
- 	if ((*source >= XK_A) && (*source <= XK_Z))
- 	    *dest = *source + (XK_a - XK_A);
- 	else if ((*source >= XK_Agrave) && (*source <= XK_Odiaeresis))
- 	    *dest = *source + (XK_agrave - XK_Agrave);
- 	else if ((*source >= XK_Ooblique) && (*source <= XK_Thorn))
- 	    *dest = *source + (XK_oslash - XK_Ooblique);
- 	else
- 	    *dest = *source;
-     }
-     *dest = '\0';
- }
- 
- 
- /*
-  *	NAME
   *		_XcmsParseColorString
   *
   *	SYNOPSIS
--- 180,185 ----
***************
*** 247,253 ****
   */
  {
      XcmsColorSpace	*pColorSpace;
!     char		string_lowered_64[64];
      char		*string_lowered;
      int			len;
      int			res;
--- 204,210 ----
   */
  {
      XcmsColorSpace	*pColorSpace;
!     char		string_buf[64];
      char		*string_lowered;
      int			len;
      int			res;
***************
*** 259,276 ****
      /*
       * While copying color_string to string_lowered, convert to lowercase
       */
!     if ((len = strlen(color_string)) > 63) {
  	string_lowered = (char *) Xmalloc(len+1);
      } else {
! 	string_lowered = string_lowered_64;
      }
  
!     _XcmsCopyISOLatin1Lowered((char *)string_lowered, (char *)color_string);
  
      if (*string_lowered == '#') {
  	if ((pColorSpace = _XcmsColorSpaceOfString(ccc, "rgb:")) != NULL) {
  	    res = (*pColorSpace->parseString)(string_lowered, pColor);
! 	    if (len > 63) Xfree(string_lowered);
  	    return res;
  	}
      }
--- 216,233 ----
      /*
       * While copying color_string to string_lowered, convert to lowercase
       */
!     if ((len = strlen(color_string)) >= sizeof(string_buf)) {
  	string_lowered = (char *) Xmalloc(len+1);
      } else {
! 	string_lowered = string_buf;
      }
  
!     _XcmsCopyISOLatin1Lowered(string_lowered, color_string);
  
      if (*string_lowered == '#') {
  	if ((pColorSpace = _XcmsColorSpaceOfString(ccc, "rgb:")) != NULL) {
  	    res = (*pColorSpace->parseString)(string_lowered, pColor);
! 	    if (len >= sizeof(string_buf)) Xfree(string_lowered);
  	    return res;
  	}
      }
***************
*** 277,287 ****
  
      if ((pColorSpace = _XcmsColorSpaceOfString(ccc, string_lowered)) != NULL) {
  	res = (*pColorSpace->parseString)(string_lowered, pColor);
! 	if (len > 63) Xfree(string_lowered);
  	return res;
      }
  
!     if (len > 63) Xfree(string_lowered);
      return(0);
  }
  
--- 234,244 ----
  
      if ((pColorSpace = _XcmsColorSpaceOfString(ccc, string_lowered)) != NULL) {
  	res = (*pColorSpace->parseString)(string_lowered, pColor);
! 	if (len >= sizeof(string_buf)) Xfree(string_lowered);
  	return res;
      }
  
!     if (len >= sizeof(string_buf)) Xfree(string_lowered);
      return(0);
  }
  
***************
*** 479,485 ****
  	name_lowered = name_lowered_64;
      }
  
!     _XcmsCopyISOLatin1Lowered((char *)name_lowered, (char *)tmpName);
  
      /*
       * Now, remove spaces.
--- 436,442 ----
  	name_lowered = name_lowered_64;
      }
  
!     _XcmsCopyISOLatin1Lowered(name_lowered, tmpName);
  
      /*
       * Now, remove spaces.
***************
*** 730,740 ****
  
  	/* Left String */
  	pRec->first = pString;
! 	_XcmsCopyISOLatin1Lowered((char *)pString, (char *)f1);
  	pString += (1 + RemoveSpaces(pString));
  	pRec->second = pString;
  	/* Right String */
! 	_XcmsCopyISOLatin1Lowered((char *)pString, (char *)f2);
  	pString += RemoveSpaces(pString) + 1;
  	pRec++;
  
--- 687,697 ----
  
  	/* Left String */
  	pRec->first = pString;
! 	_XcmsCopyISOLatin1Lowered(pString, f1);
  	pString += (1 + RemoveSpaces(pString));
  	pRec->second = pString;
  	/* Right String */
! 	_XcmsCopyISOLatin1Lowered(pString, f2);
  	pString += RemoveSpaces(pString) + 1;
  	pRec++;
  
***************
*** 846,851 ****
--- 803,850 ----
   *									*
   ************************************************************************/
  
+ /*
+  *	NAME
+  *		_XcmsCopyISOLatin1Lowered
+  *
+  *	SYNOPSIS
+  */
+ void
+ _XcmsCopyISOLatin1Lowered(dst, src)
+     char *dst, *src;
+ /*
+  *	DESCRIPTION
+  *		ISO Latin-1 case conversion routine
+  *		Identical to XmuCopyISOLatin1Lowered() but provided here
+  *		to eliminate need to link with libXmu.a.
+  *
+  *		IMPLEMENTORS NOTE:
+  *		    This routine is also used in XcmsFormatOfPrefix.
+  *
+  *	RETURNS
+  *		Void
+  *
+  */
+ {
+     register unsigned char *dest, *source;
+ 
+     for (dest = (unsigned char *)dst, source = (unsigned char *)src;
+ 	 *source;
+ 	 source++, dest++)
+     {
+ 	if ((*source >= XK_A) && (*source <= XK_Z))
+ 	    *dest = *source + (XK_a - XK_A);
+ 	else if ((*source >= XK_Agrave) && (*source <= XK_Odiaeresis))
+ 	    *dest = *source + (XK_agrave - XK_Agrave);
+ 	else if ((*source >= XK_Ooblique) && (*source <= XK_Thorn))
+ 	    *dest = *source + (XK_oslash - XK_Ooblique);
+ 	else
+ 	    *dest = *source;
+     }
+     *dest = '\0';
+ }
+ 
+ 
  /*
   *	NAME
   *		_XcmsResolveColorString - 

*** /tmp/,RCSt1000296	Thu Nov 14 17:25:53 1991
--- mit/lib/X/XcmsIdOfPr.c	Wed Nov  6 16:45:44 1991
***************
*** 1,4 ****
! /* $XConsortium: XcmsIdOfPr.c,v 1.4 91/05/13 23:22:36 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: XcmsIdOfPr.c,v 1.6 91/11/06 16:45:23 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 41,48 ****
   */
  extern XcmsColorSpace **_XcmsDIColorSpaces;
  extern XcmsColorSpace **_XcmsDDColorSpaces;
  
- 
  
  /*
   *	NAME
--- 41,48 ----
   */
  extern XcmsColorSpace **_XcmsDIColorSpaces;
  extern XcmsColorSpace **_XcmsDDColorSpaces;
+ void _XcmsCopyISOLatin1Lowered();
  
  
  /*
   *	NAME
***************
*** 64,78 ****
   */
  {
      XcmsColorSpace	**papColorSpaces;
  
      /*
       * First try Device-Independent color spaces
       */
      papColorSpaces = _XcmsDIColorSpaces;
      if (papColorSpaces != NULL) {
  	while (*papColorSpaces != NULL) {
! 	    if (strncmp((*papColorSpaces)->prefix, prefix,
! 		    strlen((*papColorSpaces)->prefix)) == 0) {
  		return((*papColorSpaces)->id);
  	    }
  	    papColorSpaces++;
--- 64,91 ----
   */
  {
      XcmsColorSpace	**papColorSpaces;
+     char		string_buf[64];
+     char		*string_lowered;
+     int			len;
  
      /*
+      * While copying prefix to string_lowered, convert to lowercase
+      */
+     if ((len = strlen(prefix)) >= sizeof(string_buf)) {
+ 	string_lowered = (char *) Xmalloc(len+1);
+     } else {
+ 	string_lowered = string_buf;
+     }
+     _XcmsCopyISOLatin1Lowered(string_lowered, prefix);
+ 
+     /*
       * First try Device-Independent color spaces
       */
      papColorSpaces = _XcmsDIColorSpaces;
      if (papColorSpaces != NULL) {
  	while (*papColorSpaces != NULL) {
! 	    if (strcmp((*papColorSpaces)->prefix, string_lowered) == 0) {
! 		if (len >= sizeof(string_buf)) Xfree(string_lowered);
  		return((*papColorSpaces)->id);
  	    }
  	    papColorSpaces++;
***************
*** 85,92 ****
      papColorSpaces = _XcmsDDColorSpaces;
      if (papColorSpaces != NULL) {
  	while (*papColorSpaces != NULL) {
! 	    if (strncmp((*papColorSpaces)->prefix, prefix,
! 		    strlen((*papColorSpaces)->prefix)) == 0) {
  		return((*papColorSpaces)->id);
  	    }
  	    papColorSpaces++;
--- 98,105 ----
      papColorSpaces = _XcmsDDColorSpaces;
      if (papColorSpaces != NULL) {
  	while (*papColorSpaces != NULL) {
! 	    if (strcmp((*papColorSpaces)->prefix, string_lowered) == 0) {
! 		if (len >= sizeof(string_buf)) Xfree(string_lowered);
  		return((*papColorSpaces)->id);
  	    }
  	    papColorSpaces++;
***************
*** 93,97 ****
--- 106,111 ----
  	}
      }
  
+     if (len >= sizeof(string_buf)) Xfree(string_lowered);
      return(XcmsUndefinedFormat);
  }

*** /tmp/,RCSt1000535	Wed Nov  6 17:30:24 1991
--- mit/lib/X/XcmsAddSF.c	Wed Nov  6 16:29:46 1991
***************
*** 1,4 ****
! /* $XConsortium: XcmsAddSF.c,v 1.5 91/07/25 01:08:22 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: XcmsAddSF.c,v 1.6 91/11/06 16:29:27 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 28,34 ****
   *		XcmsAddSF.c
   *
   *	DESCRIPTION
!  *		Source for XcmsAddFunctionSett
   *
   *
   */
--- 28,34 ----
   *		XcmsAddSF.c
   *
   *	DESCRIPTION
!  *		Source for XcmsAddFunctionSet
   *
   *
   */
***************
*** 58,70 ****
  
  /*
   *	NAME
!  *		XcmsAddFunctionSett - Add an Screen Color Characterization
   *					Function Set
   *
   *	SYNOPSIS
   */
  Status
! XcmsAddFunctionSett(pNewFS)
      XcmsFunctionSet *pNewFS;
  /*
   *	DESCRIPTION
--- 58,70 ----
  
  /*
   *	NAME
!  *		XcmsAddFunctionSet - Add an Screen Color Characterization
   *					Function Set
   *
   *	SYNOPSIS
   */
  Status
! XcmsAddFunctionSet(pNewFS)
      XcmsFunctionSet *pNewFS;
  /*
   *	DESCRIPTION

*** /tmp/,RCSt1cjMD_5	Fri Nov  8 15:34:29 1991
--- mit/lib/X/XlibInt.c	Fri Nov  8 15:17:11 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: XlibInt.c,v 11.155 91/07/23 12:14:32 rws Exp $
   */
  
  /* Copyright    Massachusetts Institute of Technology    1985, 1986, 1987 */
--- 1,5 ----
  /*
!  * $XConsortium: XlibInt.c,v 11.156 91/11/08 15:15:12 eswu Exp $
   */
  
  /* Copyright    Massachusetts Institute of Technology    1985, 1986, 1987 */
***************
*** 1656,1663 ****
      return;
  }
  
  
! #if defined(_POSIX_SOURCE) || defined(hpux) || defined(USG) || defined(SVR4)
  #define NEED_UTSNAME
  #include <sys/utsname.h>
  #endif
--- 1656,1670 ----
      return;
  }
  
+ /* Make sure this produces the same string as DefineLocal/DefineSelf in xdm.
+  * Otherwise, Xau will not be able to find your cookies in the Xauthority file.
+  *
+  * Note: POSIX says that the ``nodename'' member of utsname does _not_ have
+  *       to have sufficient information for interfacing to the network,
+  *       and so, you may be better off using gethostname (if it exists).
+  */
  
! #if (defined(_POSIX_SOURCE) && !defined(AIXV3)) || defined(hpux) || defined(USG) || defined(SVR4)
  #define NEED_UTSNAME
  #include <sys/utsname.h>
  #endif

*** /tmp/,RCSt1a24650	Wed Oct 30 14:27:42 1991
--- mit/lib/Xt/Callback.c	Wed Oct 30 14:18:23 1991
***************
*** 1,4 ****
! /* $XConsortium: Callback.c,v 1.33 91/01/25 15:29:47 rws Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Callback.c,v 1.34 91/10/30 14:16:58 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 222,228 ****
  		    while (--j >= 0)
  			*ncl++ = *ocl++;
  		    while (--i >= 0)
! 			*ncl++ = *cl++;
  		    *callbacks = icl;
  		}
  	    } else {
--- 222,228 ----
  		    while (--j >= 0)
  			*ncl++ = *ocl++;
  		    while (--i >= 0)
! 			*ncl++ = *++cl;
  		    *callbacks = icl;
  		}
  	    } else {

*** /tmp/,RCSt1a24945	Wed Oct 30 17:00:52 1991
--- mit/lib/Xt/Event.c	Fri Oct 25 13:23:26 1991
***************
*** 1,4 ****
! /* $XConsortium: Event.c,v 1.134 91/08/26 14:20:42 swick Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Event.c,v 1.135 91/10/25 13:19:23 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 868,878 ****
  	ButtonPressMask,	    /* ButtonPress		*/
  	ButtonReleaseMask,	    /* ButtonRelease		*/
  	PointerMotionMask	    /* MotionNotify		*/
- 		| Button1MotionMask
- 		| Button2MotionMask
- 		| Button3MotionMask
- 		| Button4MotionMask
- 		| Button5MotionMask
  		| ButtonMotionMask,
  	EnterWindowMask,	    /* EnterNotify		*/
  	LeaveWindowMask,	    /* LeaveNotify		*/
--- 868,873 ----
***************
*** 984,989 ****
--- 979,988 ----
  				break;
  
        case MotionNotify:	grabType = ignore; time = event->xmotion.time;
+ #define XKnownButtons (Button1MotionMask|Button2MotionMask|Button3MotionMask|\
+                        Button4MotionMask|Button5MotionMask)
+ 	                        mask |= (event->xmotion.state & XKnownButtons);
+ #undef XKnownButtons
  				break;
  
        case EnterNotify:

*** /tmp/,RCSt1cj0BXj	Fri Nov  8 15:34:31 1991
--- mit/clients/xdm/auth.c	Fri Nov  8 15:20:31 1991
***************
*** 1,7 ****
  /*
   * xdm - display manager daemon
   *
!  * $XConsortium: auth.c,v 1.46 91/09/12 19:56:05 keith Exp $
   *
   * Copyright 1988 Massachusetts Institute of Technology
   *
--- 1,7 ----
  /*
   * xdm - display manager daemon
   *
!  * $XConsortium: auth.c,v 1.47 91/11/08 15:18:18 eswu Exp $
   *
   * Copyright 1988 Massachusetts Institute of Technology
   *
***************
*** 41,48 ****
  # include <netdnet/dnetdb.h>
  #endif
  
  #if defined(SYSV) && defined(SYSV386)
- # include <sys/utsname.h>
  # include <sys/stream.h>
  # ifdef ISC
  #  include <sys/sioctl.h>
--- 41,52 ----
  # include <netdnet/dnetdb.h>
  #endif
  
+ #if (defined(_POSIX_SOURCE) && !defined(AIXV3)) || defined(hpux) || defined(USG) || defined(SVR4)
+ #define NEED_UTSNAME
+ #include <sys/utsname.h>
+ #endif
+ 
  #if defined(SYSV) && defined(SYSV386)
  # include <sys/stream.h>
  # ifdef ISC
  #  include <sys/sioctl.h>
***************
*** 52,62 ****
  # endif /* ESIX */
  #endif /* SYSV386 */
  
- #ifdef hpux
- # include <sys/utsname.h>
- #endif
  #ifdef SVR4
- # include <sys/utsname.h>
  # include <netdb.h>
  # include <sys/sockio.h>
  #endif
--- 56,62 ----
***************
*** 583,590 ****
  	char	displayname[100];
  
  	/* stolen from xinit.c */
! #ifdef hpux
! 	/* Why not use gethostname()?  Well, at least on my system, I've had to
  	 * make an ugly kernel patch to get a name longer than 8 characters, and
  	 * uname() lets me access to the whole string (it smashes release, you
  	 * see), whereas gethostname() kindly truncates it for me.
--- 583,601 ----
  	char	displayname[100];
  
  	/* stolen from xinit.c */
! 
! /* Make sure this produces the same string as _XGetHostname in lib/X/XlibInt.c.
!  * Otherwise, Xau will not be able to find your cookies in the Xauthority file.
!  *
!  * Note: POSIX says that the ``nodename'' member of utsname does _not_ have
!  *       to have sufficient information for interfacing to the network,
!  *       and so, you may be better off using gethostname (if it exists).
!  */
! 
! #ifdef NEED_UTSNAME
! 
! 	/* hpux:
! 	 * Why not use gethostname()?  Well, at least on my system, I've had to
  	 * make an ugly kernel patch to get a name longer than 8 characters, and
  	 * uname() lets me access to the whole string (it smashes release, you
  	 * see), whereas gethostname() kindly truncates it for me.
***************
*** 596,601 ****
--- 607,617 ----
  	strcpy(displayname, name.nodename);
  	}
  #else
+         /* AIXV3:
+ 	 * In AIXV3, _POSIX_SOURCE is defined, but uname gives only first
+ 	 * field of hostname. Thus, we use gethostname instead.
+ 	 */
+ 
  	gethostname(displayname, sizeof(displayname));
  #endif
  	writeAddr (FamilyLocal, strlen (displayname), displayname, file, auth);
***************
*** 717,723 ****
  	
      struct	sockaddr_in	*inetaddr;
  
!     /* Why not use gethostname()?  Well, at least on my system, I've had to
       * make an ugly kernel patch to get a name longer than 8 characters, and
       * uname() lets me access to the whole string (it smashes release, you
       * see), whereas gethostname() kindly truncates it for me.
--- 733,740 ----
  	
      struct	sockaddr_in	*inetaddr;
  
!     /* hpux:
!      * Why not use gethostname()?  Well, at least on my system, I've had to
       * make an ugly kernel patch to get a name longer than 8 characters, and
       * uname() lets me access to the whole string (it smashes release, you
       * see), whereas gethostname() kindly truncates it for me.

*** /tmp/,RCSt1006662	Wed Oct 30 11:56:49 1991
--- mit/fonts/server/fs.man	Wed Oct 30 11:56:17 1991
***************
*** 1,4 ****
! .\" $XConsortium: fs.man,v 1.3 91/09/09 17:27:01 rws Exp $
  .TH FS 1 "Release 5" "X Version 11"
  .SH NAME
  fs \- X font server
--- 1,4 ----
! .\" $XConsortium: fs.man,v 1.4 91/10/24 21:27:20 rws Exp $
  .TH FS 1 "Release 5" "X Version 11"
  .SH NAME
  fs \- X font server
***************
*** 49,102 ****
  .PP
  Recognized keywords include:
  .sp
! .ta .6i 1.5i
! .nf
! #		in the first column, a comment character
! .sp
! .\" cache-size (cardinal) 
! .\" 		Size in bytes of the font server cache.
! .sp
! catalogue (list of string)
! 		Ordered list of font path element names.
! .sp
! alternate-servers (list of string)
! 		List of alternate servers for this font server.
! .sp
! client-limit (cardinal)
! 		Number of clients this font server will support 
! 		before refusing service.  This is useful for tuning 
! 		the load on each individual font server.
! .sp
! clone-self (boolean)
!  		Whether this font server should attempt to clone itself
!  		when it reachs the client-limit.
! .sp
! default-point-size (cardinal)
! 		The default pointsize (in decipoints) for fonts that 
! 		don't specify.
! .sp
! default-resolutions (list of resolutions)
! 		Resolutions the server supports by default.
! 		This information may be used as a hint for 
! 		pre-rendering, and substituted for scaled fonts 
! 		which do not specify a resolution.
! .sp
! error-file (string)
! 		Filename of the error file.  All warnings and errors
! 		will be logged here.
! .sp
! port (cardinal)
! 		TCP port on which the server will listen for connections.
! .sp
! use-syslog (boolean)
! 		Whether syslog(3) (on supported systems) is to be used 
! 		for errors.
! .\" .sp
! .\" trusted-clients (list of string)
! .\" 		Those clients the fontserver will talk to.  Others
! .\" 		will be refused for the initial connection.  An empty
! .\" 		list means the server will talk to any client.
! .fi
  .SH "EXAMPLE"
  .nf
  #
--- 49,90 ----
  .PP
  Recognized keywords include:
  .sp
! .\" .IP "cache-size (cardinal)"
! .\" Size in bytes of the font server cache.
! .IP "catalogue (list of string)"
! Ordered list of font path element names.
! Use of the keyword "catalogue" is very misleading at present,
! the current implementation only supports a single catalogue ("all"),
! containing all of the specified fonts.
! .IP "alternate-servers (list of string)"
! List of alternate servers for this font server.
! .IP "client-limit (cardinal)"
! Number of clients this font server will support 
! before refusing service.  This is useful for tuning 
! the load on each individual font server.
! .IP "clone-self (boolean)"
! Whether this font server should attempt to clone itself
! when it reachs the client-limit.
! .IP "default-point-size (cardinal)"
! The default pointsize (in decipoints) for fonts that 
! don't specify.
! .IP "default-resolutions (list of resolutions)"
! Resolutions the server supports by default.
! This information may be used as a hint for 
! pre-rendering, and substituted for scaled fonts 
! which do not specify a resolution.
! .IP "error-file (string)"
! Filename of the error file.  All warnings and errors
! will be logged here.
! .IP "port (cardinal)"
! TCP port on which the server will listen for connections.
! .IP "use-syslog (boolean)"
! Whether syslog(3) (on supported systems) is to be used 
! for errors.
! .\" .IP "trusted-clients (list of string)"
! .\" Those clients the fontserver will talk to.  Others
! .\" will be refused for the initial connection.  An empty
! .\" list means the server will talk to any client.
  .SH "EXAMPLE"
  .nf
  #
***************
*** 161,166 ****
--- 149,156 ----
  Examples: \fIDECnet/SRVNOD::FONT$DEFAULT\fP, \fIdecnet/44.70::font$special/symbols\fP.
  .SH "SEE ALSO"
  X(1), \fIFont server implementation overview\fB
+ .SH BUGS
+ Multiple catalogues should be supported.
  .SH COPYRIGHT
  Copyright 1991, Network Computing Devices, Inc
  Copyright 1991, Massachusetts Institute of Technology

*** /tmp/,RCSt1006667	Wed Oct 30 11:56:57 1991
--- mit/fonts/server/os/osglue.c	Wed Oct 30 11:56:31 1991
***************
*** 1,4 ****
! /* $XConsortium: osglue.c,v 1.4 91/07/19 20:49:41 rws Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
--- 1,4 ----
! /* $XConsortium: osglue.c,v 1.5 91/10/24 21:46:59 rws Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
***************
*** 48,56 ****
  /*
   * XXX
   *
!  * Catalogue support is minimal at best.  the guts are here, but
   * we don't actually do anything with them so the only one exported is
!  * 'all'.
   *
   */
  
--- 48,57 ----
  /*
   * XXX
   *
!  * Catalogue support is absolutely minimal.  Some guts are here, but
   * we don't actually do anything with them so the only one exported is
!  * 'all'.  Be warned that other parts of the server may incorrectly
!  * assume the catalogue list is global, and will therefore need fixing.
   *
   */
  

*** /tmp/,RCSt1002196	Tue Nov  5 10:37:22 1991
--- mit/server/include/dix.h	Wed Oct 30 14:50:37 1991
***************
*** 21,27 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: dix.h,v 1.59 91/07/27 23:40:24 keith Exp $ */
  
  #ifndef DIX_H
  #define DIX_H
--- 21,27 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: dix.h,v 1.60 91/10/30 14:49:57 rws Exp $ */
  
  #ifndef DIX_H
  #define DIX_H
***************
*** 74,80 ****
      }
  
  #define VALIDATE_DRAWABLE_AND_GC(drawID, pDraw, pGC, client)\
!     if ((client->lastGCID != stuff->gc) || (client->lastDrawableID != drawID))\
      {\
          if (client->lastDrawableID != drawID) {\
  	    pDraw = (DrawablePtr)LookupIDByClass(drawID, RC_DRAWABLE);\
--- 74,81 ----
      }
  
  #define VALIDATE_DRAWABLE_AND_GC(drawID, pDraw, pGC, client)\
!     if ((stuff->gc == INVALID) || (client->lastGCID != stuff->gc) ||\
! 	(client->lastDrawableID != drawID))\
      {\
          if (client->lastDrawableID != drawID) {\
  	    pDraw = (DrawablePtr)LookupIDByClass(drawID, RC_DRAWABLE);\
***************
*** 85,99 ****
      	    }\
          } else\
  	    pDraw = client->lastDrawable;\
!         if (client->lastGCID != stuff->gc) {\
!     	    pGC = (GC *)LookupIDByType(stuff->gc, RT_GC);\
!     	    if (!pGC)\
!     	    {\
!             	client->errorValue = stuff->gc;\
!             	return (BadGC);\
!     	    }\
!         } else\
!             pGC = client->lastGC;\
  	if ((pDraw->type == UNDRAWABLE_WINDOW) ||\
  	    (pGC->depth != pDraw->depth) ||\
  	    (pGC->pScreen != pDraw->pScreen))\
--- 86,92 ----
      	    }\
          } else\
  	    pDraw = client->lastDrawable;\
! 	VERIFY_GC(pGC, stuff->gc, client);\
  	if ((pDraw->type == UNDRAWABLE_WINDOW) ||\
  	    (pGC->depth != pDraw->depth) ||\
  	    (pGC->pScreen != pDraw->pScreen))\

*** /tmp/,RCSt1002205	Tue Nov  5 10:37:46 1991
--- mit/server/dix/dispatch.c	Wed Oct 30 14:52:02 1991
***************
*** 1,4 ****
! /* $XConsortium: dispatch.c,v 5.34 91/07/18 22:41:32 keith Exp $ */
  /************************************************************
  Copyright 1987, 1989 by Digital Equipment Corporation, Maynard, Massachusetts,
  and the Massachusetts Institute of Technology, Cambridge, Massachusetts.
--- 1,4 ----
! /* $XConsortium: dispatch.c,v 5.36 91/10/30 14:51:40 rws Exp $ */
  /************************************************************
  Copyright 1987, 1989 by Digital Equipment Corporation, Maynard, Massachusetts,
  and the Massachusetts Institute of Technology, Cambridge, Massachusetts.
***************
*** 168,175 ****
  	{
              if (client->lastDrawableID == id)
  	    {
!                 client->lastDrawableID = INVALID;
! 		client->lastDrawable = (DrawablePtr)NULL;
  	    }
              else if (client->lastGCID == id)
  	    {
--- 168,175 ----
  	{
              if (client->lastDrawableID == id)
  	    {
! 		client->lastDrawableID = WindowTable[0]->drawable.id;
! 		client->lastDrawable = (DrawablePtr)WindowTable[0];
  	    }
              else if (client->lastGCID == id)
  	    {
***************
*** 930,935 ****
--- 930,937 ----
  ProcGrabServer(client)
      register ClientPtr client;
  {
+     REQUEST(xReq);
+     REQUEST_SIZE_MATCH(xReq);
      OnlyListenToOneClient(client);
      grabbingClient = TRUE;
      onlyClient = client;
***************
*** 3224,3231 ****
      client->clientAsMask = ((Mask)i) << CLIENTOFFSET;
      client->closeDownMode = DestroyAll;
      client->clientGone = FALSE;
!     client->lastDrawable = (DrawablePtr) NULL;
!     client->lastDrawableID = INVALID;
      client->lastGC = (GCPtr) NULL;
      client->lastGCID = INVALID;
      client->numSaved = 0;
--- 3226,3233 ----
      client->clientAsMask = ((Mask)i) << CLIENTOFFSET;
      client->closeDownMode = DestroyAll;
      client->clientGone = FALSE;
!     client->lastDrawable = (DrawablePtr)WindowTable[0];
!     client->lastDrawableID = WindowTable[0]->drawable.id;
      client->lastGC = (GCPtr) NULL;
      client->lastGCID = INVALID;
      client->numSaved = 0;

*** /tmp/,RCSt1002210	Tue Nov  5 10:37:56 1991
--- mit/server/dix/resource.c	Wed Oct 30 14:51:22 1991
***************
*** 22,28 ****
  
  ********************************************************/
  
! /* $XConsortium: resource.c,v 1.86 91/06/21 18:17:21 keith Exp $ */
  
  /*	Routines to manage various kinds of resources:
   *
--- 22,28 ----
  
  ********************************************************/
  
! /* $XConsortium: resource.c,v 1.87 91/10/30 14:50:54 rws Exp $ */
  
  /*	Routines to manage various kinds of resources:
   *
***************
*** 53,62 ****
--- 53,64 ----
  #include "resource.h"
  #include "dixstruct.h" 
  #include "opaque.h"
+ #include "windowstr.h"
  
  extern void HandleSaveSet();
  extern void FlushClientCaches();
  static void RebuildTable();
+ extern WindowPtr *WindowTable;
  
  #define SERVER_MINID 32
  
***************
*** 408,415 ****
          }
  	if(clients[cid] && (id == clients[cid]->lastDrawableID))
  	{
! 	    clients[cid]->lastDrawable = (DrawablePtr) NULL;
! 	    clients[cid]->lastDrawableID = INVALID;
  	}
      }
      if (!gotOne)
--- 410,417 ----
          }
  	if(clients[cid] && (id == clients[cid]->lastDrawableID))
  	{
! 	    clients[cid]->lastDrawable = (DrawablePtr)WindowTable[0];
! 	    clients[cid]->lastDrawableID = WindowTable[0]->drawable.id;
  	}
      }
      if (!gotOne)
***************
*** 447,454 ****
          }
  	if(clients[cid] && (id == clients[cid]->lastDrawableID))
  	{
! 	    clients[cid]->lastDrawable = (DrawablePtr) NULL;
! 	    clients[cid]->lastDrawableID = INVALID;
  	}
      }
  }
--- 449,456 ----
          }
  	if(clients[cid] && (id == clients[cid]->lastDrawableID))
  	{
! 	    clients[cid]->lastDrawable = (DrawablePtr)WindowTable[0];
! 	    clients[cid]->lastDrawableID = WindowTable[0]->drawable.id;
  	}
      }
  }


*** /tmp/,RCSt1002281	Tue Nov  5 10:44:02 1991
--- mit/server/os/osinit.c	Wed Oct 30 15:28:25 1991
***************
*** 21,27 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: osinit.c,v 1.38 91/07/06 13:05:44 rws Exp $ */
  #include "X.h"
  #include "os.h"
  #include "osdep.h"
--- 21,27 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: osinit.c,v 1.39 91/10/30 15:27:39 rws Exp $ */
  #include "X.h"
  #include "os.h"
  #include "osdep.h"
***************
*** 94,102 ****
  #endif
  	}
  
! #if !defined(SYSV) && !defined(SVR4)
  	if (getpgrp (0) == 0)
  	    setpgrp (0, getpid ());
  #endif
  
  #ifdef RLIMIT_DATA
--- 94,106 ----
  #endif
  	}
  
! #ifndef X_NOT_POSIX
! 	setsid();
! #else
! #ifndef SYSV
  	if (getpgrp (0) == 0)
  	    setpgrp (0, getpid ());
+ #endif
  #endif
  
  #ifdef RLIMIT_DATA

*** /tmp/,RCSt1002338	Tue Nov  5 10:50:18 1991
--- mit/server/ddx/mi/miwideline.c	Tue Nov  5 10:50:19 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: miwideline.c,v 1.42 91/08/23 12:16:08 gildea Exp $
   *
   * Copyright 1988 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: miwideline.c,v 1.43 91/11/01 15:52:03 keith Exp $
   *
   * Copyright 1988 Massachusetts Institute of Technology
   *
***************
*** 1984,1990 ****
      SpanDataPtr	    spanData;
      Bool	    somethingDrawn = FALSE;
      Bool	    selfJoin;
!     Bool	    endIsFg, startIsFg, firstIsFg, prevIsFg;
  
      if (pGC->lineStyle == LineDoubleDash && 
  	(pGC->fillStyle == FillOpaqueStippled || pGC->fillStyle == FillTiled))
--- 1984,1990 ----
      SpanDataPtr	    spanData;
      Bool	    somethingDrawn = FALSE;
      Bool	    selfJoin;
!     Bool	    endIsFg, startIsFg, firstIsFg = FALSE, prevIsFg;
  
      if (pGC->lineStyle == LineDoubleDash && 
  	(pGC->fillStyle == FillOpaqueStippled || pGC->fillStyle == FillTiled))

*** /tmp/,RCSt1DTEBXj	Fri Nov  8 18:29:52 1991
--- mit/server/ddx/ibm/skyway/skySGC.c	Fri Nov  8 18:11:24 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: skySGC.c,v 1.3 91/09/09 13:21:50 rws Exp $
   *
   * Copyright IBM Corporation 1987,1988,1989,1990,1991
   *
--- 1,5 ----
  /*
!  * $XConsortium: skySGC.c,v 1.4 91/11/08 18:10:05 eswu Exp $
   *
   * Copyright IBM Corporation 1987,1988,1989,1990,1991
   *
***************
*** 35,41 ****
  
  #include "cfb.h"
  
! extern RegionPtr pgcCopyArea();
  
  void
  skyValidateGC(pGC, changes, pDrawable)
--- 35,41 ----
  
  #include "cfb.h"
  
! extern RegionPtr skyCopyArea();
  
  void
  skyValidateGC(pGC, changes, pDrawable)
***************
*** 44,49 ****
      DrawablePtr	    pDrawable;
  {
    cfbValidateGC(pGC,changes,pDrawable);
    if (pGC->depth == 8)
!     pGC->ops->CopyArea = pgcCopyArea ;
  }
--- 44,52 ----
      DrawablePtr	    pDrawable;
  {
    cfbValidateGC(pGC,changes,pDrawable);
+ 
+   /* XXX - What if the ops is static? */
+ 
    if (pGC->depth == 8)
!     pGC->ops->CopyArea = skyCopyArea ;
  }

*** /tmp/,RCSt1DTsCSM	Fri Nov  8 18:30:02 1991
--- mit/server/ddx/ibm/skyway/Imakefile	Fri Nov  8 18:09:22 1991
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.4 91/07/16 22:51:23 gildea Exp $
  
  #include <Server.tmpl>
  
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.5 91/11/08 18:08:34 eswu Exp $
  
  #include <Server.tmpl>
  
***************
*** 11,17 ****
  		skyScrInit.c    \
  		skyCmap.c       \
  		skyProbe.c	\
! 		skySGC.c
  
  OBJS =	 	skyInfo.o       \
  		skyIO.o	        \
--- 11,18 ----
  		skyScrInit.c    \
  		skyCmap.c       \
  		skyProbe.c	\
! 		skySGC.c	\
! 		skyBitBlt.c
  
  OBJS =	 	skyInfo.o       \
  		skyIO.o	        \
***************
*** 22,28 ****
  		skyScrInit.o    \
  		skyCmap.o       \
  		skyProbe.o	\
! 		skySGC.o
  
  INCLUDES = -I../ -I../OPERATING_SYSTEM -I../../mfb -I../../cfb -I../ppc -I../../../include -I$(INCLUDESRC) -I../common -I../../mi -I../../../../fonts/include
  STD_DEFINES = ServerDefines
--- 23,30 ----
  		skyScrInit.o    \
  		skyCmap.o       \
  		skyProbe.o	\
! 		skySGC.o	\
! 		skyBitBlt.o
  
  INCLUDES = -I../ -I../OPERATING_SYSTEM -I../../mfb -I../../cfb -I../ppc -I../../../include -I$(INCLUDESRC) -I../common -I../../mi -I../../../../fonts/include
  STD_DEFINES = ServerDefines

*** /dev/null	Thu Nov 14 17:32:08 1991
--- mit/server/ddx/ibm/skyway/skyBitBlt.c	Fri Nov  8 19:31:49 1991
***************
*** 0 ****
--- 1,246 ----
+ /*
+  * skyway copy area: same as cfb except uses skyway accelerator.
+  */
+ 
+ /*
+ Copyright 1989 by the Massachusetts Institute of Technology
+ 
+ Permission to use, copy, modify, and distribute this software and its
+ documentation for any purpose and without fee is hereby granted,
+ provided that the above copyright notice appear in all copies and that
+ both that copyright notice and this permission notice appear in
+ supporting documentation, and that the name of M.I.T. not be used in
+ advertising or publicity pertaining to distribution of the software
+ without specific, written prior permission.  M.I.T. makes no
+ representations about the suitability of this software for any
+ purpose.  It is provided "as is" without express or implied warranty.
+ 
+ */
+ /* $XConsortium: skyBitBlt.c,v 1.2 91/11/08 19:31:16 eswu Exp $ */
+ 
+ #include	"X.h"
+ #include	"Xmd.h"
+ #include	"Xproto.h"
+ #include	"gcstruct.h"
+ #include	"windowstr.h"
+ #include	"scrnintstr.h"
+ #include	"pixmapstr.h"
+ #include	"regionstr.h"
+ 
+ #include	"cfb.h"
+ #include	"cfbmskbits.h"
+ #include	"cfb8bit.h"
+ #include	"fastblt.h"
+ 
+ 
+ extern int  cfbDoBitbltCopy();
+ extern int  cfbDoBitbltXor();
+ extern int  cfbDoBitbltOr();
+ extern int  cfbDoBitbltGeneral();
+ extern int  cfbDoBitblt();
+ 
+ extern RegionPtr cfbBitBlt();
+ 
+ 
+ RegionPtr
+ skyCopyArea(pSrcDrawable, pDstDrawable,
+             pGC, srcx, srcy, width, height, dstx, dsty)
+     register DrawablePtr pSrcDrawable;
+     register DrawablePtr pDstDrawable;
+     GC *pGC;
+     int srcx, srcy;
+     int width, height;
+     int dstx, dsty;
+ {
+     int	(*doBitBlt) ();
+     int skyDoBitblt_WinToWin();
+     
+     doBitBlt = cfbDoBitbltCopy;
+ 
+     if ((pSrcDrawable->type == DRAWABLE_WINDOW) &&
+ 	(pDstDrawable->type == DRAWABLE_WINDOW))
+     {
+ 	doBitBlt = skyDoBitblt_WinToWin;
+     }
+     else if (pGC->alu != GXcopy || (pGC->planemask & PMSK) != PMSK)
+     {
+ 	doBitBlt = cfbDoBitbltGeneral;
+ 	if ((pGC->planemask & PMSK) == PMSK)
+ 	{
+ 	    switch (pGC->alu) {
+ 	    case GXxor:
+ 		doBitBlt = cfbDoBitbltXor;
+ 		break;
+ 	    case GXor:
+ 		doBitBlt = cfbDoBitbltOr;
+ 		break;
+ 	    }
+ 	}
+     }
+     return cfbBitBlt (pSrcDrawable, pDstDrawable,
+             pGC, srcx, srcy, width, height, dstx, dsty, doBitBlt, 0);
+ }
+ 
+ 
+ 
+ int
+ skyDoBitblt_WinToWin(pSrc, pDst, alu, prgnDst, pptSrc, planemask)
+     DrawablePtr	    pSrc, pDst;
+     int		    alu;
+     RegionPtr	    prgnDst;
+     DDXPointPtr	    pptSrc;
+     unsigned long   planemask;
+ {
+     BoxPtr pbox;
+     int nbox;
+ 
+     BoxPtr pboxTmp, pboxNext, pboxBase, pboxNew1, pboxNew2;
+ 				/* temporaries for shuffling rectangles */
+     DDXPointPtr pptTmp, pptNew1, pptNew2;
+ 				/* shuffling boxes entails shuffling the
+ 				   source points too */
+     int w, h;
+     int xdir;			/* 1 = left right, -1 = right left/ */
+     int ydir;			/* 1 = top down, -1 = bottom up */
+ 
+     int careful;
+ 
+ 
+     /* XXX we have to err on the side of safety when both are windows,
+      * because we don't know if IncludeInferiors is being used.
+      */
+     careful = ((pSrc == pDst) ||
+ 	       ((pSrc->type == DRAWABLE_WINDOW) &&
+ 		(pDst->type == DRAWABLE_WINDOW)));
+ 
+     pbox = REGION_RECTS(prgnDst);
+     nbox = REGION_NUM_RECTS(prgnDst);
+ 
+     pboxNew1 = NULL;
+     pptNew1 = NULL;
+     pboxNew2 = NULL;
+     pptNew2 = NULL;
+     if (careful && (pptSrc->y < pbox->y1))
+     {
+         /* walk source botttom to top */
+ 	ydir = -1;
+ 
+ 	if (nbox > 1)
+ 	{
+ 	    /* keep ordering in each band, reverse order of bands */
+ 	    pboxNew1 = (BoxPtr)ALLOCATE_LOCAL(sizeof(BoxRec) * nbox);
+ 	    if(!pboxNew1)
+ 		return;
+ 	    pptNew1 = (DDXPointPtr)ALLOCATE_LOCAL(sizeof(DDXPointRec) * nbox);
+ 	    if(!pptNew1)
+ 	    {
+ 	        DEALLOCATE_LOCAL(pboxNew1);
+ 	        return;
+ 	    }
+ 	    pboxBase = pboxNext = pbox+nbox-1;
+ 	    while (pboxBase >= pbox)
+ 	    {
+ 	        while ((pboxNext >= pbox) &&
+ 		       (pboxBase->y1 == pboxNext->y1))
+ 		    pboxNext--;
+ 	        pboxTmp = pboxNext+1;
+ 	        pptTmp = pptSrc + (pboxTmp - pbox);
+ 	        while (pboxTmp <= pboxBase)
+ 	        {
+ 		    *pboxNew1++ = *pboxTmp++;
+ 		    *pptNew1++ = *pptTmp++;
+ 	        }
+ 	        pboxBase = pboxNext;
+ 	    }
+ 	    pboxNew1 -= nbox;
+ 	    pbox = pboxNew1;
+ 	    pptNew1 -= nbox;
+ 	    pptSrc = pptNew1;
+         }
+     }
+     else
+     {
+ 	/* walk source top to bottom */
+ 	ydir = 1;
+     }
+ 
+     if (careful && (pptSrc->x < pbox->x1))
+     {
+ 	/* walk source right to left */
+         xdir = -1;
+ 
+ 	if (nbox > 1)
+ 	{
+ 	    /* reverse order of rects in each band */
+ 	    pboxNew2 = (BoxPtr)ALLOCATE_LOCAL(sizeof(BoxRec) * nbox);
+ 	    pptNew2 = (DDXPointPtr)ALLOCATE_LOCAL(sizeof(DDXPointRec) * nbox);
+ 	    if(!pboxNew2 || !pptNew2)
+ 	    {
+ 		if (pptNew2) DEALLOCATE_LOCAL(pptNew2);
+ 		if (pboxNew2) DEALLOCATE_LOCAL(pboxNew2);
+ 		if (pboxNew1)
+ 		{
+ 		    DEALLOCATE_LOCAL(pptNew1);
+ 		    DEALLOCATE_LOCAL(pboxNew1);
+ 		}
+ 	        return;
+ 	    }
+ 	    pboxBase = pboxNext = pbox;
+ 	    while (pboxBase < pbox+nbox)
+ 	    {
+ 	        while ((pboxNext < pbox+nbox) &&
+ 		       (pboxNext->y1 == pboxBase->y1))
+ 		    pboxNext++;
+ 	        pboxTmp = pboxNext;
+ 	        pptTmp = pptSrc + (pboxTmp - pbox);
+ 	        while (pboxTmp != pboxBase)
+ 	        {
+ 		    *pboxNew2++ = *--pboxTmp;
+ 		    *pptNew2++ = *--pptTmp;
+ 	        }
+ 	        pboxBase = pboxNext;
+ 	    }
+ 	    pboxNew2 -= nbox;
+ 	    pbox = pboxNew2;
+ 	    pptNew2 -= nbox;
+ 	    pptSrc = pptNew2;
+ 	}
+     }
+     else
+     {
+ 	/* walk source left to right */
+         xdir = 1;
+     }
+ 
+     while(nbox--)
+     {
+ 	w = pbox->x2 - pbox->x1;
+ 	h = pbox->y2 - pbox->y1;
+ 
+ 
+ 	/*-------*/
+ 
+ 
+ 	SkywayBitBlt(alu, pDst->pScreen, planemask,
+ 		pptSrc->x, pptSrc->y,	/* source x,y    */
+ 		pbox->x1, pbox->y1,	/* dest x,y      */
+ 		w, h);			/* width, height */
+ 
+ 
+ 	/*-------*/
+ 
+ 	pbox++;
+ 	pptSrc++;
+     }
+ 
+     if (pboxNew2)
+     {
+ 	DEALLOCATE_LOCAL(pptNew2);
+ 	DEALLOCATE_LOCAL(pboxNew2);
+     }
+     if (pboxNew1)
+     {
+ 	DEALLOCATE_LOCAL(pptNew1);
+ 	DEALLOCATE_LOCAL(pboxNew1);
+     }
+ }

*** /tmp/,RCSt1a06291	Thu Nov 14 13:36:52 1991
--- mit/server/ddx/sun/sunMouse.c	Thu Nov 14 13:36:12 1991
***************
*** 1,3 ****
--- 1,4 ----
+ /* $XConsortium: sunMouse.c,v 5.11 91/11/14 13:35:56 keith Exp $ */
  /*-
   * sunMouse.c --
   *	Functions for playing cat and mouse... sorry.
***************
*** 454,460 ****
      register int	  	bmask;	/* Temporary button mask */
      register PtrPrivPtr		pPriv;	/* Private data for pointer */
      register SunMsPrivPtr	pSunPriv; /* Private data for mouse */
!     short			x, y;
      unsigned long		time;
  
      pPriv = (PtrPrivPtr)pMouse->devicePrivate;
--- 455,461 ----
      register int	  	bmask;	/* Temporary button mask */
      register PtrPrivPtr		pPriv;	/* Private data for pointer */
      register SunMsPrivPtr	pSunPriv; /* Private data for mouse */
!     int				x, y;
      unsigned long		time;
  
      pPriv = (PtrPrivPtr)pMouse->devicePrivate;

*** /tmp/,RCSt1000368	Thu Nov 14 17:36:02 1991
--- mit/server/ddx/sun/sunCursor.c	Thu Nov 14 13:57:13 1991
***************
*** 1,3 ****
--- 1,4 ----
+ /* $XConsortium: sunCursor.c,v 5.9 91/11/14 13:57:03 keith Exp $ */
  /*-
   * sunCursor.c --
   *	Functions for maintaining the Sun software cursor...
***************
*** 17,69 ****
  #include    "cursorstr.h"
  
  #ifdef FBIOGCURMAX  /* has hardware cursor kernel support */
- #define CURSOR_PAD  8
  
  #define GetCursorPrivate(s) (&(GetScreenPrivate(s)->hardwareCursor))
  #define SetupCursor(s)	    sunCursorPtr pCurPriv = GetCursorPrivate(s)
- #define CursorByteWidth(w)  (((w) + CURSOR_PAD - 1) / CURSOR_PAD)
  
- static void
- Repad (in, out, sc, w, h)
-     char	    *in, *out;
-     sunCursorPtr    sc;
-     int		    w, h;
- {
-     int	    x, y;
-     char    *a, *b;
-     int	    inwidth, outwidth;
-     char    mask;
- 
-     inwidth = (w + BITMAP_SCANLINE_PAD - 1) / 8;
-     mask = w & 7;
- #if BITMAP_BIT_ORDER == MSBFirst
-     if (mask == 0)
- 	mask = 0xff;
-     else
- 	mask = 0xff << (8-mask);
- #else
-     mask = 0xff >> mask;
- #endif
-     outwidth = CursorByteWidth(sc->width);
-     for (y = 0; y < h; y++) {
- 	a = in;
- 	b = out;
- 	in += inwidth;
- 	out += outwidth;
- 	for (x = 0; x < inwidth; x++)
- 	    *b++ = *a++;
- 	if (inwidth)
- 	    b[-1] &= mask;
- 	for (; x < outwidth; x++)
- 	    *b++ = '\0';
-     }
-     for (; y < sc->height; y++)
-     {
- 	for (x = 0; x < outwidth; x++)
- 	    *b++ = '\0';
-     }
- }
- 
  static Bool
  sunRealizeCursor (pScreen, pCursor)
      ScreenPtr	pScreen;
--- 18,27 ----
***************
*** 80,86 ****
--- 38,90 ----
      return TRUE;
  }
  
+ sunInitFakePixmap (pScreen, p, w, h, bits)
+     ScreenPtr	    pScreen;
+     PixmapPtr	    p;
+     int		    w, h;
+     unsigned char   *bits;
+ {
+     p->drawable.type = DRAWABLE_PIXMAP;
+     p->drawable.class = 0;
+     p->drawable.pScreen = pScreen;
+     p->drawable.depth = 1;
+     p->drawable.bitsPerPixel = 1;
+     p->drawable.id = 0;
+     p->drawable.serialNumber = NEXT_SERIAL_NUMBER;
+     p->drawable.x = 0;
+     p->drawable.y = 0;
+     p->drawable.width = w;
+     p->drawable.height = h;
+     p->devKind = PixmapBytePad(w, 1);
+     p->refcnt = 1;
+     p->devPrivate.ptr = (pointer) bits;
+ }
+ 
  static void
+ sunCursorRepad (pScreen, bits, src_bits, dst_bits, ptSrc, w, h)
+     ScreenPtr	    pScreen;
+     CursorBitsPtr   bits;
+     unsigned char   *src_bits, *dst_bits;
+     DDXPointPtr	    ptSrc;
+     int		    w, h;
+ {
+     SetupCursor(pScreen);
+     PixmapRec	src, dst;
+     BoxRec	box;
+     RegionRec	rgnDst;
+ 
+     sunInitFakePixmap (pScreen, &src, bits->width, bits->height, src_bits);
+     sunInitFakePixmap (pScreen, &dst, w, h, dst_bits);
+     box.x1 = 0;
+     box.y1 = 0;
+     box.x2 = w;
+     box.y2 = h;
+     (*pScreen->RegionInit)(&rgnDst, &box, 1);
+     mfbDoBitblt(&src, &dst, GXcopy, &rgnDst, ptSrc);
+     (*pScreen->RegionUninit)(&rgnDst);
+ }
+ 
+ static void
  sunLoadCursor (pScreen, pCursor, x, y)
      ScreenPtr	pScreen;
      CursorPtr	pCursor;
***************
*** 90,98 ****
      struct fbcursor fbcursor;
      int	w, h;
      unsigned char   r[2], g[2], b[2];
  
-     w = pCursor->bits->width;
-     h = pCursor->bits->height;
      fbcursor.set = FB_CUR_SETALL;
      fbcursor.enable = 1;
      fbcursor.pos.x = x;
--- 94,102 ----
      struct fbcursor fbcursor;
      int	w, h;
      unsigned char   r[2], g[2], b[2];
+     DDXPointRec	ptSrc;
+     unsigned char   source_temp[1024], mask_temp[1024];
  
      fbcursor.set = FB_CUR_SETALL;
      fbcursor.enable = 1;
      fbcursor.pos.x = x;
***************
*** 112,140 ****
      fbcursor.cmap.blue = b;
      fbcursor.image = (char *) pCursor->bits->source;
      fbcursor.mask = (char *) pCursor->bits->mask;
!     if (w > pCurPriv->width)
!     {
! 	while (fbcursor.hot.x > pCurPriv->width && w >= 8)
! 	{
! 	    fbcursor.hot.x -= 8;
! 	    fbcursor.image++;
! 	    fbcursor.mask++;
! 	    w -= 8;
! 	}
  	if (w > pCurPriv->width)
  	    w = pCurPriv->width;
-     }
-     if (h > pCurPriv->height)
-     {
- 	while (fbcursor.hot.y > pCurPriv->height && h >= 8)
- 	{
- 	    fbcursor.hot.y -= 8;
- 	    fbcursor.image += PixmapBytePad (pCursor->bits->width, 1);
- 	    fbcursor.mask +=  PixmapBytePad (pCursor->bits->width, 1);
- 	    h -= 8;
- 	}
  	if (h > pCurPriv->height)
  	    h = pCurPriv->height;
      }
      fbcursor.size.x = w;
      fbcursor.size.y = h;
--- 116,136 ----
      fbcursor.cmap.blue = b;
      fbcursor.image = (char *) pCursor->bits->source;
      fbcursor.mask = (char *) pCursor->bits->mask;
!     w = pCursor->bits->width;
!     h = pCursor->bits->height;
!     if (w > pCurPriv->width || h > pCurPriv->height) {
! 	ptSrc.x = 0;
! 	ptSrc.y = 0;
  	if (w > pCurPriv->width)
  	    w = pCurPriv->width;
  	if (h > pCurPriv->height)
  	    h = pCurPriv->height;
+ 	sunCursorRepad (pScreen, pCursor->bits, pCursor->bits->source,
+ 			source_temp, &ptSrc, w, h);
+ 	sunCursorRepad (pScreen, pCursor->bits, pCursor->bits->mask,
+ 			mask_temp, &ptSrc, w, h);
+ 	fbcursor.image = (char *) source_temp;
+ 	fbcursor.mask = (char *) mask_temp;
      }
      fbcursor.size.x = w;
      fbcursor.size.y = h;
***************
*** 230,235 ****
--- 226,232 ----
  			 &sunPointerScreenFuncs,
  			 FALSE);
      pCurPriv->has_cursor = TRUE;
+     return TRUE;
  #else
      return FALSE;
  #endif
***************
*** 323,332 ****
      return TRUE;
  }
  #endif
- 
- 
- 
- 
- 
- 
- 
--- 320,322 ----

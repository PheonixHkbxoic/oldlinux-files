		      Release 5 Public Patch #5
			   MIT X Consortium

To apply this patch:

cd to the top of the source tree (to the directory containing the "mit"
and "contrib" subdirectories) and do:
	patch -p -s < ThisFile
Patch will work silently unless an error occurs.
If you want to watch patch do its thing, leave out the "-s" argument to patch.

Finally, to rebuild after applying this patch, cd to the "mit" subdirectory
and do:
	make -k >& make.log
Note: this will *not* "clean" your tree.

Brief notes on what this patch fixes:

Xlib: (Ximp) a variety of problems with internationalization code

Prereq: public-patch-4

*** /tmp/,RCSt1002064	Mon Oct 28 16:33:02 1991
--- mit/bug-report	Mon Oct 28 16:33:03 1991
***************
*** 2,8 ****
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-4
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:
--- 2,8 ----
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-5
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:

*** /tmp/,RCSt1001547	Mon Oct 28 15:36:53 1991
--- mit/lib/X/Ximp/XIMProto.h	Thu Oct 10 20:41:37 1991
***************
*** 1,4 ****
! /* $XConsortium: XIMProto.h,v 1.2 91/07/09 17:21:31 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: XIMProto.h,v 1.4 91/10/10 20:41:32 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by FUJITSU LIMITED
***************
*** 27,34 ****
  
  ******************************************************************/
  
  /* Ximp Protocol Version */
! #define XIMP_PROTOCOL_VERSION "XIMP.3.3"
  
  /* Input Context ID */
  typedef unsigned long	ICID;
--- 27,37 ----
  
  ******************************************************************/
  
+ /* Ximp implementation revision */
+ #define XIMP_REVISION "Ximp Revision 3.1"
+ 
  /* Ximp Protocol Version */
! #define XIMP_PROTOCOL_VERSION "XIMP.3.5"
  
  /* Input Context ID */
  typedef unsigned long	ICID;
***************
*** 78,83 ****
--- 81,87 ----
  #define  XIMP_STATUSDONE	47
  #define  XIMP_STATUSDRAW	48
  #define  XIMP_STATUSDRAW_CM	49
+ #define  XIMP_PREEDITDRAW_TINY	50
  
  /* Extension Protocol */
  #define  XIMP_EXTENSION		90
***************
*** 129,140 ****
  #define  _XIMP_CTEXT		"_XIMP_CTEXT"
  
  /* CallBack Property Name */
! #define  _XIMP_PREEDITDRAW_DATA		"_XIMP_PREEDITDRAW_DATA"
! #define  _XIMP_FEEDBACKS		"_XIMP_FEEDBACKS"
! #define  _XIMP_PREEDITDRAWLENGTH 	"_XIMP_PREEDITDRAWLENGTH"
! #define  _XIMP_PREEDITDRAWSTRING 	"_XIMP_PREEDITDRAWSTRING"
! #define  _XIMP_PREEDITDRAWFEEDBACK 	"_XIMP_PREEDITDRAWFEEDBACK"
  
  /* mask (XIMP_CREATE, XIMP_SETVALUE, XIMP_GETVALUE) */
  #define XIMP_FOCUS_WIN_MASK		(1L <<  0)
  #define XIMP_PRE_AREA_MASK		(1L <<  1)
--- 133,160 ----
  #define  _XIMP_CTEXT		"_XIMP_CTEXT"
  
  /* CallBack Property Name */
! #define  _XIMP_PREEDIT_DRAW_DATA		"_XIMP_PREEDIT_DRAW_DATA"
! #define  _XIMP_FEEDBACKS			"_XIMP_FEEDBACKS"
! #define  _XIMP_PREEDITDRAWLENGTH 		"_XIMP_PREEDITDRAWLENGTH"
! #define  _XIMP_PREEDITDRAWSTRING 		"_XIMP_PREEDITDRAWSTRING"
! #define  _XIMP_PREEDITDRAWFEEDBACK 		"_XIMP_PREEDITDRAWFEEDBACK"
  
+ #define  _XIMP_EXT_XIMP_CHOICE_START_REQ	"_XIMP_EXT_XIMP_CHOICE_START_REQ"
+ #define  _XIMP_EXT_XIMP_CHOICE_START_REP	"_XIMP_EXT_XIMP_CHOICE_START_REP"
+ #define  _XIMP_EXT_XIMP_CHOICE_DRAW_REQ		"_XIMP_EXT_XIMP_CHOICE_DRAW_REQ"
+ #define  _XIMP_EXT_XIMP_CHOICE_PROC_REQ		"_XIMP_EXT_XIMP_CHOICE_PROC_REQ"
+ #define  _XIMP_EXT_XIMP_CHOICE_PROC_REP		"_XIMP_EXT_XIMP_CHOICE_PROC_REP"
+ #define  _XIMP_EXT_XIMP_LOOKUPCHOICES		"_XIMP_EXT_XIMP_LOOKUPCHOICES"
+ 
+ /* Lookup choices REQ and REP */
+ #define  LOOKUP_CHOICES_BEGIN	        0
+ #define  LOOKUP_CHOICES_START_REQ	1
+ #define  LOOKUP_CHOICES_START_REP	2
+ #define  LOOKUP_CHOICES_PROCESS_REQ	3
+ #define  LOOKUP_CHOICES_PROCESS_REP	4
+ #define  LOOKUP_CHOICES_DRAW_REQ	5
+ #define  LOOKUP_CHOICES_DONE_REQ	6
+ 
  /* mask (XIMP_CREATE, XIMP_SETVALUE, XIMP_GETVALUE) */
  #define XIMP_FOCUS_WIN_MASK		(1L <<  0)
  #define XIMP_PRE_AREA_MASK		(1L <<  1)
***************
*** 162,167 ****
--- 182,212 ----
  #define XIMP_FRONTEND	 0
  #define XIMP_BACKEND	 1
  
+ /*  XIMP_PREEDITDRAW_CM status value
+  * post Ximp 3.4 protocol maybe compliant. 
+  * XIMP status flag will may contain the supplementary infomations to 
+  * reassemble the XIMPreeditDrawCallbackStruct.
+  *	  +-----------------------------------------+
+  *	0 | XIMP_PREEDITDRAW_CM                     |
+  *	  +-----------------------------------------+
+  *	4 | ICID                                    |
+  *	  +-------------------+---------------------+
+  *	8 |PreeditDrawCBStatus|       caret         |
+  *	  +-------------------+---------------------+
+  *	12|      chg_first    |      chg_length     |
+  *	  +-------------------+---------------------+
+  *	16|               feedback                  |
+  *	  +-----------------------------------------+
+  * PreeditDrawCBStatus:
+  *    0x0001 no_text:  if 1, string == NULL (no following client message.)
+  *    0x0002 no_feedback: if 1 feedback == NULL
+  *    0x0004 feedbacks_via_property: if 1 , feedback field is property atom#
+  **/
+ 
+ #define XIMP_PDCBSTATUS_NOTEXT 			0x0001
+ #define XIMP_PDCBSTATUS_NOFEEDBACK 		0x0002
+ #define XIMP_PDCBSTATUS_FEEDBACKS_VIA_PROP	0x0004
+ 
  /* _XIMP_KEYS   struct  */
  
  typedef struct {
***************
*** 230,232 ****
--- 275,296 ----
  	long chg_first;
  	long chg_length;
  } Ximp_PreeditDrawDataPropRec, *Ximp_PreeditDrawDataProp;
+ 
+ /* for Commit, PreEditDraw, StatusDraw */
+ typedef struct _Ximp_CommitPropRec {
+ 	unsigned long   icid;
+ 	char            size;
+ 	char            ctext[11];
+ } Ximp_CommitPropRec, Ximp_PreEditDrawCallbackPropRec,
+   Ximp_StatusDrawCallbackPropRec;
+ 
+ /* for PreEditDraw */
+ typedef struct {
+ 	short           chg_first;
+ 	short           chg_length;
+ } Ximp_slong;
+ 
+ typedef union {
+ 	Ximp_slong      slong;
+ 	long            l;
+ } Ximp_uslong;

*** /tmp/,RCSt1001569	Mon Oct 28 15:37:32 1991
--- mit/lib/X/Ximp/XimpCallbk.c	Mon Oct  7 17:47:42 1991
***************
*** 1,547 ****
! /* $XConsortium: XimpCallbk.c,v 1.3 91/07/09 17:21:33 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by Fuji Xerox Co.,Ltd.
                Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
! provided that the above copyright notice appear in all copies and
! that both that copyright notice and this permission notice appear
! in supporting documentation, and that the name of Fuji Xerox Co.,Ltd.,
! FUJITSU LIMITED not be used in advertising or publicity pertaining to
! distribution of the software without specific, written prior permission.
! Fuji Xerox Co.,Ltd., FUJITSU LIMITED makes no representations about
! the suitability of this software for any purpose.
! It is provided "as is" without express or implied warranty.
  
! FUJI XEROX CO.,LTD., FUJITSU LIMITED DISCLAIMS ALL WARRANTIES WITH
! REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
! AND FITNESS, IN NO EVENT SHALL FUJI XEROX CO.,LTD., FUJITSU LIMITED
! BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
! OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  
    Auther: Kazunori Nishihara,  Fuji Xerox Co.,Ltd.
                                 kaz@ssdev.ksp.fujixerox.co.jp
!           Takashi Fujiwara     FUJITSU LIMITED 
                                 fujiwara@a80.tech.yk.fujitsu.co.jp
! 
  ******************************************************************/
  
  #define NEED_EVENTS
  #include "Xlibint.h"
  #include "Xlcint.h"
  
  #include "Ximplc.h"
  
  #define XIMP_MAXBUF	256
  
  void
  _Ximp_CallGeometryCallback(xic, event)
! Ximp_XIC xic;
! XClientMessageEvent *event;
  {
! 	register XIMCallback *cb;
  
! 	cb = &xic->core.geometry_callback;
! 	if (cb->callback) {
! 		(*cb->callback)(xic, cb->client_data, NULL);
! 	}
  }
  
  void
  _Ximp_CallPreeditStartCallback(xic, event)
! Ximp_XIC xic;
! XClientMessageEvent *event;
  {
! 	register XIMCallback *cb;
! 	static XClientMessageEvent clmsg;
  
! 	clmsg.type = ClientMessage;
! 	clmsg.display = xic->core.im->core.display;
! 	clmsg.window = ((Ximp_XIM)xic->core.im)->ximp_impart->fe_window;
! 	clmsg.message_type = ((Ximp_XIM)xic->core.im)->ximp_impart->improtocol_id;
! 	clmsg.format = 32;
! 	clmsg.data.l[0] = XIMP_PREEDITSTART_RETURN;
! 	clmsg.data.l[1] = xic->ximp_icpart->icid;
! 	cb = &xic->core.preedit_attr.callbacks.start;
! 	if (cb->callback) {
! 		clmsg.data.l[2] = (*(int (*)())cb->callback)(xic, cb->client_data, NULL);
  
! 	}else {
! 		clmsg.data.l[2] = -1;
! 	}
! 	XSendEvent(xic->core.im->core.display,
! 		   ((Ximp_XIM)xic->core.im)->ximp_impart->fe_window,
! 		   False, NoEventMask, (XEvent *)&clmsg);
! 	XFlush(xic->core.im->core.display);
  }
  
  void
  _Ximp_CallPreeditDoneCallback(xic, event)
! Ximp_XIC xic;
! XClientMessageEvent *event;
  {
! 	register XIMCallback *cb;
  
! 	cb = &xic->core.preedit_attr.callbacks.done;
! 	if (cb->callback) {
! 		(*cb->callback)(xic, cb->client_data, NULL);
! 	}
  }
  
  void
  _Ximp_CallPreeditDrawCallback(xic, event)
! Ximp_XIC xic;
! XClientMessageEvent *event;
  {
! 	register XIMCallback *cb;
! 	XIMPreeditDrawCallbackStruct CallData;
! 	XIMText cbtext;
! 	char *text;
! 	int length;
! 	Atom type;
! 	int format;
! 	unsigned long nitems, after;
! 	Ximp_PreeditDrawDataProp data;
  
! 	cb = &xic->core.preedit_attr.callbacks.draw;
! 	if (cb->callback) {
! 		if (XGetWindowProperty(xic->core.im->core.display,
! 			((Ximp_XIM)xic->core.im)->ximp_impart->fe_window,
! 			event->data.l[2], 0, 3, True, AnyPropertyType,
! 			&type, &format, &nitems, &after,
! 			(unsigned char **)&data) == Success) {
! 			CallData.caret = data->caret;
! 			CallData.chg_first = data->chg_first;
! 			CallData.chg_length = data->chg_length;
! 			Xfree(data);
! 		} else {
! 			/* Error */
! 			CallData.chg_length = -1;
! 		}
! 		if (XGetWindowProperty(xic->core.im->core.display,
! 			((Ximp_XIM)xic->core.im)->ximp_impart->fe_window,
! 			event->data.l[4], 0, 4096, True, AnyPropertyType,
! 			&type, &format, &nitems, &after,
! 			(unsigned char **)&cbtext.feedback) == Success) {
! 			cbtext.length = nitems;
! 		} else {
! 			cbtext.feedback = NULL;
! 			cbtext.length = 0;
! 		}
! 		if(XGetWindowProperty(xic->core.im->core.display,
! 			((Ximp_XIM)xic->core.im)->ximp_impart->fe_window,
! 			event->data.l[3], 0, 4096, True, AnyPropertyType,
! 			&type, &format, &nitems, &after,
! 			(unsigned char **)&text) == Success) {
! #ifndef USE_WIDE_CHAR
! 			cbtext.string.multi_byte = Xmalloc(XIMP_MAXBUF + 1);
! 			length = XIMP_MAXBUF;
! 			_Ximp_cttombs(xic->core.im->core.lcd, text, nitems,
! 						cbtext.string.multi_byte,
! 						&length, NULL);
! 			if (cbtext.feedback == NULL) {
! 				wchar_t *junc = (wchar_t *)Xmalloc(sizeof(wchar_t) * (XIMP_MAXBUF + 1));
! 				length = XIMP_MAXBUF;
! 				_Ximp_cttowcs(xic->core.im->core.lcd, text, nitems,
! 							junc,
! 							&length, NULL);
! 				cbtext.length = length;
! 				Xfree(junc);
  			}
  			cbtext.encoding_is_wchar = False;
! #else USE_WIDE_CHAR
! 			cbtext.string.wide_char = (wchar_t *)Xmalloc(sizeof(wchar_t) * (XIMP_MAXBUF + 1));
! 			length = XIMP_MAXBUF;
! 			_Ximp_cttowcs(xic->core.im->core.lcd, text, nitems,
! 						cbtext.string.wide_char,
! 						&length, NULL);
! 			if (cbtext.feedback == NULL) {
  				cbtext.length = length;
  			}
! 			cbtext.encoding_is_wchar = True;
! #endif USE_WIDE_CHAR
! 			Xfree((XPointer)text);
  		} else {
! 			cbtext.string.multi_byte = NULL;
  		}
! 		CallData.text = &cbtext;
! 		(*cb->callback)(xic, cb->client_data, &CallData);
! #ifndef USE_WIDE_CHAR
! 		if (cbtext.string.multi_byte) {
! 			Xfree((XPointer)(cbtext.string.multi_byte));
! 		}
! #else USE_WIDE_CHAR
! 		if (cbtext.string.wide_char) {
! 			Xfree((XPointer)(cbtext.string.wide_char));
! 		}
! #endif USE_WIDE_CHAR
! 		if (cbtext.feedback) Xfree((XPointer)cbtext.feedback);
  	} else {
! 		if (XGetWindowProperty(xic->core.im->core.display,
! 			((Ximp_XIM)xic->core.im)->ximp_impart->fe_window,
! 			event->data.l[2], 0, 3, True, AnyPropertyType,
! 			&type, &format, &nitems, &after,
! 			(unsigned char **)&data) == Success) {
! 			Xfree(data);
! 		}
! 		if (XGetWindowProperty(xic->core.im->core.display,
! 			((Ximp_XIM)xic->core.im)->ximp_impart->fe_window,
! 			event->data.l[4], 0, 4096, True, AnyPropertyType,
! 			&type, &format, &nitems, &after,
! 			(unsigned char **)&cbtext.feedback) == Success) {
! 			Xfree(cbtext.feedback);
! 		}
! 		if(XGetWindowProperty(xic->core.im->core.display,
! 			((Ximp_XIM)xic->core.im)->ximp_impart->fe_window,
! 			event->data.l[3], 0, 4096, True, AnyPropertyType,
! 			&type, &format, &nitems, &after,
! 			(unsigned char **)&text) == Success) {
! 			Xfree(text);
! 		}
  	}
  }
  
! static int	 _time_flag = 0;
  #ifdef XIMP_SIGNAL
  static int
  _time_out()
  {
! 	_time_flag = 1;
  }
! #endif /* XIMP_SIGNAL */
  
  void
  _Ximp_CallPreeditDrawCallback2(xic, event)
! Ximp_XIC xic;
! XClientMessageEvent *event;
  {
! 	register XIMCallback *cb;
! 	XIMPreeditDrawCallbackStruct CallData;
! 	XIMText cbtext;
! 	char *text;
! 	int length;
! 	XEvent ev;
  
! 	cb = &xic->core.preedit_attr.callbacks.draw;
  
! 	CallData.caret = event->data.l[2];
! 	CallData.chg_first = (long)((event->data.l[3] >> 16) & 0xffffl);
! 	CallData.chg_length =  (long)(event->data.l[3] & 0xffffl);
! 	CallData.text = &cbtext;
  
  #ifdef XIMP_SIGNAL
! 	signal(SIGALRM, _time_out);
! 	alarm(XIMP_TIME_OUT);
! #endif /* XIMP_SIGNAL */
! 	while(_time_flag != 1) {
! 		if( (XCheckTypedEvent(xic->core.im->core.display, ClientMessage, &ev)) == False) {
  #ifdef XIMP_SIGNAL
! 			sleep(1);
! #endif /* XIMP_SIGNAL */
! 			continue;
  		}
! 		if(ev.xclient.message_type != ((Ximp_XIM)xic->core.im)->ximp_impart->improtocol_id) {
! 			XPutBackEvent(xic->core.im->core.display, &ev);
! 			continue;
! 		}
! 		else {
  #ifdef XIMP_SIGNAL
! 			alarm(0);
! #endif /* XIMP_SIGNAL */
! 			break;
  		}
! 	}
! 	if (cb->callback) {
! 		_time_flag = 0;
! 		length = XIMP_MAXBUF;
! #ifndef USE_WIDE_CHAR
! 		cbtext.string.multi_byte = Xmalloc(XIMP_MAXBUF + 1);
  		cbtext.encoding_is_wchar = False;
! 		_Ximp_cttombs(xic->core.im->core.lcd,
! 					&ev.xclient.data.b[5], ev.xclient.data.b[4],
! 					cbtext.string.multi_byte,
! 					&length, NULL);
! 		{
! 			wchar_t *junc = (wchar_t *)Xmalloc(XIMP_MAXBUF * sizeof(wchar_t));
! 			_Ximp_cttowcs(xic->core.im->core.lcd,
! 						&ev.xclient.data.b[5], ev.xclient.data.b[4],
! 						junc,
! 						&length, NULL);
! 			Xfree(junc);
  		}
! #else USE_WIDE_CHAR
! 		cbtext.string.wide_char = (wchar_t *)Xmalloc((XIMP_MAXBUF + 1) * sizeof(wchar_t));
! 		cbtext.encoding_is_wchar = True;
! 		_Ximp_cttombs(xic->core.im->core.lcd,
! 					&ev.xclient.data.b[5], ev.xclient.data.b[4],
! 					cbtext.string.wide_char,
! 					&length, NULL);
! #endif USE_WIDE_CHAR
  		cbtext.length = length;
! 		if (event->data.l[4] != -1) {
! 			int i;
! 
! 			cbtext.feedback = (XIMFeedback *)Xmalloc(cbtext.length * sizeof(XIMFeedback));
! 			for (i = 0; i < (int)cbtext.length; i++) {
! 				cbtext.feedback[i] = event->data.l[4];
! 			}
! 		} else {
! 			cbtext.feedback = NULL;
  		}
! 		(*cb->callback)(xic, cb->client_data, &CallData);
! #ifndef USE_WIDE_CHAR
! 		if (cbtext.string.multi_byte) Xfree((XPointer)(cbtext.string.multi_byte));
! #else USE_WIDE_CHAR
! 		if (cbtext.string.wide_char) Xfree((XPointer)(cbtext.string.wide_char));
! #endif USE_WIDE_CHAR
! 		if (cbtext.feedback) Xfree((XPointer)cbtext.feedback);
  	}
  }
  
  void
  _Ximp_CallPreeditCaretCallback(xic, event)
! Ximp_XIC xic;
! XClientMessageEvent *event;
  {
! 	register XIMCallback *cb;
! 	XIMPreeditCaretCallbackStruct CallData;
  #define ToXIMCaretStyle(x) ((XIMCaretStyle)(x))
  #define ToXIMCaretDirection(x) ((XIMCaretDirection)(x))
  
! 	cb = &xic->core.preedit_attr.callbacks.caret;
! 	if (cb->callback) {
! #ifndef RET_NEW_POS
! 		static XClientMessageEvent clmsg;
! #endif /* RET_NEW_POS */
! 		CallData.position = event->data.l[2];
! 		CallData.direction = ToXIMCaretDirection(event->data.l[3]);
! 		CallData.style = ToXIMCaretStyle(event->data.l[4]);
! 		(*cb->callback)(xic, cb->client_data, &CallData);
! #ifndef RET_NEW_POS
! 		clmsg.type = ClientMessage;
! 		clmsg.display = xic->core.im->core.display;
! 		clmsg.window = ((Ximp_XIM)xic->core.im)->ximp_impart->fe_window;
! 		clmsg.message_type = ((Ximp_XIM)xic->core.im)->ximp_impart->improtocol_id;
! 		clmsg.format = 32;
! 		clmsg.data.l[0] = XIMP_PREEDITCARET_RETURN;
! 		clmsg.data.l[1] = xic->ximp_icpart->icid;
! 		clmsg.data.l[2] = CallData.position;;
  
! 		XSendEvent(xic->core.im->core.display,
! 			((Ximp_XIM)xic->core.im)->ximp_impart->fe_window,
! 			False, NoEventMask, &clmsg);
! 		XFlush(xic->core.im->core.display);
! #endif /* RET_NEW_POS */
! 	}
  }
  
  void
  _Ximp_CallStatusStartCallback(xic, event)
! Ximp_XIC xic;
! XClientMessageEvent *event;
  {
! 	register XIMCallback *cb;
  
! 	cb = &xic->core.status_attr.callbacks.start;
! 	if (cb->callback) {
! 		(*cb->callback)(xic, cb->client_data, NULL);
! 	}
  }
  
  void
  _Ximp_CallStatusDoneCallback(xic, event)
! Ximp_XIC xic;
! XClientMessageEvent *event;
  {
! 	register XIMCallback *cb;
  
! 	cb = &xic->core.status_attr.callbacks.done;
! 	if (cb->callback) {
! 		(*cb->callback)(xic, cb->client_data, NULL);
! 	}
  }
  
  void
  _Ximp_CallStatusDrawCallback(xic, event)
! Ximp_XIC xic;
! XClientMessageEvent *event;
  {
! 	register XIMCallback *cb;
! 	char *text;
! 	int length;
! 	XIMStatusDrawCallbackStruct CallData;
! 	XIMText cbtext;
  
  #define ToXIMStatusDataType(x) ((XIMStatusDataType)(x))
  
! 	cb = &xic->core.status_attr.callbacks.draw;
! 	CallData.type = ToXIMStatusDataType(event->data.l[2]);
! 	if (CallData.type == XIMTextType) {
! 		Atom type;
! 		int format;
! 		unsigned long nitems, after;
! 		CallData.data.text = &cbtext;
! 		if (XGetWindowProperty(xic->core.im->core.display,
! 			((Ximp_XIM)xic->core.im)->ximp_impart->fe_window,
! 			event->data.l[4], 0, 4096, True, AnyPropertyType,
! 			&type, &format, &nitems, &after,
! 			(unsigned char **)&cbtext.feedback) == Success) {
! 			cbtext.length = nitems;
! 		} else {
! 			cbtext.feedback = NULL;
! 			cbtext.length = 0;
  		}
! 		if (XGetWindowProperty(xic->core.im->core.display,
! 			((Ximp_XIM)xic->core.im)->ximp_impart->fe_window,
! 			event->data.l[3], 0, 4096, True, AnyPropertyType,
! 			&type, &format, &nitems, &after,
! 			(unsigned char **)&text) == Success) {
! #ifndef USE_WIDE_CHAR
! 			cbtext.string.multi_byte = Xmalloc(XIMP_MAXBUF + 1);
! 			length = XIMP_MAXBUF;
! 			_Ximp_cttombs(xic->core.im->core.lcd, text, nitems,
! 						cbtext.string.multi_byte,
! 						&length, NULL);
! 			if (cbtext.length == 0) {
! 				wchar_t *junc = (wchar_t *)Xmalloc((XIMP_MAXBUF + 1) * sizeof(wchar_t));
! 				length = XIMP_MAXBUF;
! 				_Ximp_cttowcs(xic->core.im->core.lcd, text,
! 							nitems, junc, &length, NULL);
! 				cbtext.length = length;
! 				Xfree((XPointer)junc);
! 			}
! 			Xfree((XPointer)text);
! 			cbtext.encoding_is_wchar = False;
! #else USE_WIDE_CHAR
! 			cbtext.string.wide_char = (wchar_t *)Xmalloc((XIMP_MAXBUF + 1) * sizeof(wchar_t));
! 			length = XIMP_MAXBUF;
! 			_Ximp_cttowcs(xic->core.im->core.lcd, text, nitems,
! 						cbtext.string.wide_char,
! 						&length, NULL);
! 			cbtext.length = length;
! 			Xfree((XPointer)text);
! 			cbtext.encoding_is_wchar = True;
! #endif USE_WIDE_CHAR
! 		} else {
! #ifndef USE_WIDE_CHAR
! 			cbtext.string.multi_byte = Xmalloc(1);
! 			cbtext.string.multi_byte[0] = 0;
! 			cbtext.length = 0;
! #else USE_WIDE_CHAR
! 			cbtext.string.wide_char = (wchar_t *)Xmalloc(sizeof(wchar_t));
! 			cbtext.string.wide_char[0] = 0;
! 			cbtext.length = 0;
! #endif USE_WIDE_CHAR
  		}
! 		if (cb->callback) {
! 				(*cb->callback)(xic, cb->client_data, &CallData);
  		}
! #ifndef USE_WIDE_CHAR
! 		Xfree((XPointer)(cbtext.string.multi_byte));
! #else USE_WIDE_CHAR
! 		Xfree((XPointer)(cbtext.string.wide_char));
! #endif USE_WIDE_CHAR
! 		if (cbtext.feedback) Xfree((XPointer)cbtext.feedback);
! 	} else { /* XIMBitmapType */
! 		CallData.data.bitmap = (Pixmap)event->data.l[3];
! 		if (cb->callback) {
! 				(*cb->callback)(xic, cb->client_data, &CallData);
! 		}
  	}
  }
  
  void
  _Ximp_CallStatusDrawCallback2(xic, event)
! Ximp_XIC xic;
! XClientMessageEvent *event;
  {
! 	register XIMCallback *cb;
! 	char *text;
! 	int length;
! 	XIMStatusDrawCallbackStruct CallData;
! 	XIMText cbtext;
! 	XEvent ev;
  
! 	cb = &xic->core.status_attr.callbacks.draw;
! 	CallData.type = ToXIMStatusDataType(event->data.l[2]);
! 	if (CallData.type == XIMTextType) {
! 		CallData.data.text = &cbtext;
  
  #ifdef XIMP_SIGNAL
! 		signal(SIGALRM, _time_out);
! 		alarm(XIMP_TIME_OUT);
! #endif /* XIMP_SIGNAL */
! 		while(_time_flag != 1) {
! 			if( (XCheckTypedEvent(xic->core.im->core.display, ClientMessage, &ev)) == False) {
  #ifdef XIMP_SIGNAL
! 				sleep(1);
! #endif /* XIMP_SIGNAL */
! 				continue;
! 			}
! 			if(ev.xclient.message_type != ((Ximp_XIM)xic->core.im)->ximp_impart->improtocol_id) {
! 				XPutBackEvent(xic->core.im->core.display, &ev);
! 				continue;
! 			}
! 			else {
  #ifdef XIMP_SIGNAL
! 				alarm(0);
! #endif /* XIMP_SIGNAL */
! 				break;
! 			}
  		}
! 		_time_flag = 0;
! 		if (cb->callback) {
! 			length = XIMP_MAXBUF;
! #ifndef USE_WIDE_CHAR
! 			cbtext.string.multi_byte = Xmalloc(XIMP_MAXBUF + 1);
! 			cbtext.encoding_is_wchar = False;
! 			_Ximp_cttombs(xic->core.im->core.lcd,
! 						&ev.xclient.data.b[5], ev.xclient.data.b[4],
! 						cbtext.string.multi_byte,
! 						&length, NULL);
! 			{
! 				wchar_t *junc = (wchar_t *)Xmalloc(XIMP_MAXBUF * sizeof(wchar_t));
! 				_Ximp_cttowcs(xic->core.im->core.lcd,
! 							&ev.xclient.data.b[5], ev.xclient.data.b[4],
! 							junc,
! 							&length, NULL);
! 				Xfree(junc);
! 			}
! #else USE_WIDE_CHAR
! 			cbtext.string.wide_char = (wchar_t *)Xmalloc((XIMP_MAXBUF + 1) * sizeof(wchar_t));
! 			cbtext.encoding_is_wchar = True;
! 			_Ximp_cttombs(xic->core.im->core.lcd,
! 						&ev.xclient.data.b[5], ev.xclient.data.b[4],
! 						cbtext.string.wide_char,
! 						&length, NULL);
! #endif USE_WIDE_CHAR
! 			cbtext.length = length;
! 			if (event->data.l[4] != -1) {
! 				int i;
! 
! 				cbtext.feedback = (XIMFeedback *)Xmalloc(cbtext.length * sizeof(long));
! 				for (i = 0; i < (int)cbtext.length; i++) {
! 					cbtext.feedback[i] = event->data.l[4];
! 				}
! 			} else {
! 				cbtext.feedback = NULL;
! 			}
! 			(*cb->callback)(xic, cb->client_data, &CallData);
! #ifndef USE_WIDE_CHAR
! 			Xfree((XPointer)(cbtext.string.multi_byte));
! #else USE_WIDE_CHAR
! 			Xfree((XPointer)(cbtext.string.wide_char));
! #endif USE_WIDE_CHAR
! 			Xfree((XPointer)cbtext.feedback);
  		}
! 	} else { /* XIMBitmapType */
! 		if (cb->callback) {
! 			CallData.data.bitmap = (Pixmap)event->data.l[3];
! 			(*cb->callback)(xic, cb->client_data, &CallData);
  		}
  	}
  }
--- 1,758 ----
! /* $XConsortium: XimpCallbk.c,v 1.4 91/10/07 17:47:37 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by Fuji Xerox Co.,Ltd.
                Copyright 1991, by FUJITSU LIMITED
+               Copyright 1991, by Sun Microsystems, Inc.
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
! provided that the above copyright notice appear in all copies and that
! both that copyright notice and this permission notice appear in
! supporting documentation, and that the name of Fuji Xerox Co.,Ltd.,
! FUJITSU LIMITED, Sun Microsystems, Inc. not be used in advertising or
! publicity pertaining to distribution of the software without specific,
! written prior permission.  Fuji Xerox Co.,Ltd., FUJITSU LIMITED makes
! no representations about the suitability of this software for any
! purpose.  It is provided "as is" without express or implied warranty.
  
! FUJI XEROX CO.,LTD., FUJITSU LIMITED, SUN MICROSYSTEMS DISCLAIMS ALL
! WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
! WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJI
! XEROX CO.,LTD., FUJITSU LIMITED, SUN MICROSYSTEMS BE LIABLE FOR ANY
! SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
! RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
! CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  
    Auther: Kazunori Nishihara,  Fuji Xerox Co.,Ltd.
                                 kaz@ssdev.ksp.fujixerox.co.jp
!           Takashi Fujiwara     FUJITSU LIMITED
                                 fujiwara@a80.tech.yk.fujitsu.co.jp
! 	  Hideki Hiura         hhiura@Sun.COM
! 	  		       Sun Microsystems, Inc.
  ******************************************************************/
  
  #define NEED_EVENTS
  #include "Xlibint.h"
  #include "Xlcint.h"
+ #include "Xlibnet.h"
  
  #include "Ximplc.h"
  
  #define XIMP_MAXBUF	256
  
+ 
  void
  _Ximp_CallGeometryCallback(xic, event)
!     Ximp_XIC        xic;
!     XClientMessageEvent *event;
  {
!     register XIMCallback *cb;
  
!     cb = &xic->core.geometry_callback;
!     if (cb->callback) {
! 	(*cb->callback) (xic, cb->client_data, NULL);
!     }
  }
  
  void
  _Ximp_CallPreeditStartCallback(xic, event)
!     Ximp_XIC        xic;
!     XClientMessageEvent *event;
  {
!     register XIMCallback *cb;
!     static XClientMessageEvent clmsg;
  
!     clmsg.type = ClientMessage;
!     clmsg.display = xic->core.im->core.display;
!     clmsg.window = ((Ximp_XIM) xic->core.im)->ximp_impart->fe_window;
!     clmsg.message_type = ((Ximp_XIM) xic->core.im)->ximp_impart->improtocol_id;
!     clmsg.format = 32;
!     clmsg.data.l[0] = XIMP_PREEDITSTART_RETURN;
!     clmsg.data.l[1] = xic->ximp_icpart->icid;
!     cb = &xic->core.preedit_attr.callbacks.start;
!     if (cb->callback) {
! 	clmsg.data.l[2] = (*(int (*) ()) cb->callback) (xic, cb->client_data, NULL);
  
!     } else {
! 	clmsg.data.l[2] = -1;
!     }
!     XSendEvent(xic->core.im->core.display,
! 	       ((Ximp_XIM) xic->core.im)->ximp_impart->fe_window,
! 	       False, NoEventMask, (XEvent *) & clmsg);
!     XFlush(xic->core.im->core.display);
  }
  
  void
  _Ximp_CallPreeditDoneCallback(xic, event)
!     Ximp_XIC        xic;
!     XClientMessageEvent *event;
  {
!     register XIMCallback *cb;
  
!     cb = &xic->core.preedit_attr.callbacks.done;
!     if (cb->callback) {
! 	(*cb->callback) (xic, cb->client_data, NULL);
!     }
  }
  
  void
  _Ximp_CallPreeditDrawCallback(xic, event)
!     Ximp_XIC        xic;
!     XClientMessageEvent *event;
  {
!     register XIMCallback *cb;
!     XIMPreeditDrawCallbackStruct CallData;
!     XIMText         cbtext;
!     char           *ctext;
!     int             length;
!     Atom            type;
!     int             format;
!     unsigned long   nitems, after;
!     Ximp_PreeditDrawDataProp data;
  
!     bzero(&CallData, sizeof(XIMPreeditDrawCallbackStruct));
!     bzero(&cbtext, sizeof(XIMText));
!     bzero(&data, sizeof(Ximp_PreeditDrawDataProp));
! 
!     cb = &xic->core.preedit_attr.callbacks.draw;
!     if (cb->callback) {
! 	if (XGetWindowProperty(xic->core.im->core.display,
! 			  ((Ximp_XIM) xic->core.im)->ximp_impart->fe_window,
! 			       event->data.l[2], 0, 3, True, AnyPropertyType,
! 			       &type, &format, &nitems, &after,
! 			       (unsigned char **) &data) == Success) {
! 	    if (data) {
! 		CallData.caret = data->caret;
! 		CallData.chg_first = data->chg_first;
! 		CallData.chg_length = data->chg_length;
! 		Xfree(data);
! 	    } else {
! 		CallData.caret = 0;
! 		CallData.chg_first = 0;
! 		CallData.chg_length = 0;
! 	    }
! 	} else {
! 	    /* Error */
! 	    CallData.chg_length = -1;
! 	}
! 	if (event->data.l[4]) {
! 	    if (XGetWindowProperty(xic->core.im->core.display,
! 				   ((Ximp_XIM) xic->core.im)->ximp_impart->fe_window,
! 				   event->data.l[4], 0, 4096, True, AnyPropertyType,
! 				   &type, &format, &nitems, &after,
! 				   (unsigned char **) &cbtext.feedback) == Success) {
! 		cbtext.length = nitems;
! 	    } else {
! 		cbtext.length = 0 ;
! 	    }
! 	    if (cbtext.length <=0) {
! 		if (cbtext.feedback)
! 		  Xfree(cbtext.feedback);
! 		cbtext.feedback = NULL ;
! 	    }
! 	} else {
! 	    cbtext.feedback = NULL ;
! 	}
! 	/*
! 	 * nitems == 0 usually means same feedback as before.
! 	 * But if text length is also 0, then deem it as
! 	 * feedback == NULL (text deletion)
! 	 */
! 	if (event->data.l[3]) {
! 	    if (XGetWindowProperty(xic->core.im->core.display,
! 				   ((Ximp_XIM) xic->core.im)->ximp_impart->fe_window,
! 				   event->data.l[3], 0, 4096, True, AnyPropertyType,
! 				   &type, &format, &nitems, &after,
! 				   (unsigned char **) &ctext) == Success) {
! 		if (nitems > 0) {
! 		    int  ctlen = nitems ;
! 		    if (ctlen > XIMP_MAXBUF) {
! 			ctlen = XIMP_MAXBUF;
! 		    }
! 		    length = ctlen;
! 		    /*
! 		     * wide_char is union with multi_byte.
! 		     */
! 		    cbtext.string.wide_char = (wchar_t *) Xmalloc(ctlen * sizeof(wchar_t));
! 		    bzero(cbtext.string.wide_char, sizeof(wchar_t) * ctlen);
! 		    
! 		    if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
! 			cbtext.encoding_is_wchar = True;
! 			if (_Ximp_cttowcs(xic->core.im->core.lcd, ctext,
! 					  nitems, cbtext.string.wide_char,
! 					  &length, NULL) < 0) {
! 			    length = 0;
  			}
+ 		    } else {
  			cbtext.encoding_is_wchar = False;
! 			if (_Ximp_cttombs(xic->core.im->core.lcd, ctext,
! 					  nitems, cbtext.string.multi_byte,
! 				          &length, NULL) < 0) {
! 			    length = 0;
! 			}
! 		    }
! 		    
! 		    if (cbtext.feedback == NULL) {
! 			if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
! 			    if (!(cbtext.length = length)) {
! 				if (cbtext.string.wide_char)
! 				  Xfree(cbtext.string.wide_char);
! 				cbtext.string.wide_char = NULL;
! 			    }
! 			} else {
! 			    if (strlen(cbtext.string.multi_byte) == 0) {
! 				cbtext.length = 0 ;
! 				if (cbtext.string.multi_byte)
! 				  Xfree(cbtext.string.multi_byte);
! 				cbtext.string.multi_byte = NULL;
! 				
! 			    } else {
! 				if ((length =
! 				     _Ximp_mbs_charlen(xic->core.im->core.lcd,
! 						       cbtext.string.multi_byte,
! 						       length)) < 0) {
! 				    length = 0 ;
! 				    if (cbtext.string.multi_byte)
! 					Xfree(cbtext.string.multi_byte);
! 				    cbtext.string.multi_byte = NULL;
! 				}
  				cbtext.length = length;
+ 			    }
  			}
! 		    }
  		} else {
! 		    /*
! 		     * No preedit string.
! 		     * feedback updates only
! 		     */
! 		    cbtext.string.multi_byte = NULL;
  		}
! 		Xfree((XPointer) ctext);
! 	    } else {
! 		/*
! 		 * No preedit string.
! 		 * feedback updates only
! 		 */
! 		cbtext.string.multi_byte = NULL;
! 	    }
  	} else {
! 	    cbtext.string.multi_byte = NULL;
  	}
+ 	if ((cbtext.string.multi_byte == NULL) && cbtext.feedback == NULL) {
+ 	    /*
+ 	     * text deletion
+ 	     */
+ 	    CallData.text = NULL ;
+ 	} else {
+ 	    CallData.text = &cbtext;
+ 	}
+ 	
+ 
+ 	(*cb->callback) (xic, cb->client_data, &CallData);
+ 	if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
+ 	    if (cbtext.string.wide_char) {
+ 		Xfree((XPointer) (cbtext.string.wide_char));
+ 	    }
+ 	} else {
+ 	    if (cbtext.string.multi_byte) {
+ 		Xfree((XPointer) (cbtext.string.multi_byte));
+ 	    }
+ 	}
+ 	if (cbtext.feedback)
+ 	    Xfree((XPointer) cbtext.feedback);
+     } else {
+ 	XDeleteProperty(xic->core.im->core.display,
+ 			((Ximp_XIM) xic->core.im)->ximp_impart->fe_window,
+ 			event->data.l[2]);
+ 	XDeleteProperty(xic->core.im->core.display,
+ 			((Ximp_XIM) xic->core.im)->ximp_impart->fe_window,
+ 			event->data.l[3]);
+ 	XDeleteProperty(xic->core.im->core.display,
+ 			((Ximp_XIM) xic->core.im)->ximp_impart->fe_window,
+ 			event->data.l[4]);
+     }
  }
  
! static int      _time_flag = 0;
  #ifdef XIMP_SIGNAL
  static int
  _time_out()
  {
!     _time_flag = 1;
  }
! #endif				/* XIMP_SIGNAL */
  
  void
  _Ximp_CallPreeditDrawCallback2(xic, event)
!     Ximp_XIC        xic;
!     XClientMessageEvent *event;
  {
!     register XIMCallback *cb = &xic->core.preedit_attr.callbacks.draw ;
!     XIMPreeditDrawCallbackStruct CallData;
!     XIMText         cbtext;
!     char           *text;
!     int             length;
!     XEvent          ev;
!     short	    pdcbStatus = (short) ((event->data.l[2] >> 16) & 0xffffl);
!     int             ctlen;
!     Atom            type;
!     int             format;
!     unsigned long   nitems, after;
  
!     bzero(&CallData, sizeof(XIMPreeditDrawCallbackStruct));
!     bzero(&cbtext, sizeof(XIMText));
  
! /**
!  * post Ximp 3.4 protocol maybe compliant. 
!  * XIMP status flag will may contain the supplementary infomations to 
!  * reassemble the XIMPreeditDrawCallbackStruct.
!  *	  +-----------------------------------------+
!  *	0 | XIMP_PREEDITDRAW_CM                     |
!  *	  +-----------------------------------------+
!  *	4 | ICID                                    |
!  *	  +-------------------+---------------------+
!  *	8 |PreeditDrawCBStatus|       caret         |
!  *	  +-------------------+---------------------+
!  *	12|      chg_first    |      chg_length     |
!  *	  +-------------------+---------------------+
!  *	16|               feedback                  |
!  *	  +-----------------------------------------+
!  * PreeditDrawCBStatus:
!  *    0x0001 no_text:  if 1, string == NULL (no following client message.)
!  *    0x0002 no_feedback: if 1 feedback == NULL
!  *    0x0004 feedbacks_via_property: if 1 , feedback field is property atom#
!  **/
!     CallData.caret = (long)(event->data.l[2] & 0xffffl);
!     CallData.chg_first = (long) ((event->data.l[3] >> 16) & 0xffffl);
!     CallData.chg_length = (long) (event->data.l[3] & 0xffffl);
!     CallData.text = &cbtext;
  
+     if (cb->callback) {
+ 	if (pdcbStatus & XIMP_PDCBSTATUS_NOTEXT) {
+ 	    cbtext.string.multi_byte = NULL ;
+ 	    if (pdcbStatus & XIMP_PDCBSTATUS_NOFEEDBACK) {
+ 		CallData.text = NULL ;
+ 	    } else {
+ 		if (!(pdcbStatus & XIMP_PDCBSTATUS_FEEDBACKS_VIA_PROP)) {
+ 		    /* error */
+ 		} else {
+ 		    /*
+ 		     * Not implemented yet.
+ 		     */
+ 		    if (XGetWindowProperty(xic->core.im->core.display,
+ 					   ((Ximp_XIM) xic->core.im)->ximp_impart->fe_window,
+ 					   event->data.l[4], 0, 4096, True, AnyPropertyType,
+ 					   &type, &format, &nitems, &after,
+ 					   (unsigned char **) &cbtext.feedback) == Success) {
+ 			cbtext.length = nitems;
+ 		    } else {
+ 			cbtext.length = 0 ;
+ 		    }
+ 		}
+ 	    }
+ 	} else { /* if preedit text is exist */
+ 	    /*
+ 	     * Following Client message must be the preedit string.
+ 	     */
  #ifdef XIMP_SIGNAL
! 	    signal(SIGALRM, _time_out);
! 	    alarm(XIMP_TIME_OUT);
! #endif				/* XIMP_SIGNAL */
! 	    while (_time_flag != 1) {
! 		if ((XCheckTypedEvent(xic->core.im->core.display, ClientMessage, &ev)) == False) {
  #ifdef XIMP_SIGNAL
! 		    sleep(1);
! #endif				/* XIMP_SIGNAL */
! 		    continue;
  		}
! 		if (ev.xclient.message_type != ((Ximp_XIM) xic->core.im)->ximp_impart->improtocol_id) {
! 		    XPutBackEvent(xic->core.im->core.display, &ev);
! 		    continue;
! 		} else {
  #ifdef XIMP_SIGNAL
! 		    alarm(0);
! #endif				/* XIMP_SIGNAL */
! 		    break;
  		}
! 	    }
! 
! 	    ctlen = ev.xclient.data.b[4];
! 	    length = ctlen * XIMP_MB_CUR_MAX(xic->core.im->core.lcd);
! 	    _time_flag = 0;
! 	    
! 	    if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
! 		cbtext.string.wide_char = (wchar_t *) Xmalloc((length + 1) * sizeof(wchar_t));
! 		bzero(cbtext.string.wide_char, sizeof(wchar_t) * (length + 1));
! 		cbtext.encoding_is_wchar = True;
! 		if (_Ximp_cttowcs(xic->core.im->core.lcd,
! 			          &ev.xclient.data.b[5], ev.xclient.data.b[4],
! 			          cbtext.string.wide_char,
! 			          &length, NULL) < 0) {
! 		    length = 0;
! 		}
! 		cbtext.length = length;
! 	    } else {
! 		cbtext.string.multi_byte = Xmalloc(length + 1);
! 		bzero(cbtext.string.multi_byte, length + 1);
  		cbtext.encoding_is_wchar = False;
! 		if (_Ximp_cttombs(xic->core.im->core.lcd,
! 				  &ev.xclient.data.b[5], ev.xclient.data.b[4],
! 				  cbtext.string.multi_byte,
! 				  &length, NULL) < 0) {
! 		    length = 0;
  		}
! 		
! 		if ((length =
! 		     _Ximp_mbs_charlen(xic->core.im->core.lcd,
! 				       cbtext.string.multi_byte,
! 				       length)) < 0) {
! 		    length = 0 ;
! 		    if (cbtext.string.multi_byte)
! 			Xfree(cbtext.string.multi_byte);
! 		    cbtext.string.multi_byte = NULL;
! 		}
  		cbtext.length = length;
! 		
! 	    }
! 	    
! 	    
! 	    if (event->data.l[4] != -1) {
! 		int             i;
! 		
! 		cbtext.feedback = (XIMFeedback *) Xmalloc(cbtext.length * sizeof(XIMFeedback));
! 		for (i = 0; i < (int) cbtext.length; i++) {
! 		    cbtext.feedback[i] = event->data.l[4];
  		}
! 	    } else {
! 		cbtext.feedback = NULL;
! 	    }
! 
  	}
+ 	(*cb->callback) (xic, cb->client_data, &CallData);
+ 	if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
+ 	    if (cbtext.string.wide_char)
+ 	      Xfree((XPointer) (cbtext.string.wide_char));
+ 	} else {
+ 	    if (cbtext.string.multi_byte)
+ 	      Xfree((XPointer) (cbtext.string.multi_byte));
+ 	}
+ 	if (cbtext.feedback)
+ 	  Xfree((XPointer) cbtext.feedback);
+     }
  }
  
  void
+ _Ximp_CallPreeditDrawCallback3(xic, event)
+     Ximp_XIC        xic;
+     XClientMessageEvent *event;
+ {
+     register XIMCallback *cb = &xic->core.preedit_attr.callbacks.draw ;
+     XIMPreeditDrawCallbackStruct CallData;
+     XIMText         cbtext;
+     unsigned long text_data[2];
+     static wchar_t local_buf[16];
+     int length = 16;
+ 
+     bzero(&CallData, sizeof(XIMPreeditDrawCallbackStruct));
+     bzero(&cbtext, sizeof(XIMText));
+ 
+ /**
+  * post Ximp 3.4 protocol maybe compliant. 
+  *	  +---------------------------------------------+
+  *	0 | XIMP_PREEDITDRAW_CM_TINY                    |
+  *	  +---------------------------------------------+
+  *	4 | ICID                                        |
+  *	  +-------------------+------------+------------+
+  *	8 |    chg_first      | chg_length |   length   |
+  *	  +-------------------+------------+------------+
+  *	12|    string (COMPOUND TEXT, Network order)    |
+  *	  +-------------------+-------------------------+
+  *	16|    string (continued)                       |
+  *	  +---------------------------------------------+
+  * caret = chg_first + length_in_char_of_insert_string
+  **/
+     CallData.caret = (long)(event->data.l[2] & 0xffffl);
+ 
+     CallData.chg_first = (long) ((event->data.l[2] >> 16) & 0xffffl);
+     CallData.chg_length = (long) ((event->data.l[2] >> 8) & 0xffl);
+     cbtext.feedback = (XIMFeedback *)NULL;
+     CallData.text = &cbtext;
+     text_data[0] = htonl(event->data.l[3]);
+     text_data[1] = htonl(event->data.l[4]);
+ 
+     if (cb->callback) {
+ 	if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
+ 	    cbtext.encoding_is_wchar = True;
+ 	    cbtext.string.wide_char = local_buf;
+ 	    if (_Ximp_cttowcs(xic->core.im->core.lcd, (char *)text_data, (event->data.l[2] & 0xffl), cbtext.string.wide_char, &length, NULL) >= 0) {
+ 		cbtext.length = length;
+ 		(*cb->callback) (xic, cb->client_data, &CallData);
+ 	    }
+ 	} else {
+ 	    cbtext.encoding_is_wchar = False;
+ 	    cbtext.string.multi_byte = (char *)local_buf;
+ 	    if (_Ximp_cttombs(xic->core.im->core.lcd, (char *)text_data, (event->data.l[2] & 0xffl), cbtext.string.multi_byte, &length, NULL) >= 0) {
+ 		cbtext.length = _Ximp_mbs_charlen(xic->core.im->core.lcd, cbtext.string.multi_byte, length);
+ 		(*cb->callback) (xic, cb->client_data, &CallData);
+ 	    }
+ 	}
+     }
+ }
+ 
+ void
  _Ximp_CallPreeditCaretCallback(xic, event)
!     Ximp_XIC        xic;
!     XClientMessageEvent *event;
  {
!     register XIMCallback *cb;
!     XIMPreeditCaretCallbackStruct CallData;
  #define ToXIMCaretStyle(x) ((XIMCaretStyle)(x))
  #define ToXIMCaretDirection(x) ((XIMCaretDirection)(x))
  
!     cb = &xic->core.preedit_attr.callbacks.caret;
!     if (cb->callback) {
! 	static XClientMessageEvent clmsg;
! 	CallData.position = event->data.l[2];
! 	CallData.direction = ToXIMCaretDirection(event->data.l[3]);
! 	CallData.style = ToXIMCaretStyle(event->data.l[4]);
! 	(*cb->callback) (xic, cb->client_data, &CallData);
! 	clmsg.type = ClientMessage;
! 	clmsg.display = xic->core.im->core.display;
! 	clmsg.window = ((Ximp_XIM) xic->core.im)->ximp_impart->fe_window;
! 	clmsg.message_type = ((Ximp_XIM) xic->core.im)->ximp_impart->improtocol_id;
! 	clmsg.format = 32;
! 	clmsg.data.l[0] = XIMP_PREEDITCARET_RETURN;
! 	clmsg.data.l[1] = xic->ximp_icpart->icid;
! 	clmsg.data.l[2] = CallData.position;;
  
! 	XSendEvent(xic->core.im->core.display,
! 		   ((Ximp_XIM) xic->core.im)->ximp_impart->fe_window,
! 		   False, NoEventMask, &clmsg);
! 	XFlush(xic->core.im->core.display);
!     }
  }
  
  void
  _Ximp_CallStatusStartCallback(xic, event)
!     Ximp_XIC        xic;
!     XClientMessageEvent *event;
  {
!     register XIMCallback *cb;
  
!     cb = &xic->core.status_attr.callbacks.start;
!     if (cb->callback) {
! 	(*cb->callback) (xic, cb->client_data, NULL);
!     }
  }
  
  void
  _Ximp_CallStatusDoneCallback(xic, event)
!     Ximp_XIC        xic;
!     XClientMessageEvent *event;
  {
!     register XIMCallback *cb;
  
!     cb = &xic->core.status_attr.callbacks.done;
!     if (cb->callback) {
! 	(*cb->callback) (xic, cb->client_data, NULL);
!     }
  }
  
  void
  _Ximp_CallStatusDrawCallback(xic, event)
!     Ximp_XIC        xic;
!     XClientMessageEvent *event;
  {
!     register XIMCallback *cb;
!     char           *text;
!     int             length;
!     XIMStatusDrawCallbackStruct CallData;
!     XIMText         cbtext;
  
+     bzero(&CallData, sizeof(XIMStatusDrawCallbackStruct));
+     bzero(&cbtext, sizeof(XIMText));
+ 
  #define ToXIMStatusDataType(x) ((XIMStatusDataType)(x))
  
!     cb = &xic->core.status_attr.callbacks.draw;
!     CallData.type = ToXIMStatusDataType(event->data.l[2]);
!     if (CallData.type == XIMTextType) {
! 	Atom            type;
! 	int             format;
! 	unsigned long   nitems, after;
! 	CallData.data.text = &cbtext;
! 	if (XGetWindowProperty(xic->core.im->core.display,
! 			  ((Ximp_XIM) xic->core.im)->ximp_impart->fe_window,
! 			   event->data.l[4], 0, 4096, True, AnyPropertyType,
! 			       &type, &format, &nitems, &after,
! 			  (unsigned char **) &cbtext.feedback) == Success) {
! 	    cbtext.length = nitems;
! 	} else {
! 	    cbtext.feedback = NULL;
! 	    cbtext.length = 0;
! 	}
! 	if (XGetWindowProperty(xic->core.im->core.display,
! 			  ((Ximp_XIM) xic->core.im)->ximp_impart->fe_window,
! 			   event->data.l[3], 0, 4096, True, AnyPropertyType,
! 			       &type, &format, &nitems, &after,
! 			       (unsigned char **) &text) == Success) {
! 	    if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
! 		cbtext.string.wide_char = (wchar_t *) Xmalloc((XIMP_MAXBUF + 1) * sizeof(wchar_t));
! 		bzero(cbtext.string.wide_char, (XIMP_MAXBUF + 1) * sizeof(wchar_t));
! 		length = XIMP_MAXBUF;
! 		if (_Ximp_cttowcs(xic->core.im->core.lcd, text, nitems,
! 				  cbtext.string.wide_char,
! 				  &length, NULL) < 0) {
! 		    length = 0;
  		}
! 		cbtext.length = length;
! 		Xfree((XPointer) text);
! 		cbtext.encoding_is_wchar = True;
! 	    } else {
! 		cbtext.string.multi_byte = Xmalloc(XIMP_MAXBUF + 1);
! 		bzero(cbtext.string.multi_byte, XIMP_MAXBUF + 1);
! 		length = XIMP_MAXBUF;
! 		if (_Ximp_cttombs(xic->core.im->core.lcd, text, nitems,
! 				  cbtext.string.multi_byte,
! 				  &length, NULL) < 0) {
! 		    length = 0;
  		}
! 		if (cbtext.length == 0) {
! 		    if ((length =
! 			 _Ximp_mbs_charlen(xic->core.im->core.lcd,
! 					   cbtext.string.multi_byte,
! 					   length)) < 0) {
! 			length = 0 ;
! 			if (cbtext.string.multi_byte)
! 			    Xfree(cbtext.string.multi_byte);
! 			cbtext.string.multi_byte = NULL;
! 		    }
! 		    cbtext.length  = length;
  		}
! 		Xfree((XPointer) text);
! 		cbtext.encoding_is_wchar = False;
! 	    }
! 	} else {
! 	    if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
! 		cbtext.string.wide_char = (wchar_t *) Xmalloc(sizeof(wchar_t));
! 		cbtext.string.wide_char[0] = 0;
! 		cbtext.length = 0;
! 	    } else {
! 		cbtext.string.multi_byte = Xmalloc(1);
! 		cbtext.string.multi_byte[0] = 0;
! 		cbtext.length = 0;
! 	    }
  	}
+ 	if (cb->callback) {
+ 	    (*cb->callback) (xic, cb->client_data, &CallData);
+ 	}
+ 	if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
+ 	    Xfree((XPointer) (cbtext.string.wide_char));
+ 	} else {
+ 	    Xfree((XPointer) (cbtext.string.multi_byte));
+ 	}
+ 	if (cbtext.feedback)
+ 	    Xfree((XPointer) cbtext.feedback);
+     } else {			/* XIMBitmapType */
+ 	CallData.data.bitmap = (Pixmap) event->data.l[3];
+ 	if (cb->callback) {
+ 	    (*cb->callback) (xic, cb->client_data, &CallData);
+ 	}
+     }
  }
  
  void
  _Ximp_CallStatusDrawCallback2(xic, event)
!     Ximp_XIC        xic;
!     XClientMessageEvent *event;
  {
!     register XIMCallback *cb;
!     char           *text;
!     int             length;
!     XIMStatusDrawCallbackStruct CallData;
!     XIMText         cbtext;
!     XEvent          ev;
  
!     cb = &xic->core.status_attr.callbacks.draw;
!     CallData.type = ToXIMStatusDataType(event->data.l[2]);
!     if (CallData.type == XIMTextType) {
! 	CallData.data.text = &cbtext;
  
  #ifdef XIMP_SIGNAL
! 	signal(SIGALRM, _time_out);
! 	alarm(XIMP_TIME_OUT);
! #endif				/* XIMP_SIGNAL */
! 	while (_time_flag != 1) {
! 	    if ((XCheckTypedEvent(xic->core.im->core.display, ClientMessage, &ev)) == False) {
  #ifdef XIMP_SIGNAL
! 		sleep(1);
! #endif				/* XIMP_SIGNAL */
! 		continue;
! 	    }
! 	    if (ev.xclient.message_type != ((Ximp_XIM) xic->core.im)->ximp_impart->improtocol_id) {
! 		XPutBackEvent(xic->core.im->core.display, &ev);
! 		continue;
! 	    } else {
  #ifdef XIMP_SIGNAL
! 		alarm(0);
! #endif				/* XIMP_SIGNAL */
! 		break;
! 	    }
! 	}
! 	_time_flag = 0;
! 	if (cb->callback) {
! 	    length = ev.xclient.data.b[4];
! 	    if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
! 		cbtext.string.wide_char = (wchar_t *) Xmalloc((XIMP_MAXBUF + 1) * sizeof(wchar_t));
! 		bzero(cbtext.string.wide_char,(XIMP_MAXBUF + 1) * sizeof(wchar_t));
! 		cbtext.encoding_is_wchar = True;
! 		if (_Ximp_cttowcs(xic->core.im->core.lcd,
! 				  &ev.xclient.data.b[5], ev.xclient.data.b[4],
! 				  cbtext.string.wide_char,
! 				  &length, NULL) < 0) {
! 		    length = 0;
  		}
! 	    } else {
! 		cbtext.string.multi_byte = Xmalloc(length + 1);
! 		bzero(cbtext.string.multi_byte, length + 1);
! 		cbtext.encoding_is_wchar = False;
! 		if (_Ximp_cttombs(xic->core.im->core.lcd,
! 				  &ev.xclient.data.b[5], ev.xclient.data.b[4],
! 				  cbtext.string.multi_byte,
! 				  &length, NULL) < 0) {
! 		    length = 0;
  		}
! 		if ((length = _Ximp_mbs_charlen(xic->core.im->core.lcd,
! 				           cbtext.string.multi_byte,
! 				           length)) < 0) {
! 		    length = 0;
  		}
+ 	    }
+ 	    cbtext.length = length;
+ 	    if (event->data.l[4] != -1) {
+ 		int             i;
+ 
+ 		cbtext.feedback = (XIMFeedback *) Xmalloc(cbtext.length * sizeof(long));
+ 		for (i = 0; i < (int) cbtext.length; i++) {
+ 		    cbtext.feedback[i] = event->data.l[4];
+ 		}
+ 	    } else {
+ 		cbtext.feedback = NULL;
+ 	    }
+ 	    (*cb->callback) (xic, cb->client_data, &CallData);
+ 	    if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
+ 		Xfree((XPointer) (cbtext.string.wide_char));
+ 	    } else {
+ 		Xfree((XPointer) (cbtext.string.multi_byte));
+ 	    }
+ 	    Xfree((XPointer) cbtext.feedback);
  	}
+     } else {			/* XIMBitmapType */
+ 	if (cb->callback) {
+ 	    CallData.data.bitmap = (Pixmap) event->data.l[3];
+ 	    (*cb->callback) (xic, cb->client_data, &CallData);
+ 	}
+     }
  }

*** /tmp/,RCSt1001579	Mon Oct 28 15:37:40 1991
--- mit/lib/X/Ximp/XimpConv.c	Mon Oct  7 17:47:48 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpConv.c,v 1.4 91/07/30 14:27:17 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpConv.c,v 1.5 91/10/07 17:47:44 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
***************
*** 68,73 ****
--- 68,124 ----
  #include "Xlcint.h"
  #include "Ximplc.h"
  
+ #define CHAR_LENGTH(xxxtocs) \
+     unsigned char buf[BUFSIZE]; \
+     int char_length; \
+     int buf_len, scan_len; \
+     int ret = 0; \
+ \
+     (*lcd->ximp_lcpart->methods->cnv_start)(lcd); \
+ \
+     while (from_len > 0) { \
+         buf_len = BUFSIZE; \
+         scan_len = (*xxxtocs)(lcd, from_ptr, from_len, buf, &buf_len, \
+                               NULL, &char_length); \
+         if (scan_len == -1) { \
+ 	    ret = -1; \
+ 	    goto error; \
+ 	} \
+         if (scan_len == 0)  \
+ 	    break; \
+ \
+ 	ret += buf_len / char_length; \
+         from_ptr += scan_len; \
+         from_len -= scan_len; \
+     } \
+ \
+ error: \
+     (*lcd->ximp_lcpart->methods->cnv_end)(lcd); \
+ \
+     return ret;
+ 
+ int
+ _Ximp_str_charlen(lcd, strtocs, from, from_len)
+     Ximp_XLCd lcd;
+     int (*strtocs)();
+     unsigned char *from;
+     int from_len;
+ {
+     unsigned char *from_ptr = from;
+     CHAR_LENGTH(strtocs)
+ }
+ 
+ int
+ _Ximp_mbs_charlen(lcd, mbstr, mbstr_len)
+     Ximp_XLCd lcd;
+     unsigned char *mbstr;
+     int mbstr_len;
+ {
+     return _Ximp_str_charlen(lcd, lcd->ximp_lcpart->methods->mbstocs,
+ 			     mbstr, mbstr_len);
+ }
+ 
+ 
  #define STRING_CONV(xxxtocs, cstoxxx) \
      unsigned char buf[BUFSIZE]; \
      int cs_num; \
***************
*** 74,82 ****
      int to_length, buf_len, scan_len, tmp_len; \
      int ret = -1; \
  \
!     if (to_len) \
          to_length = *to_len; \
!     else \
          to_length = MAXINT; \
      if (unconv_num) \
          *unconv_num = 0; \
--- 125,134 ----
      int to_length, buf_len, scan_len, tmp_len; \
      int ret = -1; \
  \
!     if (to_len) { \
          to_length = *to_len; \
! 	*to_len = 0; \
!     } else \
          to_length = MAXINT; \
      if (unconv_num) \
          *unconv_num = 0; \
***************
*** 89,94 ****
--- 141,148 ----
                                &cs_num, NULL); \
          if (scan_len == -1) \
              goto error; \
+         if (scan_len == 0)  \
+ 	    break; \
  \
          from_ptr += scan_len; \
          from_len -= scan_len; \
***************
*** 102,114 ****
  	    goto error; \
          } \
  \
!         to_ptr += tmp_len; \
          to_length -= tmp_len; \
      } \
  \
-     if (to_len) \
-         *to_len = to_ptr - to; \
- \
      ret =  from_ptr - from; \
  \
  error: \
--- 156,168 ----
  	    goto error; \
          } \
  \
! 	if (to_ptr) \
!             to_ptr += tmp_len; \
! 	if (to_len) \
! 	    *to_len += tmp_len; \
          to_length -= tmp_len; \
      } \
  \
      ret =  from_ptr - from; \
  \
  error: \
***************
*** 182,201 ****
  
  
  int
- Ximp_mbstowcs(mbstr, mbstr_len, wcstr, wcstr_len)
-     unsigned char *mbstr;
-     int mbstr_len;
-     wchar_t *wcstr;
-     int *wcstr_len;
- {
-     Ximp_XLCd lcd = (Ximp_XLCd) _XlcCurrentLC();
- 
-     return _Ximp_strtowstr(lcd, lcd->ximp_lcpart->methods->mbstocs, mbstr,
- 			   mbstr_len, lcd->ximp_lcpart->methods->cstowcs,
- 			   wcstr, wcstr_len, NULL);
- }
- 
- int
  _Ximp_mbstowcs(lcd, mbstr, mbstr_len, wcstr, wcstr_len, unconv_num)
      Ximp_XLCd lcd;
      unsigned char *mbstr;
--- 236,241 ----
***************
*** 204,209 ****
--- 244,252 ----
      int *wcstr_len;
      int *unconv_num;
  {
+     if (lcd == NULL && (lcd = (Ximp_XLCd) _XlcCurrentLC()) == NULL)
+ 	return -1;
+ 
      return _Ximp_strtowstr(lcd, lcd->ximp_lcpart->methods->mbstocs, mbstr,
  			   mbstr_len, lcd->ximp_lcpart->methods->cstowcs,
  			   wcstr, wcstr_len, unconv_num);
***************
*** 211,230 ****
  
  
  int
- Ximp_wcstombs(wcstr, wcstr_len, mbstr, mbstr_len)
-     wchar_t *wcstr;
-     int wcstr_len;
-     unsigned char *mbstr;
-     int *mbstr_len;
- {
-     Ximp_XLCd lcd = (Ximp_XLCd) _XlcCurrentLC();
- 
-     return _Ximp_wstrtostr(lcd, lcd->ximp_lcpart->methods->wcstocs, wcstr,
- 			   wcstr_len, lcd->ximp_lcpart->methods->cstombs,
- 			   mbstr, mbstr_len, NULL);
- }
- 
- int
  _Ximp_wcstombs(lcd, wcstr, wcstr_len, mbstr, mbstr_len, unconv_num)
      Ximp_XLCd lcd;
      wchar_t *wcstr;
--- 254,259 ----
***************
*** 233,238 ****
--- 262,270 ----
      int *mbstr_len;
      int *unconv_num;
  {
+     if (lcd == NULL && (lcd = (Ximp_XLCd) _XlcCurrentLC()) == NULL)
+ 	return -1;
+ 
      return _Ximp_wstrtostr(lcd, lcd->ximp_lcpart->methods->wcstocs, wcstr,
  			   wcstr_len, lcd->ximp_lcpart->methods->cstombs,
  			   mbstr, mbstr_len, unconv_num);
***************
*** 263,283 ****
      return str1 - str1_tmp;
  }
  
  int
! Ximp_wstrcpy(wstr1, wstr2)
      register wchar_t *wstr1, *wstr2;
  {
!     register wchar_t *wstr_tmp = wstr1;
  
      while (*wstr1++ = *wstr2++)
  	;
-     wstr1--;
  
!     return wstr1 - wstr_tmp;
  }
  
  int
! Ximp_wstrlen(wstr)
      register wchar_t *wstr;
  {
      register wchar_t *wstr_ptr = wstr;
--- 295,426 ----
      return str1 - str1_tmp;
  }
  
+ 
  int
! _Xmblen(str, len)
!     char *str;
!     int len;
! {
!     return _Xmbtowc(NULL, str, len);
! }
! 
! int
! _Xmbtowc(wstr, str, len)
!     wchar_t *wstr;
!     char *str;
!     int len;
! {
!     Ximp_XLCd lcd = (Ximp_XLCd) _XlcCurrentLC();
!     wchar_t tmp_wc;
! 
!     if (lcd == NULL)
! 	return -1;
!     if (str == NULL)
! 	return lcd->ximp_lcpart->state_dependent;
!     if (len == 0)
! 	return 0;
!     if (*str == '\0') {
! 	*wstr = 0;
! 	return 0;
!     }
!     if (wstr == NULL)
! 	wstr = &tmp_wc;
! 
!     return _Ximp_strtowstr(lcd, lcd->ximp_lcpart->methods->mbstocs, str, len,
! 			   lcd->ximp_lcpart->methods->cstowcs, wstr, 1, NULL);
! }
! 
! int
! _Xwctomb(str, wc)
!     char *str;
!     wchar_t wc;
! {
!     int len;
! 
!     Ximp_XLCd lcd = (Ximp_XLCd) _XlcCurrentLC();
! 
!     if (lcd == NULL)
! 	return -1;
!     if (str == NULL)
! 	return lcd->ximp_lcpart->state_dependent;
!     len = XIMP_MB_CUR_MAX(lcd);
! 
!     if (_Ximp_wstrtostr(lcd, lcd->ximp_lcpart->methods->wcstocs, &wc, 1,
! 		lcd->ximp_lcpart->methods->cstombs, str, &len, NULL) < 0)
! 	return -1;
!     
!     return len;
! }
! 
! int
! _Xmbstowcs(wstr, str, len)
!     wchar_t *wstr;
!     char *str;
!     int len;
! {
!     Ximp_XLCd lcd = (Ximp_XLCd) _XlcCurrentLC();
! 
!     if (lcd == NULL)
! 	return -1;
!     
!     if (_Ximp_strtowstr(lcd, lcd->ximp_lcpart->methods->mbstocs, str, 
! 			strlen(str), lcd->ximp_lcpart->methods->cstowcs,
! 			wstr, &len, NULL) < 0)
! 	return -1;
! 
!     return len;
! }
! 
! int
! _Xwcstombs(str, wstr, len)
!     char *str;
!     wchar_t *wstr;
!     int len;
! {
!     Ximp_XLCd lcd = (Ximp_XLCd) _XlcCurrentLC();
! 
!     if (lcd == NULL)
! 	return -1;
! 
!     if (_Ximp_wstrtostr(lcd, lcd->ximp_lcpart->methods->wcstocs, wstr,
! 			_Xwcslen(wstr), lcd->ximp_lcpart->methods->cstombs,
! 			str, &len, NULL) < 0)
! 	return -1;
! 
!     return len;
! }
! 
! wchar_t *
! _Xwcscpy(wstr1, wstr2)
      register wchar_t *wstr1, *wstr2;
  {
!     wchar_t *wstr_tmp = wstr1;
  
      while (*wstr1++ = *wstr2++)
  	;
  
!     return wstr_tmp;
  }
  
+ wchar_t *
+ _Xwcsncpy(wstr1, wstr2, len)
+     register wchar_t *wstr1, *wstr2;
+     register len;
+ {
+     wchar_t *wstr_tmp = wstr1;
+ 
+     while (len-- > 0)
+ 	if (!(*wstr1++ = *wstr2++))
+ 	    break;
+ 
+     while (len-- > 0)
+ 	*wstr1++ = (wchar_t) 0;
+ 
+     return wstr_tmp;
+ }
+ 
  int
! _Xwcslen(wstr)
      register wchar_t *wstr;
  {
      register wchar_t *wstr_ptr = wstr;
***************
*** 287,292 ****
--- 430,436 ----
      
      return wstr_ptr - wstr;
  }
+ 
  
  char *
  XDefaultString()

*** /tmp/,RCSt1001589	Mon Oct 28 15:37:46 1991
--- mit/lib/X/Ximp/XimpCrFS.c	Mon Oct  7 17:47:56 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpCrFS.c,v 1.4 91/07/30 14:27:21 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpCrFS.c,v 1.5 91/10/07 17:47:50 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
***************
*** 113,119 ****
  {
      Ximp_XFontSet ximp_fontset;
      XFontSetXimpRec *fspart;
!     FontSetRec *fontset = NULL;
      int codeset_num = lcd->ximp_lcpart->codeset_num;
  
      ximp_fontset = (Ximp_XFontSet) Xmalloc(sizeof(Ximp_XFontSetRec));
--- 113,119 ----
  {
      Ximp_XFontSet ximp_fontset;
      XFontSetXimpRec *fspart;
!     FontSetRec *fontset;
      int codeset_num = lcd->ximp_lcpart->codeset_num;
  
      ximp_fontset = (Ximp_XFontSet) Xmalloc(sizeof(Ximp_XFontSetRec));
***************
*** 125,131 ****
  	goto error;
  
      fontset = (FontSetRec *) Xmalloc(sizeof(FontSetRec) * codeset_num);
!     if (ximp_fontset == NULL)
  	goto error;
  
      bzero(ximp_fontset, sizeof(Ximp_XFontSetRec));
--- 125,131 ----
  	goto error;
  
      fontset = (FontSetRec *) Xmalloc(sizeof(FontSetRec) * codeset_num);
!     if (fontset == NULL)
  	goto error;
  
      bzero(ximp_fontset, sizeof(Ximp_XFontSetRec));
***************
*** 158,164 ****
      FontInfoRec *info_ptr;
      char *name;
      int	count, data_num;
!     int	i, j, k;
  
      count = 0;
      data_num = lcd->ximp_lcpart->fontset_data_num;
--- 158,164 ----
      FontInfoRec *info_ptr;
      char *name;
      int	count, data_num;
!     int	i;
  
      count = 0;
      data_num = lcd->ximp_lcpart->fontset_data_num;
***************
*** 171,177 ****
  		break;
  	    }
  
! 	if (i == count) {
  	    info_ptr->charset_name = name;
  	    info_ptr->font_data_list[data->cset_number] = data;
  	    if (++count >= MAX_FONTSET)
--- 171,177 ----
  		break;
  	    }
  
! 	if (i == count) {	/* not found same font name */
  	    info_ptr->charset_name = name;
  	    info_ptr->font_data_list[data->cset_number] = data;
  	    if (++count >= MAX_FONTSET)
***************
*** 210,215 ****
--- 210,216 ----
      if (len1 < len2)
  	return False;
  
+     /* XXX */
      charset_field = xlfd_name + (len1 - len2);
      if (!_Ximp_CompareISOLatin1(charset_field, charset))
  	return True;
***************
*** 353,373 ****
      XRectangle *ink = &font_set->core.font_set_extents.max_ink_extent;
      XRectangle *logical = &font_set->core.font_set_extents.max_logical_extent;
      XFontStruct **font_list, *font;
      int	num = font_set->core.num_of_fonts;
  
      font_list = font_set->core.font_struct_list;
!     while (num--) {
  	font = *font_list++;
! 	ink->x = min(ink->x, font->min_bounds.lbearing);
! 	ink->y = min(ink->y, -(font->max_bounds.ascent));
! 	ink->width = max(ink->width, font->max_bounds.width);
! 	ink->height = max(ink->height,
! 			  font->max_bounds.ascent + font->max_bounds.descent);
!         logical->y = min(logical->y, -(font->ascent));
! 	logical->height = max(ink->height, font->ascent + font->descent);
      }
      logical->x = 0;
!     logical->width = ink->width;
  }
  
  static Bool
--- 354,390 ----
      XRectangle *ink = &font_set->core.font_set_extents.max_ink_extent;
      XRectangle *logical = &font_set->core.font_set_extents.max_logical_extent;
      XFontStruct **font_list, *font;
+     XCharStruct overall;
+     int logical_ascent, logical_descent;
      int	num = font_set->core.num_of_fonts;
  
      font_list = font_set->core.font_struct_list;
!     font = *font_list++;
!     overall = font->max_bounds;
!     overall.lbearing = font->min_bounds.lbearing;
!     logical_ascent = font->ascent;
!     logical_descent = font->descent;
! 
!     while (--num > 0) {
  	font = *font_list++;
! 	overall.lbearing = min(overall.lbearing, font->min_bounds.lbearing);
! 	overall.rbearing = max(overall.rbearing, font->max_bounds.rbearing);
! 	overall.ascent = max(overall.ascent, font->max_bounds.ascent);
! 	overall.descent = max(overall.descent, font->max_bounds.descent);
! 	overall.width = max(overall.width, font->max_bounds.width);
! 	logical_ascent = max(logical_ascent, font->ascent);
! 	logical_descent = max(logical_descent, font->descent);
      }
+ 
+     ink->x = overall.lbearing;
+     ink->y = -(overall.ascent);
+     ink->width = overall.rbearing - overall.lbearing;
+     ink->height = overall.ascent + overall.descent;
+ 
      logical->x = 0;
!     logical->y = -(logical_ascent);
!     logical->width = overall.width;
!     logical->height = logical_ascent + logical_descent;
  }
  
  static Bool
***************
*** 565,570 ****
--- 582,588 ----
  
      if (setCorePartData(font_set, font_info, font_info_num) == False)
  	goto error;
+     /* XXX */
      font_set->core.base_name_list = base_name;
  
      if (setMissingList(lcd, font_set, font_info, font_info_num,
***************
*** 589,595 ****
  
      return (XFontSet) NULL;
  }
- 
  
  static void
  _Ximp_free_fontset(dpy, xfont_set)
--- 607,612 ----

*** /tmp/,RCSt1001599	Mon Oct 28 15:37:53 1991
--- mit/lib/X/Ximp/XimpDefCnv.c	Mon Oct  7 17:48:16 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpDefCnv.c,v 1.1 91/07/09 17:36:50 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpDefCnv.c,v 1.2 91/10/07 17:47:57 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
***************
*** 95,100 ****
--- 95,103 ----
  def_initialize(lcd)
      Ximp_XLCd lcd;
  {
+     lcd->ximp_lcpart->mb_cur_max = 1;
+     lcd->ximp_lcpart->state_dependent = False;
+ 
      return True;
  }
  
*** /tmp/,RCSt1001620	Mon Oct 28 15:38:11 1991
--- mit/lib/X/Ximp/XimpEUC.c	Mon Oct  7 17:48:21 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpEUC.c,v 1.2 91/07/30 14:27:27 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpEUC.c,v 1.3 91/10/07 17:48:17 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
***************
*** 120,127 ****
      register int codeset_num;
      register CodeSetRec *codeset;
      EUCExtRec *extension;
!     int max_char_length = 1;
  
      codeset = lcd->ximp_lcpart->codeset;
      if ((codeset_num = lcd->ximp_lcpart->codeset_num) > 4)
  	codeset_num = lcd->ximp_lcpart->codeset_num = 4;
--- 120,128 ----
      register int codeset_num;
      register CodeSetRec *codeset;
      EUCExtRec *extension;
!     int mb_cur_max, max_char_length;
  
+     mb_cur_max = max_char_length = 1;
      codeset = lcd->ximp_lcpart->codeset;
      if ((codeset_num = lcd->ximp_lcpart->codeset_num) > 4)
  	codeset_num = lcd->ximp_lcpart->codeset_num = 4;
***************
*** 128,139 ****
--- 129,147 ----
  
      switch (codeset_num) {
  	case 4:
+ 	    mb_cur_max = max(mb_cur_max, codeset[3].char_length + 1);
  	    max_char_length = max(max_char_length, codeset[3].char_length);
  	case 3:
+ 	    mb_cur_max = max(mb_cur_max, codeset[2].char_length + 1);
  	    max_char_length = max(max_char_length, codeset[2].char_length);
  	case 2:
+ 	    mb_cur_max = max(mb_cur_max, codeset[1].char_length);
  	    max_char_length = max(max_char_length, codeset[1].char_length);
      }
+ 
+     lcd->ximp_lcpart->mb_cur_max = mb_cur_max;
+     lcd->ximp_lcpart->state_dependent = False;
+ 
      if ((extension = (EUCExtRec *) Xmalloc(sizeof(EUCExtRec))) == NULL)
  	return False;
      extension->max_char_length = max_char_length;
***************
*** 156,164 ****
  
      codeset = lcd->ximp_lcpart->codeset;
      codeset_num = lcd->ximp_lcpart->codeset_num;
      max_char_length = 
  		((EUCExtRec *) lcd->ximp_lcpart->extension)->max_char_length;
- 
      if (max_char_length < 3) {
  	WC_mask = WC_MASK;
  	CS1_WC_mask = CS1_WC_MASK;
--- 164,180 ----
  
      codeset = lcd->ximp_lcpart->codeset;
      codeset_num = lcd->ximp_lcpart->codeset_num;
+ 
+ #ifdef FIX_EUC32
+     WC_mask = WC_MASK_L;
+     CS1_WC_mask = CS1_WC_MASK_L;
+     CS2_WC_mask = CS2_WC_MASK_L;
+     CS3_WC_mask = CS3_WC_MASK_L;
+     Shift_bits = SHIFT_BITS_L;
+     Code_mask = CODE_MASK_L;
+ #else
      max_char_length = 
  		((EUCExtRec *) lcd->ximp_lcpart->extension)->max_char_length;
      if (max_char_length < 3) {
  	WC_mask = WC_MASK;
  	CS1_WC_mask = CS1_WC_MASK;
***************
*** 174,179 ****
--- 190,196 ----
  	Shift_bits = SHIFT_BITS_L;
  	Code_mask = CODE_MASK_L;
      }
+ #endif
  
      CS1_length = CS2_length = CS3_length = 0;
  
*** /tmp/,RCSt1001630	Mon Oct 28 15:38:17 1991
--- mit/lib/X/Ximp/XimpExten.c	Thu Oct 10 20:41:42 1991
***************
*** 1,8 ****
! /* $XConsortium: XimpExten.c,v 1.2 91/07/30 14:27:30 rws Exp $ */
  /******************************************************************
  
!             Copyright 1991, by FUJITSU LIMITED.
!             Copyright 1991, by Sun Microsystems, Inc.
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,8 ----
! /* $XConsortium: XimpExten.c,v 1.4 91/10/10 20:41:37 rws Exp $ */
  /******************************************************************
  
!     Copyright 1991, by FUJITSU LIMITED.
!     Copyright 1991, by Sun Microsystems, Inc.
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 24,45 ****
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  
!   Author: Takashi Fujiwara     FUJITSU LIMITED
!                                fujiwara@a80.tech.yk.fujitsu.co.jp
!           Hideki Hiura (hhiura@Sun.COM)
! 	  				     Sun Microsystems, Inc.
  ******************************************************************/
  
- 
- 
  #define NEED_EVENTS
  #include <X11/keysym.h>
  #include "Xlibint.h"
  #include "Xlcint.h"
  #include "Ximplc.h"
  
! extern Ximp_XIC              _Ximp_LookupXIC();
  
  #define Private static
  /*
   * Ximp extentions to XIC attributes
--- 24,117 ----
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  
! Author: Takashi Fujiwara     FUJITSU LIMITED
! 		       fujiwara@a80.tech.yk.fujitsu.co.jp
!   Hideki Hiura (hhiura@Sun.COM)
! 				     Sun Microsystems, Inc.
  ******************************************************************/
  
  #define NEED_EVENTS
  #include <X11/keysym.h>
+ #include <X11/Xlib.h>
  #include "Xlibint.h"
  #include "Xlcint.h"
  #include "Ximplc.h"
  
! #define		XIM_UNKNOWN_KEYSYM	0x77777777
! #define		XIM_UNDETERMINED	0x77777776
  
+ typedef int     XIMTextVisiblePosType;
+ 
+ /*
+  * LookupChoice Region
+  */
+ 
+ typedef enum {
+     XIMCB_Success,
+     XIMCB_FatalError,
+ }               XIMCBResult;
+ 
+ 
+ typedef enum {
+     DrawUpHorizontally = 0,
+     DrawUpVertically = 1,
+ }               DrawUpDirection;
+ 
+ typedef enum {
+     XIMOwnsLabel = 0,
+     CBOwnsLabel = 1,
+ }               WhoOwnsLabel;
+ 
+ typedef struct {
+     int             choice_per_window;	/* Number of choices can be display
+ 					 * in the region */
+     int             nrows;
+     int             ncolumns;
+     DrawUpDirection DrawUpDirection;
+     WhoOwnsLabel    WhoOwnsLabel;	/* For callback to tell XIM whether
+ 					 * it wants to control what label
+ 					 * should be for the choices. */
+ }               LayoutInfo;
+ 
+ typedef enum {
+     HasNotBeenNegotiated = 0,
+     XIMIsMaster = 1,
+     CBIsMaster = 2
+ } WhoIsMaster;
+ 
+ typedef struct _XIMLookupStartCallbackStruct {
+     XKeyEvent      *event;
+     WhoIsMaster     WhoIsMaster;/* For callback to tell whether is going to
+ 				 * be a master */
+     LayoutInfo     *XIMPreference;
+     LayoutInfo     *CBPreference;
+ }               XIMLookupStartCallbackStruct;
+ 
+ typedef struct _XIMChoiceObject {
+     XIMText        *label;
+     XIMText        *value;
+ }               XIMChoiceObject;
+ 
+ typedef struct _XIMLookupDrawCallbackStruct {
+     XIMChoiceObject *choices;	/* the lookup choices */
+     int             n_choices;	/* Total number of lookup choices */
+     int             max_len;	/* Max number of characters per choice item */
+     int             index_of_first_candidate;
+     int             index_of_last_candidate;
+ }               XIMLookupDrawCallbackStruct;
+ 
+ typedef struct _XIMLookupProcessCallbackStruct {
+     XKeyEvent      *event;
+     int             index_of_choice_selected;	/* Set by callback for the
+ 						 * selected choice.
+ 						 * XIM_UNKNOW_KEYSYM and
+ 						 * XIM_UNDETERMINED are also
+ 						 * possible value. */
+ }               XIMLookupProcessCallbackStruct;
+ 
+ extern Ximp_XIC _Ximp_LookupXIC();
+ extern void     _Ximp_IM_SendMessage();
+ 
  #define Private static
  /*
   * Ximp extentions to XIC attributes
***************
*** 48,67 ****
  #define XNExtXimp_Statuswindow          "XNExtXimp_Statuswindow"
  #define XNExtXimp_Conversion	        "XNExtXimp_Conversion"
  #define XNExtXimp_Error		        "XNExtXimp_Error"
  #define XNExtXimp_LookupStartCallback   "XNExtXimp_LookupStartCallback"
  #define XNExtXimp_LookupDrawCallback    "XNExtXimp_LookupDrawCallback"
  #define XNExtXimp_LookupDoneCallback    "XNExtXimp_LookupDoneCallback"
  #define XNExtXimp_LookupProcessCallback "XNExtXimp_LookupProcessCallback"
  #define XNExtXimp_AuxStartCallback      "XNExtXimp_AuxStartCallback"
  #define XNExtXimp_AuxDrawCallback       "XNExtXimp_AuxDrawCallback"
  #define XNExtXimp_AuxProcessCallback    "XNExtXimp_AuxProcessCallback"
  #define XNExtXimp_AuxDoneCallback       "XNExtXimp_AuxDoneCallback"
  
  /*
   * Ximp properties for extented XIC attribute
   */
  #define XIMP_EXT_XIMP_CONVERSION           "_XIMP_EXT_XIMP_CONVERSION"
! #define XIMP_EXT_XIMP_BACK_FRONT            "_XIMP_EXT_XIMP_BACK_FRONT"
  #define XIMP_EXT_XIMP_STATUSWINDOW         "_XIMP_EXT_XIMP_STATUSWINDOW"
  #define XIMP_EXT_XIMP_ERROR		   "_XIMP_EXT_XIMP_ERROR"
  #define XIMP_EXT_XIMP_AUXSTARTCALLBACK     "_XIMP_EXT_XIMP_AUXSTARTCALLBACK"
--- 120,142 ----
  #define XNExtXimp_Statuswindow          "XNExtXimp_Statuswindow"
  #define XNExtXimp_Conversion	        "XNExtXimp_Conversion"
  #define XNExtXimp_Error		        "XNExtXimp_Error"
+ #define XNExtXimp_LookupAttributes	"XNExtXimp_LookupAttributes"
  #define XNExtXimp_LookupStartCallback   "XNExtXimp_LookupStartCallback"
  #define XNExtXimp_LookupDrawCallback    "XNExtXimp_LookupDrawCallback"
  #define XNExtXimp_LookupDoneCallback    "XNExtXimp_LookupDoneCallback"
  #define XNExtXimp_LookupProcessCallback "XNExtXimp_LookupProcessCallback"
+ #define XNExtXimp_AuxAttributes		"XNExtXimp_AuxAttributes"
  #define XNExtXimp_AuxStartCallback      "XNExtXimp_AuxStartCallback"
  #define XNExtXimp_AuxDrawCallback       "XNExtXimp_AuxDrawCallback"
  #define XNExtXimp_AuxProcessCallback    "XNExtXimp_AuxProcessCallback"
  #define XNExtXimp_AuxDoneCallback       "XNExtXimp_AuxDoneCallback"
+ #define XNExtXimp_LookupBegin	        "XNExtXimp_LookupBegin"
  
  /*
   * Ximp properties for extented XIC attribute
   */
  #define XIMP_EXT_XIMP_CONVERSION           "_XIMP_EXT_XIMP_CONVERSION"
! #define XIMP_EXT_XIMP_BACK_FRONT           "_XIMP_EXT_XIMP_BACK_FRONT"
  #define XIMP_EXT_XIMP_STATUSWINDOW         "_XIMP_EXT_XIMP_STATUSWINDOW"
  #define XIMP_EXT_XIMP_ERROR		   "_XIMP_EXT_XIMP_ERROR"
  #define XIMP_EXT_XIMP_AUXSTARTCALLBACK     "_XIMP_EXT_XIMP_AUXSTARTCALLBACK"
***************
*** 73,78 ****
--- 148,154 ----
  #define XIMP_EXT_XIMP_LOOKUPDONECALLBACK   "_XIMP_EXT_XIMP_LOOKUPDONECALLBACK"
  #define XIMP_EXT_XIMP_LOOKUPPROCESSCALLBACK "_XIMP_EXT_XIMP_LOOKUPPROCESSCALLBACK"
  
+ #define XIMP_EXT_XIMP_LOOKUPCHOICES        "_XIMP_EXT_XIMP_LOOKUPCHOICES"
  /*
   * Ximp extentions to IM attributes
   */
***************
*** 97,103 ****
      XICOpGet = 3,
  }               XICOp_t;
  
- 
  /*
   * Declaration of the entry functions for each extensions.
   */
--- 173,178 ----
***************
*** 105,110 ****
--- 180,186 ----
  Private int     ximp_ext_conversion();
  Private int     ximp_ext_statuswindow();
  Private int     ximp_ext_error();
+ Private int     ximp_ext_lookup_begin();
  Private int     ximp_ext_lookup_start_callback();
  Private int     ximp_ext_lookup_draw_callback();
  Private int     ximp_ext_lookup_done_callback();
***************
*** 113,118 ****
--- 189,196 ----
  Private int     ximp_ext_aux_draw_callback();
  Private int     ximp_ext_aux_process_callback();
  Private int     ximp_ext_aux_done_callback();
+ Private int	nested_list();
+ 
  /* If you need to extend IC attributes, please add function here */
  
  typedef struct {
***************
*** 123,147 ****
  Private
  icop_t icoptbl[] = {
      XNExtXimp_Backfront, ximp_ext_backfront,
!     XNExtXimp_Conversion, ximp_ext_conversion,
!     XNExtXimp_Statuswindow, ximp_ext_statuswindow,
!     XNExtXimp_Error, ximp_ext_error,
!     XNExtXimp_LookupStartCallback, ximp_ext_lookup_start_callback,
!     XNExtXimp_LookupDrawCallback, ximp_ext_lookup_draw_callback,
!     XNExtXimp_LookupDoneCallback, ximp_ext_lookup_done_callback,
!     XNExtXimp_LookupProcessCallback, ximp_ext_lookup_process_callback,
!     XNExtXimp_AuxStartCallback, ximp_ext_aux_start_callback,
!     XNExtXimp_AuxDrawCallback, ximp_ext_aux_draw_callback,
!     XNExtXimp_AuxProcessCallback, ximp_ext_aux_process_callback,
!     XNExtXimp_AuxDoneCallback, ximp_ext_aux_done_callback,
      /*
       * If you need to extend IC attributes, please add attribute/function
       * here
       */
!     0
  };
  #define ICOPTBLSIZE ((sizeof(icoptbl)/sizeof(icop_t)) - 1)
  
  Private int
  ximp_ext_backfront(ic, op, value)
      Ximp_XIC        ic;
--- 201,234 ----
  Private
  icop_t icoptbl[] = {
      XNExtXimp_Backfront, ximp_ext_backfront,
! 	XNExtXimp_Conversion, ximp_ext_conversion,
! 	XNExtXimp_Statuswindow, ximp_ext_statuswindow,
! 	XNExtXimp_Error, ximp_ext_error,
!     	XNExtXimp_LookupAttributes, nested_list,
! 	XNExtXimp_LookupStartCallback, ximp_ext_lookup_start_callback,
! 	XNExtXimp_LookupDrawCallback, ximp_ext_lookup_draw_callback,
! 	XNExtXimp_LookupDoneCallback, ximp_ext_lookup_done_callback,
! 	XNExtXimp_LookupProcessCallback, ximp_ext_lookup_process_callback,
!     	XNExtXimp_LookupAttributes, nested_list,
! 	XNExtXimp_AuxStartCallback, ximp_ext_aux_start_callback,
! 	XNExtXimp_AuxDrawCallback, ximp_ext_aux_draw_callback,
! 	XNExtXimp_AuxProcessCallback, ximp_ext_aux_process_callback,
! 	XNExtXimp_AuxDoneCallback, ximp_ext_aux_done_callback,
! 	XNExtXimp_LookupBegin, ximp_ext_lookup_begin,
      /*
       * If you need to extend IC attributes, please add attribute/function
       * here
       */
! 	0
  };
+ 
  #define ICOPTBLSIZE ((sizeof(icoptbl)/sizeof(icop_t)) - 1)
  
+ /*
+  * Ximp extentions
+  *      XIMP_EXT_XIMP_BACK_FRONT
+  */
+ 
  Private int
  ximp_ext_backfront(ic, op, value)
      Ximp_XIC        ic;
***************
*** 148,158 ****
      XICOp_t         op;
      long            value;
  {
!     XIMXimpRec     *im_impart;
      Ximp_ExtXIMRec *ext_im;
  
!     if ((im_impart = ((Ximp_XIMRec *) ic->core.im)->ximp_impart) ==
! 	(XIMXimpRec *) NULL)
  	return (False);
      ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
      if (!(ext_im->extension_back_front_exist))
--- 235,245 ----
      XICOp_t         op;
      long            value;
  {
!     XIMXimpRec     *im_impart = ((Ximp_XIM)ic->core.im)->ximp_impart;
      Ximp_ExtXIMRec *ext_im;
+     long           *p_long;
  
!     if(!(im_impart->inputserver))
  	return (False);
      ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
      if (!(ext_im->extension_back_front_exist))
***************
*** 162,177 ****
      case XICOpCreate:
      case XICOpSet:
  	ic->ximp_icpart->is_bep_mode = (int) value;
! 	return True;
  	break;
      case XICOpGet:
! 	*((long *) value) = ic->ximp_icpart->is_bep_mode;
! 	return True;
  	break;
      }
      return (False);
  }
  
  /**
   * Extended protocol for XNExtXimp_Conversion.
   * From Ximp lib to IM Server (To query or to set)
--- 249,273 ----
      case XICOpCreate:
      case XICOpSet:
  	ic->ximp_icpart->is_bep_mode = (int) value;
! 	return (True);
  	break;
      case XICOpGet:
! 	if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 		*((long *) value) = (long)NULL;
! 		break;
! 	}
! 	*p_long = (long)(ic->ximp_icpart->is_bep_mode);
! 	*((long *) value) = (long)p_long;
! 	return (True);
  	break;
      }
      return (False);
  }
  
+ /*
+  * Ximp extentions
+  *      XIMP_EXT_XIMP_CONVERSION
+  */
  /**
   * Extended protocol for XNExtXimp_Conversion.
   * From Ximp lib to IM Server (To query or to set)
***************
*** 207,217 ****
      XICOp_t         op;
      long            value;
  {
!     XIMXimpRec     *im_impart;
      Ximp_ExtXIMRec *ext_im;
  
!     if ((im_impart = ((Ximp_XIMRec *) ic->core.im)->ximp_impart)
! 	== (XIMXimpRec *) NULL)
  	return (False);
      ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
      if (!(ext_im->extension_conversion_exist))
--- 303,313 ----
      XICOp_t         op;
      long            value;
  {
!     XIMXimpRec     *im_impart = ((Ximp_XIM)ic->core.im)->ximp_impart;
      Ximp_ExtXIMRec *ext_im;
+     int            *p_long;
  
!     if(!(im_impart->inputserver))
  	return (False);
      ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
      if (!(ext_im->extension_conversion_exist))
***************
*** 231,252 ****
  	 * This call expect IM Server to report new conversion state to Ximp
  	 * lib right after setting.
  	 */
  	break;
      case XICOpGet:
  	_Ximp_IM_SendMessage(ic, XIMP_EXTENSION,
! 			     ext_im->extension_conversion_id,
! 			     False,	/* GetICVelues */
! 			     value);
  	/*
  	 * KNOWN issue: above call would never affect following.
  	 */
! 	*((long *) value) = ext_im->extension_conversion;
  	break;
      }
      return (False);
- 
  }
  
  Private int
  ximp_ext_statuswindow(ic, op, value)
      Ximp_XIC        ic;
--- 327,359 ----
  	 * This call expect IM Server to report new conversion state to Ximp
  	 * lib right after setting.
  	 */
+ 	return True;
  	break;
      case XICOpGet:
  	_Ximp_IM_SendMessage(ic, XIMP_EXTENSION,
! 		     ext_im->extension_conversion_id,
! 		     False,	/* GetICVelues */
! 		     value);
  	/*
  	 * KNOWN issue: above call would never affect following.
  	 */
! 	if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 		*((long *) value) = (long)NULL;
! 		break;
!         }
! 	*p_long = (long)(ext_im->extension_conversion);
! 	*((long *) value) = (long)p_long;
! 	return (True);
  	break;
      }
      return (False);
  }
  
+ /*
+  * Ximp extentions
+  *      XIMP_EXT_XIMP_STATUSWINDOW
+  */
+ 
  Private int
  ximp_ext_statuswindow(ic, op, value)
      Ximp_XIC        ic;
***************
*** 253,258 ****
--- 360,372 ----
      XICOp_t         op;
      long            value;
  {
+     XIMXimpRec     *im_impart = ((Ximp_XIM)ic->core.im)->ximp_impart;
+     Ximp_ExtXIMRec *ext_im;
+ 
+     ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
+     if (!(ext_im->extension_statuswindow_exist))
+ 	return (False);
+ 
      switch (op) {
      case XICOpCreate:
      case XICOpSet:
***************
*** 267,275 ****
  	break;
      }
      return (False);
- 
  }
  
  Private int
  ximp_ext_error(ic, op, value)
      Ximp_XIC        ic;
--- 381,393 ----
  	break;
      }
      return (False);
  }
  
+ /*
+  * Ximp extentions
+  *      XIMP_EXT_XIMP_ERROR
+  */
+ 
  Private int
  ximp_ext_error(ic, op, value)
      Ximp_XIC        ic;
***************
*** 276,285 ****
      XICOp_t         op;
      long            value;
  {
-     XIMXimpRec     *im_impart;
-     Ximp_ExtXIMRec *ext_im;
- 
- 
      switch (op) {
      case XICOpCreate:
      case XICOpSet:
--- 394,399 ----
***************
*** 296,301 ****
--- 410,420 ----
      return (False);
  }
  
+ /*
+  * Ximp extentions
+  *      XIMP_EXT_XIMP_LOOKUPCHOICES
+  */
+ 
  Private int
  ximp_ext_lookup_start_callback(ic, op, value)
      Ximp_XIC        ic;
***************
*** 305,313 ****
      switch (op) {
      case XICOpCreate:
      case XICOpSet:
! 	/*
! 	 * NOT Implemented Yet
! 	 */
  	break;
      case XICOpGet:
  	/*
--- 424,434 ----
      switch (op) {
      case XICOpCreate:
      case XICOpSet:
! 	ic->ximp_icpart->lookup_attr.callbacks.start.client_data =
! 	    ((XIMCallback *) value)->client_data;
! 	ic->ximp_icpart->lookup_attr.callbacks.start.callback =
! 	    ((XIMCallback *) value)->callback;
! 	return (True);
  	break;
      case XICOpGet:
  	/*
***************
*** 327,335 ****
      switch (op) {
      case XICOpCreate:
      case XICOpSet:
! 	/*
! 	 * NOT Implemented Yet
! 	 */
  	break;
      case XICOpGet:
  	/*
--- 448,458 ----
      switch (op) {
      case XICOpCreate:
      case XICOpSet:
! 	ic->ximp_icpart->lookup_attr.callbacks.draw.client_data =
! 	    ((XIMCallback *) value)->client_data;
! 	ic->ximp_icpart->lookup_attr.callbacks.draw.callback =
! 	    ((XIMCallback *) value)->callback;
! 	return (True);
  	break;
      case XICOpGet:
  	/*
***************
*** 349,357 ****
      switch (op) {
      case XICOpCreate:
      case XICOpSet:
! 	/*
! 	 * NOT Implemented Yet
! 	 */
  	break;
      case XICOpGet:
  	/*
--- 472,482 ----
      switch (op) {
      case XICOpCreate:
      case XICOpSet:
! 	ic->ximp_icpart->lookup_attr.callbacks.done.client_data =
! 	    ((XIMCallback *) value)->client_data;
! 	ic->ximp_icpart->lookup_attr.callbacks.done.callback =
! 	    ((XIMCallback *) value)->callback;
! 	return (True);
  	break;
      case XICOpGet:
  	/*
***************
*** 371,379 ****
      switch (op) {
      case XICOpCreate:
      case XICOpSet:
! 	/*
! 	 * NOT Implemented Yet
! 	 */
  	break;
      case XICOpGet:
  	/*
--- 496,506 ----
      switch (op) {
      case XICOpCreate:
      case XICOpSet:
! 	ic->ximp_icpart->lookup_attr.callbacks.proc.client_data =
! 	    ((XIMCallback *) value)->client_data;
! 	ic->ximp_icpart->lookup_attr.callbacks.proc.callback =
! 	    ((XIMCallback *) value)->callback;
! 	return (True);
  	break;
      case XICOpGet:
  	/*
***************
*** 472,481 ****
--- 599,1023 ----
      return (False);
  }
  
+ Private int
+ ximp_ext_lookup_begin(ic, op, value)
+     Ximp_XIC        ic;
+     XICOp_t         op;
+     long            value;
+ {
+     XIMXimpRec     *im_impart = ((Ximp_XIM)ic->core.im)->ximp_impart;
+     Ximp_ExtXIMRec *ext_im;
+ 
+     if(!(im_impart->inputserver))
+ 	return (False);
+     ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
+     if (!(ext_im->extension_lookup_exist))
+ 	return (False);
+ 
+     switch (op) {
+     case XICOpCreate:
+ 	ic->ximp_icpart->use_lookup_choices = True ;
+ 	break ;
+     case XICOpSet:
+ 	ic->ximp_icpart->use_lookup_choices = True ;
+ 	_Ximp_IM_SendMessage(ic, XIMP_EXTENSION,
+ 			     ext_im->extension_lookup_id,
+ 			     LOOKUP_CHOICES_BEGIN,
+ 			     NULL);
+ 	return (True);
+ 	break;
+     case XICOpGet:
+ 	/*
+ 	 * NOT surely implemented Yet. Need attention.
+ 	 */
+ 	break;
+     }
+     return (False);
+ }
+ 
+ static void _Ximp_Extlookupstart();
+ static void _Ximp_Extlookupdraw();
+ static void _Ximp_Extlookupprocess();
+ static void _Ximp_Extlookupdone();
+ 
  void
+ _Ximp_ExtLookup(d, w, ev, ic)
+     Display        *d;
+     Window          w;
+     XClientMessageEvent *ev;
+     Ximp_XIC        ic;
+ {
+     switch (ev->data.l[3]) {
+     case LOOKUP_CHOICES_START_REQ:
+ 	_Ximp_Extlookupstart(ic, ev);
+ 	break;
+     case LOOKUP_CHOICES_DRAW_REQ:
+ 	_Ximp_Extlookupdraw(ic, ev);
+ 	break;
+     case LOOKUP_CHOICES_PROCESS_REQ:
+ 	_Ximp_Extlookupprocess(ic, ev, d, w);
+ 	break;
+     case LOOKUP_CHOICES_DONE_REQ:
+ 	_Ximp_Extlookupdone(ic, ev);
+ 	break;
+     }
+     return;
+ }
+ 
+ static void
+ FreeXIMLookupDrawCallbackStruct(p)
+ XIMLookupDrawCallbackStruct *p;
+ {
+     register i ;
+     for(i = 0 ; i < p->n_choices ; i++){
+ 	if(p->choices[i].label){
+ 	    if(p->choices[i].label->string.multi_byte)
+ 	      Xfree(p->choices[i].label->string.multi_byte);
+ 	    if(p->choices[i].label->feedback)
+ 	      Xfree(p->choices[i].label->feedback);
+ 	    Xfree(p->choices[i].label);
+ 	}
+ 	if(p->choices[i].value){
+ 	    if(p->choices[i].value->string.multi_byte)
+ 	      Xfree(p->choices[i].value->string.multi_byte);
+ 	    if(p->choices[i].value->feedback)
+ 	      Xfree(p->choices[i].value->feedback);
+ 	    Xfree(p->choices[i].value);
+ 	}
+     }
+     Xfree(p->choices);
+     Xfree(p);
+ }
+ 
+ static void
+ _Ximp_Extlookupstart(ic, event)
+     Ximp_XIC        ic;
+     XClientMessageEvent *event;
+ {
+     register XIMCallback *cb;
+     static XClientMessageEvent clmsg;
+     XIMLookupStartCallbackStruct xim_start;
+     Ximp_ExtXIMRec *ext_im;
+     long           *prop;
+     Atom            type;
+     int             format;
+     unsigned long   nitems, after;
+ 
+     cb = &ic->ximp_icpart->lookup_attr.callbacks.start;
+     if(ic->ximp_icpart->lookup_attr.draw_data){
+ 	FreeXIMLookupDrawCallbackStruct(ic->ximp_icpart->lookup_attr.draw_data);
+ 	ic->ximp_icpart->lookup_attr.draw_data = NULL ;
+     }
+     if (cb->callback) {
+ 	if ((XGetWindowProperty(ic->core.im->core.display,
+ 			   ((Ximp_XIM) ic->core.im)->ximp_impart->fe_window,
+ 			       event->data.l[4], 0, 8, True, AnyPropertyType,
+ 			       &type, &format, &nitems, &after,
+ 			       (unsigned char **) &prop) == Success) && prop){
+ 
+ 	    xim_start.event = (XKeyEvent *) malloc(sizeof(XEvent));
+ 	    bzero(xim_start.event , sizeof(XEvent));
+ 	    xim_start.event->keycode = *prop;
+ 	    xim_start.event->state = *(prop + 1);
+ 	    xim_start.event->window = ic->core.focus_window ;
+ 	    xim_start.WhoIsMaster = *(prop + 2);
+ 	    xim_start.XIMPreference = (LayoutInfo *) malloc(sizeof(LayoutInfo));
+ 	    xim_start.XIMPreference->choice_per_window = *(prop + 3);
+ 	    xim_start.XIMPreference->nrows = *(prop + 4);
+ 	    xim_start.XIMPreference->ncolumns = *(prop + 5);
+ 	    xim_start.XIMPreference->DrawUpDirection = *(prop + 6);
+ 	    xim_start.XIMPreference->WhoOwnsLabel = *(prop + 7);
+ 	    xim_start.CBPreference = (LayoutInfo *) malloc(sizeof(LayoutInfo));
+ 	    XFree((char *) prop);
+ 
+ 	    (*cb->callback) (ic, cb->client_data, &xim_start);
+ 
+ 	    ext_im = (Ximp_ExtXIMRec *) (((Ximp_XIMRec *) ic->core.im)->ximp_impart->imtype);
+ 
+ 	    prop = (long *) malloc(sizeof(long) * 6);
+ 	    *(prop + 0) = xim_start.WhoIsMaster;
+ 	    *(prop + 1) = xim_start.CBPreference->choice_per_window;
+ 	    *(prop + 2) = xim_start.CBPreference->nrows;
+ 	    *(prop + 3) = xim_start.CBPreference->ncolumns;
+ 	    *(prop + 4) = xim_start.CBPreference->DrawUpDirection;
+ 	    *(prop + 5) = xim_start.CBPreference->WhoOwnsLabel;
+ 
+ 	    XChangeProperty(ic->core.im->core.display,
+ 			    ic->core.focus_window,
+ 			    ext_im->extension_lookup_start_rep,
+ 			    ext_im->extension_lookup_start_rep,
+ 			    32,
+ 			    PropModeReplace,
+ 			    prop,
+ 			    6);
+ 
+ 	    XFlush(ic->core.im->core.display);
+ 
+ 	    _Ximp_IM_SendMessage(ic, XIMP_EXTENSION,
+ 				 ext_im->extension_lookup_id,
+ 				 LOOKUP_CHOICES_START_REP,
+ 				 ext_im->extension_lookup_start_rep,
+ 				 NULL);
+ 
+ 	    XFlush(ic->core.im->core.display);
+ 
+ 	    free((char *) prop);
+ 	    free((char *) xim_start.event);
+ 	    free((char *) xim_start.CBPreference);
+ 	    free((char *) xim_start.XIMPreference);
+ 	}
+     }
+ }
+ 
+ static void
+ _Ximp_Extlookupdraw(ic, event)
+     Ximp_XIC        ic;
+     XClientMessageEvent *event;
+ {
+     register XIMCallback *cb;
+     static XClientMessageEvent clmsg;
+     XIMLookupDrawCallbackStruct *luc_draw;
+     Ximp_ExtXIMRec *ext_im;
+     long           *prop;
+     char           *text, *textaddr;
+     long           *feedback;
+     XIMText        *textbuf;
+     XIMChoiceObject *choicebuf, *chptr;
+     Atom            type;
+     int             format;
+     int             i, l, j;
+     int             strnum;
+     unsigned long   nitems, after;
+ 
+     cb = &ic->ximp_icpart->lookup_attr.callbacks.draw;
+     if(ic->ximp_icpart->lookup_attr.draw_data){
+ 	FreeXIMLookupDrawCallbackStruct(ic->ximp_icpart->lookup_attr.draw_data);
+ 	ic->ximp_icpart->lookup_attr.draw_data =  NULL ;
+ 	
+     }
+     if (!cb->callback)
+ 	return;
+ 
+     ic->ximp_icpart->lookup_attr.draw_data =  (XPointer)(luc_draw
+       = (XIMLookupDrawCallbackStruct *)Xmalloc(sizeof(XIMLookupDrawCallbackStruct)));
+     bzero(luc_draw, sizeof(XIMLookupDrawCallbackStruct));
+ 
+     if ((XGetWindowProperty(ic->core.im->core.display,
+ 			   ((Ximp_XIM) ic->core.im)->ximp_impart->fe_window,
+ 			   event->data.l[4], 0, 5, True, AnyPropertyType,
+ 			   &type, &format, &nitems, &after,
+ 			   (unsigned char **) &prop) != Success) || !prop)
+ 	return;
+ 
+     luc_draw->max_len = *prop;
+     luc_draw->index_of_first_candidate = *(prop + 1);
+     luc_draw->index_of_last_candidate = *(prop + 2);
+ 
+     if ((XGetWindowProperty(ic->core.im->core.display,
+ 			   ((Ximp_XIM) ic->core.im)->ximp_impart->fe_window,
+ 			   *(prop + 3), 0, 4096, True, AnyPropertyType,
+ 			   &type, &format, &nitems, &after,
+ 			   (unsigned char **) &text) == Success) && text) {
+ 
+ 	for (strnum = 0, textaddr = text, i = 0; i < nitems; i++) {
+ 	    j = strlen(textaddr);
+ 	    textaddr += (j + 1);
+ 	    strnum++;
+ 	    i += j;
+ 	}
+ 
+ 	choicebuf = (XIMChoiceObject *) Xmalloc(sizeof(XIMChoiceObject)
+ 					       * (strnum / 2));
+ 	bzero(choicebuf, sizeof(XIMChoiceObject) * (strnum / 2));
+ 
+ 	for (textaddr = text, chptr = choicebuf, i = 0; i < strnum; i += 2, chptr++) {
+ 	    if (*textaddr) {
+ 		chptr->label = (XIMText *) Xmalloc(sizeof(XIMText));
+ 		bzero(chptr->label, sizeof(XIMText));
+ 		l = j = strlen(textaddr);
+ 		chptr->label->string.multi_byte = (char *) Xmalloc(j);
+ 		bzero(chptr->label->string.multi_byte,j);
+ 		_Ximp_cttombs(ic->core.im->core.lcd,
+ 			      textaddr, j,
+ 			      chptr->label->string.multi_byte, &l, NULL);
+ 		chptr->label->length = l;
+ 		textaddr += j;
+ 	    }
+ 	    textaddr++;
+ 
+ 	    if (*textaddr) {
+ 		chptr->value = (XIMText *) Xmalloc(sizeof(XIMText));
+ 		bzero(chptr->value, sizeof(XIMText));
+ 		l = j = strlen(textaddr);
+ 		chptr->value->string.multi_byte = (char *) Xmalloc(j);
+ 		bzero(chptr->value->string.multi_byte,j);
+ 		_Ximp_cttombs(ic->core.im->core.lcd,
+ 			      textaddr, j,
+ 			      chptr->value->string.multi_byte, &l, NULL);
+ 		chptr->value->length = l;
+ 		textaddr += j;
+ 	    }
+ 	    textaddr++;
+ 	}
+ 
+ 	luc_draw->choices = choicebuf;
+ 	luc_draw->n_choices = (strnum / 2);
+     }
+     if ((XGetWindowProperty(ic->core.im->core.display,
+ 			   ((Ximp_XIM) ic->core.im)->ximp_impart->fe_window,
+ 			   *(prop + 4), 0, 4096, True, AnyPropertyType,
+ 			   &type, &format, &nitems, &after,
+ 			   (unsigned char *) &feedback) == Success)&&feedback){
+ 
+ 	for (i = l = 0; i < luc_draw->n_choices; i++, l += 2) {
+ 	    if (luc_draw->choices[i].value){
+ 		register len = luc_draw->choices[i].value->length ;
+ 		luc_draw->choices[i].value->feedback =
+ 		  (XIMFeedback *)Xmalloc(sizeof(XIMFeedback) * len );
+ 		if(len == 1){
+ 		    luc_draw->choices[i].value->feedback[0] = feedback[l];
+ 		} else {
+ 		    register j ;
+ 		    for (j = 0 ; j < len ; j++){
+ 			luc_draw->choices[i].value->feedback[j] = feedback[l+1];
+ 		    }
+ 		}
+ 		if (luc_draw->choices[i].label){
+ 		    luc_draw->choices[i].label->feedback = 
+ 		      (XIMFeedback *)Xmalloc(sizeof(XIMFeedback) * len );
+ 		    if(len == 1){
+ 			luc_draw->choices[i].label->feedback[0] = feedback[l];
+ 		    } else {
+ 			register j ;
+ 			for (j = 0 ; j < len ; j++){
+ 			    luc_draw->choices[i].label->feedback[j] = feedback[l];
+ 			}
+ 		    }
+ 		}
+ 	    }
+ 	}
+ 	(*cb->callback) (ic, cb->client_data, luc_draw);
+ 	XFree(text);
+ 	XFree(feedback);
+     }
+ }
+ 
+ static void
+ _Ximp_Extlookupprocess(ic, event, d, w)
+     Ximp_XIC        ic;
+     XClientMessageEvent *event;
+     Display        *d;
+     Window          w;
+ {
+     register XIMCallback *cb;
+     static XClientMessageEvent clmsg;
+     XIMLookupProcessCallbackStruct xim_proc;
+     Ximp_ExtXIMRec *ext_im;
+     long           *prop;
+     Atom            type;
+     int             format;
+     unsigned long   nitems, after;
+ 
+     cb = &ic->ximp_icpart->lookup_attr.callbacks.proc;
+ 
+     if (cb->callback) {
+ 	if ((XGetWindowProperty(ic->core.im->core.display,
+ 			   ((Ximp_XIM) ic->core.im)->ximp_impart->fe_window,
+ 			       event->data.l[4], 0, 2, True, AnyPropertyType,
+ 			       &type, &format, &nitems, &after,
+ 			       (unsigned char **) &prop) == Success)&&prop) {
+ 
+ 	    xim_proc.event = (XKeyEvent *)event;
+ 	    xim_proc.event->keycode = ((long *)prop)[0];
+ 	    xim_proc.event->state = ((long *)prop)[1];
+ 	    xim_proc.event->type = KeyPress ;
+ 
+ 	    (*cb->callback) (ic, cb->client_data, &xim_proc);
+ 
+ 	    ext_im = (Ximp_ExtXIMRec *) (((Ximp_XIMRec *) ic->core.im)->ximp_impart->imtype);
+ 
+ 	    _Ximp_IM_SendMessage(ic, XIMP_EXTENSION,
+ 				 ext_im->extension_lookup_id,
+ 				 LOOKUP_CHOICES_PROCESS_REP,
+ 				 xim_proc.index_of_choice_selected,
+ 				 NULL);
+ 
+ 	    XFlush(ic->core.im->core.display);
+ 	}
+     }
+ }
+ 
+ static void
+ _Ximp_Extlookupdone(ic, event)
+     Ximp_XIC        ic;
+     XClientMessageEvent *event;
+ {
+     register XIMCallback *cb;
+ 
+     cb = &ic->ximp_icpart->lookup_attr.callbacks.done;
+ 
+     if (cb->callback) {
+ 	(*cb->callback) (ic, cb->client_data, NULL);
+     }
+     if(ic->ximp_icpart->lookup_attr.draw_data){
+ 	FreeXIMLookupDrawCallbackStruct(ic->ximp_icpart->lookup_attr.draw_data);
+ 	ic->ximp_icpart->lookup_attr.draw_data = NULL ;	
+     }
+ }
+ 
+ /*
+  * Following functions are called by Core of Ximp.
+  * These are used as fook for extension to Ximp.
+  */
+ 
+ Private int
+ _Ximp_ext_icop(ic, name, op, value)
+     Ximp_XIC        ic;
+     char           *name;
+     XICOp_t         op;
+     long            value;
+ {
+     register        i;
+ 
+     for (i = 0; i < ICOPTBLSIZE; i++) {
+ 	if (name[0] == icoptbl[i].name[0]) {	/* For faster comparison */
+ 	    if (!strcmp(name + 1, icoptbl[i].name + 1)) {
+ 		return ((*(icoptbl[i].func)) (ic, op, value));
+ 
+ 	    }
+ 	}
+     }
+     return False ;
+ }
+ 
+ Private int
+ nested_list(ic, op, args)
+ Ximp_XIC ic ;
+ XICOp_t op;
+ XIMArg *args ;
+ {
+     register i ;
+     int status ;
+     register XIMArg *arg;
+ 
+     for (arg = args; arg->name && *(arg->name); arg++) {
+ 	if(_Ximp_ext_icop(ic, arg->name, op, arg->value ) == False){
+ 	    return False ;
+ 	}
+     }
+     return True ;
+ }  
+ 
+ /*
+  * _Ximp_OpenIMResourceExtension() and _Ximp_SetupExtention()
+  * is called from XOpenIM().
+  */
+ 
+ void
  _Ximp_OpenIMResourceExtension(im)
      Ximp_XIM        im;
  {
+     /* Add extension here */
      return;
  }
  
***************
*** 487,492 ****
--- 1029,1036 ----
      Atom           *atom;
      Atom            back_front;	/* Ximp registered extention */
      Atom            conversion;	/* Ximp registered extention */
+     Atom            status_win;	/* Ximp registered extention */
+     Atom            lookup;	/* Ximp registered extention */
  
      if ((ext_im = (Ximp_ExtXIMRec *) Xmalloc(sizeof(Ximp_ExtXIMRec))) == (Ximp_ExtXIMRec *) NULL)
  	return;
***************
*** 504,509 ****
--- 1048,1064 ----
      conversion = XInternAtom(im->core.display,
  			     XIMP_EXT_XIMP_CONVERSION, True);
  
+     /*
+      * Status Window
+      */
+     status_win = XInternAtom(im->core.display,
+ 			     XIMP_EXT_XIMP_STATUSWINDOW, True);
+     /*
+      * Lookup Choice  switching
+      */
+     lookup = XInternAtom(im->core.display,
+ 			 XIMP_EXT_XIMP_LOOKUPCHOICES, True);
+ 
      for (atom = im->ximp_impart->im_ext_list; *atom; atom++) {
  	if (back_front == *atom) {	/* Backend / Frontend */
  	    ext_im->extension_back_front_exist = True;
***************
*** 511,522 ****
  	} else if (conversion == *atom) {
  	    ext_im->extension_conversion_exist = True;
  	    ext_im->extension_conversion_id = conversion;
! 	} else;			/* Add Extension */
      }
      im->ximp_impart->imtype = ext_im;
      return;
  }
  
  void
  _Ximp_SetupFreeExtension(im)
      Ximp_XIM        im;
--- 1066,1097 ----
  	} else if (conversion == *atom) {
  	    ext_im->extension_conversion_exist = True;
  	    ext_im->extension_conversion_id = conversion;
! 	} else if (status_win == *atom) {
! 	    ext_im->extension_statuswindow_exist = True;
! 	    ext_im->extension_statuswindow_id = status_win;
! 	} else if (lookup == *atom) {
! 	    ext_im->extension_lookup_exist = True;
! 	    ext_im->extension_lookup_id = lookup;
! 
! 	    ext_im->extension_lookup_start = XInternAtom(
! 				 im->core.display,
! 				   XIMP_EXT_XIMP_LOOKUPSTARTCALLBACK, True);
! 	    ext_im->extension_lookup_start_rep = XInternAtom(im->core.display,
! 				   "_XIMP_EXT_XIMP_CHOICE_START_REP", True);
! 
! 	    ext_im->extension_lookup_proc_rep = XInternAtom(im->core.display,
! 				 "_XIMP_EXT_XIMP_CHOICE_PROCESS_REP", True);
! 	} else;
! 	    	/* Add extension here */
      }
      im->ximp_impart->imtype = ext_im;
      return;
  }
  
+ /*
+  * _Ximp_SetupFreeExtension() is called by XCloseIM().
+  */
+ 
  void
  _Ximp_SetupFreeExtension(im)
      Ximp_XIM        im;
***************
*** 523,531 ****
--- 1098,1111 ----
  {
      if (im->ximp_impart->imtype)
  	Xfree(im->ximp_impart->imtype);
+     /* Add extension here */
      return;
  }
  
+ /*
+  * _Ximp_GetIMFreeExtension() is called by XGetIMValues().
+  */
+ 
  Bool
  _Ximp_GetIMExtension(ic, name, value)
      Ximp_XIC        ic;
***************
*** 532,568 ****
      char           *name;
      long            value;
  {
      return (False);
  }
  
! Private int
! _Ximp_ext_icop(ic, name, op, value)
!     Ximp_XIC        ic;
!     char           *name;
!     XICOp_t         op;
!     long            value;
! {
!     register        i;
  
-     for (i = 0; i < ICOPTBLSIZE; i++) {
- 	if (name[0] == icoptbl[i].name[0]) {	/* For faster comparison */
- 	    if (!strcmp(name + 1, icoptbl[i].name + 1)) {
- 		return ((*(icoptbl[i].func)) (ic, op, value));
- 
- 	    }
- 	}
-     }
- }
- 
  Bool
! _Ximp_SetICExtension(ic, name, value)
      Ximp_XIC        ic;
      char           *name;
      long            value;
  {
!     return _Ximp_ext_icop(ic, name, XICOpSet, value);
  }
  
  Bool
  _Ximp_GetICExtension(ic, name, value)
      Ximp_XIC        ic;
--- 1112,1142 ----
      char           *name;
      long            value;
  {
+     /* Add extension here */
      return (False);
  }
  
! /*
!  * _Ximp_SetICExtension() is called by XCreateIC() or XSetICValues().
!  */
  
  Bool
! _Ximp_SetICExtension(ic, name, value, mode)
      Ximp_XIC        ic;
      char           *name;
      long            value;
+     int             mode;
  {
!     if(mode == XIMP_CREATE_IC)
!         return _Ximp_ext_icop(ic, name, XICOpCreate, value);
!     else
!         return _Ximp_ext_icop(ic, name, XICOpSet, value);
  }
  
+ /*
+  * _Ximp_GetICExtension() is called by XGetICValues().
+  */
+ 
  Bool
  _Ximp_GetICExtension(ic, name, value)
      Ximp_XIC        ic;
***************
*** 572,577 ****
--- 1146,1156 ----
      return _Ximp_ext_icop(ic, name, XICOpGet, value);
  }
  
+ /*
+  * _Ximp_A_CreateExtension() is called by XCretaeIC().
+  * But this is called after protocol of XIMP_CRETAE.
+  */
+ 
  void
  _Ximp_A_CreateExtension(ic)
      Ximp_XIC        ic;
***************
*** 587,595 ****
--- 1166,1189 ----
  			     ic->ximp_icpart->is_bep_mode,
  			     NULL);
      }
+ 
+     /* Lookup Choice using check */
+     if((ext_im->extension_lookup_exist)) {
+ 	if ( ic->ximp_icpart->use_lookup_choices ) {
+ 	    	_Ximp_IM_SendMessage(ic, XIMP_EXTENSION,
+ 				     ext_im->extension_lookup_id,
+ 				     LOOKUP_CHOICES_BEGIN,
+ 				     NULL);
+ 	}
+     }
+     /* Add extension here */
      return;
  }
  
+ /*
+  * _Ximp_ProcExtension() is called by XFilterEvent().
+  */
+ 
  void
  _Ximp_ProcExtension(d, w, ev)
      Display        *d;
***************
*** 606,614 ****
      ext_id = ev->data.l[2];
      ic = _Ximp_LookupXIC(icid);
  
!     if ((im_impart = ((Ximp_XIMRec *) ic->core.im)->ximp_impart)
! 	== (XIMXimpRec *) NULL)
  	return;
      ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
  
      if (ext_id == ext_im->extension_conversion_id) {
--- 1200,1208 ----
      ext_id = ev->data.l[2];
      ic = _Ximp_LookupXIC(icid);
  
!     if(!((Ximp_XIM)ic->core.im)->ximp_impart->inputserver)
  	return;
+     im_impart = ((Ximp_XIM)ic->core.im)->ximp_impart;
      ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
  
      if (ext_id == ext_im->extension_conversion_id) {
***************
*** 618,626 ****
      } else if (ext_id == ext_im->extension_back_front_id) {
  	if (!(ext_im->extension_back_front_exist))
  	    return;
  	/* anything to do it? */
      } else;
      /* Add extension here */
      return;
- 
  }
--- 1212,1223 ----
      } else if (ext_id == ext_im->extension_back_front_id) {
  	if (!(ext_im->extension_back_front_exist))
  	    return;
+     } else if (ext_id == ext_im->extension_lookup_id) {
+ 	if (ext_im->extension_lookup_exist)
+ 	    _Ximp_ExtLookup(d, w, ev, ic);
+ 	return;
  	/* anything to do it? */
      } else;
      /* Add extension here */
      return;
  }

*** /tmp/,RCSt1001640	Mon Oct 28 15:38:25 1991
--- mit/lib/X/Ximp/XimpIC.c	Mon Oct  7 17:48:35 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpIC.c,v 1.3 91/07/09 17:21:44 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: XimpIC.c,v 1.4 91/10/07 17:48:30 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by FUJITSU LIMITED
***************
*** 70,80 ****
  				_Ximp_WcLookupString,	/* wc_lookup_string */
  				};
  
  XIC
  _Ximp_CreateIC(im, values)
  	XIM		 im;
  	XIMArg		*values;
! 	{
  	Ximp_XIC	 ic;
  	long		 dummy;
  	XICXimpRec	*ximp_icpart;
--- 70,94 ----
  				_Ximp_WcLookupString,	/* wc_lookup_string */
  				};
  
+ Bool
+ _Ximp_XimFilter_Keypress (d, w, ev, client_data)
+ 	Display		*d;
+ 	Window		w;
+ 	XEvent		*ev;
+ 	XPointer	*client_data;
+ {
+ 	extern Bool	_Ximp_Keypress ();
+ 
+ 	return(_Ximp_Keypress (d, w, ev, client_data));
+ }
+ 
+ static Ximp_XIC		current_xic = 0;
+ 
  XIC
  _Ximp_CreateIC(im, values)
  	XIM		 im;
  	XIMArg		*values;
! {
  	Ximp_XIC	 ic;
  	long		 dummy;
  	XICXimpRec	*ximp_icpart;
***************
*** 113,128 ****
  	if(!(ximp_icpart->value_mask & XIMP_CLIENT_WIN)) /* Client Window */
  		goto Set_Error;
  	
! 	if(   (ximp_icpart->value_mask & XIMP_RES_NAME)
! 	   || (ximp_icpart->value_mask & XIMP_RES_CLASS) )
! 		_Ximp_SetValue_Resource(ic, &dummy);
  
! 	if(((Ximp_XIM)im)->ximp_impart != (XIMXimpRec *)NULL) {
! 		if(((Ximp_XIM)im)->ximp_impart->inputserver) {
! 			if(_Ximp_SetOpenXIMP(ic) == False)
! 				goto Set_Error;
! 			}
! 		}
  	return((XIC)ic);
  
     Set_Error :
--- 127,146 ----
  	if(!(ximp_icpart->value_mask & XIMP_CLIENT_WIN)) /* Client Window */
  		goto Set_Error;
  	
! 	_Ximp_SetValue_Resource(ic, &dummy);
  
! 	if(((Ximp_XIM)im)->ximp_impart->inputserver) {
! 		if(_Ximp_SetOpenXIMP(ic) == False)
! 			goto Set_Error;
! 	}
! 	if (!current_xic) {
! 		_XRegisterFilterByType (ic->core.im->core.display,
! 				ic->core.focus_window,
! 				KeyPress, KeyPress,
! 				_Ximp_XimFilter_Keypress,
! 				ic);
! 		current_xic = ic;
! 	}
  	return((XIC)ic);
  
     Set_Error :
***************
*** 129,168 ****
  	Xfree(ic);
  	Xfree(ximp_icpart);
  	return((XIC)NULL);
! 	}
  
  static void
  _Ximp_DestroyIC(ic)
  	Ximp_XIC	 ic;
! 	{
! 	if(ic->ximp_icpart->icid)
   		_Ximp_IM_SendMessage(ic, XIMP_DESTROY, NULL, NULL, NULL);
  	Xfree(ic->ximp_icpart);
  	return;
! 	}
  
  static void
  _Ximp_SetFocus(ic)
  	Ximp_XIC	ic;
! 	{
! 	if(ic->ximp_icpart->icid)
   		_Ximp_IM_SendMessage(ic, XIMP_SETFOCUS, NULL, NULL, NULL);
! 	return;
  	}
  
  static void
  _Ximp_UnSetFocus(ic)
  	Ximp_XIC	ic;
! 	{
! 	if(ic->ximp_icpart->icid)
!  		_Ximp_IM_SendMessage(ic, XIMP_UNSETFOCUS, NULL, NULL, NULL);
! 	return;
  	}
  
  void
  _Ximp_SetFocusWindow(ic)
  	Ximp_XIC	 ic;
! 	{
  	Atom		 actual_type;
  	int		 actual_format;
  	unsigned long	 nitems, bytes_after;
--- 147,214 ----
  	Xfree(ic);
  	Xfree(ximp_icpart);
  	return((XIC)NULL);
! }
  
  static void
  _Ximp_DestroyIC(ic)
  	Ximp_XIC	 ic;
! {
! 	if(ic->ximp_icpart->icid) {
   		_Ximp_IM_SendMessage(ic, XIMP_DESTROY, NULL, NULL, NULL);
+ 		if (current_xic) {
+ 			_XUnregisterFilter (ic->core.im->core.display,
+ 					ic->core.focus_window,
+ 					_Ximp_XimFilter_Keypress,
+ 					current_xic);
+ 			current_xic = 0;
+ 		}
+ 	}
  	Xfree(ic->ximp_icpart);
  	return;
! }
  
  static void
  _Ximp_SetFocus(ic)
  	Ximp_XIC	ic;
! {
! 	if (ic->ximp_icpart->icid) {
   		_Ximp_IM_SendMessage(ic, XIMP_SETFOCUS, NULL, NULL, NULL);
! 		if (current_xic)
! 			_XUnregisterFilter (ic->core.im->core.display,
! 						ic->core.focus_window,
! 						_Ximp_XimFilter_Keypress,
! 						current_xic);
! 		_XRegisterFilterByType (ic->core.im->core.display,
! 					ic->core.focus_window,
! 					KeyPress, KeyPress,
! 					_Ximp_XimFilter_Keypress,
! 					ic);
! 		current_xic = ic;
  	}
+ 	return;
+ }
  
  static void
  _Ximp_UnSetFocus(ic)
  	Ximp_XIC	ic;
! {
! 	if(ic->ximp_icpart->icid) {
! 		_Ximp_IM_SendMessage(ic, XIMP_UNSETFOCUS, NULL, NULL, NULL);
! 		if (current_xic) {
! 			_XUnregisterFilter (ic->core.im->core.display,
! 					ic->core.focus_window,
! 					_Ximp_XimFilter_Keypress,
! 					current_xic);
! 			current_xic = 0;
! 		}
  	}
+ 	return;
+ }
  
  void
  _Ximp_SetFocusWindow(ic)
  	Ximp_XIC	 ic;
! {
  	Atom		 actual_type;
  	int		 actual_format;
  	unsigned long	 nitems, bytes_after;
***************
*** 191,202 ****
  			       ClientMessage, ClientMessage,
  			       _Ximp_XimFilter_Client, NULL);
  	return;
! 	}
  
  void
  _Ximp_SetPreeditAtr(ic)
  	Ximp_XIC		 ic;
! 	{
  	Ximp_PreeditPropRec	*preedit_atr;
  	Atom			 actual_type;
  	int			 actual_format;
--- 237,248 ----
  			       ClientMessage, ClientMessage,
  			       _Ximp_XimFilter_Client, NULL);
  	return;
! }
  
  void
  _Ximp_SetPreeditAtr(ic)
  	Ximp_XIC		 ic;
! {
  	Ximp_PreeditPropRec	*preedit_atr;
  	Atom			 actual_type;
  	int			 actual_format;
***************
*** 237,248 ****
  			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
  			32, PropModeReplace, prop_data, XIMP_PREEDIT_MAX_LONG);
  	return;
! 	}
  
  void
  _Ximp_SetPreeditFont(ic)
  	Ximp_XIC		 ic;
! 	{
  	Ximp_PreeditPropRec	*preedit_atr;
  	Atom			actual_type;
  	int			actual_format;
--- 283,294 ----
  			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
  			32, PropModeReplace, prop_data, XIMP_PREEDIT_MAX_LONG);
  	return;
! }
  
  void
  _Ximp_SetPreeditFont(ic)
  	Ximp_XIC		 ic;
! {
  	Ximp_PreeditPropRec	*preedit_atr;
  	Atom			actual_type;
  	int			actual_format;
***************
*** 266,279 ****
  			XA_STRING, 8, PropModeReplace,
  			(unsigned char *)(ic->ximp_icpart->preedit_font),
  			strlen(ic->ximp_icpart->preedit_font));
  	    }
  	return;
! 	}
  
  void
  _Ximp_SetStatusAtr(ic)
  	Ximp_XIC		 ic;
! 	{
  	Ximp_StatusPropRec	*status_atr;
  	Atom			 actual_type;
  	int			 actual_format;
--- 312,326 ----
  			XA_STRING, 8, PropModeReplace,
  			(unsigned char *)(ic->ximp_icpart->preedit_font),
  			strlen(ic->ximp_icpart->preedit_font));
+ 	    XFree(ic->ximp_icpart->preedit_font);
  	    }
  	return;
! }
  
  void
  _Ximp_SetStatusAtr(ic)
  	Ximp_XIC		 ic;
! {
  	Ximp_StatusPropRec	*status_atr;
  	Atom			 actual_type;
  	int			 actual_format;
***************
*** 313,324 ****
  			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
  			32, PropModeReplace, prop_data, XIMP_STATUS_MAX_LONG);
  	return;
! 	}
  
  void
  _Ximp_SetStatusFont(ic)
  	Ximp_XIC		ic;
! 	{
  	Atom			actual_type;
  	int			actual_format;
  	unsigned long		nitems, bytes_after;
--- 360,371 ----
  			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
  			32, PropModeReplace, prop_data, XIMP_STATUS_MAX_LONG);
  	return;
! }
  
  void
  _Ximp_SetStatusFont(ic)
  	Ximp_XIC		ic;
! {
  	Atom			actual_type;
  	int			actual_format;
  	unsigned long		nitems, bytes_after;
***************
*** 341,349 ****
  			XA_STRING, 8, PropModeReplace,
  			(unsigned char *)(ic->ximp_icpart->status_font),
  			strlen(ic->ximp_icpart->status_font));
  	    }
  	return;
! 	}
  
  static void
  _Ximp_AttributesSetL(data, setdata, cnt)
--- 388,397 ----
  			XA_STRING, 8, PropModeReplace,
  			(unsigned char *)(ic->ximp_icpart->status_font),
  			strlen(ic->ximp_icpart->status_font));
+ 	    XFree(ic->ximp_icpart->status_font);
  	    }
  	return;
! }
  
  static void
  _Ximp_AttributesSetL(data, setdata, cnt)
***************
*** 350,362 ****
  	char	*data;
  	long	 setdata;
  	int	 cnt;
! 	{
  	long	*ptr;
  
  	ptr = (long *)&data[cnt];
  	*ptr = setdata;
  	return;
! 	}
  
  void
  _Ximp_IM_SendMessage(ic, request, data1, data2, data3)
--- 398,410 ----
  	char	*data;
  	long	 setdata;
  	int	 cnt;
! {
  	long	*ptr;
  
  	ptr = (long *)&data[cnt];
  	*ptr = setdata;
  	return;
! }
  
  void
  _Ximp_IM_SendMessage(ic, request, data1, data2, data3)
***************
*** 363,369 ****
  	Ximp_XIC	ic;
  	unsigned long	request;
  	unsigned long	data1, data2, data3;
! 	{
  	XEvent		Message;
  	
  	/* ClientMessage Send */
--- 411,417 ----
  	Ximp_XIC	ic;
  	unsigned long	request;
  	unsigned long	data1, data2, data3;
! {
  	XEvent		Message;
  	
  	/* ClientMessage Send */
***************
*** 385,388 ****
  			   False, NoEventMask, &Message);
  	XFlush(ic->core.im->core.display);
  	return;
! 	}
--- 433,436 ----
  			   False, NoEventMask, &Message);
  	XFlush(ic->core.im->core.display);
  	return;
! }

*** /tmp/,RCSt1001650	Mon Oct 28 15:38:32 1991
--- mit/lib/X/Ximp/XimpICG.c	Thu Oct 10 20:08:36 1991
***************
*** 1,29 ****
! /* $XConsortium: XimpICG.c,v 1.2 91/07/30 14:27:33 rws Exp $ */
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
! provided that the above copyright notice appear in all copies and
! that both that copyright notice and this permission notice appear
! in supporting documentation, and that the name of FUJITSU LIMITED
! not be used in advertising or publicity pertaining to distribution
! of the software without specific, written prior permission.
! FUJITSU LIMITED makes no representations about the suitability of
! this software for any purpose.  It is provided "as is" without
! express or implied warranty.
  
! FUJITSU LIMITED DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
! INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
! IN NO EVENT SHALL FUJITSU LIMITED BE LIABLE FOR ANY SPECIAL, INDIRECT
! OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
! OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
! OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
! OR PERFORMANCE OF THIS SOFTWARE.
  
!   Author: Takashi Fujiwara     FUJITSU LIMITED 
!                                fujiwara@a80.tech.yk.fujitsu.co.jp
  
  ******************************************************************/
  
--- 1,33 ----
! /* $XConsortium: XimpICG.c,v 1.5 91/10/10 20:08:25 rws Exp $ */
  /******************************************************************
  
!     Copyright 1991, by FUJITSU LIMITED.
!     Copyright 1991, by Sun Microsystems, Inc.
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
! provided that the above copyright notice appear in all copies and that
! both that copyright notice and this permission notice appear in
! supporting documentation, and that the name of FUJITSU LIMITED or Sun
! Microsystems, Inc.  not be used in advertising or publicity pertaining
! to distribution of the software without specific, written prior
! permission.  FUJITSU LIMITED and Sun Microsystems, Inc. make no
! representations about the suitability of this software for any
! purpose.  It is provided "as is" without express or implied warranty.
  
! FUJITSU LIMITED AND SUN MICROSYSTEMS, INC. DISCLAIMS ALL WARRANTIES
! WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU LIMITED AND SUN
! MICROSYSTEMS, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
! CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
! USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
! OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
! PERFORMANCE OF THIS SOFTWARE.
  
! Author: Takashi Fujiwara     FUJITSU LIMITED
! 		       fujiwara@a80.tech.yk.fujitsu.co.jp
!         Hideki Hiura (hhiura@Sun.COM)
! 				     Sun Microsystems, Inc.
  
  ******************************************************************/
  
***************
*** 50,56 ****
  _Ximp_GetICValues(ic, values)
  	Ximp_XIC	 ic;
  	XIMArg		*values;
! 	{
  	XIMArg		*p;
  	char		*p_char;
  	long		*p_long;
--- 54,60 ----
  _Ximp_GetICValues(ic, values)
  	Ximp_XIC	 ic;
  	XIMArg		*values;
! {
  	XIMArg		*p;
  	char		*p_char;
  	long		*p_long;
***************
*** 61,177 ****
  	for(p = values; p->name != NULL; p++) {
  		if(strcmp(p->name, XNInputStyle) == 0) {
  			if(ic->ximp_icpart->value_mask & XIMP_INPUT_STYLE) {
! 				if((p_long = (long *)Xmalloc(sizeof(XIMStyle))) == NULL) {
! 					return_name = p->name;
! 					break;
! 					}
! 				*p_long = ic->core.input_style;
! 				(*((long *)(p->value))) = (long)p_long;
! 				}
! 			else {
! 				return_name = p->name;
! 				break;
! 				}
  			}
! 		else if(strcmp(p->name, XNClientWindow)==0) {
  			if(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN) {
! 				if((p_long = (long *)Xmalloc(sizeof(Window))) == NULL) {
! 					return_name = p->name;
! 					break;
! 					}
! 				*p_long = (long)ic->core.client_window;
! 				(*((long *)(p->value))) = (long)p_long;
! 				}
! 			else {
! 				return_name = p->name;
! 				break;
! 				}
  			}
! 		else if(strcmp(p->name, XNFocusWindow)==0) {
  			if(ic->ximp_icpart->proto_mask & XIMP_FOCUS_WIN_MASK) {
! 				if((p_long = (long *)Xmalloc(sizeof(Window))) == NULL) {
! 					return_name = p->name;
! 					break;
! 					}
! 				*p_long = (long)ic->core.focus_window;
! 				(*((long *)(p->value))) = (long)p_long;
! 				}
! 			else if(((Ximp_XIM)ic->core.im)->ximp_impart == (XIMXimpRec *) NULL)
! 				(*((long *)(p->value))) = (long)NULL;
! 			else
! 				(*((long *)(p->value))) = (long)_Ximp_GetRequestIM(ic,
  						 XIMP_FOCUS_WIN_MASK,
  						((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id,
  						XA_WINDOW);
  			}
! 		else if(strcmp(p->name, XNResourceName)==0) {
  			if(ic->core.im->core.res_name != (char *)NULL) {
! 				len = strlen(ic->core.im->core.res_name);
! 				if((p_char = Xmalloc(sizeof(len+1))) == NULL) {
! 					return_name = p->name;
! 					break;
! 					}
! 				strcpy(p_char, ic->core.im->core.res_name);
! 				(*((long *)(p->value))) = (long)p_char;
! 				}
! 			else
! 				(*((long *)(p->value))) = (long)NULL;
  			}
! 		else if(strcmp(p->name, XNResourceClass)==0) {
  			if(ic->core.im->core.res_class != (char *)NULL) {
! 				len = strlen(ic->core.im->core.res_class);
! 				if((p_char = Xmalloc(sizeof(len+1))) == NULL) {
! 					return_name = p->name;
! 					break;
! 					}
! 				strcpy(p_char, ic->core.im->core.res_class);
! 				(*((long *)(p->value))) = (long)p_char;
! 				}
! 			else
! 				(*((long *)(p->value))) = (long)NULL;
  			}
! 		else if(strcmp(p->name, XNGeometryCallback)==0) {
  			if(ic->ximp_icpart->value_mask & XIMP_GEOMETRY_CB) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					return_name = p->name;
! 					break;
! 					}
! 				p_callback->client_data =
! 					ic->core.geometry_callback.client_data;
! 				p_callback->callback =
! 					ic->core.geometry_callback.callback;
! 				(*((long *)(p->value))) = (long)p_callback;
! 				}
! 			else
! 				(*((long *)(p->value))) = (long)NULL;
  			}
! 		else if(strcmp(p->name, XNFilterEvents)==0) {
! 			if((p_long = (long *)Xmalloc(sizeof(unsigned long))) == NULL) {
! 				return_name = p->name;
! 				break;
! 				}
! 			*p_long = (long)ic->core.filter_events;
! 			(*((long *)(p->value))) = (long)p_long;
! 			}
! 		else if(strcmp(p->name, XNPreeditAttributes)==0) {
  			if( _Ximp_PreGetAttributes(ic, p->value,
  						   return_name) == False)
  				break;
! 			}
! 		else if(strcmp(p->name, XNStatusAttributes)==0) {
  			if( _Ximp_StatusGetAttributes(ic, p->value,
  						   return_name) == False)
  				break;
! 			}
! 		else {
  			if( _Ximp_GetICExtension(ic, p->name, p->value) == False) {
  				return_name = p->name;
  				break;
- 				}
  			}
  		}
- 	return(return_name);
  	}
  
  static Bool
  _Ximp_PreGetAttributes(ic, vl, return_name)
--- 65,142 ----
  	for(p = values; p->name != NULL; p++) {
  		if(strcmp(p->name, XNInputStyle) == 0) {
  			if(ic->ximp_icpart->value_mask & XIMP_INPUT_STYLE) {
! 			    (*((long *)(p->value))) = (long)ic->core.input_style;
! 			} else {			    
! 			    return_name = p->name;
! 			    break;
  			}
! 		} else if(strcmp(p->name, XNClientWindow)==0) {
  			if(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN) {
! 			    (*((long *)(p->value))) = (long)ic->core.client_window;
! 			} else {
! 			    return_name = p->name;
! 			    break;
  			}
! 		} else if(strcmp(p->name, XNFocusWindow)==0) {
  			if(ic->ximp_icpart->proto_mask & XIMP_FOCUS_WIN_MASK) {
! 			    (*((long *)(p->value))) = (long)ic->core.focus_window;
! 			} else if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver){
! 			    return_name = p->name;
! 			    break;
! 			} else {
! 			    XPointer tmp = _Ximp_GetRequestIM(ic,
  						 XIMP_FOCUS_WIN_MASK,
  						((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id,
  						XA_WINDOW);
+ 			    (*((long *)(p->value))) = *(long*)tmp ;
+ 			    free(tmp) ;
  			}
! 		} else if(strcmp(p->name, XNResourceName)==0) {
  			if(ic->core.im->core.res_name != (char *)NULL) {
! 			    len = strlen(ic->core.im->core.res_name);
! 			    if((p_char = Xmalloc(sizeof(len+1))) == NULL) {
! 				return_name = p->name;
! 				break;
! 			    }
! 			    strcpy(p_char, ic->core.im->core.res_name);
! 			    (*((long *)(p->value))) = (long)p_char;
! 			} else {
! 			    return_name = p->name;
! 			    break;
  			}
! 		} else if(strcmp(p->name, XNResourceClass)==0) {
  			if(ic->core.im->core.res_class != (char *)NULL) {
! 			    (*((long *)(p->value))) = (long)ic->core.im->core.res_class;
! 			} else {
! 			    return_name = p->name;
! 			    break;
  			}
! 		} else if(strcmp(p->name, XNGeometryCallback)==0) {
  			if(ic->ximp_icpart->value_mask & XIMP_GEOMETRY_CB) {
! 			    (*((long *)(p->value))) = (long)ic->core.geometry_callback.callback;
! 			} else {
! 			    return_name = p->name;
! 			    break;
  			}
! 		} else if(strcmp(p->name, XNFilterEvents)==0) {
! 		    (*((long *)(p->value))) = (long)ic->core.filter_events;
! 		} else if(strcmp(p->name, XNPreeditAttributes)==0) {
  			if( _Ximp_PreGetAttributes(ic, p->value,
  						   return_name) == False)
  				break;
! 		} else if(strcmp(p->name, XNStatusAttributes)==0) {
  			if( _Ximp_StatusGetAttributes(ic, p->value,
  						   return_name) == False)
  				break;
! 		} else {
  			if( _Ximp_GetICExtension(ic, p->name, p->value) == False) {
  				return_name = p->name;
  				break;
  			}
  		}
  	}
+ 	return(return_name);
+ }
  
  static Bool
  _Ximp_PreGetAttributes(ic, vl, return_name)
***************
*** 178,184 ****
  	Ximp_XIC	 ic;
  	XIMArg		*vl;
  	char		*return_name;
! 	{
  	XIMArg		*p;
  	XRectangle	*p_rect;
  	XPoint		*p_point;
--- 143,149 ----
  	Ximp_XIC	 ic;
  	XIMArg		*vl;
  	char		*return_name;
! {
  	XIMArg		*p;
  	XRectangle	*p_rect;
  	XPoint		*p_point;
***************
*** 189,195 ****
  	Ximp_PreeditPropRec	*preedit_data;
  	XIMCallback 	*p_callback;
  
! 	if(((Ximp_XIM)ic->core.im)->ximp_impart != (XIMXimpRec *) NULL) {
  		for(mask = 0, p = vl; p->name != NULL; p++) {
  			if(strcmp(p->name, XNArea)==0)
  				mask |= XIMP_PRE_AREA_MASK;
--- 154,160 ----
  	Ximp_PreeditPropRec	*preedit_data;
  	XIMCallback 	*p_callback;
  
! 	if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver) {
  		for(mask = 0, p = vl; p->name != NULL; p++) {
  			if(strcmp(p->name, XNArea)==0)
  				mask |= XIMP_PRE_AREA_MASK;
***************
*** 213,219 ****
  				mask |= XIMP_PRE_CURSOR_MASK;
  			else if(strcmp(p->name, XNFontSet)==0)
  				im_font_flag = 1;
! 			}
  		if(mask) {
  			preedit_data = (Ximp_PreeditPropRec *)_Ximp_GetRequestIM(ic, mask,
  				((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
--- 178,184 ----
  				mask |= XIMP_PRE_CURSOR_MASK;
  			else if(strcmp(p->name, XNFontSet)==0)
  				im_font_flag = 1;
! 		}
  		if(mask) {
  			preedit_data = (Ximp_PreeditPropRec *)_Ximp_GetRequestIM(ic, mask,
  				((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
***************
*** 220,507 ****
  				((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id);
  			if(preedit_data != (Ximp_PreeditPropRec *)NULL)
  				im_preedit_flag = 1;
- 			}
  		}
! 
  	for(p = vl; p->name != NULL; p++) {
  		if(strcmp(p->name, XNArea)==0) {
  			if(im_preedit_flag) {
! 				if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 					return_name = p->name;
! 					return(False);
! 					}
  				p_rect->x       = preedit_data->Area.x;
  				p_rect->y       = preedit_data->Area.y;
  				p_rect->width   = preedit_data->Area.width;
  				p_rect->height  = preedit_data->Area.height;
! 				}
! 			else  {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_AREA_MASK) {
! 					if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 						return_name = p->name;
! 						return(False);
! 						}
  					p_rect->x       = ic->core.preedit_attr.area.x;
  					p_rect->y       = ic->core.preedit_attr.area.y;
  					p_rect->width   = ic->core.preedit_attr.area.width;
  					p_rect->height  = ic->core.preedit_attr.area.height;
! 					}
! 				else
! 					p_rect = NULL;
  				}
- 			(*((long *)(p->value))) = (long)p_rect;
  			}
! 		else if(strcmp(p->name, XNAreaNeeded)==0) {
  			if(im_preedit_flag) {
! 				if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 					return_name = p->name;
! 					return(False);
! 					}
  				p_rect->x  = p_rect->y  = 0;
  				p_rect->width   = preedit_data->AreaNeeded.width;
  				p_rect->height  = preedit_data->AreaNeeded.height;
! 				}
! 			else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_AREANEED_MASK) {
! 					if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 						return_name = p->name;
! 						return(False);
! 						}
  					p_rect->x  = p_rect->y  = 0;
  					p_rect->width   = ic->core.preedit_attr.area_needed.width;
  					p_rect->height  = ic->core.preedit_attr.area_needed.height;
! 					}
! 				else
! 					p_rect = NULL;
  				}
- 			(*((long *)(p->value))) = (long)p_rect;
  			}
! 		else if(strcmp(p->name, XNSpotLocation)==0) {
  			if(im_preedit_flag) {
! 				if((p_point = (XPoint *)Xmalloc(sizeof(XPoint))) == NULL) {
! 					return_name = p->name;
! 					return(False);
! 					}
  				p_point->x = preedit_data->SpotLocation.x;
  				p_point->y = preedit_data->SpotLocation.y;
! 				}
! 			else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_SPOTL_MASK) {
! 					if((p_point = (XPoint *)Xmalloc(sizeof(XPoint))) == NULL) {
! 						return_name = p->name;
! 						return(False);
! 						}
  					p_point->x = ic->core.preedit_attr.spot_location.x;
  					p_point->y = ic->core.preedit_attr.spot_location.y;
! 					}
! 				else
! 					p_point = NULL;
  				}
- 			(*((long *)(p->value))) = (long)p_point;
  			}
! 		else if(  strcmp(p->name, XNColormap)==0
  		        || strcmp(p->name, XNStdColormap)==0) {
  			if(im_preedit_flag) {
! 				if((p_long = (long *)Xmalloc(sizeof(Colormap))) == NULL) {
! 					return_name = p->name;
! 					return(False);
! 					}
  				*p_long = preedit_data->Colormap;
! 				}
! 			else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_COLORMAP_MASK) {
! 					if((p_long = (long *)Xmalloc(sizeof(Colormap))) == NULL) {
! 						return_name = p->name;
! 						return(False);
! 						}
  					*p_long = ic->core.preedit_attr.colormap;
! 					}
! 				else
! 					p_long = NULL;
  				}
- 			(*((long *)(p->value))) = (long)p_long;
  			}
! 		else if(strcmp(p->name, XNBackground)==0) {
  			if(im_preedit_flag) {
! 				if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 					return_name = p->name;
! 					return(False);
! 					}
  				*p_long = preedit_data->Background;
! 				}
! 			else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_BG_MASK) {
! 					if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 						return_name = p->name;
! 						return(False);
! 						}
  					*p_long = ic->core.preedit_attr.background;
! 					}
! 				else
! 					p_long = NULL;
  				}
- 			(*((long *)(p->value))) = (long)p_long;
  			}
! 		else if(strcmp(p->name, XNForeground)==0) {
  			if(im_preedit_flag) {
! 				if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 					return_name = p->name;
! 					return(False);
! 					}
  				*p_long = preedit_data->Foreground;
! 				}
! 			else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_FG_MASK) {
! 					if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 						return_name = p->name;
! 						return(False);
! 						}
  					*p_long = ic->core.preedit_attr.foreground;
! 					}
! 				else
! 					p_long = NULL;
  				}
- 			(*((long *)(p->value))) = (long)p_long;
  			}
! 		else if(strcmp(p->name, XNBackgroundPixmap)==0) {
  			if(im_preedit_flag) {
! 				if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 					return_name = p->name;
! 					return(False);
! 					}
  				*p_long = preedit_data->Bg_Pixmap;
! 				}
! 			else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_BGPIXMAP_MASK) {
! 					if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 						return_name = p->name;
! 						return(False);
! 						}
  					*p_long = ic->core.preedit_attr.background_pixmap;
! 					}
! 				else
! 					p_long = NULL;
  				}
- 			(*((long *)(p->value))) = (long)p_long;
  			}
! 		else if(strcmp(p->name, XNFontSet)==0) {
  			if(ic->ximp_icpart->proto_mask & XIMP_PRE_FONT_MASK) {
! 				if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 					return_name = p->name;
! 					return(False);
! 					}
  				*p_long = (long)ic->core.preedit_attr.fontset;
! 				}
! 			else
! 				p_long = NULL;
! 			(*((long *)(p->value))) = (long)p_long;
  			}
! 		else if(strcmp(p->name, XNLineSpace)==0) {
  			if(im_preedit_flag) {
! 				if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 					return_name = p->name;
! 					return(False);
! 					}
  				*p_long = preedit_data->LineSpacing;
! 				}
! 			else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_LINESP_MASK) {
! 					if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 						return_name = p->name;
! 						return(False);
! 						}
  					*p_long = ic->core.preedit_attr.line_space;
! 					}
! 				else
! 					p_long = NULL;
  				}
- 			(*((long *)(p->value))) = (long)p_long;
  			}
! 		else if(strcmp(p->name, XNCursor)==0) {
  			if(im_preedit_flag) {
! 				if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 					return_name = p->name;
! 					return(False);
! 					}
  				*p_long = preedit_data->Cursor;
! 				}
! 			else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_CURSOR_MASK) {
! 					if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 						return_name = p->name;
! 						return(False);
! 						}
  					*p_long = ic->core.preedit_attr.cursor;
! 					}
! 				else
! 					p_long = NULL;
  				}
- 			(*((long *)(p->value))) = (long)p_long;
  			}
! 		else if(strcmp(p->name, XNPreeditStartCallback)==0) {
  			if((int)ic->core.preedit_attr.callbacks.start.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					return_name = p->name;
! 					break;
! 					}
  				p_callback->client_data =
  					ic->core.preedit_attr.callbacks.start.client_data;
  				p_callback->callback =
  					ic->core.preedit_attr.callbacks.start.callback;
! 				(*((long *)(p->value))) = (long)p_callback;
! 				}
! 			else
! 				(*((long *)(p->value))) = (long)NULL;
  			}
! 		else if(strcmp(p->name, XNPreeditDrawCallback)==0) {
  			if((int)ic->core.preedit_attr.callbacks.draw.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					return_name = p->name;
! 					break;
! 					}
  				p_callback->client_data =
  					ic->core.preedit_attr.callbacks.draw.client_data;
  				p_callback->callback =
  					ic->core.preedit_attr.callbacks.draw.callback;
! 				(*((long *)(p->value))) = (long)p_callback;
! 				}
! 			else
! 				(*((long *)(p->value))) = (long)NULL;
  			}
! 		else if(strcmp(p->name, XNPreeditDoneCallback)==0) {
  			if((int)ic->core.preedit_attr.callbacks.done.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					return_name = p->name;
! 					break;
! 					}
  				p_callback->client_data =
  					ic->core.preedit_attr.callbacks.done.client_data;
  				p_callback->callback =
  					ic->core.preedit_attr.callbacks.done.callback;
! 				(*((long *)(p->value))) = (long)p_callback;
! 				}
! 			else
! 				(*((long *)(p->value))) = (long)NULL;
  			}
! 		else if(strcmp(p->name, XNPreeditCaretCallback)==0) {
  			if((int)ic->core.preedit_attr.callbacks.caret.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					return_name = p->name;
! 					break;
! 					}
  				p_callback->client_data =
  					ic->core.preedit_attr.callbacks.caret.client_data;
  				p_callback->callback =
  					ic->core.preedit_attr.callbacks.caret.callback;
! 				(*((long *)(p->value))) = (long)p_callback;
! 				}
! 			else
! 				(*((long *)(p->value))) = (long)NULL;
  			}
  		}
  	XFree(preedit_data);
  	return(True);
! 	}
  
  static Bool
  _Ximp_StatusGetAttributes(ic, vl, return_name)
--- 185,380 ----
  				((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id);
  			if(preedit_data != (Ximp_PreeditPropRec *)NULL)
  				im_preedit_flag = 1;
  		}
! 	}
  	for(p = vl; p->name != NULL; p++) {
  		if(strcmp(p->name, XNArea)==0) {
  			if(im_preedit_flag) {
! 				p_rect = (XRectangle *)(p->value) ;
  				p_rect->x       = preedit_data->Area.x;
  				p_rect->y       = preedit_data->Area.y;
  				p_rect->width   = preedit_data->Area.width;
  				p_rect->height  = preedit_data->Area.height;
! 			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_AREA_MASK) {
! 				        p_rect = (XRectangle *)(p->value) ;
  					p_rect->x       = ic->core.preedit_attr.area.x;
  					p_rect->y       = ic->core.preedit_attr.area.y;
  					p_rect->width   = ic->core.preedit_attr.area.width;
  					p_rect->height  = ic->core.preedit_attr.area.height;
! 				} else {
! 				        return_name = p->name;
! 				        return(False);
  				}
  			}
! 		} else if(strcmp(p->name, XNAreaNeeded)==0) {
  			if(im_preedit_flag) {
! 				p_rect =  (XRectangle *)(p->value) ;
  				p_rect->x  = p_rect->y  = 0;
  				p_rect->width   = preedit_data->AreaNeeded.width;
  				p_rect->height  = preedit_data->AreaNeeded.height;
! 			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_AREANEED_MASK) {
! 				        p_rect = (XRectangle *)(p->value) ;
  					p_rect->x  = p_rect->y  = 0;
  					p_rect->width   = ic->core.preedit_attr.area_needed.width;
  					p_rect->height  = ic->core.preedit_attr.area_needed.height;
! 				} else {
! 				        return_name = p->name;
! 				        return(False);
  				}
  			}
! 		} else if(strcmp(p->name, XNSpotLocation)==0) {
  			if(im_preedit_flag) {
! 			        p_point = (XPoint *)(p->value);
  				p_point->x = preedit_data->SpotLocation.x;
  				p_point->y = preedit_data->SpotLocation.y;
! 			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_SPOTL_MASK) {
! 				        p_point = (XPoint *)(p->value);
  					p_point->x = ic->core.preedit_attr.spot_location.x;
  					p_point->y = ic->core.preedit_attr.spot_location.y;
! 				} else {
! 				        return_name = p->name;
! 				        return(False);
  				}
  			}
! 		} else if(  strcmp(p->name, XNColormap)==0
  		        || strcmp(p->name, XNStdColormap)==0) {
  			if(im_preedit_flag) {
! 			         p_long = (long *)(p->value);
  				*p_long = preedit_data->Colormap;
! 			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_COLORMAP_MASK) {
! 				         p_long = (long *)(p->value);
  					*p_long = ic->core.preedit_attr.colormap;
! 				} else {
! 					return_name = p->name;
! 					return(False);
  				}
  			}
! 		} else if(strcmp(p->name, XNBackground)==0) {
  			if(im_preedit_flag) {
! 			         p_long = (long *)(p->value);
  				*p_long = preedit_data->Background;
! 			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_BG_MASK) {
! 				         p_long = (long *)(p->value);
  					*p_long = ic->core.preedit_attr.background;
! 				} else {
! 					return_name = p->name;
! 					return(False);
  				}
  			}
! 		} else if(strcmp(p->name, XNForeground)==0) {
  			if(im_preedit_flag) {
! 			         p_long = (long *)(p->value);
  				*p_long = preedit_data->Foreground;
! 			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_FG_MASK) {
! 				         p_long = (long *)(p->value);
  					*p_long = ic->core.preedit_attr.foreground;
! 				} else {
! 					return_name = p->name;
! 					return(False);
  				}
  			}
! 		} else if(strcmp(p->name, XNBackgroundPixmap)==0) {
  			if(im_preedit_flag) {
! 			         p_long = (long *)(p->value);
  				*p_long = preedit_data->Bg_Pixmap;
! 			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_BGPIXMAP_MASK) {
! 				         p_long = (long *)(p->value);
  					*p_long = ic->core.preedit_attr.background_pixmap;
! 				} else {
! 					return_name = p->name;
! 					return(False);
  				}
  			}
! 		} else if(strcmp(p->name, XNFontSet)==0) {
  			if(ic->ximp_icpart->proto_mask & XIMP_PRE_FONT_MASK) {
! 			         p_long = (long *)(p->value);
  				*p_long = (long)ic->core.preedit_attr.fontset;
! 			} else {
! 				return_name = p->name;
! 				return(False);
  			}
! 		} else if(strcmp(p->name, XNLineSpace)==0) {
  			if(im_preedit_flag) {
! 			         p_long = (long *)(p->value);
  				*p_long = preedit_data->LineSpacing;
! 			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_LINESP_MASK) {
! 				         p_long = (long *)(p->value);
  					*p_long = ic->core.preedit_attr.line_space;
! 				} else {
! 					return_name = p->name;
! 					return(False);
  				}
  			}
! 		} else if(strcmp(p->name, XNCursor)==0) {
  			if(im_preedit_flag) {
! 			         p_long = (long *)(p->value);
  				*p_long = preedit_data->Cursor;
! 			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_CURSOR_MASK) {
! 				         p_long = (long *)(p->value);
  					*p_long = ic->core.preedit_attr.cursor;
! 				} else {
! 					return_name = p->name;
! 					return(False);
  				}
  			}
! 		} else if(strcmp(p->name, XNPreeditStartCallback)==0) {
  			if((int)ic->core.preedit_attr.callbacks.start.callback) {
! 			        p_callback = (XIMCallback *)(p->value) ;
  				p_callback->client_data =
  					ic->core.preedit_attr.callbacks.start.client_data;
  				p_callback->callback =
  					ic->core.preedit_attr.callbacks.start.callback;
! 			} else {
! 				return_name = p->name;
! 				return(False);
  			}
! 		} else if(strcmp(p->name, XNPreeditDrawCallback)==0) {
  			if((int)ic->core.preedit_attr.callbacks.draw.callback) {
! 			        p_callback = (XIMCallback *)(p->value) ;
  				p_callback->client_data =
  					ic->core.preedit_attr.callbacks.draw.client_data;
  				p_callback->callback =
  					ic->core.preedit_attr.callbacks.draw.callback;
! 			} else {
! 				return_name = p->name;
! 				return(False);
  			}
! 		} else if(strcmp(p->name, XNPreeditDoneCallback)==0) {
  			if((int)ic->core.preedit_attr.callbacks.done.callback) {
! 			        p_callback = (XIMCallback *)(p->value) ;
  				p_callback->client_data =
  					ic->core.preedit_attr.callbacks.done.client_data;
  				p_callback->callback =
  					ic->core.preedit_attr.callbacks.done.callback;
! 			} else {
! 				return_name = p->name;
! 				return(False);
  			}
! 		} else if(strcmp(p->name, XNPreeditCaretCallback)==0) {
  			if((int)ic->core.preedit_attr.callbacks.caret.callback) {
! 			        p_callback = (XIMCallback *)(p->value) ;
  				p_callback->client_data =
  					ic->core.preedit_attr.callbacks.caret.client_data;
  				p_callback->callback =
  					ic->core.preedit_attr.callbacks.caret.callback;
! 			} else {
! 				return_name = p->name;
! 				return(False);
  			}
  		}
+ 	}
  	XFree(preedit_data);
  	return(True);
! }
  
  static Bool
  _Ximp_StatusGetAttributes(ic, vl, return_name)
***************
*** 508,514 ****
  	Ximp_XIC	 ic;
  	XIMArg	 	*vl;
  	char		*return_name;
! 	{
  	XIMArg		*p;
  	XRectangle	*p_rect;
  	XPoint		*p_point;
--- 381,387 ----
  	Ximp_XIC	 ic;
  	XIMArg	 	*vl;
  	char		*return_name;
! {
  	XIMArg		*p;
  	XRectangle	*p_rect;
  	XPoint		*p_point;
***************
*** 519,525 ****
  	Ximp_StatusPropRec	*status_data;
  	XIMCallback 	*p_callback;
  
! 	if(((Ximp_XIM)ic->core.im)->ximp_impart != (XIMXimpRec *) NULL) {
  		for(mask = 0, p = vl; p->name != NULL; p++) {
  			if(strcmp(p->name, XNArea)==0)
  				mask |= XIMP_STS_AREA_MASK;
--- 392,398 ----
  	Ximp_StatusPropRec	*status_data;
  	XIMCallback 	*p_callback;
  
! 	if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver) {
  		for(mask = 0, p = vl; p->name != NULL; p++) {
  			if(strcmp(p->name, XNArea)==0)
  				mask |= XIMP_STS_AREA_MASK;
***************
*** 541,547 ****
  				mask |= XIMP_STS_CURSOR_MASK;
  			else if(strcmp(p->name, XNFontSet)==0)
  				im_font_flag = 1;
! 			}
  		if(mask) {
  			status_data = (Ximp_StatusPropRec *)_Ximp_GetRequestIM(ic, mask,
  				((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
--- 414,420 ----
  				mask |= XIMP_STS_CURSOR_MASK;
  			else if(strcmp(p->name, XNFontSet)==0)
  				im_font_flag = 1;
! 		}
  		if(mask) {
  			status_data = (Ximp_StatusPropRec *)_Ximp_GetRequestIM(ic, mask,
  				((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
***************
*** 548,797 ****
  				((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id);
  			if(status_data != (Ximp_StatusPropRec *)NULL)
  				im_status_flag = 1;
- 			}
  		}
  
  	for(p = vl; p->name != NULL; p++) {
  		if(strcmp(p->name, XNArea)==0) {
  			if(im_status_flag) {
! 				if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 					return_name = p->name;
! 					return(False);
! 					}
  				p_rect->x       = status_data->Area.x;
  				p_rect->y       = status_data->Area.y;
  				p_rect->width   = status_data->Area.width;
  				p_rect->height  = status_data->Area.height;
! 				}
! 			else  {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_AREA_MASK) {
! 					if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 						return_name = p->name;
! 						return(False);
! 						}
  					p_rect->x       = ic->core.status_attr.area.x;
  					p_rect->y       = ic->core.status_attr.area.y;
  					p_rect->width   = ic->core.status_attr.area.width;
  					p_rect->height  = ic->core.status_attr.area.height;
! 					}
! 				else
! 					p_rect = NULL;
  				}
- 			(*((long *)(p->value))) = (long)p_rect;
  			}
! 		else if(strcmp(p->name, XNAreaNeeded)==0) {
  			if(im_status_flag) {
! 				if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 					return_name = p->name;
! 					return(False);
! 					}
  				p_rect->x  = p_rect->y  = 0;
  				p_rect->width   = status_data->AreaNeeded.width;
  				p_rect->height  = status_data->AreaNeeded.height;
! 				}
! 			else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_AREANEED_MASK) {
! 					if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 						return_name = p->name;
! 						return(False);
! 						}
  					p_rect->x  = p_rect->y  = 0;
  					p_rect->width   = ic->core.status_attr.area_needed.width;
  					p_rect->height  = ic->core.status_attr.area_needed.height;
! 					}
! 				else
! 					p_rect = NULL;
  				}
- 			(*((long *)(p->value))) = (long)p_rect;
  			}
! 		else if(  strcmp(p->name, XNColormap)==0
  		        || strcmp(p->name, XNStdColormap)==0) {
  			if(im_status_flag) {
! 				if((p_long = (long *)Xmalloc(sizeof(Colormap))) == NULL) {
! 					return_name = p->name;
! 					return(False);
! 					}
  				*p_long = status_data->Colormap;
! 				}
! 			else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_COLORMAP_MASK) {
! 					if((p_long = (long *)Xmalloc(sizeof(Colormap))) == NULL) {
! 						return_name = p->name;
! 						return(False);
! 						}
  					*p_long = ic->core.status_attr.colormap;
! 					}
! 				else
! 					p_long = NULL;
  				}
- 			(*((long *)(p->value))) = (long)p_long;
  			}
! 		else if(strcmp(p->name, XNBackground)==0) {
  			if(im_status_flag) {
! 				if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 					return_name = p->name;
! 					return(False);
! 					}
  				*p_long = status_data->Background;
! 				}
! 			else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_BG_MASK) {
! 					if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 						return_name = p->name;
! 						return(False);
! 						}
  					*p_long = ic->core.status_attr.background;
! 					}
! 				else
! 					p_long = NULL;
! 				}
! 			(*((long *)(p->value))) = (long)p_long;
! 			}
! 		else if(strcmp(p->name, XNForeground)==0) {
! 			if(im_status_flag) {
! 				if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
  					return_name = p->name;
  					return(False);
! 					}
  				*p_long = status_data->Foreground;
! 				}
! 			else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_FG_MASK) {
! 					if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 						return_name = p->name;
! 						return(False);
! 						}
  					*p_long = ic->core.status_attr.foreground;
! 					}
! 				else
! 					p_long = NULL;
  				}
- 			(*((long *)(p->value))) = (long)p_long;
  			}
! 		else if(strcmp(p->name, XNBackgroundPixmap)==0) {
  			if(im_status_flag) {
! 				if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 					return_name = p->name;
! 					return(False);
! 					}
  				*p_long = status_data->Bg_Pixmap;
! 				}
! 			else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_BGPIXMAP_MASK) {
! 					if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 						return_name = p->name;
! 						return(False);
! 						}
  					*p_long = ic->core.status_attr.background_pixmap;
! 					}
! 				else
! 					p_long = NULL;
! 				}
! 			(*((long *)(p->value))) = (long)p_long;
! 			}
! 		else if(strcmp(p->name, XNFontSet)==0) {
! 			if(ic->ximp_icpart->proto_mask & XIMP_STS_FONT_MASK) {
! 				if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
  					return_name = p->name;
  					return(False);
! 					}
  				*p_long = (long)ic->core.status_attr.fontset;
! 				}
! 			else
! 				p_long = NULL;
! 			(*((long *)(p->value))) = (long)p_long;
  			}
! 		else if(strcmp(p->name, XNLineSpace)==0) {
  			if(im_status_flag) {
! 				if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 					return_name = p->name;
! 					return(False);
! 					}
  				*p_long = status_data->LineSpacing;
! 				}
! 			else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_LINESP_MASK) {
! 					if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 						return_name = p->name;
! 						return(False);
! 						}
  					*p_long = ic->core.status_attr.line_space;
! 					}
! 				else
! 					p_long = NULL;
  				}
! 			(*((long *)(p->value))) = (long)p_long;
  			}
! 		else if(strcmp(p->name, XNCursor)==0) {
  			if(im_status_flag) {
! 				if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 					return_name = p->name;
! 					return(False);
! 					}
  				*p_long = status_data->Cursor;
! 				}
! 			else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_CURSOR_MASK) {
! 					if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 						return_name = p->name;
! 						return(False);
! 						}
  					*p_long = ic->core.status_attr.cursor;
! 					}
! 				else
! 					p_long = NULL;
! 				}
! 			(*((long *)(p->value))) = (long)p_long;
  			}
! 		else if(strcmp(p->name, XNStatusStartCallback)==0) {
  			if((int)ic->core.status_attr.callbacks.start.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					return_name = p->name;
! 					break;
! 					}
  				p_callback->client_data =
  					ic->core.status_attr.callbacks.start.client_data;
  				p_callback->callback =
  					ic->core.status_attr.callbacks.start.callback;
! 				(*((long *)(p->value))) = (long)p_callback;
! 				}
! 			else
! 				(*((long *)(p->value))) = (long)NULL;
  			}
! 		else if(strcmp(p->name, XNStatusDrawCallback)==0) {
  			if((int)ic->core.status_attr.callbacks.draw.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					return_name = p->name;
! 					break;
! 					}
  				p_callback->client_data =
  					ic->core.status_attr.callbacks.draw.client_data;
  				p_callback->callback =
  					ic->core.status_attr.callbacks.draw.callback;
! 				(*((long *)(p->value))) = (long)p_callback;
! 				}
! 			else
! 				(*((long *)(p->value))) = (long)NULL;
  			}
! 		else if(strcmp(p->name, XNStatusDoneCallback)==0) {
  			if((int)ic->core.status_attr.callbacks.done.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					return_name = p->name;
! 					break;
! 					}
  				p_callback->client_data =
  					ic->core.status_attr.callbacks.done.client_data;
  				p_callback->callback =
  					ic->core.status_attr.callbacks.done.callback;
! 				(*((long *)(p->value))) = (long)p_callback;
! 				}
! 			else
! 				(*((long *)(p->value))) = (long)NULL;
  			}
  		}
  	XFree(status_data);
  	return(True);
! 	}
  
  static int	 _time_flag = 0;
  
--- 421,592 ----
  				((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id);
  			if(status_data != (Ximp_StatusPropRec *)NULL)
  				im_status_flag = 1;
  		}
+ 	}
  
  	for(p = vl; p->name != NULL; p++) {
  		if(strcmp(p->name, XNArea)==0) {
  			if(im_status_flag) {
! 				p_rect = (XRectangle *)(p->value) ;
  				p_rect->x       = status_data->Area.x;
  				p_rect->y       = status_data->Area.y;
  				p_rect->width   = status_data->Area.width;
  				p_rect->height  = status_data->Area.height;
! 			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_AREA_MASK) {
! 					p_rect = (XRectangle *)(p->value) ;
  					p_rect->x       = ic->core.status_attr.area.x;
  					p_rect->y       = ic->core.status_attr.area.y;
  					p_rect->width   = ic->core.status_attr.area.width;
  					p_rect->height  = ic->core.status_attr.area.height;
! 				} else {
! 				        return_name = p->name;
! 				        return(False);
  				}
  			}
! 		} else if(strcmp(p->name, XNAreaNeeded)==0) {
  			if(im_status_flag) {
! 				p_rect =  (XRectangle *)(p->value) ;
  				p_rect->x  = p_rect->y  = 0;
  				p_rect->width   = status_data->AreaNeeded.width;
  				p_rect->height  = status_data->AreaNeeded.height;
! 			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_AREANEED_MASK) {
! 					p_rect =  (XRectangle *)(p->value) ;
  					p_rect->x  = p_rect->y  = 0;
  					p_rect->width   = ic->core.status_attr.area_needed.width;
  					p_rect->height  = ic->core.status_attr.area_needed.height;
! 				} else {
! 					return_name = p->name;
! 					return(False);
  				}
  			}
! 		} else if(  strcmp(p->name, XNColormap)==0
  		        || strcmp(p->name, XNStdColormap)==0) {
  			if(im_status_flag) {
! 			         p_long = (long *)(p->value);
  				*p_long = status_data->Colormap;
! 			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_COLORMAP_MASK) {
! 				         p_long = (long *)(p->value);
  					*p_long = ic->core.status_attr.colormap;
! 				} else {
! 					return_name = p->name;
! 					return(False);
  				}
  			}
! 		} else if(strcmp(p->name, XNBackground)==0) {
  			if(im_status_flag) {
! 			         p_long = (long *)(p->value);
  				*p_long = status_data->Background;
! 			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_BG_MASK) {
! 				         p_long = (long *)(p->value);
  					*p_long = ic->core.status_attr.background;
! 				} else {
  					return_name = p->name;
  					return(False);
! 			        }
! 			}
! 		} else if(strcmp(p->name, XNForeground)==0) {
! 			if(im_status_flag) {
! 			         p_long = (long *)(p->value);
  				*p_long = status_data->Foreground;
! 			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_FG_MASK) {
! 				         p_long = (long *)(p->value);
  					*p_long = ic->core.status_attr.foreground;
! 				} else {
! 					return_name = p->name;
! 					return(False);
  				}
  			}
! 		} else if(strcmp(p->name, XNBackgroundPixmap)==0) {
  			if(im_status_flag) {
! 			         p_long = (long *)(p->value);
  				*p_long = status_data->Bg_Pixmap;
! 			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_BGPIXMAP_MASK) {
! 				         p_long = (long *)(p->value);
  					*p_long = ic->core.status_attr.background_pixmap;
! 				} else {
  					return_name = p->name;
  					return(False);
! 			        }
! 			}
! 		} else if(strcmp(p->name, XNFontSet)==0) {
! 			if(ic->ximp_icpart->proto_mask & XIMP_STS_FONT_MASK) {
! 			         p_long = (long *)(p->value);
  				*p_long = (long)ic->core.status_attr.fontset;
! 			} else {
! 				return_name = p->name;
! 				return(False);
  			}
! 		} else if(strcmp(p->name, XNLineSpace)==0) {
  			if(im_status_flag) {
! 			         p_long = (long *)(p->value);
  				*p_long = status_data->LineSpacing;
! 			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_LINESP_MASK) {
! 				         p_long = (long *)(p->value);
  					*p_long = ic->core.status_attr.line_space;
! 				} else {
! 					return_name = p->name;
! 					return(False);
  				}
! 
  			}
! 		} else if(strcmp(p->name, XNCursor)==0) {
  			if(im_status_flag) {
! 			         p_long = (long *)(p->value);
  				*p_long = status_data->Cursor;
! 			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_CURSOR_MASK) {
! 				         p_long = (long *)(p->value);
  					*p_long = ic->core.status_attr.cursor;
! 				} else { 
! 					return_name = p->name;
! 					return(False);
! 			        }
  			}
! 		} else if(strcmp(p->name, XNStatusStartCallback)==0) {
  			if((int)ic->core.status_attr.callbacks.start.callback) {
! 			        p_callback = (XIMCallback *)(p->value) ;
  				p_callback->client_data =
  					ic->core.status_attr.callbacks.start.client_data;
  				p_callback->callback =
  					ic->core.status_attr.callbacks.start.callback;
! 			} else {
! 				return_name = p->name;
! 				break;
  			}
! 		} else if(strcmp(p->name, XNStatusDrawCallback)==0) {
  			if((int)ic->core.status_attr.callbacks.draw.callback) {
! 			        p_callback = (XIMCallback *)(p->value) ;
  				p_callback->client_data =
  					ic->core.status_attr.callbacks.draw.client_data;
  				p_callback->callback =
  					ic->core.status_attr.callbacks.draw.callback;
! 			} else {
! 				return_name = p->name;
! 				break;
  			}
! 		} else if(strcmp(p->name, XNStatusDoneCallback)==0) {
  			if((int)ic->core.status_attr.callbacks.done.callback) {
! 			        p_callback = (XIMCallback *)(p->value) ;
  				p_callback->client_data =
  					ic->core.status_attr.callbacks.done.client_data;
  				p_callback->callback =
  					ic->core.status_attr.callbacks.done.callback;
! 			} else {
! 				return_name = p->name;
! 				break;
  			}
  		}
+ 	}
  	XFree(status_data);
  	return(True);
! }
  
  static int	 _time_flag = 0;
  
***************
*** 798,806 ****
  #ifdef XIMP_SIGNAL
  static int
  _time_out()
! 	{
  	_time_flag = 1;
! 	}
  #endif /* XIMP_SIGNAL */
  
  static XPointer
--- 593,601 ----
  #ifdef XIMP_SIGNAL
  static int
  _time_out()
! {
  	_time_flag = 1;
! }
  #endif /* XIMP_SIGNAL */
  
  static XPointer
***************
*** 808,814 ****
  	Ximp_XIC	 ic;
  	unsigned long	 mask;
  	Atom		 get_atom_id, atom_id;
! 	{
  	XEvent		 event;
  	Atom            actual_type_ret;
  	int		actual_format_ret;
--- 603,609 ----
  	Ximp_XIC	 ic;
  	unsigned long	 mask;
  	Atom		 get_atom_id, atom_id;
! {
  	XEvent		 event;
  	Atom            actual_type_ret;
  	int		actual_format_ret;
***************
*** 833,850 ****
  			sleep(1);
  #endif /* XIMP_SIGNAL */
  			continue;
! 			}
  		if(event.xclient.message_type == ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id) {
  #ifdef XIMP_SIGNAL
  			alarm(0);
  #endif /* XIMP_SIGNAL */
  			break;
! 			}
! 		else {
  			XPutBackEvent(ic->core.im->core.display, &event);
  			continue;
- 			}
  		}
  	_time_flag = 0;
  
  	if(event.xclient.data.l[0] != XIMP_GETVALUE_RETURN)
--- 628,644 ----
  			sleep(1);
  #endif /* XIMP_SIGNAL */
  			continue;
! 		}
  		if(event.xclient.message_type == ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id) {
  #ifdef XIMP_SIGNAL
  			alarm(0);
  #endif /* XIMP_SIGNAL */
  			break;
! 		} else {
  			XPutBackEvent(ic->core.im->core.display, &event);
  			continue;
  		}
+ 	}
  	_time_flag = 0;
  
  	if(event.xclient.data.l[0] != XIMP_GETVALUE_RETURN)
***************
*** 859,862 ****
          if(actual_format_ret == 0 || nitems_ret == 0)
  		return(NULL);
  	return((XPointer)data);
! 	}
--- 653,656 ----
          if(actual_format_ret == 0 || nitems_ret == 0)
  		return(NULL);
  	return((XPointer)data);
! }

*** /tmp/,RCSt1001660	Mon Oct 28 15:38:39 1991
--- mit/lib/X/Ximp/XimpICS.c	Mon Oct  7 17:48:50 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpICS.c,v 1.1 91/07/09 17:37:06 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: XimpICS.c,v 1.2 91/10/07 17:48:43 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by FUJITSU LIMITED
***************
*** 74,87 ****
  		}
  	if(change_mask & XIMP_PROP_FOCUS)
  		_Ximp_SetFocusWindow(ic);
! 	if(change_mask & XIMP_PROP_PREEDIT)
! 		_Ximp_SetPreeditAtr(ic);
! 	if(change_mask & XIMP_PROP_PREFONT)
! 		_Ximp_SetPreeditFont(ic);
! 	if(change_mask & XIMP_PROP_STATUS)
! 		_Ximp_SetStatusAtr(ic);
! 	if(change_mask & XIMP_PROP_STSFONT)
! 		_Ximp_SetStatusFont(ic);
   	_Ximp_IM_SendMessage(ic, XIMP_SETVALUE, change_mask, NULL, NULL);
  	return(ret);
  	}
--- 74,99 ----
  		}
  	if(change_mask & XIMP_PROP_FOCUS)
  		_Ximp_SetFocusWindow(ic);
! 	if(!(   (ic->core.input_style & XIMPreeditCallbacks)
! 	     || (ic->core.input_style & XIMPreeditNone) ) ) { 
! 		if(change_mask & XIMP_PROP_PREEDIT)
! 			_Ximp_SetPreeditAtr(ic);
! 		if(change_mask & XIMP_PROP_PREFONT)
! 			_Ximp_SetPreeditFont(ic);
! 		}
! 	else {
! 		change_mask &= ~(XIMP_PROP_PREEDIT | XIMP_PROP_PREFONT);
! 		}
! 	if(!(   (ic->core.input_style & XIMStatusCallbacks)
! 	     || (ic->core.input_style & XIMStatusNone) ) ) { 
! 		if(change_mask & XIMP_PROP_STATUS)
! 			_Ximp_SetStatusAtr(ic);
! 		if(change_mask & XIMP_PROP_STSFONT)
! 			_Ximp_SetStatusFont(ic);
! 		}
! 	else {
! 		change_mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
! 		}
   	_Ximp_IM_SendMessage(ic, XIMP_SETVALUE, change_mask, NULL, NULL);
  	return(ret);
  	}
***************
*** 129,135 ****
  						     &wattr);
  				dummy_mask = wattr.your_event_mask;
  				ic->ximp_icpart->back_mask = dummy_mask;
! 				dummy_mask &= ~(KeyPressMask | KeyReleaseMask);
  				XSelectInput(ic->core.im->core.display,
  					     new_focus_window,
  					     dummy_mask);
--- 141,152 ----
  						     &wattr);
  				dummy_mask = wattr.your_event_mask;
  				ic->ximp_icpart->back_mask = dummy_mask;
! 				if(ic->ximp_icpart->is_bep_mode == XIMP_FRONTEND) {
! 					dummy_mask &= ~(KeyPressMask | KeyReleaseMask);
! 					}
! 				else {
! 					dummy_mask &= ~(KeyReleaseMask);
! 					}
  				XSelectInput(ic->core.im->core.display,
  					     new_focus_window,
  					     dummy_mask);
***************
*** 168,174 ****
  				break;
  			}
  		else {
! 			if( _Ximp_SetICExtension(ic, p->name, p->value) == False ) {
  				return_name = p->name;
  				break;
  				}
--- 185,191 ----
  				break;
  			}
  		else {
! 			if( _Ximp_SetICExtension(ic, p->name, p->value, mode) == False ) {
  				return_name = p->name;
  				break;
  				}
***************
*** 188,194 ****
--- 205,217 ----
  	{
  	XIMArg			*p;
  	Colormap		 colormap_ret;
+ 	int			 list_ret;
+ 	XFontStruct		**struct_list;
+ 	char			**name_list;
+ 	int 			 i, len;
+ 	char 			*tmp;
  
+ 
  	for(p = vl; p->name != NULL; p++) {
  		if(strcmp(p->name, XNArea)==0) {
  			ic->core.preedit_attr.area.x = ((XRectangle *)p->value)->x;
***************
*** 259,267 ****
  		else if(strcmp(p->name, XNFontSet)==0) {
  			ic->core.preedit_attr.fontset = (XFontSet)p->value;
  			if(p->value != NULL) {
! 				ic->ximp_icpart->preedit_font =
! 					XBaseFontNameListOfFontSet(
! 					ic->core.preedit_attr.fontset);
  				ic->ximp_icpart->proto_mask |= XIMP_PRE_FONT_MASK;
  				*change_mask                |= XIMP_PRE_FONT_MASK;
  				}
--- 282,301 ----
  		else if(strcmp(p->name, XNFontSet)==0) {
  			ic->core.preedit_attr.fontset = (XFontSet)p->value;
  			if(p->value != NULL) {
! 				list_ret = XFontsOfFontSet(
! 					ic->core.preedit_attr.fontset,
! 					&struct_list, &name_list);
! 				for(i = 0, len = 0; i < list_ret; i++) {
! 					len += strlen(name_list[i]);
! 					}
! 				tmp = Xmalloc(len + i);
! 				tmp[0] = NULL;
! 				for(i = 0; i < list_ret; i++) {
! 					strcat(tmp, name_list[i]);
! 					strcat(tmp, ",");
! 					}
! 				tmp[len + i - 1] = NULL;
! 				ic->ximp_icpart->preedit_font = tmp;
  				ic->ximp_icpart->proto_mask |= XIMP_PRE_FONT_MASK;
  				*change_mask                |= XIMP_PRE_FONT_MASK;
  				}
***************
*** 321,326 ****
--- 355,365 ----
  	{
  	XIMArg			*p;
  	Colormap	 	colormap_ret;
+ 	int			 list_ret;
+ 	XFontStruct		**struct_list;
+ 	char			**name_list;
+ 	int 			 i, len;
+ 	char 			*tmp;
  
  	for(p = vl; p->name != NULL; p++) {
  		if(strcmp(p->name, XNArea)==0) {
***************
*** 384,392 ****
  		else if(strcmp(p->name, XNFontSet)==0) {
  			ic->core.status_attr.fontset = (XFontSet)p->value;
  			if (p->value != NULL) {
! 				ic->ximp_icpart->status_font =
! 					XBaseFontNameListOfFontSet(
! 					ic->core.status_attr.fontset);
  				ic->ximp_icpart->proto_mask |= XIMP_STS_FONT_MASK;
  				*change_mask                |= XIMP_STS_FONT_MASK;
  				}
--- 423,442 ----
  		else if(strcmp(p->name, XNFontSet)==0) {
  			ic->core.status_attr.fontset = (XFontSet)p->value;
  			if (p->value != NULL) {
! 				list_ret = XFontsOfFontSet(
! 					ic->core.status_attr.fontset,
! 					&struct_list, &name_list);
! 				for(i = 0, len = 0; i < list_ret; i++) {
! 					len += strlen(name_list[i]);
! 					}
! 				tmp = Xmalloc(len + i);
! 				tmp[0] = NULL;
! 				for(i = 0; i < list_ret; i++) {
! 					strcat(tmp, name_list[i]);
! 					strcat(tmp, ",");
! 					}
! 				tmp[len + i - 1] = NULL;
! 				ic->ximp_icpart->status_font = tmp;
  				ic->ximp_icpart->proto_mask |= XIMP_STS_FONT_MASK;
  				*change_mask                |= XIMP_STS_FONT_MASK;
  				}
*** /tmp/,RCSt1001670	Mon Oct 28 15:38:45 1991
--- mit/lib/X/Ximp/XimpIM.c	Mon Oct  7 17:48:56 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpIM.c,v 1.3 91/07/30 14:27:39 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: XimpIM.c,v 1.4 91/10/07 17:48:51 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by FUJITSU LIMITED
***************
*** 56,61 ****
--- 56,77 ----
  				_Ximp_CreateIC, 	/* create_ic */
  				};
  
+ static char	*strstr( src, dest )
+ register char	*src, *dest;
+ {
+     register	len;
+ 
+     if( src == NULL  ||  dest == NULL )
+ 	return( NULL );
+     len = strlen(dest);
+     while( src = index( src, *dest ) ) {
+ 	if( strncmp( src, dest, len ) == 0 )
+ 	    return( src );
+ 	src++;
+     }
+     return( NULL );
+ }
+ 
  XIM
  _Ximp_OpenIM(lcd, dpy, rdb, res_name, res_class)
  	XLCd		 lcd;
***************
*** 62,74 ****
  	Display		*dpy;
  	XrmDatabase	 rdb;
  	char		*res_name, *res_class;
! 	{
  	Ximp_XIM		 im;
! 	Bool			 start_server, ret;
  
  	if((im = (Ximp_XIM)Xmalloc(sizeof(Ximp_XIMRec))) == (Ximp_XIM)NULL) {
  		return((XIM)NULL);
! 		}
  
  	im->methods = &Ximp_im_methods;
  
--- 78,91 ----
  	Display		*dpy;
  	XrmDatabase	 rdb;
  	char		*res_name, *res_class;
! {
  	Ximp_XIM		 im;
! 	XIMXimpRec		*ximp_impart;
! 	Bool			 ret;
  
  	if((im = (Ximp_XIM)Xmalloc(sizeof(Ximp_XIMRec))) == (Ximp_XIM)NULL) {
  		return((XIM)NULL);
! 	}
  
  	im->methods = &Ximp_im_methods;
  
***************
*** 79,104 ****
  	im->core.res_name  = res_name;
  	im->core.res_class = res_class;
  
! 	im->ximp_impart    = (XIMXimpRec *)NULL;
  
!         start_server = _Ximp_OpenIM_Resource(im);
! 	ret = _Ximp_Setup(im);
! 	if(start_server == True) {
! 		if(ret == False) {
! 			Xfree(im);
! 			return((XIM)NULL);
! 			}
! 		else
! 			im->ximp_impart->inputserver = 1;
! 		}
! 	return((XIM)im);
  	}
  
  static char *
  _Ximp_GetIMValues(im, values)
  	Ximp_XIM	 im;
  	XIMArg		*values;
! 	{
  	XIMArg		*p;
  
  	for(p = values; p->name != NULL; p++) {
--- 96,125 ----
  	im->core.res_name  = res_name;
  	im->core.res_class = res_class;
  
! 	if((ximp_impart = (XIMXimpRec *)Xmalloc(sizeof(XIMXimpRec))) == (XIMXimpRec *)NULL) {
! 		Xfree(im);
! 		return((XIM)NULL);
! 	}
! 	ximp_impart->connectserver  = 0;
! 	ximp_impart->inputserver    = 1;
! 	ximp_impart->use_wchar      = False;
! 	im->ximp_impart = ximp_impart;
  
!         if(_Ximp_OpenIM_Resource(im) == True)
! 		im->ximp_impart->inputserver = 0;
! 	if(_Ximp_Setup(im) == False && im->ximp_impart->inputserver) {
! 		Xfree(ximp_impart);
! 		Xfree(im);
! 		return((XIM)NULL);
  	}
+ 	return((XIM)im);
+ }
  
  static char *
  _Ximp_GetIMValues(im, values)
  	Ximp_XIM	 im;
  	XIMArg		*values;
! {
  	XIMArg		*p;
  
  	for(p = values; p->name != NULL; p++) {
***************
*** 105,123 ****
  		if(strcmp(p->name, XNQueryInputStyle) == 0) {
  			if( _Ximp_GetStyle(im, p->value) == False )
  				break;
! 			}
  		else {
  			if( _Ximp_GetIMExtension(im, p->name, p->value) == False )
  				break;
- 			}
  		}
- 	return(p->name);
  	}
  
  static Status
  _Ximp_CloseIM(im)
  	Ximp_XIM	im;
! 	{
  	XIC		ic;
  	int		i;
  	XIMXimpRec	*ximp_impart;
--- 126,144 ----
  		if(strcmp(p->name, XNQueryInputStyle) == 0) {
  			if( _Ximp_GetStyle(im, p->value) == False )
  				break;
! 		}
  		else {
  			if( _Ximp_GetIMExtension(im, p->name, p->value) == False )
  				break;
  		}
  	}
+ 	return(p->name);
+ }
  
  static Status
  _Ximp_CloseIM(im)
  	Ximp_XIM	im;
! {
  	XIC		ic;
  	int		i;
  	XIMXimpRec	*ximp_impart;
***************
*** 124,137 ****
  
  	for(ic = im->core.ic_chain; ic; ic = ic->core.next)
  		XDestroyIC(ic);
! 	if(im->ximp_impart) {
! 		ximp_impart = (XIMXimpRec *)im->ximp_impart;
  		for(i=0; i < Ximp_Xim_count; i++) {
  			if(Ximp_Xim_List[i] == im) {
  				Ximp_Xim_List[i] = NULL;
  				break;
- 				}
  			}
  		_Ximp_SetupFreeExtension(im);
  		_Ximp_SetupFree(ximp_impart->im_proto_vl,
  				ximp_impart->im_styles,
--- 145,158 ----
  
  	for(ic = im->core.ic_chain; ic; ic = ic->core.next)
  		XDestroyIC(ic);
! 	ximp_impart = (XIMXimpRec *)im->ximp_impart;
! 	if(ximp_impart->connectserver) {
  		for(i=0; i < Ximp_Xim_count; i++) {
  			if(Ximp_Xim_List[i] == im) {
  				Ximp_Xim_List[i] = NULL;
  				break;
  			}
+ 		}
  		_Ximp_SetupFreeExtension(im);
  		_Ximp_SetupFree(ximp_impart->im_proto_vl,
  				ximp_impart->im_styles,
***************
*** 140,149 ****
  				ximp_impart->im_server_vl,
  				ximp_impart->im_vendor_name,
  				ximp_impart->im_ext_list);
- 		Xfree(ximp_impart);
- 		}
- 	return(True);
  	}
  
  static	char	 IMname[XIMP_NAME];
  static  char     LCname[XIMP_NAME];
--- 161,170 ----
  				ximp_impart->im_server_vl,
  				ximp_impart->im_vendor_name,
  				ximp_impart->im_ext_list);
  	}
+ 	Xfree(ximp_impart);
+ 	return(True);
+ }
  
  static	char	 IMname[XIMP_NAME];
  static  char     LCname[XIMP_NAME];
***************
*** 151,157 ****
  Bool
  _Ximp_Setup(im)
  	Ximp_XIM	im;
! 	{
  	XLCd		 lcd;
  	Atom		 atom_server;
  	Window	 	 fe_window_id;
--- 172,178 ----
  Bool
  _Ximp_Setup(im)
  	Ximp_XIM	im;
! {
  	XLCd		 lcd;
  	Atom		 atom_server;
  	Window	 	 fe_window_id;
***************
*** 175,181 ****
  	long		*prop_long;
  	int		*prop_int;
  	int		 i, n, count;
- 	XIMXimpRec	*ximp_impart;
  
  	lcd = im->core.lcd;
  	dpy = im->core.display;
--- 196,201 ----
***************
*** 190,203 ****
  	    *prop = 0;
  
  	/* IMserver Name  ex. _XIMP_ja_JP  */
! 	if(lcd->core.modifiers == (char *)NULL)
  		sprintf(IMname, "%s%s", _XIMP_BASE, LCname); /* Default */
! 	else
! 		sprintf(IMname, "%s%s%s%s%s%s", _XIMP_BASE, LCname, "@", lcd->core.modifiers, ".", dpy->default_screen);
  	/* Get IMS Window WID */
  	if((atom_server = XInternAtom(dpy, IMname, False)) == (Atom)NULL){
  		return(False);
! 		}
  	fe_window_id = XGetSelectionOwner(dpy, atom_server);
  	if(fe_window_id == NULL) return(False);
  
--- 210,241 ----
  	    *prop = 0;
  
  	/* IMserver Name  ex. _XIMP_ja_JP  */
! 	if(lcd->core.modifiers == (char *)NULL || *lcd->core.modifiers == '\0')
  		sprintf(IMname, "%s%s", _XIMP_BASE, LCname); /* Default */
! 	else {
! #define MODIFIER "@im="
!  		char *mod, *s, buf[20];
!  
!  		(void)strcpy(IMname, _XIMP_BASE);
!  		(void)strcat(IMname, LCname);
!  		mod = strstr(lcd->core.modifiers, MODIFIER);
!  		if (mod) {
!  			(void)strcat(IMname, "@");
!  			mod += strlen(MODIFIER);
!  			s = IMname + strlen(IMname);
!  			while (*mod && *mod != '@') {
!  				*s++ = *mod++;
! 			}
! 			*s = '\0';
! 		}
! 		(void)sprintf(buf, ".%d", dpy->default_screen);
! 		(void)strcat(IMname, buf);
! 	}
! #undef MODIFIER
  	/* Get IMS Window WID */
  	if((atom_server = XInternAtom(dpy, IMname, False)) == (Atom)NULL){
  		return(False);
! 	}
  	fe_window_id = XGetSelectionOwner(dpy, atom_server);
  	if(fe_window_id == NULL) return(False);
  
***************
*** 220,239 ****
  			&bytes_after, (unsigned char **)(&prop_long)) != Success) {
  		_Ximp_SetupFree(version, NULL, NULL, NULL, NULL, NULL, NULL);
  		return(False);
! 		}
  	if((imstyle = (XIMStyles *)Xmalloc(sizeof(XIMStyles))) == NULL) {
  		_Ximp_SetupFree(version, NULL, NULL, NULL, NULL, NULL, NULL);
  		return(False);
! 		}
  	if((imstyle->supported_styles =
  		(XIMStyle *)Xmalloc(sizeof(XIMStyle) * nitems)) == NULL) {
  		Xfree(imstyle);
  		_Ximp_SetupFree(version, NULL, NULL, NULL, NULL, NULL, NULL);
  		return(False);
! 		}
  	for(i=0; i < nitems; i++) {
  		imstyle->supported_styles[i] = prop_long[i];
! 		}
  	imstyle->count_styles = nitems;
  	XFree((XPointer)prop_long);
  
--- 258,277 ----
  			&bytes_after, (unsigned char **)(&prop_long)) != Success) {
  		_Ximp_SetupFree(version, NULL, NULL, NULL, NULL, NULL, NULL);
  		return(False);
! 	}
  	if((imstyle = (XIMStyles *)Xmalloc(sizeof(XIMStyles))) == NULL) {
  		_Ximp_SetupFree(version, NULL, NULL, NULL, NULL, NULL, NULL);
  		return(False);
! 	}
  	if((imstyle->supported_styles =
  		(XIMStyle *)Xmalloc(sizeof(XIMStyle) * nitems)) == NULL) {
  		Xfree(imstyle);
  		_Ximp_SetupFree(version, NULL, NULL, NULL, NULL, NULL, NULL);
  		return(False);
! 	}
  	for(i=0; i < nitems; i++) {
  		imstyle->supported_styles[i] = prop_long[i];
! 	}
  	imstyle->count_styles = nitems;
  	XFree((XPointer)prop_long);
  
***************
*** 244,265 ****
  			&bytes_after, (unsigned char **)(&prop_int)) != Success) {
  		_Ximp_SetupFree(version, imstyle, NULL, NULL, NULL, NULL, NULL);
  		return(False);
! 		}
  	if((keylist = (Ximp_KeyList *)Xmalloc(sizeof(Ximp_KeyList))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, NULL, NULL, NULL, NULL, NULL);
  		return(False);
! 		}
  	count = nitems / 3;
  	if((keylist->keys_list = (Ximp_Key *)Xmalloc(sizeof(Ximp_Key) * count)) == NULL) {
  		Xfree(keylist);
  		_Ximp_SetupFree(version, imstyle, NULL, NULL, NULL, NULL, NULL);
  		return(False);
! 		}
  	for(i=0,n=0; n < count; n++) {
  		keylist->keys_list[n].modifier        = prop_int[i++];
  		keylist->keys_list[n].modifier_mask   = prop_int[i++];
  		keylist->keys_list[n].keysym          = prop_int[i++];
! 		}
  	keylist->count_keys = count;
  	XFree((XPointer)prop_int);
  
--- 282,303 ----
  			&bytes_after, (unsigned char **)(&prop_int)) != Success) {
  		_Ximp_SetupFree(version, imstyle, NULL, NULL, NULL, NULL, NULL);
  		return(False);
! 	}
  	if((keylist = (Ximp_KeyList *)Xmalloc(sizeof(Ximp_KeyList))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, NULL, NULL, NULL, NULL, NULL);
  		return(False);
! 	}
  	count = nitems / 3;
  	if((keylist->keys_list = (Ximp_Key *)Xmalloc(sizeof(Ximp_Key) * count)) == NULL) {
  		Xfree(keylist);
  		_Ximp_SetupFree(version, imstyle, NULL, NULL, NULL, NULL, NULL);
  		return(False);
! 	}
  	for(i=0,n=0; n < count; n++) {
  		keylist->keys_list[n].modifier        = prop_int[i++];
  		keylist->keys_list[n].modifier_mask   = prop_int[i++];
  		keylist->keys_list[n].keysym          = prop_int[i++];
! 	}
  	keylist->count_keys = count;
  	XFree((XPointer)prop_int);
  
***************
*** 270,280 ****
  			&bytes_after, (unsigned char **)(&prop)) != Success) {
  		_Ximp_SetupFree(version, imstyle, keylist, NULL, NULL, NULL, NULL);
  		return(False);
! 		}
  	if((server_name = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, NULL, NULL, NULL, NULL);
  		return(False);
! 		}
  	strncpy(server_name, prop, nitems);
  	server_name[nitems] = '\0';
  	XFree(prop);
--- 308,318 ----
  			&bytes_after, (unsigned char **)(&prop)) != Success) {
  		_Ximp_SetupFree(version, imstyle, keylist, NULL, NULL, NULL, NULL);
  		return(False);
! 	}
  	if((server_name = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, NULL, NULL, NULL, NULL);
  		return(False);
! 	}
  	strncpy(server_name, prop, nitems);
  	server_name[nitems] = '\0';
  	XFree(prop);
***************
*** 286,296 ****
  			&bytes_after, (unsigned char **)(&prop)) != Success) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, NULL, NULL, NULL);
  		return(False);
! 		}
  	if((server_vl = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, NULL, NULL, NULL);
  		return(False);
! 		}
  	strncpy(server_vl, prop, nitems);
  	server_vl[nitems] = '\0';
  	XFree(prop);
--- 324,334 ----
  			&bytes_after, (unsigned char **)(&prop)) != Success) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, NULL, NULL, NULL);
  		return(False);
! 	}
  	if((server_vl = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, NULL, NULL, NULL);
  		return(False);
! 	}
  	strncpy(server_vl, prop, nitems);
  	server_vl[nitems] = '\0';
  	XFree(prop);
***************
*** 302,312 ****
  			&bytes_after, (unsigned char **)(&prop)) != Success) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, NULL, NULL, NULL);
  		return(False);
! 		}
  	if((vendor_name = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, NULL, NULL, NULL);
  		return(False);
! 		}
  	strncpy(vendor_name, prop, nitems);
  	vendor_name[nitems] = '\0';
  	XFree(prop);
--- 340,350 ----
  			&bytes_after, (unsigned char **)(&prop)) != Success) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, NULL, NULL, NULL);
  		return(False);
! 	}
  	if((vendor_name = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, NULL, NULL, NULL);
  		return(False);
! 	}
  	strncpy(vendor_name, prop, nitems);
  	vendor_name[nitems] = '\0';
  	XFree(prop);
***************
*** 318,369 ****
  			&bytes_after, (unsigned char **)(&prop_int)) != Success) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
  		return(False);
! 		}
  	if((ext_list = (Atom *)Xmalloc((sizeof(Atom) * nitems + 1))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
  		return(False);
! 		}
  	for(i=0; i < nitems; i++)
  		ext_list[i] = prop_int[i];
  	ext_list[nitems] = NULL;
  	if(prop_int) XFree((XPointer)prop_int);
  
! 	if((ximp_impart = (XIMXimpRec *)Xmalloc(sizeof(XIMXimpRec))) == (XIMXimpRec *)NULL) {
! 		_Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, ext_list);
! 		return(False);
! 		}
! 
! 	ximp_impart->inputserver    = 0;
! 	ximp_impart->fe_window	    = fe_window_id;
  	Protocol_ID                 = XInternAtom(dpy, _XIMP_PROTOCOL, False);
! 	ximp_impart->improtocol_id  = Protocol_ID;
! 	ximp_impart->version_id     = version_id;
! 	ximp_impart->style_id       = style_id;
! 	ximp_impart->keys_id        = keys_id;
! 	ximp_impart->servername_id  = servername_id;
! 	ximp_impart->serverversion_id = serverversion_id;
! 	ximp_impart->vendorname_id  = vendorname_id;
! 	ximp_impart->extentions_id  = extentions_id;
! 	ximp_impart->ctext_id       = XInternAtom(dpy, _XIMP_CTEXT, False);
! 	ximp_impart->focus_win_id   = XInternAtom(dpy, _XIMP_FOCUS, False);
! 	ximp_impart->preedit_atr_id = XInternAtom(dpy, _XIMP_PREEDIT, False);
! 	ximp_impart->status_atr_id  = XInternAtom(dpy, _XIMP_STATUS, False);
! 	ximp_impart->preeditfont_id = XInternAtom(dpy, _XIMP_PREEDITFONT, False);
! 	ximp_impart->statusfont_id  = XInternAtom(dpy, _XIMP_STATUSFONT, False);
! 	ximp_impart->preeditmaxsize_id = XInternAtom(dpy, _XIMP_PREEDITMAXSIZE, False);
! 	ximp_impart->im_proto_vl = version;
! 	ximp_impart->im_styles   = imstyle;;
! 	ximp_impart->im_keyslist = keylist;
! 	ximp_impart->im_server_name = server_name;
! 	ximp_impart->im_server_vl = server_vl;
! 	ximp_impart->im_vendor_name = vendor_name;
! 	ximp_impart->im_ext_list  = ext_list;
  
  	if(Ximp_Xim_List == (Ximp_XIM *)NULL){
  		Ximp_Xim_List = (Ximp_XIM *)Xmalloc(sizeof(Ximp_XIM));
  		Ximp_Xim_List[0] = im;
  		Ximp_Xim_count = 1;
! 		}
  	else {
  		n = 0;
  		for(i=0; i < Ximp_Xim_count; i++) {
--- 356,401 ----
  			&bytes_after, (unsigned char **)(&prop_int)) != Success) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
  		return(False);
! 	}
  	if((ext_list = (Atom *)Xmalloc((sizeof(Atom) * nitems + 1))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
  		return(False);
! 	}
  	for(i=0; i < nitems; i++)
  		ext_list[i] = prop_int[i];
  	ext_list[nitems] = NULL;
  	if(prop_int) XFree((XPointer)prop_int);
  
! 	im->ximp_impart->fe_window	    = fe_window_id;
  	Protocol_ID                 = XInternAtom(dpy, _XIMP_PROTOCOL, False);
! 	im->ximp_impart->improtocol_id  = Protocol_ID;
! 	im->ximp_impart->version_id     = version_id;
! 	im->ximp_impart->style_id       = style_id;
! 	im->ximp_impart->keys_id        = keys_id;
! 	im->ximp_impart->servername_id  = servername_id;
! 	im->ximp_impart->serverversion_id = serverversion_id;
! 	im->ximp_impart->vendorname_id  = vendorname_id;
! 	im->ximp_impart->extentions_id  = extentions_id;
! 	im->ximp_impart->ctext_id       = XInternAtom(dpy, _XIMP_CTEXT, False);
! 	im->ximp_impart->focus_win_id   = XInternAtom(dpy, _XIMP_FOCUS, False);
! 	im->ximp_impart->preedit_atr_id = XInternAtom(dpy, _XIMP_PREEDIT, False);
! 	im->ximp_impart->status_atr_id  = XInternAtom(dpy, _XIMP_STATUS, False);
! 	im->ximp_impart->preeditfont_id = XInternAtom(dpy, _XIMP_PREEDITFONT, False);
! 	im->ximp_impart->statusfont_id  = XInternAtom(dpy, _XIMP_STATUSFONT, False);
! 	im->ximp_impart->preeditmaxsize_id = XInternAtom(dpy, _XIMP_PREEDITMAXSIZE, False);
! 	im->ximp_impart->im_proto_vl = version;
! 	im->ximp_impart->im_styles   = imstyle;;
! 	im->ximp_impart->im_keyslist = keylist;
! 	im->ximp_impart->im_server_name = server_name;
! 	im->ximp_impart->im_server_vl = server_vl;
! 	im->ximp_impart->im_vendor_name = vendor_name;
! 	im->ximp_impart->im_ext_list  = ext_list;
  
  	if(Ximp_Xim_List == (Ximp_XIM *)NULL){
  		Ximp_Xim_List = (Ximp_XIM *)Xmalloc(sizeof(Ximp_XIM));
  		Ximp_Xim_List[0] = im;
  		Ximp_Xim_count = 1;
! 	}
  	else {
  		n = 0;
  		for(i=0; i < Ximp_Xim_count; i++) {
***************
*** 371,389 ****
  				Ximp_Xim_List[i] = im;
  				n = 1;
  				break;
- 				}
  			}
  		if(n == 0) {
  			Ximp_Xim_List = (Ximp_XIM *)Xrealloc(Ximp_Xim_List, ((i + 1) * sizeof(Ximp_XIM)));
  			Ximp_Xim_List[i-1] = im;
  			Ximp_Xim_count = i;
- 			}
  		}
  
- 	im->ximp_impart = ximp_impart;
  	_Ximp_SetupExtension(im);
  	return(True);
! 	}
  
  int
  _Ximp_SetupFree(proto_vl, style_list, keys_list, server_name, server_vl, 
--- 403,421 ----
  				Ximp_Xim_List[i] = im;
  				n = 1;
  				break;
  			}
+ 		}
  		if(n == 0) {
  			Ximp_Xim_List = (Ximp_XIM *)Xrealloc(Ximp_Xim_List, ((i + 1) * sizeof(Ximp_XIM)));
  			Ximp_Xim_List[i-1] = im;
  			Ximp_Xim_count = i;
  		}
+ 	}
  
  	_Ximp_SetupExtension(im);
+ 	im->ximp_impart->connectserver  = 1;
  	return(True);
! }
  
  int
  _Ximp_SetupFree(proto_vl, style_list, keys_list, server_name, server_vl, 
***************
*** 395,411 ****
  	char		*server_vl;
  	char		*vendor_name;
  	Atom		*ext_list;
! 	{
  	if(proto_vl)
  		Xfree(proto_vl);
  	if(style_list) {
  		Xfree(style_list->supported_styles);
  		Xfree(style_list);
! 		}
  	if(keys_list) {
  		Xfree(keys_list->keys_list);
  		Xfree(keys_list);
! 		}
  	if(server_name)
  		Xfree(server_name);
  	if(server_vl)
--- 427,443 ----
  	char		*server_vl;
  	char		*vendor_name;
  	Atom		*ext_list;
! {
  	if(proto_vl)
  		Xfree(proto_vl);
  	if(style_list) {
  		Xfree(style_list->supported_styles);
  		Xfree(style_list);
! 	}
  	if(keys_list) {
  		Xfree(keys_list->keys_list);
  		Xfree(keys_list);
! 	}
  	if(server_name)
  		Xfree(server_name);
  	if(server_vl)
***************
*** 414,425 ****
  		Xfree(vendor_name);
  	if(ext_list)
  		Xfree(ext_list);
! 	}
  
  Ximp_XIC
  _Ximp_LookupXIC(icid)
  	int	icid;
! 	{
  	int		i;
  	Ximp_XIM	pim;
  	Ximp_XIC	pic;
--- 446,457 ----
  		Xfree(vendor_name);
  	if(ext_list)
  		Xfree(ext_list);
! }
  
  Ximp_XIC
  _Ximp_LookupXIC(icid)
  	int	icid;
! {
  	int		i;
  	Ximp_XIM	pim;
  	Ximp_XIC	pic;
***************
*** 429,461 ****
  		for(pic = (Ximp_XIC)pim->core.ic_chain; pic; pic = (Ximp_XIC)pic->core.next) {
  			if(pic->ximp_icpart->icid == icid)
  				return(pic);
- 			}
  		}
- 	return(NULL);
  	}
  
  static Bool
  _Ximp_GetStyle(im, p_style)
  	Ximp_XIM	im;
! 	XIMStyles	*p_style;
! 	{
  	XIMStyles	*p;
  	int		i;
  
! 	if(im->ximp_impart == NULL) {
! 		p_style->count_styles = 0;
  		return(False);
! 		}
  	p = im->ximp_impart->im_styles;
! 	p_style->count_styles = p->count_styles;
  	for(i=0; i < (int)p->count_styles; i++) {
! 		p_style->supported_styles[i] = p->supported_styles[i];
! 		}
! 	return(True);
  	}
  
  Atom
  _Ximp_Protocol_id()
! 	{
  	return(Protocol_ID);
! 	}
--- 461,496 ----
  		for(pic = (Ximp_XIC)pim->core.ic_chain; pic; pic = (Ximp_XIC)pic->core.next) {
  			if(pic->ximp_icpart->icid == icid)
  				return(pic);
  		}
  	}
+ 	return(NULL);
+ }
  
  static Bool
  _Ximp_GetStyle(im, p_style)
  	Ximp_XIM	im;
! 	XIMStyles	**p_style;
! {
  	XIMStyles	*p;
  	int		i;
  
! 	if(!(im->ximp_impart->connectserver)) {
! 		(*((long *)(p_style))) = (long)NULL;
  		return(False);
! 	}
  	p = im->ximp_impart->im_styles;
! 	*p_style = (XIMStyles *)Xmalloc(sizeof(XIMStyles));
! 	(*p_style)->count_styles = p->count_styles;
! 	(*p_style)->supported_styles = (XIMStyle *)
! 		Xmalloc(p->count_styles * sizeof(XIMStyle));
  	for(i=0; i < (int)p->count_styles; i++) {
! 		(*p_style)->supported_styles[i] = p->supported_styles[i];
  	}
+ 	return(True);
+ }
  
  Atom
  _Ximp_Protocol_id()
! {
  	return(Protocol_ID);
! }

*** /tmp/,RCSt1001681	Mon Oct 28 15:38:53 1991
--- mit/lib/X/Ximp/XimpLCUtil.c	Mon Oct  7 17:49:01 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpLCUtil.c,v 1.5 91/07/30 14:27:42 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpLCUtil.c,v 1.6 91/10/07 17:48:57 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
***************
*** 501,506 ****
--- 501,512 ----
      }
  }
  
+ #ifdef X_NOT_STDC_ENV
+ #ifndef toupper
+ #define toupper(c)	((int)(c) - 'a' + 'A')
+ #endif
+ #endif
+ 
  int 
  _Ximp_CompareISOLatin1(str1, str2)
      char *str1, *str2;
***************
*** 509,517 ****
  
      for ( ; (ch1 = *str1) && (ch2 = *str2); str1++, str2++) {
  	if (islower(ch1))
! 	    ch1 -= 0x20;
  	if (islower(ch2))
! 	    ch2 -= 0x20;
  
  	if (ch1 != ch2)
  	    break;
--- 515,523 ----
  
      for ( ; (ch1 = *str1) && (ch2 = *str2); str1++, str2++) {
  	if (islower(ch1))
! 	    ch1 = toupper(ch1);
  	if (islower(ch2))
! 	    ch2 = toupper(ch2);
  
  	if (ch1 != ch2)
  	    break;
***************
*** 528,536 ****
  
      for ( ; (ch1 = *str1) && (ch2 = *str2) && len; str1++, str2++, len--) {
  	if (islower(ch1))
! 	    ch1 -= 0x20;
  	if (islower(ch2))
! 	    ch2 -= 0x20;
  
  	if (ch1 != ch2)
  	    break;
--- 534,542 ----
  
      for ( ; (ch1 = *str1) && (ch2 = *str2) && len; str1++, str2++, len--) {
  	if (islower(ch1))
! 	    ch1 = toupper(ch1);
  	if (islower(ch2))
! 	    ch2 = toupper(ch2);
  
  	if (ch1 != ch2)
  	    break;

*** /tmp/,RCSt1001702	Mon Oct 28 15:39:20 1991
--- mit/lib/X/Ximp/XimpLkup.c	Mon Oct  7 17:50:07 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpLkup.c,v 1.4 91/07/30 14:27:46 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by Sony Corporation
--- 1,4 ----
! /* $XConsortium: XimpLkup.c,v 1.5 91/10/07 17:49:03 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by Sony Corporation
***************
*** 111,117 ****
  static unsigned char *
  _Ximp_Reset(ic)
  	Ximp_XIC	 ic;
! 	{
  	XEvent		 Message;
  	XEvent		 event;
  	XimpResetPredArgRec Arg;
--- 111,117 ----
  static unsigned char *
  _Ximp_Reset(ic)
  	Ximp_XIC	 ic;
! {
  	XEvent		 Message;
  	XEvent		 event;
  	XimpResetPredArgRec Arg;
***************
*** 163,168 ****
--- 163,169 ----
  				case XIMP_PREEDITDONE:
  				case XIMP_PREEDITDRAW:
  				case XIMP_PREEDITDRAW_CM:
+ 				case XIMP_PREEDITDRAW_TINY:
  				case XIMP_STATUSDONE:
  				case XIMP_STATUSDRAW:
  				case XIMP_STATUSDRAW_CM:
***************
*** 183,189 ****
  		_time_flag = 0;
  		}
  	return((unsigned char *)NULL);
! 	}
  
  #define XIMP_MAXBUF 1024
  
--- 184,190 ----
  		_time_flag = 0;
  		}
  	return((unsigned char *)NULL);
! }
  
  #define XIMP_MAXBUF 1024
  
***************
*** 190,196 ****
  char *
  _Ximp_MbReset(ic)
  	Ximp_XIC	 ic;
! 	{
  	char *mb;
  	int length = XIMP_MAXBUF +1;
  	unsigned char *ct = _Ximp_Reset(ic);
--- 191,197 ----
  char *
  _Ximp_MbReset(ic)
  	Ximp_XIC	 ic;
! {
  	char *mb;
  	int length = XIMP_MAXBUF +1;
  	unsigned char *ct = _Ximp_Reset(ic);
***************
*** 200,211 ****
  	_Ximp_cttombs(ic->core.im->core.lcd, ct, strlen(ct), mb, &length, NULL);
  	mb[length] = '\0';
  	return(mb);
! 	}
  
  wchar_t *
  _Ximp_WcReset(ic)
  	Ximp_XIC	 ic;
! 	{
  	wchar_t *wc;
  	int length = XIMP_MAXBUF +1;
  	unsigned char *ct = _Ximp_Reset(ic);
--- 201,212 ----
  	_Ximp_cttombs(ic->core.im->core.lcd, ct, strlen(ct), mb, &length, NULL);
  	mb[length] = '\0';
  	return(mb);
! }
  
  wchar_t *
  _Ximp_WcReset(ic)
  	Ximp_XIC	 ic;
! {
  	wchar_t *wc;
  	int length = XIMP_MAXBUF +1;
  	unsigned char *ct = _Ximp_Reset(ic);
***************
*** 215,221 ****
  	_Ximp_cttowcs(ic->core.im->core.lcd, ct, strlen(ct), wc, &length, NULL);
  	wc[length] = (wchar_t)0;
  	return(wc);
! 	}
  
  #define	LookupKeypress	1
  #define LookupProperty	2
--- 216,222 ----
  	_Ximp_cttowcs(ic->core.im->core.lcd, ct, strlen(ct), wc, &length, NULL);
  	wc[length] = (wchar_t)0;
  	return(wc);
! }
  
  #define	LookupKeypress	1
  #define LookupProperty	2
***************
*** 237,245 ****
  	int		 bytes;
  	KeySym		*keysym;
  	Status		*status;
! 	{
  	XComposeStatus	 comp_status;
! 	int		 ret, len;
  
  	if(ev->type == KeyPress && ev->keycode == 0) { /* Filter function */
  		if (_xim_lookup_sign == LookupKeypress) {
--- 238,246 ----
  	int		 bytes;
  	KeySym		*keysym;
  	Status		*status;
! {
  	XComposeStatus	 comp_status;
! 	int		 ret = 0, len;
  
  	if(ev->type == KeyPress && ev->keycode == 0) { /* Filter function */
  		if (_xim_lookup_sign == LookupKeypress) {
***************
*** 246,253 ****
  			ev->state   = _xim_backup_state;
  			ev->keycode = _xim_backup_keycode;
  			ret = _Ximp_LookupMBText(ic, ev, buffer, bytes, keysym, &comp_status);
  			if(ret > 0) {
! 				if(*keysym != NoSymbol) {
  					if(status) *status = XLookupBoth;
  					 }
  				else {
--- 247,255 ----
  			ev->state   = _xim_backup_state;
  			ev->keycode = _xim_backup_keycode;
  			ret = _Ximp_LookupMBText(ic, ev, buffer, bytes, keysym, &comp_status);
+ 			ev->send_event = False ;
  			if(ret > 0) {
! 				if(keysym && *keysym != NoSymbol) {
  					if(status) *status = XLookupBoth;
  					 }
  				else {
***************
*** 255,261 ****
  					}
  				}
  			else {
! 				if(*keysym != NoSymbol) {
  					if(status) *status = XLookupKeySym;
  					}
  				else {
--- 257,263 ----
  					}
  				}
  			else {
! 				if(keysym && *keysym != NoSymbol) {
  					if(status) *status = XLookupKeySym;
  					}
  				else {
***************
*** 286,292 ****
  		if(status)*status = (ret > 0) ? XLookupChars : XLookupNone;
  		return(ret);
  		}
! 	else {
  		if(ic->core.client_window == (Window)NULL) {
  			if(status) *status = XLookupNone;
  			return(0);
--- 288,294 ----
  		if(status)*status = (ret > 0) ? XLookupChars : XLookupNone;
  		return(ret);
  		}
! 	else if(ev->type == KeyPress) {
  		if(ic->core.client_window == (Window)NULL) {
  			if(status) *status = XLookupNone;
  			return(0);
***************
*** 300,310 ****
  			}
  		ret = _Ximp_LookupMBText(ic, ev, buffer, bytes, keysym, &comp_status);
  		if(ret >= 0) {
! 			if(_Ximp_StartXIMP(ic, ev, *keysym)) {
  				if(status) *status = XLookupNone;
  					return(0);
  				}
! 			if(*keysym != NoSymbol) {
  				if(status) *status = XLookupBoth;
  				}
  			 else {
--- 302,314 ----
  			}
  		ret = _Ximp_LookupMBText(ic, ev, buffer, bytes, keysym, &comp_status);
  		if(ret >= 0) {
! 			if(_Ximp_StartXIMP(ic, ev, keysym ? *keysym : 0)) {
  				if(status) *status = XLookupNone;
  					return(0);
  				}
! 			}
! 		if(ret > 0) {
! 			if(keysym && *keysym != NoSymbol) {
  				if(status) *status = XLookupBoth;
  				}
  			 else {
***************
*** 312,318 ****
  				}
  			}
  		else {
! 			if(*keysym != NoSymbol) {
  				if(status) *status = XLookupKeySym;
  				}
  			 else {
--- 316,322 ----
  				}
  			}
  		else {
! 			if(keysym && *keysym != NoSymbol) {
  				if(status) *status = XLookupKeySym;
  				}
  			 else {
***************
*** 320,327 ****
  				}
  			}
   		}
  	return(ret);
! 	}
  
  int
  _Ximp_WcLookupString(ic, ev, buffer, wlen, keysym, status)
--- 324,335 ----
  				}
  			}
   		}
+ 	else {
+ 		if (status)
+ 			*status = XLookupNone;
+     		}
  	return(ret);
! }
  
  int
  _Ximp_WcLookupString(ic, ev, buffer, wlen, keysym, status)
***************
*** 331,337 ****
  	int		 wlen;
  	KeySym		*keysym;
  	Status		*status;
! 	{
  	XComposeStatus	 comp_status;
  	int		 ret, len;
  	char		 look[128];
--- 339,345 ----
  	int		 wlen;
  	KeySym		*keysym;
  	Status		*status;
! {
  	XComposeStatus	 comp_status;
  	int		 ret, len;
  	char		 look[128];
***************
*** 340,348 ****
  		if (_xim_lookup_sign == LookupKeypress) {
  			ev->state   = _xim_backup_state;
  			ev->keycode = _xim_backup_keycode;
! 			ret = _Ximp_LookupWCText(ic, ev, look, wlen, keysym, &comp_status);
  			if(ret > 0) {
! 				if(*keysym != NoSymbol) {
  					if(status) *status = XLookupBoth;
  					 }
  				else {
--- 348,357 ----
  		if (_xim_lookup_sign == LookupKeypress) {
  			ev->state   = _xim_backup_state;
  			ev->keycode = _xim_backup_keycode;
! 			ret = _Ximp_LookupWCText(ic, ev, buffer, wlen, keysym, &comp_status);
! 			ev->send_event = False ;
  			if(ret > 0) {
! 				if(keysym && *keysym != NoSymbol) {
  					if(status) *status = XLookupBoth;
  					 }
  				else {
***************
*** 350,356 ****
  					}
  				}
  			else {
! 				if(*keysym != NoSymbol) {
  					if(status) *status = XLookupKeySym;
  					}
  				else {
--- 359,365 ----
  					}
  				}
  			else {
! 				if(keysym && *keysym != NoSymbol) {
  					if(status) *status = XLookupKeySym;
  					}
  				else {
***************
*** 360,365 ****
--- 369,375 ----
  			return(ret);
  			}
  		else if(_xim_lookup_sign == LookupProperty) {
+ 			len = wlen;
  			if (_Ximp_cttowcs(ic->core.im->core.lcd,
  							  _xim_prop_return,
  							  _xim_string_length,
***************
*** 370,375 ****
--- 380,386 ----
  			XFree((XPointer)_xim_prop_return);
  			}
  		else if (_xim_lookup_sign == LookupMessage) {
+ 			len = wlen;
  			if (_Ximp_cttowcs(ic->core.im->core.lcd,
  							  _xim_message_buf,
  							  _xim_message_len,
***************
*** 393,405 ****
  			if(status) *status = XLookupNone;
  			return(0);
  			}
! 		ret = _Ximp_LookupWCText(ic, ev, look, wlen, keysym, &comp_status);
  		if(ret >= 0) {
! 			if(_Ximp_StartXIMP(ic, ev, *keysym)) {
  				if(status) *status = XLookupNone;
  					return(0);
  				}
! 			if(*keysym != NoSymbol) {
  				if(status) *status = XLookupBoth;
  				}
  			 else {
--- 404,416 ----
  			if(status) *status = XLookupNone;
  			return(0);
  			}
! 		ret = _Ximp_LookupWCText(ic, ev, buffer, wlen, keysym, &comp_status);
  		if(ret >= 0) {
! 			if(_Ximp_StartXIMP(ic, ev, keysym ? *keysym : 0)) {
  				if(status) *status = XLookupNone;
  					return(0);
  				}
! 			if(keysym && *keysym != NoSymbol) {
  				if(status) *status = XLookupBoth;
  				}
  			 else {
***************
*** 407,413 ****
  				}
  			}
  		else {
! 			if(*keysym != NoSymbol) {
  				if(status) *status = XLookupKeySym;
  				}
  			 else {
--- 418,424 ----
  				}
  			}
  		else {
! 			if(keysym && *keysym != NoSymbol) {
  				if(status) *status = XLookupKeySym;
  				}
  			 else {
***************
*** 416,422 ****
--- 427,458 ----
  			}
   		}
  	return(ret);
+ }
+ 
+ static Bool
+ _Ximp_FocusInput (window, mask)
+ 	Window		window;
+ 	unsigned long	*mask;
+ {
+ 	int		i;
+ 	Ximp_XIM	pim;
+ 	Ximp_XIC	pic;
+ 	extern int	Ximp_Xim_count;
+ 	extern Ximp_XIM	*Ximp_Xim_List;
+ 
+ 	for(i = 0; i < Ximp_Xim_count; i++) {
+ 		pim = Ximp_Xim_List[i];
+ 		for (pic = (Ximp_XIC)pim->core.ic_chain;
+ 			pic; pic = (Ximp_XIC)pic->core.next) {
+ 			if(pic->core.focus_window == window &&
+ 				pic->ximp_icpart->input_mode) {
+ 				*mask = pic->ximp_icpart->back_mask;
+ 				return(True);
+ 			}
+ 		}
  	}
+ 	return (False);
+ }
  
  static Bool
  _Ximp_StartXIMP(ic, ev, keysym)
***************
*** 423,431 ****
  	Ximp_XIC		 ic;
  	XKeyEvent		*ev;
  	KeySym			 keysym;
! 	{
  	Ximp_KeyList		*list;
! 	int			 i, flag;
  	XWindowAttributes	 ret_attributes;
  	unsigned long		 dummy_mask;
  	XEvent			 Message;
--- 459,467 ----
  	Ximp_XIC		 ic;
  	XKeyEvent		*ev;
  	KeySym			 keysym;
! {
  	Ximp_KeyList		*list;
! 	int			 i, isEventPassedToIMS;
  	XWindowAttributes	 ret_attributes;
  	unsigned long		 dummy_mask;
  	XEvent			 Message;
***************
*** 434,461 ****
  	if(ic->ximp_icpart->input_mode) /* ON : input_mode */
  		return(False);
  
! 	if(((Ximp_XIM)ic->core.im)->ximp_impart == (XIMXimpRec *)NULL) {
! 		if (keysym == XK_Kanji || keysym == XK_Henkan_Mode) {
  			if(_Ximp_Setup (ic->core.im) == False)
! 				flag = 1;
  			else
! 				flag = 0;
  		}
  		else
! 			flag = 1;
  	}
  	else {	
  		list = ((Ximp_XIM)ic->core.im)->ximp_impart->im_keyslist;
! 		for(i = 0, flag = 1; i < (int)list->count_keys; i++) {
! 			if(   (keysym == list->keys_list[i].keysym)
  			   && ((ev->state & list->keys_list[i].modifier_mask)
  			       == list->keys_list[i].modifier ) ) {
! 				flag = 0;
  				break;
  				}
  			}
  	}
! 	if(flag) return(False);
  
  	if(ic->ximp_icpart->icid == NULL)
  		if(!(_Ximp_SetOpenXIMP(ic))) return(False);
--- 470,498 ----
  	if(ic->ximp_icpart->input_mode) /* ON : input_mode */
  		return(False);
  
! 	if(!(((Ximp_XIM)ic->core.im)->ximp_impart->connectserver)) {
! 		if(keysym && keysym ==
! 		  (((Ximp_XIM)ic->core.im)->ximp_impart->def_startkeysym)) {
  			if(_Ximp_Setup (ic->core.im) == False)
! 				isEventPassedToIMS = 1;
  			else
! 				isEventPassedToIMS = 0;
  		}
  		else
! 			isEventPassedToIMS = 1;
  	}
  	else {	
  		list = ((Ximp_XIM)ic->core.im)->ximp_impart->im_keyslist;
! 		for(i = 0, isEventPassedToIMS = 1; i < (int)list->count_keys; i++) {
! 			if(   (keysym && keysym == list->keys_list[i].keysym)
  			   && ((ev->state & list->keys_list[i].modifier_mask)
  			       == list->keys_list[i].modifier ) ) {
! 				isEventPassedToIMS = 0;
  				break;
  				}
  			}
  	}
! 	if(isEventPassedToIMS) return(False);
  
  	if(ic->ximp_icpart->icid == NULL)
  		if(!(_Ximp_SetOpenXIMP(ic))) return(False);
***************
*** 471,496 ****
  			((Ximp_XIM)ic->core.im)->ximp_impart->fe_window,
  			StructureNotifyMask);
  
! 	if(ic->ximp_icpart->is_bep_mode == XIMP_FRONTEND) {
! 		XGetWindowAttributes(ic->core.im->core.display,
! 				     ic->core.focus_window, &ret_attributes);
! 		dummy_mask = ret_attributes.your_event_mask;
  		ic->ximp_icpart->back_mask = dummy_mask;
! 		dummy_mask &= ~(KeyPressMask | KeyReleaseMask);
! 		XSelectInput(ic->core.im->core.display,
! 			     ic->core.focus_window, dummy_mask);
! 		XFlush(ic->core.im->core.display);
! 		}
  
! 	_Ximp_IM_SendMessage(ic, XIMP_BEGIN, NULL, NULL, NULL);
  	ic->ximp_icpart->input_mode = 1;
  	return(True);
! 	}
  
  Bool
  _Ximp_SetOpenXIMP(ic)
  	Ximp_XIC	ic;
! 	{
  	unsigned long	 mask;
  	XEvent		 event;
  
--- 508,537 ----
  			((Ximp_XIM)ic->core.im)->ximp_impart->fe_window,
  			StructureNotifyMask);
  
! 	if (_Ximp_FocusInput (ic->core.focus_window, &dummy_mask))
  		ic->ximp_icpart->back_mask = dummy_mask;
! 	else {
! 		Display *d = ic->core.im->core.display;
  
! 		XGetWindowAttributes(d, ic->core.focus_window, &ret_attributes);
! 		dummy_mask = ret_attributes.your_event_mask;
! 		ic->ximp_icpart->back_mask = dummy_mask;
! 		if(ic->ximp_icpart->is_bep_mode == XIMP_FRONTEND)
! 			dummy_mask &= ~(KeyPressMask | KeyReleaseMask);
! 		else
! 			dummy_mask &= ~(KeyReleaseMask);
! 		XSelectInput(d, ic->core.focus_window, dummy_mask);
! 	}
  	ic->ximp_icpart->input_mode = 1;
+ 	_Ximp_IM_SendMessage(ic, XIMP_BEGIN, NULL, NULL, NULL);
+ 	XFlush(ic->core.im->core.display);
  	return(True);
! }
  
  Bool
  _Ximp_SetOpenXIMP(ic)
  	Ximp_XIC	ic;
! {
  	unsigned long	 mask;
  	XEvent		 event;
  
***************
*** 512,525 ****
  	mask = ic->ximp_icpart->proto_mask;
  	if(mask & XIMP_PROP_FOCUS)
  		_Ximp_SetFocusWindow(ic);
! 	if(mask & XIMP_PROP_PREEDIT)
! 		_Ximp_SetPreeditAtr(ic);
! 	if(mask & XIMP_PROP_PREFONT)
! 		_Ximp_SetPreeditFont(ic);
! 	if(mask & XIMP_PROP_STATUS)
! 		_Ximp_SetStatusAtr(ic);
! 	if(mask & XIMP_PROP_STSFONT)
! 		_Ximp_SetStatusFont(ic);
  
  	/* ClientMessage Send */
  	_Ximp_IM_SendMessage(ic, XIMP_CREATE, ic->core.input_style, mask, NULL);
--- 553,578 ----
  	mask = ic->ximp_icpart->proto_mask;
  	if(mask & XIMP_PROP_FOCUS)
  		_Ximp_SetFocusWindow(ic);
! 	if(!(   (ic->core.input_style & XIMPreeditCallbacks)
! 	     || (ic->core.input_style & XIMPreeditNone) ) ) { 
! 		if(mask & XIMP_PROP_PREEDIT)
! 			_Ximp_SetPreeditAtr(ic);
! 		if(mask & XIMP_PROP_PREFONT)
! 			_Ximp_SetPreeditFont(ic);
! 		}
! 	else {
! 		mask &= ~(XIMP_PROP_PREEDIT | XIMP_PROP_PREFONT);
! 		}
! 	if(!(   (ic->core.input_style & XIMStatusCallbacks)
! 	     || (ic->core.input_style & XIMStatusNone) ) ) { 
! 		if(mask & XIMP_PROP_STATUS)
! 			_Ximp_SetStatusAtr(ic);
! 		if(mask & XIMP_PROP_STSFONT)
! 			_Ximp_SetStatusFont(ic);
! 		}
! 	else {
! 		mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
! 		}
  
  	/* ClientMessage Send */
  	_Ximp_IM_SendMessage(ic, XIMP_CREATE, ic->core.input_style, mask, NULL);
***************
*** 545,551 ****
  #endif /* XIMP_SIGNAL */
  			_Ximp_ProcError (ic->core.im->core.display, NULL, &event);
  			_time_flag = 0;
! 			return(False);
  			}
  		else { /* XIMP_CRETAE_RETURN   Event */
  #ifdef XIMP_SIGNAL
--- 598,605 ----
  #endif /* XIMP_SIGNAL */
  			_Ximp_ProcError (ic->core.im->core.display, NULL, &event);
  			_time_flag = 0;
! 			/* return(False); */
! 			continue;
  			}
  		else { /* XIMP_CRETAE_RETURN   Event */
  #ifdef XIMP_SIGNAL
***************
*** 559,582 ****
  		}
  	_time_flag = 0;
  	return(False);
! 	}
  
! static void
  _Ximp_MakeKeypress (d, w, ev)
  	Display			*d;
  	Window			w;
  	XKeyEvent		*ev;
! 	{
  	ev->type = KeyPress;
  	ev->keycode = 0;
! 	}
  
! static void
  _Ximp_ProcKeypress (d, w, ev)
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
! 	{
  	ICID	icid;
  
  	icid = ev->data.l[1];
--- 613,636 ----
  		}
  	_time_flag = 0;
  	return(False);
! }
  
! void
  _Ximp_MakeKeypress (d, w, ev)
  	Display			*d;
  	Window			w;
  	XKeyEvent		*ev;
! {
  	ev->type = KeyPress;
  	ev->keycode = 0;
! }
  
! void
  _Ximp_ProcKeypress (d, w, ev)
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
! {
  	ICID	icid;
  
  	icid = ev->data.l[1];
***************
*** 583,589 ****
  	_xim_backup_keycode = ev->data.l[2];
  	_xim_backup_state = ev->data.l[3];
  	_xim_lookup_sign = LookupKeypress;
! 	}
  
  static void
  _Ximp_ProcCreateReturn (d, w, ev)
--- 637,643 ----
  	_xim_backup_keycode = ev->data.l[2];
  	_xim_backup_state = ev->data.l[3];
  	_xim_lookup_sign = LookupKeypress;
! }
  
  static void
  _Ximp_ProcCreateReturn (d, w, ev)
***************
*** 590,600 ****
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
! 	{
  	ICID	icid;
  
  	icid = ev->data.l[1];
! 	}
  
  static void
  _Ximp_ProcConversionBegin (d, w, ev)
--- 644,654 ----
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
! {
  	ICID	icid;
  
  	icid = ev->data.l[1];
! }
  
  static void
  _Ximp_ProcConversionBegin (d, w, ev)
***************
*** 601,607 ****
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
! 	{
  	ICID			icid;
  	Ximp_XIC		ic;
  	XWindowAttributes	ret_attributes;
--- 655,661 ----
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
! {
  	ICID			icid;
  	Ximp_XIC		ic;
  	XWindowAttributes	ret_attributes;
***************
*** 609,625 ****
  
  	icid = ev->data.l[1];
  	ic   = _Ximp_LookupXIC(icid);
! 	if(ic->ximp_icpart->is_bep_mode == XIMP_FRONTEND) {
  		XGetWindowAttributes(d, ic->core.focus_window, &ret_attributes);
  		dummy_mask = ret_attributes.your_event_mask;
  		ic->ximp_icpart->back_mask = dummy_mask;
! 		dummy_mask &= ~(KeyPressMask | KeyReleaseMask);
  		XSelectInput(d, ic->core.focus_window, dummy_mask);
  		XFlush(d);
! 		}
  	ic->ximp_icpart->input_mode = 1;
  	return;
! 	}
  
  static void
  _Ximp_ProcConversionEnd (d, w, ev)
--- 663,688 ----
  
  	icid = ev->data.l[1];
  	ic   = _Ximp_LookupXIC(icid);
! 
! 	if(ic->ximp_icpart->input_mode) /* ON : input_mode */
! 		return;
! 
! 	if (_Ximp_FocusInput (ic->core.focus_window, &dummy_mask))
! 		ic->ximp_icpart->back_mask = dummy_mask;
! 	else {
  		XGetWindowAttributes(d, ic->core.focus_window, &ret_attributes);
  		dummy_mask = ret_attributes.your_event_mask;
  		ic->ximp_icpart->back_mask = dummy_mask;
! 		if(ic->ximp_icpart->is_bep_mode == XIMP_FRONTEND)
! 			dummy_mask &= ~(KeyPressMask | KeyReleaseMask);
! 		else
! 			dummy_mask &= ~(KeyReleaseMask);
  		XSelectInput(d, ic->core.focus_window, dummy_mask);
  		XFlush(d);
! 	}
  	ic->ximp_icpart->input_mode = 1;
  	return;
! }
  
  static void
  _Ximp_ProcConversionEnd (d, w, ev)
***************
*** 626,646 ****
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
! 	{
  	ICID			icid;
  	Ximp_XIC		ic;
  
  	icid = ev->data.l[1];
  	ic   = _Ximp_LookupXIC(icid);
! 	if(ic->ximp_icpart->is_bep_mode == XIMP_FRONTEND) {
! 		XSelectInput(	d,
! 				ic->core.focus_window,
! 				ic->ximp_icpart->back_mask );
! 		XFlush(d);
! 		}
  	ic->ximp_icpart->input_mode = 0;
  	return;
! 	}
  
  static void
  _Ximp_ProcReadProperty (d, w, ev)
--- 689,705 ----
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
! {
  	ICID			icid;
  	Ximp_XIC		ic;
  
  	icid = ev->data.l[1];
  	ic   = _Ximp_LookupXIC(icid);
! 	XSelectInput(d, ic->core.focus_window, ic->ximp_icpart->back_mask );
! 	XFlush(d);
  	ic->ximp_icpart->input_mode = 0;
  	return;
! }
  
  static void
  _Ximp_ProcReadProperty (d, w, ev)
***************
*** 647,653 ****
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
! 	{
  	Ximp_XIC		ic;
  	ICID			icid;
  	Atom			read_prop;
--- 706,712 ----
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
! {
  	Ximp_XIC		ic;
  	ICID			icid;
  	Atom			read_prop;
***************
*** 671,677 ****
  	 *	do not forget to do XFree it.
  	 */
  	_xim_lookup_sign = LookupProperty;
! 	}
  
  static void
  _Ximp_ProcError (d, w, ev)
--- 730,736 ----
  	 *	do not forget to do XFree it.
  	 */
  	_xim_lookup_sign = LookupProperty;
! }
  
  static void
  _Ximp_ProcError (d, w, ev)
***************
*** 678,684 ****
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
! 	{
  	ICID			icid;
  	Ximp_XIC		ic;
  	unsigned long		data[3];
--- 737,743 ----
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
! {
  	ICID			icid;
  	Ximp_XIC		ic;
  	unsigned long		data[3];
***************
*** 689,697 ****
  	 *	you should modify this routine.
  	 */
  
  	if (ic->ximp_icpart->error.callback) {
- 		icid = ev->data.l[1];
- 		ic   = _Ximp_LookupXIC(icid);
  		data[0] = ev->data.l[2];
  		data[2] = ev->data.l[4];
  		if(ev->data.l[0] != XIMP_ERROR)
--- 748,756 ----
  	 *	you should modify this routine.
  	 */
  
+ 	icid = ev->data.l[1];
+ 	ic   = _Ximp_LookupXIC(icid);
  	if (ic->ximp_icpart->error.callback) {
  		data[0] = ev->data.l[2];
  		data[2] = ev->data.l[4];
  		if(ev->data.l[0] != XIMP_ERROR)
***************
*** 703,709 ****
  					ic->ximp_icpart->error.client_data,
  					data);
  		}
! 	}
  
  static void
  _Ximp_ProcReadMessage (d, w, ev)
--- 762,768 ----
  					ic->ximp_icpart->error.client_data,
  					data);
  		}
! }
  
  static void
  _Ximp_ProcReadMessage (d, w, ev)
***************
*** 710,716 ****
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
! 	{
  	ICID	icid;
  	long	nicid;
  
--- 769,775 ----
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
! {
  	ICID	icid;
  	long	nicid;
  
***************
*** 723,729 ****
  	_xim_message_buf[_xim_message_len + 2] = 0;
  	_xim_message_buf[_xim_message_len + 3] = 0;
  	_xim_lookup_sign = LookupMessage;
! 	}
  
  static void
  _Ximp_CallCallback (d, w, ev)
--- 782,788 ----
  	_xim_message_buf[_xim_message_len + 2] = 0;
  	_xim_message_buf[_xim_message_len + 3] = 0;
  	_xim_lookup_sign = LookupMessage;
! }
  
  static void
  _Ximp_CallCallback (d, w, ev)
***************
*** 730,736 ****
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
! 	{
  	ICID		icid;
  	Ximp_XIC	ic;
  
--- 789,795 ----
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
! {
  	ICID		icid;
  	Ximp_XIC	ic;
  
***************
*** 752,757 ****
--- 811,819 ----
  		case XIMP_PREEDITDRAW_CM:
  			_Ximp_CallPreeditDrawCallback2 (ic, ev);
  			break;
+ 		case XIMP_PREEDITDRAW_TINY:
+ 			_Ximp_CallPreeditDrawCallback3 (ic, ev);
+ 			break;
  		case XIMP_PREEDITCARET:
  			_Ximp_CallPreeditCaretCallback (ic, ev);
  			break;
***************
*** 770,776 ****
  		default:
  			break;
  		}
! 	}
  
  static Bool
  _Ximp_ProtoReceive (d, w, ev, client_data)
--- 832,838 ----
  		default:
  			break;
  		}
! }
  
  static Bool
  _Ximp_ProtoReceive (d, w, ev, client_data)
***************
*** 778,784 ****
  	Window			w;
  	XClientMessageEvent	*ev;
  	XPointer		*client_data;
! 	{
  	if (ev->message_type != _Ximp_Protocol_id ())
  		return (False);
  	if (ev->format == 32) {
--- 840,846 ----
  	Window			w;
  	XClientMessageEvent	*ev;
  	XPointer		*client_data;
! {
  	if (ev->message_type != _Ximp_Protocol_id ())
  		return (False);
  	if (ev->format == 32) {
***************
*** 786,792 ****
  		case XIMP_KEYPRESS:
  			_Ximp_ProcKeypress (d, w, ev);
  			_Ximp_MakeKeypress (d, w, ev);
! 			return (False);
  		case XIMP_CREATE_RETURN:
  			_Ximp_ProcCreateReturn (d, w, ev);
  			break;
--- 848,856 ----
  		case XIMP_KEYPRESS:
  			_Ximp_ProcKeypress (d, w, ev);
  			_Ximp_MakeKeypress (d, w, ev);
! 			ev->send_event = False ;
! 			XPutBackEvent(d, ev);
! 			break ;
  		case XIMP_CREATE_RETURN:
  			_Ximp_ProcCreateReturn (d, w, ev);
  			break;
***************
*** 799,805 ****
  		case XIMP_READPROP:
  			_Ximp_ProcReadProperty (d, w, ev);
  			_Ximp_MakeKeypress (d, w, ev);
! 			return (False);
  		case XIMP_ERROR:
  			_Ximp_ProcError (d, w, ev);
  			break;
--- 863,871 ----
  		case XIMP_READPROP:
  			_Ximp_ProcReadProperty (d, w, ev);
  			_Ximp_MakeKeypress (d, w, ev);
! 			ev->send_event = False ;
! 			XPutBackEvent(d, ev);
! 			break ;
  		case XIMP_ERROR:
  			_Ximp_ProcError (d, w, ev);
  			break;
***************
*** 820,840 ****
  			break;
  		default:
  			break;
- 			}
  		}
! 	else if (ev->format == 8) {
  		_Ximp_ProcReadMessage (d, w, ev);
  		_Ximp_MakeKeypress (d, w, ev);
! 		return (False);
! 		}
  	return (True);
! 	}
  
  static Bool
  _Ximp_ServerDestroy (d, w, ev, client_data)
  	Display			*d;
  	Window			w;
! 	XClientMessageEvent	*ev;
  	XPointer		*client_data;
  {
  	extern Ximp_XIM		*Ximp_Xim_List;
--- 886,906 ----
  			break;
  		default:
  			break;
  		}
!         } else if (ev->format == 8) {
  		_Ximp_ProcReadMessage (d, w, ev);
  		_Ximp_MakeKeypress (d, w, ev);
! 		ev->send_event = False ;
! 		XPutBackEvent(d, ev);
!         }
  	return (True);
! }
  
  static Bool
  _Ximp_ServerDestroy (d, w, ev, client_data)
  	Display			*d;
  	Window			w;
! 	XEvent			*ev;
  	XPointer		*client_data;
  {
  	extern Ximp_XIM		*Ximp_Xim_List;
***************
*** 857,868 ****
  			ximp_impart->im_server_vl,
  			ximp_impart->im_vendor_name,
  			ximp_impart->im_ext_list);
! 		Xfree(ximp_impart);
! 		Ximp_Xim_List[i]->ximp_impart = NULL;
  		for(ic = Ximp_Xim_List[i]->core.ic_chain; ic; ic = ic->core.next) {
  			((Ximp_XIC)ic)->ximp_icpart->icid = NULL;
! 			if(((Ximp_XIC)ic)->ximp_icpart->is_bep_mode == XIMP_FRONTEND &&
! 			   ((Ximp_XIC)ic)->ximp_icpart->input_mode) {/* ON : input_mode */
  				dummy_mask = ((Ximp_XIC)ic)->ximp_icpart->back_mask;
  				XSelectInput(ic->core.im->core.display,
  				     ic->core.focus_window, dummy_mask);
--- 923,932 ----
  			ximp_impart->im_server_vl,
  			ximp_impart->im_vendor_name,
  			ximp_impart->im_ext_list);
! 		ximp_impart->connectserver = 0;
  		for(ic = Ximp_Xim_List[i]->core.ic_chain; ic; ic = ic->core.next) {
  			((Ximp_XIC)ic)->ximp_icpart->icid = NULL;
! 			if(((Ximp_XIC)ic)->ximp_icpart->input_mode) {/* ON : input_mode */
  				dummy_mask = ((Ximp_XIC)ic)->ximp_icpart->back_mask;
  				XSelectInput(ic->core.im->core.display,
  				     ic->core.focus_window, dummy_mask);
***************
*** 872,877 ****
--- 936,956 ----
  	}
  	XFlush (d);
  	return (False);
+ }
+ 
+ Bool
+ _Ximp_Keypress (d, w, ev, ic)
+ 	Display			*d;
+ 	Window			w;
+ 	XKeyEvent		*ev;
+ 	Ximp_XIC		ic;
+ {
+ #define BUFFLIM		32
+ 	KeySym		ks;
+ 	char		buff[BUFFLIM];
+ 
+ 	XLookupString (ev, buff, BUFFLIM, &ks, NULL);
+ 	return _Ximp_StartXIMP (ic, ev, ks);
  }
  
  /*

*** /tmp/,RCSt1001713	Mon Oct 28 15:39:30 1991
--- mit/lib/X/Ximp/XimpMCT.c	Mon Oct  7 17:50:14 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpMCT.c,v 1.3 91/07/30 14:27:49 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpMCT.c,v 1.4 91/10/07 17:50:08 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
***************
*** 82,87 ****
--- 82,90 ----
  {
      Ximp_XLCd lcd = (Ximp_XLCd) _XlcCurrentLC();
  
+     if (lcd == NULL)
+ 	return -1;
+ 
      return _Ximp_strtostr(lcd, lcd->ximp_lcpart->methods->mbstocs, mbstr,
  			  mbstr_len, _Ximp_cstostring, string, string_len,
  			  unconv_num);
***************
*** 112,117 ****
--- 115,123 ----
  {
      Ximp_XLCd lcd = (Ximp_XLCd) _XlcCurrentLC();
  
+     if (lcd == NULL)
+ 	return -1;
+ 
      return _Ximp_strtostr(lcd, lcd->ximp_lcpart->methods->mbstocs, mbstr,
  			  mbstr_len, _Ximp_cstoct, ctext, ctext_len,
  			  unconv_num);
***************
*** 140,147 ****
      int *mbstr_len;
      int *unconv_num;
  {
!     return _Ximp_cttombs(_XlcCurrentLC(), ctext, ctext_len,
! 			 mbstr, mbstr_len, unconv_num);
  }
  
  int
--- 146,157 ----
      int *mbstr_len;
      int *unconv_num;
  {
!     Ximp_XLCd lcd = (Ximp_XLCd) _XlcCurrentLC();
! 
!     if (lcd == NULL)
! 	return -1;
! 
!     return _Ximp_cttombs(lcd, ctext, ctext_len, mbstr, mbstr_len, unconv_num);
  }
  
  int

*** /tmp/,RCSt1001764	Mon Oct 28 15:40:21 1991
--- mit/lib/X/Ximp/XimpMPrTxt.c	Mon Oct  7 17:50:19 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpMPrTxt.c,v 1.1 91/07/09 17:37:15 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpMPrTxt.c,v 1.2 91/10/07 17:50:17 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
***************
*** 80,98 ****
      int *count_ret;
  {
      unsigned char **list;
!     unsigned char buf[BUFSIZE], *buf_ptr, *str_ptr;
!     int i, count, unconv_num, tmp_len;
  #define CNV_STR_FUNC	_Ximp_strcpy
  #define CNV_CTEXT_FUNC	_Ximp_cttombs
  #define CNV_TEXT_FUNC	_Ximp_strcpy
  
  #include "XimpPrTxt.c"
  
!     if ((list = (unsigned char **) Xmalloc(count * sizeof(char *))) == NULL)
! 	return XNoMemory;
      str_ptr = (unsigned char *) Xmalloc(buf_ptr - buf);
      if (str_ptr == NULL) {
! 	Xfree(list);
  	return XNoMemory;
      }
      
--- 80,108 ----
      int *count_ret;
  {
      unsigned char **list;
!     unsigned char *buf, *buf_ptr, *str_ptr;
!     int i, count, unconv_num, tmp_len, buf_len;
  #define CNV_STR_FUNC	_Ximp_strcpy
  #define CNV_CTEXT_FUNC	_Ximp_cttombs
  #define CNV_TEXT_FUNC	_Ximp_strcpy
  
+     /* XXX */
+     buf_len = text_prop->nitems + 1;
+     buf_len = (buf_len / BUFSIZE + 1) * BUFSIZE;
+     if ((buf = (unsigned char *) Xmalloc(buf_len)) == NULL)
+ 	return XNoMemory;
+     /* XXX */
+ 
  #include "XimpPrTxt.c"
  
!     if ((list = (unsigned char **) Xmalloc(count * sizeof(char *))) == NULL) 
! 	goto no_mem;
      str_ptr = (unsigned char *) Xmalloc(buf_ptr - buf);
      if (str_ptr == NULL) {
! no_mem:
! 	Xfree(buf);
! 	if (list)
! 	    Xfree(list);
  	return XNoMemory;
      }
      
***************
*** 104,109 ****
--- 114,120 ----
  	str_ptr += tmp_len;
  	buf_ptr += tmp_len;
      }
+     Xfree(buf);
  
      *list_ret = (char **) list;
      *count_ret = count;

*** /tmp/,RCSt1001774	Mon Oct 28 15:40:27 1991
--- mit/lib/X/Ximp/XimpMTxtPr.c	Mon Oct  7 17:50:22 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpMTxtPr.c,v 1.1 91/07/09 17:37:18 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpMTxtPr.c,v 1.2 91/10/07 17:50:20 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
***************
*** 82,91 ****
--- 82,102 ----
      XTextProperty *text_prop;
  {
      char **list_ptr = list;
+     int i, buf_len = 0;
+ 
  #define CNV_STR_FUNC	_Ximp_mbstostring
  #define CNV_CTEXT_FUNC	_Ximp_mbstoct
  #define CNV_TEXT_FUNC	_Ximp_strcpy
  #define STRLEN_FUNC	strlen
+ 
+     /* XXX */
+     for (i = 0; i < count; i++)
+ 	if (list[i])
+ 	    buf_len += strlen(list[i]) + 1;
+ 
+     buf_len *= 3;
+     buf_len = (buf_len / BUFSIZE + 1) * BUFSIZE;
+     /* XXX */
  
  #include "XimpTxtPr.c"
  }

*** /tmp/,RCSt1001784	Mon Oct 28 15:40:33 1991
--- mit/lib/X/Ximp/XimpPrTxt.c	Mon Oct  7 17:50:26 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpPrTxt.c,v 1.1 91/07/09 17:37:20 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpPrTxt.c,v 1.2 91/10/07 17:50:23 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
***************
*** 73,90 ****
      Ximp_XLCd lcd;
      Atom encoding;
      unsigned char *last_ptr;
!     int nitems, buf_len, tmp_num;
      int (*cnv_func)();
  
      if ((nitems = text_prop->nitems) <= 0) {
  	*list_ret = NULL;
  	*count_ret = 0;
  	return Success;
      }
!     if (text_prop->format != 8)
  	return XConverterNotFound;
!     if ((lcd = (Ximp_XLCd) _XlcCurrentLC()) == NULL)
  	return XLocaleNotSupported;
  
      encoding = text_prop->encoding;
  
--- 73,95 ----
      Ximp_XLCd lcd;
      Atom encoding;
      unsigned char *last_ptr;
!     int nitems, tmp_num;
      int (*cnv_func)();
  
      if ((nitems = text_prop->nitems) <= 0) {
  	*list_ret = NULL;
  	*count_ret = 0;
+ 	Xfree(buf);
  	return Success;
      }
!     if (text_prop->format != 8) {
! 	Xfree(buf);
  	return XConverterNotFound;
!     }
!     if ((lcd = (Ximp_XLCd) _XlcCurrentLC()) == NULL) {
! 	Xfree(buf);
  	return XLocaleNotSupported;
+     }
  
      encoding = text_prop->encoding;
  
***************
*** 94,112 ****
  	cnv_func = CNV_CTEXT_FUNC;
      else if (encoding == XInternAtom(dpy, "TEXT", False))
  	cnv_func = CNV_TEXT_FUNC;
!     else
  	return XConverterNotFound;
  
      last_ptr = str_ptr = text_prop->value;
      buf_ptr = buf;
-     buf_len = BUFSIZE - 1;
      unconv_num = count = 0;
      while (1) {
  	if (nitems == 0 || *str_ptr == 0) {
  	    tmp_len = buf_len;
  	    if ((*cnv_func)(lcd, last_ptr, str_ptr - last_ptr, 
! 			    buf_ptr, &tmp_len, &tmp_num) == -1)
  		return XConverterNotFound;
  
  	    buf_ptr += tmp_len++;
  	    *buf_ptr++ = 0;
--- 99,120 ----
  	cnv_func = CNV_CTEXT_FUNC;
      else if (encoding == XInternAtom(dpy, "TEXT", False))
  	cnv_func = CNV_TEXT_FUNC;
!     else {
! 	Xfree(buf);
  	return XConverterNotFound;
+     }
  
      last_ptr = str_ptr = text_prop->value;
      buf_ptr = buf;
      unconv_num = count = 0;
      while (1) {
  	if (nitems == 0 || *str_ptr == 0) {
  	    tmp_len = buf_len;
  	    if ((*cnv_func)(lcd, last_ptr, str_ptr - last_ptr, 
! 			    buf_ptr, &tmp_len, &tmp_num) == -1) {
! 		Xfree(buf);
  		return XConverterNotFound;
+ 	    }
  
  	    buf_ptr += tmp_len++;
  	    *buf_ptr++ = 0;

*** /tmp/,RCSt1001794	Mon Oct 28 15:40:38 1991
--- mit/lib/X/Ximp/XimpRm.c	Mon Oct  7 17:50:31 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpRm.c,v 1.1 91/07/09 17:37:23 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: XimpRm.c,v 1.2 91/10/07 17:50:27 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by FUJITSU LIMITED
***************
*** 27,32 ****
--- 27,34 ----
  
  ******************************************************************/
  
+ #define NEED_EVENTS
+ #include <X11/keysym.h>
  #include "Xlibint.h"
  #include "Xlcint.h"
  #include "Ximplc.h"
***************
*** 34,40 ****
  
  extern void		_Ximp_OpenIMResourceExtension();
  
! static void
  _Ximp_Get_resource_name(im, res_name, res_class)
  	Ximp_XIM	 im;
  	char		*res_name;
--- 36,42 ----
  
  extern void		_Ximp_OpenIMResourceExtension();
  
! void
  _Ximp_Get_resource_name(im, res_name, res_class)
  	Ximp_XIM	 im;
  	char		*res_name;
***************
*** 42,55 ****
  	{
  	if(im->core.res_name == NULL)
  		strcpy(res_name, "*");
! 	else
  		strcpy(res_name, im->core.res_name);
  	if(im->core.res_class == NULL)
  		strcpy(res_class, "*");
! 	else
  		strcpy(res_class, im->core.res_class);
! 	strcat(res_name, ".ximp.");
! 	strcat(res_class, ".Ximp.");
  	}
  
  Bool
--- 44,61 ----
  	{
  	if(im->core.res_name == NULL)
  		strcpy(res_name, "*");
! 	else	{
  		strcpy(res_name, im->core.res_name);
+ 		strcat(res_name, ".");
+ 		}
  	if(im->core.res_class == NULL)
  		strcpy(res_class, "*");
! 	else	{
  		strcpy(res_class, im->core.res_class);
! 		strcat(res_name, ".");
! 		}
! 	strcat(res_name, "ximp.");
! 	strcat(res_class, "Ximp.");
  	}
  
  Bool
***************
*** 60,69 ****
  	char		 res_class[256];
  	char		*str_type[50];
  	XrmValue	 value;
! 	int		 ret;
  
  	if(im->core.rdb == NULL)
! 		return(False);
  
  	/* Inputserver */
  	_Ximp_Get_resource_name(im, res_name, res_class);
--- 66,76 ----
  	char		 res_class[256];
  	char		*str_type[50];
  	XrmValue	 value;
! 	Bool		 ret = False;
! 	KeySym		 keysym = NoSymbol;
  
  	if(im->core.rdb == NULL)
! 		return(ret);
  
  	/* Inputserver */
  	_Ximp_Get_resource_name(im, res_name, res_class);
***************
*** 71,83 ****
  	strcat(res_class, "Inputserver");
  	if(XrmGetResource(im->core.rdb, res_name, res_class,
  				str_type, &value) == True) { 
! 		if(strcmp(value.addr, "on") == 0) {
! 			return(True);
  			}
  		}
  	/* Extension : XOpenIM(, rdb, res_name, res_class) */
  	_Ximp_OpenIMResourceExtension(im);
! 	return(False);
  	}
  
  void
--- 78,113 ----
  	strcat(res_class, "Inputserver");
  	if(XrmGetResource(im->core.rdb, res_name, res_class,
  				str_type, &value) == True) { 
! 		if(strcmp(value.addr, "off") == 0) {
! 			/* Keysym */
! 			_Ximp_Get_resource_name(im, res_name, res_class);
! 			strcat(res_name, "startkeysym");
! 			strcat(res_class, "Startkeysym");
! 			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				str_type, &value) == True) { 
! 				keysym = XStringToKeysym(value.addr);
! 				}
! 			if(keysym == NoSymbol)
! 				ret = False;
! 			else {
! 				im->ximp_impart->def_startkeysym = keysym;
! 				ret = True;
! 				}
  			}
  		}
+ 	/* Call Back */
+ 	_Ximp_Get_resource_name(im, res_name, res_class);
+ 	strcat(res_name, "callbackEncoding");
+ 	strcat(res_class, "CallbackEncoding");
+ 	if(XrmGetResource(im->core.rdb, res_name, res_class,
+ 				str_type, &value) == True) { 
+ 		if(strcmp(value.addr, "wchar") == 0) {
+ 			im->ximp_impart->use_wchar = True;
+ 			}
+ 		}
  	/* Extension : XOpenIM(, rdb, res_name, res_class) */
  	_Ximp_OpenIMResourceExtension(im);
! 	return(ret);
  	}
  
  void
***************
*** 98,209 ****
  	if(im->core.rdb == NULL)
  		return;
  
! 	if(!(ic->ximp_icpart->proto_mask & XIMP_PRE_BG_MASK)) {
! 		_Ximp_Get_resource_name(im, res_name, res_class);
! 		strcat(res_name, "preedit.background");
! 		strcat(res_class, "Preedit.Background");
! 		if(XrmGetResource(im->core.rdb, res_name, res_class,
  					str_type, &value) == True) { 
! 			default_colormap = DefaultColormap(im->core.display,
! 					   DefaultScreen(im->core.display) );
! 			if( XAllocNamedColor(im->core.display, default_colormap,
  					     value.addr,
  					     &screen_def, &exact_def) ) {
! 				ic->core.preedit_attr.background = screen_def.pixel;
! 				ic->ximp_icpart->preedit_attr.Background = 
! 					ic->core.preedit_attr.background;
! 				ic->ximp_icpart->proto_mask |= XIMP_PRE_BG_MASK;
! 				*mask                       |= XIMP_PRE_BG_MASK;
  				}
  			}
! 
! 		}
! 	if(!(ic->ximp_icpart->proto_mask & XIMP_PRE_FG_MASK)) {
! 		_Ximp_Get_resource_name(im, res_name, res_class);
! 		strcat(res_name, "preedit.foreground");
! 		strcat(res_class, "Preedit.Foreground");
! 		if(XrmGetResource(im->core.rdb, res_name, res_class,
  					str_type, &value) == True) { 
! 			default_colormap = DefaultColormap(im->core.display,
! 					   DefaultScreen(im->core.display) );
! 			if( XAllocNamedColor(im->core.display, default_colormap,
  					     value.addr,
  					     &screen_def, &exact_def) ) {
! 				ic->core.preedit_attr.foreground = screen_def.pixel;
! 				ic->ximp_icpart->preedit_attr.Foreground = 
! 					ic->core.preedit_attr.foreground;
! 				ic->ximp_icpart->proto_mask |= XIMP_PRE_FG_MASK;
! 				*mask                       |= XIMP_PRE_FG_MASK;
  				}
  			}
  		}
! 	if(!(ic->ximp_icpart->proto_mask & XIMP_STS_BG_MASK)) {
! 		_Ximp_Get_resource_name(im, res_name, res_class);
! 		strcat(res_name, "status.background");
! 		strcat(res_class, "Status.Background");
! 		if(XrmGetResource(im->core.rdb, res_name, res_class,
  					str_type, &value) == True) { 
! 			default_colormap = DefaultColormap(im->core.display,
! 					   DefaultScreen(im->core.display) );
! 			if( XAllocNamedColor(im->core.display, default_colormap,
  					     value.addr,
  					     &screen_def, &exact_def) ) {
! 				ic->core.status_attr.background = screen_def.pixel;
! 				ic->ximp_icpart->status_attr.Background = 
! 					ic->core.status_attr.background;
! 				ic->ximp_icpart->proto_mask |= XIMP_STS_BG_MASK;
! 				*mask                       |= XIMP_STS_BG_MASK;
  				}
- 			}
  
! 		}
! 	if(!(ic->ximp_icpart->proto_mask & XIMP_STS_FG_MASK)) {
! 		_Ximp_Get_resource_name(im, res_name, res_class);
! 		strcat(res_name, "status.foreground");
! 		strcat(res_class, "Status.Foreground");
! 		if(XrmGetResource(im->core.rdb, res_name, res_class,
  					str_type, &value) == True) { 
! 			default_colormap = DefaultColormap(im->core.display,
! 					   DefaultScreen(im->core.display) );
! 			if( XAllocNamedColor(im->core.display, default_colormap,
  					     value.addr,
  					     &screen_def, &exact_def) ) {
! 				ic->core.status_attr.foreground = screen_def.pixel;
! 				ic->ximp_icpart->status_attr.Foreground = 
! 					ic->core.status_attr.foreground;
! 				ic->ximp_icpart->proto_mask |= XIMP_STS_FG_MASK;
! 				*mask                       |= XIMP_STS_FG_MASK;
  				}
  			}
! 		}
! 	if(!(ic->ximp_icpart->proto_mask & XIMP_PRE_LINESP_MASK)) {
! 		_Ximp_Get_resource_name(im, res_name, res_class);
! 		strcat(res_name, "preedit.linespacing");
! 		strcat(res_class, "Preedit.Linespacing");
! 		if(XrmGetResource(im->core.rdb, res_name, res_class,
  					str_type, &value) == True) { 
! 			num = atoi(value.addr);
! 			ic->core.preedit_attr.line_space = num;
! 			ic->ximp_icpart->preedit_attr.LineSpacing = 
! 					ic->core.preedit_attr.line_space;
! 			ic->ximp_icpart->proto_mask |= XIMP_PRE_LINESP_MASK;
! 			*mask                       |= XIMP_PRE_LINESP_MASK;
! 			}
! 		}
! 	if(!(ic->ximp_icpart->proto_mask & XIMP_STS_LINESP_MASK)) {
! 		_Ximp_Get_resource_name(im, res_name, res_class);
! 		strcat(res_name, "status.linespacing");
! 		strcat(res_class, "Status.Linespacing");
! 		if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					str_type, &value) == True) { 
! 			num = atoi(value.addr);
! 			ic->core.status_attr.line_space = num;
! 			ic->ximp_icpart->status_attr.LineSpacing = 
  					ic->core.status_attr.line_space;
! 			ic->ximp_icpart->proto_mask |= XIMP_STS_LINESP_MASK;
! 			*mask                       |= XIMP_STS_LINESP_MASK;
  			}
  		}
! 	ic->ximp_icpart->value_mask &= ~(XIMP_RES_NAME | XIMP_RES_CLASS);
  	return;
  	}
--- 128,250 ----
  	if(im->core.rdb == NULL)
  		return;
  
! 	if(!(   (ic->core.input_style & XIMPreeditCallbacks)
! 	     || (ic->core.input_style & XIMPreeditNone) ) ) {
! 		if(!(ic->ximp_icpart->proto_mask & XIMP_PRE_BG_MASK)) {
! 			_Ximp_Get_resource_name(im, res_name, res_class);
! 			strcat(res_name, "preedit.background");
! 			strcat(res_class, "Preedit.Background");
! 			if(XrmGetResource(im->core.rdb, res_name, res_class,
  					str_type, &value) == True) { 
! 				default_colormap = DefaultColormap(
! 						im->core.display,
! 						DefaultScreen(im->core.display) );
! 				if( XAllocNamedColor(im->core.display, default_colormap,
  					     value.addr,
  					     &screen_def, &exact_def) ) {
! 					ic->core.preedit_attr.background = screen_def.pixel;
! 					ic->ximp_icpart->preedit_attr.Background = 
! 						ic->core.preedit_attr.background;
! 					ic->ximp_icpart->proto_mask |= XIMP_PRE_BG_MASK;
! 					*mask                       |= XIMP_PRE_BG_MASK;
! 					}
  				}
  			}
! 		if(!(ic->ximp_icpart->proto_mask & XIMP_PRE_FG_MASK)) {
! 			_Ximp_Get_resource_name(im, res_name, res_class);
! 			strcat(res_name, "preedit.foreground");
! 			strcat(res_class, "Preedit.Foreground");
! 			if(XrmGetResource(im->core.rdb, res_name, res_class,
  					str_type, &value) == True) { 
! 				default_colormap = DefaultColormap(
! 						im->core.display,
! 						DefaultScreen(im->core.display) );
! 				if( XAllocNamedColor(im->core.display, default_colormap,
  					     value.addr,
  					     &screen_def, &exact_def) ) {
! 					ic->core.preedit_attr.foreground = screen_def.pixel;
! 					ic->ximp_icpart->preedit_attr.Foreground = 
! 						ic->core.preedit_attr.foreground;
! 					ic->ximp_icpart->proto_mask |= XIMP_PRE_FG_MASK;
! 					*mask                       |= XIMP_PRE_FG_MASK;
! 					}
  				}
  			}
+ 		if(!(ic->ximp_icpart->proto_mask & XIMP_PRE_LINESP_MASK)) {
+ 			_Ximp_Get_resource_name(im, res_name, res_class);
+ 			strcat(res_name, "preedit.linespacing");
+ 			strcat(res_class, "Preedit.Linespacing");
+ 			if(XrmGetResource(im->core.rdb, res_name, res_class,
+ 					str_type, &value) == True) { 
+ 				num = atoi(value.addr);
+ 				ic->core.preedit_attr.line_space = num;
+ 				ic->ximp_icpart->preedit_attr.LineSpacing = 
+ 					ic->core.preedit_attr.line_space;
+ 				ic->ximp_icpart->proto_mask |= XIMP_PRE_LINESP_MASK;
+ 				*mask                       |= XIMP_PRE_LINESP_MASK;
+ 				}
+ 			}
  		}
! 	if(!(   (ic->core.input_style & XIMStatusCallbacks)
! 	     || (ic->core.input_style & XIMStatusNone) ) ) {
! 		if(!(ic->ximp_icpart->proto_mask & XIMP_STS_BG_MASK)) {
! 			_Ximp_Get_resource_name(im, res_name, res_class);
! 			strcat(res_name, "status.background");
! 			strcat(res_class, "Status.Background");
! 			if(XrmGetResource(im->core.rdb, res_name, res_class,
  					str_type, &value) == True) { 
! 				default_colormap = DefaultColormap(
! 						im->core.display,
! 						DefaultScreen(im->core.display) );
! 				if( XAllocNamedColor(im->core.display, default_colormap,
  					     value.addr,
  					     &screen_def, &exact_def) ) {
! 					ic->core.status_attr.background = screen_def.pixel;
! 					ic->ximp_icpart->status_attr.Background = 
! 						ic->core.status_attr.background;
! 					ic->ximp_icpart->proto_mask |= XIMP_STS_BG_MASK;
! 					*mask                       |= XIMP_STS_BG_MASK;
! 					}
  				}
  
! 			}
! 		if(!(ic->ximp_icpart->proto_mask & XIMP_STS_FG_MASK)) {
! 			_Ximp_Get_resource_name(im, res_name, res_class);
! 			strcat(res_name, "status.foreground");
! 			strcat(res_class, "Status.Foreground");
! 			if(XrmGetResource(im->core.rdb, res_name, res_class,
  					str_type, &value) == True) { 
! 				default_colormap = DefaultColormap(
! 						im->core.display,
! 						DefaultScreen(im->core.display) );
! 				if( XAllocNamedColor(im->core.display, default_colormap,
  					     value.addr,
  					     &screen_def, &exact_def) ) {
! 					ic->core.status_attr.foreground = screen_def.pixel;
! 					ic->ximp_icpart->status_attr.Foreground = 
! 						ic->core.status_attr.foreground;
! 					ic->ximp_icpart->proto_mask |= XIMP_STS_FG_MASK;
! 					*mask                       |= XIMP_STS_FG_MASK;
! 					}
  				}
  			}
! 		if(!(ic->ximp_icpart->proto_mask & XIMP_STS_LINESP_MASK)) {
! 			_Ximp_Get_resource_name(im, res_name, res_class);
! 			strcat(res_name, "status.linespacing");
! 			strcat(res_class, "Status.Linespacing");
! 			if(XrmGetResource(im->core.rdb, res_name, res_class,
  					str_type, &value) == True) { 
! 				num = atoi(value.addr);
! 				ic->core.status_attr.line_space = num;
! 				ic->ximp_icpart->status_attr.LineSpacing = 
  					ic->core.status_attr.line_space;
! 				ic->ximp_icpart->proto_mask |= XIMP_STS_LINESP_MASK;
! 				*mask                       |= XIMP_STS_LINESP_MASK;
! 				}
  			}
  		}
! 	if(   (ic->ximp_icpart->value_mask & XIMP_RES_NAME)
!            || (ic->ximp_icpart->value_mask & XIMP_RES_CLASS) )
! 		ic->ximp_icpart->value_mask &= ~(XIMP_RES_NAME | XIMP_RES_CLASS);
  	return;
  	}

*** /tmp/,RCSt1001804	Mon Oct 28 15:40:45 1991
--- mit/lib/X/Ximp/XimpSJIS.c	Mon Oct  7 17:50:36 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpSJIS.c,v 1.2 91/07/30 14:27:52 rws Exp $ */
  /*
   * Copyright 1991 Sony Corporation
   *
--- 1,4 ----
! /* $XConsortium: XimpSJIS.c,v 1.3 91/10/07 17:50:33 rws Exp $ */
  /*
   * Copyright 1991 Sony Corporation
   *
***************
*** 69,74 ****
--- 69,77 ----
  sjis_initialize(lcd)
      Ximp_XLCd lcd;
  {
+     lcd->ximp_lcpart->mb_cur_max = 2;
+     lcd->ximp_lcpart->state_dependent = False;
+ 
      return True;
  }
  
***************
*** 177,182 ****
--- 180,188 ----
      register wchar_t wch;
      int buf_len;
      int codeset_number = 0;
+ #ifdef sony_news
+     unsigned char ch, ch2;
+ #endif
  
      if (csbuf_len)
  	buf_len = *csbuf_len;
***************
*** 185,190 ****
--- 191,236 ----
      if (char_length)
  	*char_length = 1;
  
+     wch = *wcptr;
+ #ifdef sony_news
+     ch = (unsigned char) (wch >> 8);
+     ch2 = (unsigned char) wch;
+     if (ch) {
+ 	codeset_number = 1;
+ 	if (char_length)
+ 	    *char_length = 2;
+     } else if (iskana(ch2))
+ 	codeset_number = 2;
+     
+     for ( ; wcstr_len > 0 && buf_len > 0; wcptr++, wcstr_len--) {
+ 	wch = *wcptr;
+ 	ch = (unsigned char) (wch >> 8);
+ 	ch2 = (unsigned char) wch;
+ 	if (ch) {
+ 	    if (codeset_number != 1 || buf_len < 2)
+ 		break;
+ 	    ch -= (ch >= 0xa0) ? 0xc1 : 0x81;
+ 	    if (ch2 >= 0x9f) {
+ 		*bufptr++ = (ch << 1) + 0x22;
+ 		*bufptr++ = ch2 - 0x7e;
+ 	    } else {
+ 		*bufptr++ = (ch << 1) + 0x21;
+ 		*bufptr++ = ch2 - ((ch2 <= 0x7e) ? 0x1f : 0x20 );
+ 	    }
+ 	    buf_len -= 2;
+ 	    continue;
+ 	}
+ 	if (iskana(ch2)) {
+ 	    if (codeset_number != 2)
+ 		break;
+ 	} else
+ 	    if (codeset_number != 0)
+ 		break;
+ 	
+ 	*bufptr++ = ch2;
+ 	buf_len--;
+     }
+ #else
      wc_mask = wch & WC_MASK;
      if (wc_mask == CS1_WC_MASK) {
  	codeset_number = 1;
***************
*** 203,209 ****
  	    *bufptr++ = (unsigned char) wch ;
  	    buf_len -= 2;
  	    continue;
! 	} if (wc_mask == CS2_WC_MASK) {
  	    if (codeset_number != 2)
  		break;
  	} else
--- 249,256 ----
  	    *bufptr++ = (unsigned char) wch ;
  	    buf_len -= 2;
  	    continue;
! 	}
! 	if (wc_mask == CS2_WC_MASK) {
  	    if (codeset_number != 2)
  		break;
  	} else
***************
*** 213,218 ****
--- 260,266 ----
  	*bufptr++ = (unsigned char) wch;
  	buf_len--;
      }
+ #endif
  
      if (csbuf_len)
  	*csbuf_len = bufptr - csbuf;
***************
*** 289,294 ****
--- 337,345 ----
      wchar_t *bufptr = wcbuf;
      register wchar_t wch;
      register buf_len;
+ #ifdef sony_news
+     unsigned char high, low, ch1, ch2;
+ #endif
  
      if (wcbuf_len)
  	buf_len = *wcbuf_len;
***************
*** 295,304 ****
--- 346,387 ----
      else
  	buf_len = MAXINT;
  
+ #ifdef sony_news
      if (cs_number == 1) {
  	csstr_len >>= 1;
  	if (csstr_len < buf_len)
  	    buf_len = csstr_len;
+ 	
+ 	while (buf_len--) {
+ 	    high = *csptr++ & 0x7f;
+ 	    low = *csptr++ & 0x7f;
+ 	    ch1 = ((int)(high - 0x21) >> 1) + 0x81;
+ 	    if (ch1 > 0x9f)
+ 		ch1 += 0x40;
+ 	    if (high & 1) {
+ 		ch2 = low + 0x1f;
+ 		if (low > 0x5f)
+ 		    ch2++;
+ 	    } else
+ 		ch2 = low + 0x7e;
+ 	    *bufptr++ = (ch1 << 8) | ch2;
+ 	}
+     } else if (cs_number == 2) {
+ 	if (csstr_len < buf_len)
+ 	    buf_len = csstr_len;
+ 	while (buf_len--)
+ 	    *bufptr++ = (wchar_t) (*csptr++ | 0x80);
+     } else {
+ 	if (csstr_len < buf_len)
+ 	    buf_len = csstr_len;
+ 	while (buf_len--)
+ 	    *bufptr++ = (wchar_t) (*csptr++ & 0x7f);
+     }
+ #else
+     if (cs_number == 1) {
+ 	csstr_len >>= 1;
+ 	if (csstr_len < buf_len)
+ 	    buf_len = csstr_len;
  
  	while (buf_len--) {
  	    wch = *csptr++;
***************
*** 316,321 ****
--- 399,405 ----
  	while (buf_len--)
  	    *bufptr++ = (wchar_t) (*csptr++ & 0x7f);
      }
+ #endif
  
      if (wcbuf_len)
  	*wcbuf_len = bufptr - wcbuf;

*** /tmp/,RCSt1001825	Mon Oct 28 15:41:07 1991
--- mit/lib/X/Ximp/XimpTxtExt.c	Thu Oct 10 20:41:45 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpTxtExt.c,v 1.1 91/07/09 17:37:30 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpTxtExt.c,v 1.3 91/10/10 20:41:43 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
***************
*** 80,97 ****
      int (*cnv_func)();
      int cset_num, char_length;
      int count, length, tmp_len;
!     int width = 0;
!     int direction, ascent, descent;
!     XCharStruct overall;
  
      cnv_func = lcd->ximp_lcpart->methods->CNV_FUNC;
  
      (*lcd->ximp_lcpart->methods->cnv_start)(lcd);
  
!     if (overall_ink)
!         (void) bzero(overall_ink, sizeof(XRectangle));
!     if (overall_logical)
!         (void) bzero(overall_logical, sizeof(XRectangle));
  
      while (text_length > 0) {
          length = BUFSIZE;
--- 80,95 ----
      int (*cnv_func)();
      int cset_num, char_length;
      int count, length, tmp_len;
!     int direction, logical_ascent, logical_descent, tmp_ascent, tmp_descent;
!     XCharStruct overall, tmp_overall;
!     Bool first = True;
  
      cnv_func = lcd->ximp_lcpart->methods->CNV_FUNC;
  
      (*lcd->ximp_lcpart->methods->cnv_start)(lcd);
  
!     bzero(&overall, sizeof(XCharStruct));
!     logical_ascent = logical_descent = 0;
  
      while (text_length > 0) {
          length = BUFSIZE;
***************
*** 119,142 ****
  		break;
  
  	    if (char_length < 2)
! 		XTextExtents(font, xchar_buf, tmp_len,
! 			     &direction, &ascent, &descent, &overall);
              else
! 		XTextExtents16(font, xchar2b_buf, tmp_len,
! 			       &direction, &ascent, &descent, &overall);
  
! 	    width += overall.width;
! 	    if (overall_ink) {
! 	        overall_ink->x = min((int)overall_ink->x,
! 				(int)(overall_ink->width + overall.lbearing));
! 	        overall_ink->y = min((int)overall_ink->y,
! 				(int)(-overall.ascent));
! 	        overall_ink->width += overall.width;
! 	        overall_ink->height = max((int)overall_ink->height,
! 				(int)(overall.ascent + overall.descent));
  	    }
- 	    if (overall_logical)
- 	        overall_logical->width += overall.width;
  
  	    strptr += count;
  	    length -= count;
--- 117,144 ----
  		break;
  
  	    if (char_length < 2)
! 		XTextExtents(font, xchar_buf, tmp_len, &direction,
! 			     &tmp_ascent, &tmp_descent, &tmp_overall);
              else
! 		XTextExtents16(font, xchar2b_buf, tmp_len, &direction,
! 			       &tmp_ascent, &tmp_descent, &tmp_overall);
  
! 	    if (first) {	/* initialize overall */
! 		overall = tmp_overall;
! 		logical_ascent = tmp_ascent;
! 		logical_descent = tmp_descent;
! 		first = False;
! 	    } else {
! 		overall.lbearing = min(overall.lbearing,
! 				       overall.width + tmp_overall.lbearing);
! 		overall.rbearing = max(overall.rbearing,
! 				       overall.width + tmp_overall.rbearing);
! 		overall.ascent = max(overall.ascent, tmp_overall.ascent);
! 		overall.descent = max(overall.descent, tmp_overall.descent);
! 		overall.width += tmp_overall.width;
! 		logical_ascent = max(logical_ascent, tmp_ascent);
! 		logical_descent = max(logical_descent, tmp_descent);
  	    }
  
  	    strptr += count;
  	    length -= count;
***************
*** 145,156 ****
  
      (*lcd->ximp_lcpart->methods->cnv_end)(lcd);
  
      if (overall_logical) {
!         overall_logical->y = 
! 		xfont_set->core.font_set_extents.max_logical_extent.y;
!         overall_logical->height = 
! 		xfont_set->core.font_set_extents.max_logical_extent.height;
      }
  
!     return width;
  }
--- 147,165 ----
  
      (*lcd->ximp_lcpart->methods->cnv_end)(lcd);
  
+     if (overall_ink) {
+ 	overall_ink->x = overall.lbearing;
+ 	overall_ink->y = -(overall.ascent);
+ 	overall_ink->width = overall.rbearing - overall.lbearing;
+ 	overall_ink->height = overall.ascent + overall.descent;
+     }
+ 
      if (overall_logical) {
! 	overall_logical->x = 0;
!         overall_logical->y = -(logical_ascent);
! 	overall_logical->width = overall.width;
!         overall_logical->height = logical_ascent + logical_descent;
      }
  
!     return overall.width;
  }

*** /tmp/,RCSt1001835	Mon Oct 28 15:41:13 1991
--- mit/lib/X/Ximp/XimpTxtPer.c	Thu Oct 10 20:41:48 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpTxtPer.c,v 1.1 91/07/09 17:37:32 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpTxtPer.c,v 1.3 91/10/10 20:41:46 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
***************
*** 77,101 ****
      XChar2b *xchar2b_ptr, xchar2b_buf[BUFSIZE];
      FontSetRec *fontset;
      XFontStruct *font;
!     XCharStruct *def;
!     XCharStruct *cs;
      int (*cnv_func)();
      int cset_num, char_length;
!     int count, length, tmp_len;
!     int x, y, height, ink_ascent, ink_descent;
  
      cnv_func = lcd->ximp_lcpart->methods->CNV_FUNC;
  
      (*lcd->ximp_lcpart->methods->cnv_start)(lcd);
  
!     if (overall_ink)
!         (void)bzero(overall_ink, sizeof(XRectangle));
!     if (overall_logical)
!         (void)bzero(overall_logical, sizeof(XRectangle));
!     *num_chars = 0;
!     x = ink_ascent = ink_descent = 0;
!     y = xfont_set->core.font_set_extents.max_logical_extent.y;
!     height = xfont_set->core.font_set_extents.max_logical_extent.height;
  
      while (text_length > 0) {
          length = BUFSIZE;
--- 77,95 ----
      XChar2b *xchar2b_ptr, xchar2b_buf[BUFSIZE];
      FontSetRec *fontset;
      XFontStruct *font;
!     XCharStruct *def, *cs, overall;
      int (*cnv_func)();
      int cset_num, char_length;
!     int count, length, tmp_len, require_num;
!     int logical_ascent, logical_descent;
!     Bool first = True;
  
      cnv_func = lcd->ximp_lcpart->methods->CNV_FUNC;
  
      (*lcd->ximp_lcpart->methods->cnv_start)(lcd);
  
!     bzero(&overall, sizeof(XCharStruct));
!     logical_ascent = logical_descent = require_num = *num_chars = 0;
  
      while (text_length > 0) {
          length = BUFSIZE;
***************
*** 122,127 ****
--- 116,141 ----
  	    if (count <= 0)
  		break;
  
+ 	    strptr += count;
+ 	    length -= count;
+ 
+ 	    if (require_num) {
+ 		require_num += count;
+ 		continue;
+ 	    }
+ 	    if (buf_size < tmp_len) {
+ 		require_num = *num_chars + count;
+ 		continue;
+ 	    }
+ 
+ 	    if (first) {
+ 		logical_ascent = font->ascent;
+ 		logical_descent = font->descent;
+ 	    } else {
+ 		logical_ascent = max(logical_ascent, font->ascent);
+ 		logical_descent = max(logical_descent, font->descent);
+ 	    }
+ 
  	    if (char_length < 2) {
  		CI_GET_DEFAULT_INFO_1D (font, def)
  		xchar_ptr = xchar_buf;
***************
*** 130,136 ****
  		xchar2b_ptr = xchar2b_buf;
  	    }
  
! 	    do {
  		if (char_length < 2) {
  		    CI_GET_CHAR_INFO_1D (font, *xchar_ptr, def, cs)
  		    xchar_ptr++;
--- 144,150 ----
  		xchar2b_ptr = xchar2b_buf;
  	    }
  
! 	    while (tmp_len-- > 0) {
  		if (char_length < 2) {
  		    CI_GET_CHAR_INFO_1D (font, *xchar_ptr, def, cs)
  		    xchar_ptr++;
***************
*** 142,193 ****
  		if (cs == NULL)
  		    continue;
  
! 	        if (--buf_size < 0) {
! 		    (*lcd->ximp_lcpart->methods->cnv_end)(lcd);
! 
! 		    return 0;
! 		}
! 
! 	        ink_buf->x = x + cs->lbearing;
  		ink_buf->y = -(cs->ascent);
  		ink_buf->width = cs->rbearing - cs->lbearing;
  		ink_buf->height = cs->ascent + cs->descent;
  		ink_buf++;
  
! 		logical_buf->x = x;
! 		logical_buf->y = y;
  		logical_buf->width = cs->width;
! 		logical_buf->height = height;
  		logical_buf++;
  
! 		if (overall_ink) {
!                     overall_ink->x = min((int)overall_ink->x,
! 			(int)(overall_ink->width + cs->lbearing));
!                     overall_ink->width += cs->width;
! 		    ink_ascent = max(ink_ascent, cs->ascent);
! 		    ink_descent = max(ink_descent, cs->descent);
  		}
- 		if (overall_logical)
- 		    overall_logical->width += cs->width;
- 		x += cs->width;
- 		(*num_chars)++;
- 	    } while (--tmp_len);
  
! 	    strptr += count;
! 	    length -= count;
  	}
      }
  
-     if (overall_ink) {
- 	overall_ink->y = -(ink_ascent);
- 	overall_ink->height = ink_ascent + ink_descent;
-     }
-     if (overall_logical) {
-         overall_logical->y = y;
-         overall_logical->height = height;
-     }
- 
      (*lcd->ximp_lcpart->methods->cnv_end)(lcd);
  
      return 1;
  }
--- 156,211 ----
  		if (cs == NULL)
  		    continue;
  
! 	        ink_buf->x = overall.width + cs->lbearing;
  		ink_buf->y = -(cs->ascent);
  		ink_buf->width = cs->rbearing - cs->lbearing;
  		ink_buf->height = cs->ascent + cs->descent;
  		ink_buf++;
  
! 		logical_buf->x = overall.width;
! 		logical_buf->y = -(font->ascent);
  		logical_buf->width = cs->width;
! 		logical_buf->height = font->ascent + font->descent;
  		logical_buf++;
  
! 		if (first) {
! 		    overall = *cs;
! 		    first = False;
! 		} else {
! 		    overall.ascent = max(overall.ascent, cs->ascent);
! 		    overall.descent = max(overall.descent, cs->descent);
! 		    overall.lbearing = min(overall.lbearing,
! 					   overall.width + cs->lbearing);
! 		    overall.rbearing = max(overall.rbearing,
! 					   overall.width + cs->rbearing);
! 		    overall.width += cs->width;
  		}
  
! 		(*num_chars)++;
! 	    }
  	}
      }
  
      (*lcd->ximp_lcpart->methods->cnv_end)(lcd);
+ 
+     if (require_num) {
+ 	*num_chars = require_num;
+ 	return 0;
+     } else {
+ 	if (overall_ink) {
+ 	    overall_ink->x = overall.lbearing;
+ 	    overall_ink->y = -(overall.ascent);
+ 	    overall_ink->width = overall.rbearing - overall.lbearing;
+ 	    overall_ink->height = overall.ascent + overall.descent;
+ 	}
+ 
+ 	if (overall_logical) {
+ 	    overall_logical->x = 0;
+ 	    overall_logical->y = -(logical_ascent);
+ 	    overall_logical->width = overall.width;
+ 	    overall_logical->height = logical_ascent + logical_descent;
+ 	}
+     }
  
      return 1;
  }

*** /tmp/,RCSt1001845	Mon Oct 28 15:41:19 1991
--- mit/lib/X/Ximp/XimpTxtPr.c	Mon Oct  7 17:50:47 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpTxtPr.c,v 1.1 91/07/09 17:37:34 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpTxtPr.c,v 1.2 91/10/07 17:50:45 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
***************
*** 71,80 ****
  
  {
      Ximp_XLCd lcd;
!     unsigned char *value, buf[BUFSIZE], *buf_ptr;
      Atom encoding;
      int nitems, unconv_num;
!     int i, buf_len, tmp_len, tmp_num;
      int (*cnv_func)();
  
      if ((lcd = (Ximp_XLCd) _XlcCurrentLC()) == NULL)
--- 71,80 ----
  
  {
      Ximp_XLCd lcd;
!     unsigned char *value, *buf, *buf_ptr;
      Atom encoding;
      int nitems, unconv_num;
!     int tmp_len, tmp_num;
      int (*cnv_func)();
  
      if ((lcd = (Ximp_XLCd) _XlcCurrentLC()) == NULL)
***************
*** 98,106 ****
  	    return XConverterNotFound;
      }
  
  retry:
      buf_ptr = buf;
-     buf_len = BUFSIZE - 1;
      unconv_num = 0;
      for (i = 0; i < count && buf_len > 0; i++, list_ptr++) {
  	tmp_len = buf_len;
--- 98,107 ----
  	    return XConverterNotFound;
      }
  
+     if ((buf = (unsigned char *) Xmalloc(buf_len)) == NULL)
+ 	return XNoMemory;
  retry:
      buf_ptr = buf;
      unconv_num = 0;
      for (i = 0; i < count && buf_len > 0; i++, list_ptr++) {
  	tmp_len = buf_len;
***************
*** 122,134 ****
  
      if ((nitems = buf_ptr - buf) <= 0)
  	nitems = 1;
!     if ((value = (unsigned char *) Xmalloc(nitems)) == NULL)
  	return XNoMemory;
      if (nitems == 1)
  	*value = 0;
      else
      	bcopy(buf, value, nitems);
      nitems--;
  
      text_prop->value = value;
      text_prop->encoding = encoding;
--- 123,138 ----
  
      if ((nitems = buf_ptr - buf) <= 0)
  	nitems = 1;
!     if ((value = (unsigned char *) Xmalloc(nitems)) == NULL) {
! 	Xfree(buf);
  	return XNoMemory;
+     }
      if (nitems == 1)
  	*value = 0;
      else
      	bcopy(buf, value, nitems);
      nitems--;
+     Xfree(buf);
  
      text_prop->value = value;
      text_prop->encoding = encoding;

*** /tmp/,RCSt1001855	Mon Oct 28 15:41:25 1991
--- mit/lib/X/Ximp/XimpWCT.c	Mon Oct  7 17:50:51 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpWCT.c,v 1.3 91/07/30 14:27:54 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpWCT.c,v 1.4 91/10/07 17:50:48 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
***************
*** 82,87 ****
--- 82,90 ----
  {
      Ximp_XLCd lcd = (Ximp_XLCd) _XlcCurrentLC();
  
+     if (lcd == NULL)
+ 	return -1;
+ 
      return _Ximp_wstrtostr(lcd, lcd->ximp_lcpart->methods->wcstocs, wcstr,
                             wcstr_len, _Ximp_cstostring, string, string_len,
                             unconv_num);
***************
*** 112,117 ****
--- 115,123 ----
  {
      Ximp_XLCd lcd = (Ximp_XLCd) _XlcCurrentLC();
  
+     if (lcd == NULL)
+ 	return -1;
+ 
      return _Ximp_wstrtostr(lcd, lcd->ximp_lcpart->methods->wcstocs, wcstr,
  			   wcstr_len, _Ximp_cstoct, ctext, ctext_len,
  			   unconv_num);
***************
*** 140,147 ****
      int *wcstr_len;
      int *unconv_num;
  {
!     return _Ximp_cttowcs(_XlcCurrentLC(), ctext, ctext_len,
! 			 wcstr, wcstr_len, unconv_num);
  }
  
  int
--- 146,157 ----
      int *wcstr_len;
      int *unconv_num;
  {
!     Ximp_XLCd lcd = (Ximp_XLCd) _XlcCurrentLC();
! 
!     if (lcd == NULL)
! 	return -1;
! 
!     return _Ximp_cttowcs(lcd, ctext, ctext_len, wcstr, wcstr_len, unconv_num);
  }
  
  int

*** /tmp/,RCSt1001905	Mon Oct 28 15:42:13 1991
--- mit/lib/X/Ximp/XimpWPrTxt.c	Mon Oct  7 17:50:56 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpWPrTxt.c,v 1.1 91/07/09 17:37:41 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpWPrTxt.c,v 1.2 91/10/07 17:50:54 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
***************
*** 71,76 ****
--- 71,77 ----
  #include <X11/Xatom.h>
  
  extern int _Ximp_mbstowcs(), _Ximp_cttowcs();
+ extern wchar_t *_Xwcscpy();
  
  int
  XwcTextPropertyToTextList(dpy, text_prop, list_ret, count_ret)
***************
*** 80,99 ****
      int *count_ret;
  {
      wchar_t **list, *wstr_ptr;
!     wchar_t buf[BUFSIZE], *buf_ptr;
      unsigned char *str_ptr;
!     int i, count, unconv_num, tmp_len;
  #define CNV_STR_FUNC	_Ximp_mbstowcs
  #define CNV_CTEXT_FUNC	_Ximp_cttowcs
  #define CNV_TEXT_FUNC	_Ximp_mbstowcs
  
  #include "XimpPrTxt.c"
  
      if ((list = (wchar_t **) Xmalloc(count * sizeof(wchar_t *))) == NULL)
! 	return XNoMemory;
      wstr_ptr = (wchar_t *) Xmalloc((buf_ptr - buf) * sizeof(wchar_t));
      if (wstr_ptr == NULL) {
! 	Xfree(list);
  	return XNoMemory;
      }
      
--- 81,110 ----
      int *count_ret;
  {
      wchar_t **list, *wstr_ptr;
!     wchar_t *buf, *buf_ptr;
      unsigned char *str_ptr;
!     int i, count, unconv_num, tmp_len, buf_len;
  #define CNV_STR_FUNC	_Ximp_mbstowcs
  #define CNV_CTEXT_FUNC	_Ximp_cttowcs
  #define CNV_TEXT_FUNC	_Ximp_mbstowcs
  
+     /* XXX */
+     buf_len = text_prop->nitems + 1;
+     buf_len = (buf_len / BUFSIZE + 1) * BUFSIZE;
+     if ((buf = (wchar_t *) Xmalloc(buf_len * sizeof(wchar_t))) == NULL)
+ 	return XNoMemory;
+     /* XXX */
+ 
  #include "XimpPrTxt.c"
  
      if ((list = (wchar_t **) Xmalloc(count * sizeof(wchar_t *))) == NULL)
! 	goto no_mem;
      wstr_ptr = (wchar_t *) Xmalloc((buf_ptr - buf) * sizeof(wchar_t));
      if (wstr_ptr == NULL) {
! no_mem:
! 	Xfree(buf);
! 	if (list)
! 	    Xfree(list);
  	return XNoMemory;
      }
      
***************
*** 100,109 ****
      buf_ptr = buf;
      for (i = 0; i < count; i++) {
  	list[i] = wstr_ptr;
! 	tmp_len = Ximp_wstrcpy(wstr_ptr, buf_ptr) + 1;
  	wstr_ptr += tmp_len;
  	buf_ptr += tmp_len;
      }
  
      *list_ret = list;
      *count_ret = count;
--- 111,122 ----
      buf_ptr = buf;
      for (i = 0; i < count; i++) {
  	list[i] = wstr_ptr;
! 	_Xwcscpy(wstr_ptr, buf_ptr);
! 	tmp_len = _Xwcslen(wstr_ptr) + 1;
  	wstr_ptr += tmp_len;
  	buf_ptr += tmp_len;
      }
+     Xfree(buf);
  
      *list_ret = list;
      *count_ret = count;

*** /tmp/,RCSt1001915	Mon Oct 28 15:42:19 1991
--- mit/lib/X/Ximp/XimpWTxtPr.c	Mon Oct  7 17:51:00 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpWTxtPr.c,v 1.1 91/07/09 17:37:43 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpWTxtPr.c,v 1.2 91/10/07 17:50:57 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
***************
*** 71,77 ****
  #include <X11/Xatom.h>
  
  extern int _Ximp_wcstostring(), _Ximp_wcstoct(), _Ximp_wcstombs();
! extern int Ximp_wstrlen();
  
  int
  XwcTextListToTextProperty(dpy, list, count, style, text_prop)
--- 71,77 ----
  #include <X11/Xatom.h>
  
  extern int _Ximp_wcstostring(), _Ximp_wcstoct(), _Ximp_wcstombs();
! extern int _Xwcslen();
  
  int
  XwcTextListToTextProperty(dpy, list, count, style, text_prop)
***************
*** 82,91 ****
      XTextProperty *text_prop;
  {
      wchar_t **list_ptr = list;
  #define CNV_STR_FUNC	_Ximp_wcstostring
  #define CNV_CTEXT_FUNC	_Ximp_wcstoct
  #define CNV_TEXT_FUNC	_Ximp_wcstombs
! #define STRLEN_FUNC	Ximp_wstrlen
  
  #include "XimpTxtPr.c"
  }
--- 82,102 ----
      XTextProperty *text_prop;
  {
      wchar_t **list_ptr = list;
+     int i, buf_len = 0;
+ 
  #define CNV_STR_FUNC	_Ximp_wcstostring
  #define CNV_CTEXT_FUNC	_Ximp_wcstoct
  #define CNV_TEXT_FUNC	_Ximp_wcstombs
! #define STRLEN_FUNC	_Xwcslen
! 
!     /* XXX */
!     for (i = 0; i < count; i++)
! 	if (list[i])
! 	    buf_len += _Xwcslen(list[i]);
!     
!     buf_len *= 5;
!     buf_len = (buf_len / BUFSIZE + 1) * BUFSIZE;
!     /* XXX */
  
  #include "XimpTxtPr.c"
  }

*** /tmp/,RCSt1001935	Mon Oct 28 15:42:40 1991
--- mit/lib/X/Ximp/Ximpint.c	Thu Oct 10 20:41:51 1991
***************
*** 1,4 ****
! /* $XConsortium: Ximpint.c,v 1.1 91/07/09 17:37:47 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by Fuji Xerox Co.,Ltd.
--- 1,4 ----
! /* $XConsortium: Ximpint.c,v 1.3 91/10/10 20:41:48 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by Fuji Xerox Co.,Ltd.
***************
*** 160,171 ****
  
  #define BUF_SIZE (20)
  static char local_buf[BUF_SIZE];
  
  int
  _Ximp_LookupMBText(ic, event, buffer, nbytes, keysym, status)
  Ximp_XIC ic;
  XKeyEvent *event;
! char *buffer;
  int nbytes;
  KeySym *keysym;
  XComposeStatus *status;
--- 160,172 ----
  
  #define BUF_SIZE (20)
  static char local_buf[BUF_SIZE];
+ static unsigned char look[BUF_SIZE];
  
  int
  _Ximp_LookupMBText(ic, event, buffer, nbytes, keysym, status)
  Ximp_XIC ic;
  XKeyEvent *event;
! unsigned char *buffer;
  int nbytes;
  KeySym *keysym;
  XComposeStatus *status;
***************
*** 196,204 ****
  	    local_buf[local_count] = c;
  	    local_count++;
  	    count = BUF_SIZE;
! 	    _Ximp_cttombs(ic->core.im->core.lcd,
! 			local_buf, local_count,
! 			buffer, &count, NULL);
  	}
      }
      return(count);
--- 197,207 ----
  	    local_buf[local_count] = c;
  	    local_count++;
  	    count = BUF_SIZE;
! 	    if (_Ximp_cttombs(ic->core.im->core.lcd,
! 			      local_buf, local_count,
! 			      buffer, &count, NULL) < 0) {
! 		count = 0;
! 	    }
  	}
      }
      return(count);
***************
*** 220,231 ****
      int i;
      unsigned char c;
  
!     count = XLookupString(event, buffer, nbytes, &symbol, status);
      if (keysym) *keysym = symbol;
      if ((nbytes == 0) || (symbol == NoSymbol)) {
  	return(count);
      }
!     if (count == 0) {
  	kset = (symbol >> 8) & 0xffffff;
  	for (i = 0; i < codeset_size; i++) {
  	    if (kset == codeset[i].kset) {
--- 223,234 ----
      int i;
      unsigned char c;
  
!     count = XLookupString(event, look, nbytes, &symbol, status);
      if (keysym) *keysym = symbol;
      if ((nbytes == 0) || (symbol == NoSymbol)) {
  	return(count);
      }
!     if (count == 0) { /* Not ISO 8859-1 Encoding */
  	kset = (symbol >> 8) & 0xffffff;
  	for (i = 0; i < codeset_size; i++) {
  	    if (kset == codeset[i].kset) {
***************
*** 242,247 ****
--- 245,258 ----
  	    _Ximp_cttowcs(ic->core.im->core.lcd,
  			local_buf, local_count,
  			buffer, &count, NULL);
+ 	}
+     } else if ((count == 1) && (look[0] < 0x80)) { /* ASCII Encoding */
+ 	buffer[0] = look[0];
+     } else {
+ 	if (_Ximp_cttowcs(ic->core.im->core.lcd,
+ 			  look, count,
+ 			  buffer, &count, NULL) < 0) {
+ 	    count = 0;
  	}
      }
      return(count);

*** /tmp/,RCSt1001945	Mon Oct 28 15:42:45 1991
--- mit/lib/X/Ximp/Ximplc.h	Mon Oct  7 17:51:11 1991
***************
*** 1,4 ****
! /* $XConsortium: Ximplc.h,v 1.3 91/07/30 14:28:00 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: Ximplc.h,v 1.4 91/10/07 17:51:06 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
***************
*** 72,77 ****
--- 72,84 ----
  #define GR		0x80
  #define MAX_CODESET	10
  #define MAX_FONTSET	50
+ #define XIMP_MB_CUR_MAX(lcd)   (((Ximp_XLCd)(lcd))->ximp_lcpart->mb_cur_max) 
+ #ifndef MB_CUR_MAX
+ #define MB_CUR_MAX      XIMP_MB_CUR_MAX(_XlcCurrentLC())
+ #endif
+ #ifndef MB_LEN_MAX
+ #define MB_LEN_MAX      8
+ #endif
  
  #ifndef MAXINT
  #define MAXINT (~(1 << (8 * sizeof(int)) - 1))
***************
*** 135,140 ****
--- 142,149 ----
      char	       *codeset_name;
      int			codeset_num;
      CodeSetRec	       *codeset;
+     int			mb_cur_max; 
+     Bool		state_dependent;
      int			fontset_data_num;
      FontSetDataRec     *fontset_data;
      XLCdXimpMethods    *methods;
***************
*** 227,235 ****
  typedef struct {
  	int		extension_back_front_exist;
  	Atom		extension_back_front_id;
! 	Bool            extension_conversion_exist;
! 	Atom            extension_conversion_id;
! 	Bool            extension_conversion;
  	/* Add Extension */
  	} Ximp_ExtXIMRec;
  
--- 236,253 ----
  typedef struct {
  	int		extension_back_front_exist;
  	Atom		extension_back_front_id;
! 	Bool		extension_conversion_exist;
! 	Atom		extension_conversion_id;
! 	Bool		extension_conversion;
! 	int		extension_statuswindow_exist;
! 	Atom		extension_statuswindow_id;
! 	int		extension_lookup_exist;
! 	Atom		extension_lookup_id;
! 	Atom		extension_lookup_start;
! 	Atom		extension_lookup_start_rep;
! 	Atom		extension_lookup_draw;
! 	Atom		extension_lookup_proc;
! 	Atom		extension_lookup_proc_rep;
  	/* Add Extension */
  	} Ximp_ExtXIMRec;
  
***************
*** 238,244 ****
--- 256,265 ----
   */
  typedef struct  {
  	XIM		 im_next;
+ 	int		 connectserver;
  	int		 inputserver;
+ 	Bool		 use_wchar;
+ 	KeySym		 def_startkeysym;
  	char		*locale_server;
  	Window		 fe_window;
  	Window		 owner;
***************
*** 276,281 ****
--- 297,329 ----
  	XIMXimpRec	*ximp_impart;
  	} Ximp_XIMRec;
  
+ typedef struct {
+ 	XIMCallback     start;
+ 	XIMCallback     done;
+ 	XIMCallback     draw;
+ 	XIMCallback     proc;
+ 	} ICExtLookupCallbacks;
+ 
+  /*
+   * data block describing the visual attributes associated with an input
+   * context
+   */
+ typedef struct {
+ 	XRectangle      area;
+ 	XRectangle      area_needed;
+ 	XPoint          spot_location;
+ 	Colormap        colormap;
+ 	Atom            std_colormap;
+ 	unsigned long   foreground;
+ 	unsigned long   background;
+ 	Pixmap          background_pixmap;
+ 	XFontSet        fontset;
+ 	int             line_space;
+ 	Cursor          cursor;
+ 	XPointer	draw_data;
+ 	ICExtLookupCallbacks callbacks;
+ 	} ICExtLookupAttributes, *ICExtLookupAttributesPtr;
+ 
  /*
   * IC deprndent data
   */
***************
*** 292,297 ****
--- 340,348 ----
  	Ximp_StatusPropRec	 status_attr;
  	char			*status_font;
  	XIMCallback		 error;
+  	/* Extended Callback attribute */
+ 	Bool			 use_lookup_choices;
+ 	ICExtLookupAttributes	 lookup_attr;
  
  	void			*ictype;
  	} XICXimpRec;

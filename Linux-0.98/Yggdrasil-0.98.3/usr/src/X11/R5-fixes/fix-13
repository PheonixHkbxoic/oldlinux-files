		      Release 5 Public Patch #13
			   MIT X Consortium

To apply this patch:

cd to the top of the source tree (to the directory containing the "mit"
and "contrib" subdirectories) and do:
	patch -p -s < ThisFile
Patch will work silently unless an error occurs.  You will likely get
the following warning messages, which can be ignored:
	mkdir: mit: File exists
	mkdir: mit/fonts: File exists
	mkdir: mit/fonts/server: File exists
	mkdir: mit/fonts/server/difs: File exists
If you want to watch patch do its thing, leave out the "-s" argument to patch.

This patch creates one new file, mit/fonts/server/difs/charinfo.c.
If you are using a symbolic link tree, you will need to create a new link.

Next, from the same top-level directory do:
	rm -f mit/fonts/lib/font/util/fsfuncs.[co]
	rm -f mit/fonts/lib/font/bitmap/fsfuncs.[co]
(If you are using a symbolic tree, the .o files should be deleted there.)

Finally, to rebuild after applying this patch, cd to the "mit" subdirectory
and do:
	make Everything >& every.log
Note: this will *not* "clean" your tree.


Brief notes on what this patch fixes:

This patch fixes some serious Font Service protocol errors in both the
font server and font client libraries.  Because these fixes change the
implemented protocol in an incompatible way, the version number is
changed to 2.0.  The old, broken implementation is still supported as
version 1; new clients can talk to old font servers, and vice versa.

These protocol fixes and other bug fixes are detailed below:

FS protocol: fontserver and fontlib have fsChar2B backwards
FS protocol: ListFontsWithXInfo reply incorrectly formatted
FS protocol: fs returns font metrics rather than ink metrics for some fonts
FS protocol: ListFontsWithXInfo reply length incorrect
FS protocol: ListFontsWithXInfo last reply length incorrect
FS protocol: fs can return -1 authorization index
FS protocol: auth_len is miscalculated in initial connection
config: bdftopcf and mkfontdir not made if BuildFonts is NO
fontlib: fs crashes if filename suggests scalable but XLFD name does not
fontlib: bdf file with empty XLFD field crashes fs
fontlib: bdf reader doesn't check for end of file
fontlib: pcf reader frees uninitialized pointer on error
fontlib: "byte" used as a variable name
fontlib: fs_send_load_bitmap uses QueryXBitamp8 with 16-bit encoded character
fontlib: attempt to access fonts through chained font servers fails
fontlib: Speedo reader frees uninitialized pointer on error
fontlib: Speedo generation fails at tiny sizes
fontlib: ListFontsWithXInfo reply incorrectly parsed
fontlib: libFS tries to read extension data twice
fontlib: X server can't detect when font server has died
fontlib: memory leaks
fontserver: fs dies if garbage characters fed to its socket
fontserver: fs doesn't manage signals correctly
fontserver: syntax errors in osdep.h
fontserver: fs dispatch routines poorly named
fontserver: parameters swapped on call to WriteSwappedDataToClient
fontserver: some error states return the same value as FSSuccess
fontserver: fs can dereference a bogus pointer when reseting
fontserver: ListFonts can attempt to free nonexistent memory
fontserver: fs can dump core when chaining fontservers
fontserver: when no font path elements, ListFonts sends no reply
fontserver: num_range not byte-swapped for QueryXExtents and QueryXBitmaps
fontserver: QueryExtension request doesn't get byte swapped
fontserver: memory leaks
FS protocol document: changed to read version 2.0
showfont: handles nonexistent characters incorrectly
showfont: incorrectly generates 2-byte ranges
showfont: bitmap format is not always passed to the font server correctly
misc fonts: some Scandinavian characters wrong or poorly-formed


Prereq: public-patch-12

*** /tmp/da09678	Mon Jul 20 14:05:24 1992
--- mit/bug-report	Mon Jul 20 14:05:24 1992
***************
*** 2,8 ****
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-12
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:
--- 2,8 ----
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-13
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:
*** /tmp/da28082	Tue Jul 14 18:07:11 1992
--- mit/fonts/include/FS.h	Tue Jul 14 18:07:10 1992
***************
*** 1,4 ****
! /* $XConsortium: FS.h,v 1.4 91/05/13 16:45:26 gildea Exp $ */
  /* 
   * Copyright 1990, 1991 Network Computing Devices; 
   * Portions Copyright 1987 by Digital Equipment Corporation and the 
--- 1,4 ----
! /* $XConsortium: FS.h,v 1.5 92/05/12 18:07:12 gildea Exp $ */
  /* 
   * Copyright 1990, 1991 Network Computing Devices; 
   * Portions Copyright 1987 by Digital Equipment Corporation and the 
***************
*** 20,28 ****
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  *
-  * @(#)FS.h	3.2	91/04/11
-  *
   */
  #ifndef _FS_H_
  #define	_FS_H_
--- 20,25 ----
***************
*** 29,35 ****
  
  #include <fsmasks.h>
  
! #define	FS_PROTOCOL		1
  #define	FS_PROTOCOL_MINOR	0
  
  typedef unsigned long FSID;
--- 26,32 ----
  
  #include <fsmasks.h>
  
! #define	FS_PROTOCOL		2
  #define	FS_PROTOCOL_MINOR	0
  
  typedef unsigned long FSID;
*** /tmp/da28104	Tue Jul 14 18:07:13 1992
--- mit/fonts/include/FSproto.h	Tue Jul 14 18:07:12 1992
***************
*** 1,4 ****
! /* $XConsortium: FSproto.h,v 1.5 91/07/26 21:00:24 keith Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
--- 1,4 ----
! /* $XConsortium: FSproto.h,v 1.6 92/05/12 18:07:14 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
***************
*** 20,28 ****
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  *
-  * $NCDId: @(#)FSproto.h,v 4.3 1991/06/27 16:30:07 lemke Exp $
-  *
   */
  
  #ifndef _FS_PROTO_H_
--- 20,25 ----
***************
*** 114,122 ****
  }           fsCharInfo;
  
  typedef struct {
      CARD8       low,
                  high;
! }           fsChar2b;
  
  typedef struct {
      fsChar2b    min_char,
--- 111,124 ----
  }           fsCharInfo;
  
  typedef struct {
+     CARD8       high;
+     CARD8       low;
+ }           fsChar2b;
+ 
+ typedef struct {
      CARD8       low,
                  high;
! }           fsChar2b_version1;
  
  typedef struct {
      fsChar2b    min_char,
*** /tmp/da28168	Tue Jul 14 18:07:18 1992
--- mit/fonts/include/fontstruct.h	Tue Jul 14 18:07:18 1992
***************
*** 1,4 ****
! /* $Header: fontstruct.h,v 1.10 91/07/22 15:37:41 keith Exp $ */
  /***********************************************************
  Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
  and the Massachusetts Institute of Technology, Cambridge, Massachusetts.
--- 1,4 ----
! /* $XConsortium: fontstruct.h,v 1.11 92/05/12 18:07:16 gildea Exp $ */
  /***********************************************************
  Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
  and the Massachusetts Institute of Technology, Cambridge, Massachusetts.
***************
*** 21,28 ****
  ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
  SOFTWARE.
  
- 	@(#)fontstruct.h	3.2	91/04/15
- 
  ******************************************************************/
  
  #ifndef FONTSTR_H
--- 21,26 ----
***************
*** 115,124 ****
      fsBitmapFormat format;
      int         (*get_glyphs) ( /* font, count, chars, encoding, count, glyphs */ );
      int         (*get_metrics) ( /* font, count, chars, encoding, count, glyphs */ );
-     int         (*get_bitmaps) (/* client, font, flags, ranges, nranges,
- 				    nextents, extents */ );
-     int         (*get_extents) (/* client, font, format, flags, ranges,
- 				    nranges, nglyphs, offsets, glyphs */ );
      void        (*unload_font) ( /* font */ );
      FontPathElementPtr fpe;
      pointer     svrPrivate;
--- 113,118 ----
*** /tmp/da25571	Tue Jul 14 18:03:15 1992
--- mit/fonts/lib/Imakefile	Tue Jul 14 18:03:15 1992
***************
*** 1,12 ****
! XCOMM $XConsortium: Imakefile,v 1.2 91/07/17 16:05:47 gildea Exp $
  #define IHaveSubdirs
  #define PassCDebugFlags 'CDEBUGFLAGS=$(CDEBUGFLAGS)'
  
! #if BuildServer | BuildFontServer | BuildFonts
! SRVDIRS = font
! #endif
! 
! SUBDIRS = $(SRVDIRS) fs
  
  MakeSubdirs($(SUBDIRS))
  DependSubdirs($(SUBDIRS))
--- 1,8 ----
! XCOMM $XConsortium: Imakefile,v 1.3 91/12/23 11:05:24 rws Exp $
  #define IHaveSubdirs
  #define PassCDebugFlags 'CDEBUGFLAGS=$(CDEBUGFLAGS)'
  
! SUBDIRS = font fs
  
  MakeSubdirs($(SUBDIRS))
  DependSubdirs($(SUBDIRS))
*** /tmp/da25708	Tue Jul 14 18:03:29 1992
--- mit/fonts/lib/font/fontfile/fontdir.c	Tue Jul 14 18:03:28 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: fontdir.c,v 1.6 91/12/11 19:46:47 eswu Exp $
   *
   * Copyright 1991 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: fontdir.c,v 1.9 92/03/20 15:53:29 eswu Exp $
   *
   * Copyright 1991 Massachusetts Institute of Technology
   *
***************
*** 138,144 ****
  
      /* can't add entries to a sorted table, pointers get broken! */
      if (table->sorted)
! 	abort ();
      if (table->used == table->size) {
  	newsize = table->size + 100;
  	entry = (FontEntryPtr) xrealloc(table->entries,
--- 138,144 ----
  
      /* can't add entries to a sorted table, pointers get broken! */
      if (table->sorted)
! 	return (FontEntryPtr) 0;    /* "cannot" happen */
      if (table->used == table->size) {
  	newsize = table->size + 100;
  	entry = (FontEntryPtr) xrealloc(table->entries,
***************
*** 425,430 ****
--- 425,435 ----
  					     &vals, FONT_XLFD_REPLACE_NONE)) ||
  	  vals.pixel != 0)
      {
+       /* If the fontname says it is nonScalable, make sure that the
+        * renderer supports OpenBitmap and GetInfoBitmap.
+        */
+       if (renderer->OpenBitmap && renderer->GetInfoBitmap)
+       {
  	entry.type = FONT_ENTRY_BITMAP;
  	entry.u.bitmap.renderer = renderer;
  	entry.u.bitmap.pFont = NullFont;
***************
*** 435,440 ****
--- 440,446 ----
  	    xfree (entry.u.bitmap.fileName);
  	    return FALSE;
  	}
+       }
      }
      /*
       * Parse out scalable fields from XLFD names - a scalable name
***************
*** 442,447 ****
--- 448,458 ----
       */
      if (isscale)
      {
+       /* If the fontname says it is scalable, make sure that the
+        * renderer supports OpenScalable and GetInfoScalable.
+        */
+       if (renderer->OpenScalable && renderer->GetInfoScalable)
+       {
  	if (vals.pixel != 0)
  	{
  	    zeroVals.pixel = 0;
***************
*** 524,529 ****
--- 535,541 ----
  	}
  	if (vals.pixel != 0)
  	    FontFileAddScaledInstance (scalable, &vals, NullFont, bitmap->name.name);
+       }
      }
      return TRUE;
  }
*** /tmp/da25926	Tue Jul 14 18:03:49 1992
--- mit/fonts/lib/font/bitmap/pcfwrite.c	Tue Jul 14 18:03:48 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: pcfwrite.c,v 1.2 91/05/10 15:58:16 keith Exp $
   *
   * Copyright 1990 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: pcfwrite.c,v 1.3 92/03/26 17:37:17 gildea Exp $
   *
   * Copyright 1990 Massachusetts Institute of Technology
   *
***************
*** 208,218 ****
  pcfNameForAtom(a)
      Atom        a;
  {
!     char       *name;
! 
!     if (!(name = NameForAtom(a)))
! 	name = "";
!     return name;
  }
  
  pcfWriteFont(pFont, file)
--- 208,214 ----
  pcfNameForAtom(a)
      Atom        a;
  {
!     return NameForAtom(a);
  }
  
  pcfWriteFont(pFont, file)
*** /tmp/da25948	Tue Jul 14 18:03:51 1992
--- mit/fonts/lib/font/bitmap/Imakefile	Tue Jul 14 18:03:51 1992
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.5 91/07/22 22:20:44 rws Exp $
  #include <Server.tmpl>
  
          INCLUDES = -I$(FONTSRC)/include -I../include -I$(FONTSERVERSRC)/include
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.6 92/05/13 14:12:15 gildea Exp $
  #include <Server.tmpl>
  
          INCLUDES = -I$(FONTSRC)/include -I../include -I$(FONTSERVERSRC)/include
***************
*** 7,17 ****
       FORMAT_DEFS = FontFormatDefines
  #endif
              SRCS = bdfread.c bdfutils.c bitmap.c bitmaputils.c bitscale.c \
! 		   bitmapfuncs.c fsfuncs.c pcfread.c pcfwrite.c snfread.c \
  		   fontink.c
  
              OBJS = bdfread.o bdfutils.o bitmap.o bitmaputils.o bitscale.o \
! 		   bitmapfuncs.o fsfuncs.o pcfread.o pcfwrite.o snfread.o \
  		   fontink.o
  
  SubdirLibraryRule($(OBJS))
--- 7,17 ----
       FORMAT_DEFS = FontFormatDefines
  #endif
              SRCS = bdfread.c bdfutils.c bitmap.c bitmaputils.c bitscale.c \
! 		   bitmapfuncs.c pcfread.c pcfwrite.c snfread.c \
  		   fontink.c
  
              OBJS = bdfread.o bdfutils.o bitmap.o bitmaputils.o bitscale.o \
! 		   bitmapfuncs.o pcfread.o pcfwrite.o snfread.o \
  		   fontink.o
  
  SubdirLibraryRule($(OBJS))
*** /tmp/da25991	Tue Jul 14 18:03:56 1992
--- mit/fonts/lib/font/bitmap/bdfread.c	Tue Jul 14 18:03:54 1992
***************
*** 22,28 ****
  
  ************************************************************************/
  
! /* $XConsortium: bdfread.c,v 1.8 91/07/22 22:58:44 keith Exp $ */
  
  #include <ctype.h>
  #include "fontfilest.h"
--- 22,28 ----
  
  ************************************************************************/
  
! /* $XConsortium: bdfread.c,v 1.13 92/05/12 18:07:40 gildea Exp $ */
  
  #include <ctype.h>
  #include "fontfilest.h"
***************
*** 32,37 ****
--- 32,38 ----
  
  #define INDICES 256
  #define MAXENCODING 0xFFFF
+ #define BDFLINELEN  1024
  
  extern int  bitmapGetGlyphs(), bitmapGetMetrics();
  extern int  bitmapGetBitmaps(), bitmapGetExtents();
***************
*** 62,68 ****
      unsigned char *pInBits,
                 *picture,
                 *line = NULL;
!     char        lineBuf[BUFSIZ];
  
      widthBits = GLYPHWIDTHPIXELS(pCI);
      height = GLYPHHEIGHTPIXELS(pCI);
--- 63,69 ----
      unsigned char *pInBits,
                 *picture,
                 *line = NULL;
!     char        lineBuf[BDFLINELEN];
  
      widthBits = GLYPHWIDTHPIXELS(pCI);
      height = GLYPHHEIGHTPIXELS(pCI);
***************
*** 88,94 ****
  /*		0 width characters? */
  
      for (row = 0; row < height; row++) {
! 	line = bdfGetLine(file, lineBuf, BUFSIZ);
  	if (!line)
  	    break;
  
--- 89,95 ----
  /*		0 width characters? */
  
      for (row = 0; row < height; row++) {
! 	line = bdfGetLine(file, lineBuf, BDFLINELEN);
  	if (!line)
  	    break;
  
***************
*** 136,142 ****
      }
  
      if ((line && (!bdfIsPrefix(line, "ENDCHAR"))) || (height == 0))
! 	line = bdfGetLine(file, lineBuf, BUFSIZ);
  
      if ((!line) || (!bdfIsPrefix(line, "ENDCHAR"))) {
  	bdfError("missing 'ENDCHAR'\n");
--- 137,143 ----
      }
  
      if ((line && (!bdfIsPrefix(line, "ENDCHAR"))) || (height == 0))
! 	line = bdfGetLine(file, lineBuf, BDFLINELEN);
  
      if ((!line) || (!bdfIsPrefix(line, "ENDCHAR"))) {
  	bdfError("missing 'ENDCHAR'\n");
***************
*** 174,183 ****
  {
      unsigned char *line;
      int         i = 0;
!     char        lineBuf[BUFSIZ];
  
      do {
! 	line = bdfGetLine(file, lineBuf, BUFSIZ);
  	i++;
      } while (line && !bdfIsPrefix(line, "ENDCHAR") && i <= height);
  
--- 175,184 ----
  {
      unsigned char *line;
      int         i = 0;
!     char        lineBuf[BDFLINELEN];
  
      do {
! 	line = bdfGetLine(file, lineBuf, BDFLINELEN);
  	i++;
      } while (line && !bdfIsPrefix(line, "ENDCHAR") && i <= height);
  
***************
*** 207,220 ****
                  ndx,
                  nchars,
                  nignored;
!     int         char_row,
!                 char_col;
      int         numEncodedGlyphs = 0;
      CharInfoPtr *bdfEncoding[256];
      BitmapFontPtr  bitmapFont;
      BitmapExtraPtr bitmapExtra;
      CARD32     *bitmapsSizes;
!     char        lineBuf[BUFSIZ];
      int         nencoding;
  
      bitmapFont = (BitmapFontPtr) pFont->fontPrivate;
--- 208,220 ----
                  ndx,
                  nchars,
                  nignored;
!     unsigned int char_row, char_col;
      int         numEncodedGlyphs = 0;
      CharInfoPtr *bdfEncoding[256];
      BitmapFontPtr  bitmapFont;
      BitmapExtraPtr bitmapExtra;
      CARD32     *bitmapsSizes;
!     char        lineBuf[BDFLINELEN];
      int         nencoding;
  
      bitmapFont = (BitmapFontPtr) pFont->fontPrivate;
***************
*** 224,231 ****
  	bitmapsSizes = bitmapExtra->bitmapsSizes;
  	for (i = 0; i < GLYPHPADOPTIONS; i++)
  	    bitmapsSizes[i] = 0;
- 	bitmapExtra->glyphNames = 0;
- 	bitmapExtra->sWidths = 0;
      } else
  	bitmapsSizes = NULL;
  
--- 224,229 ----
***************
*** 233,239 ****
      bitmapFont->metrics = NULL;
      ndx = 0;
  
!     line = bdfGetLine(file, lineBuf, BUFSIZ);
  
      if ((!line) || (sscanf((char *) line, "CHARS %d", &nchars) != 1)) {
  	bdfError("bad 'CHARS' in bdf file\n");
--- 231,237 ----
      bitmapFont->metrics = NULL;
      ndx = 0;
  
!     line = bdfGetLine(file, lineBuf, BDFLINELEN);
  
      if ((!line) || (sscanf((char *) line, "CHARS %d", &nchars) != 1)) {
  	bdfError("bad 'CHARS' in bdf file\n");
***************
*** 267,273 ****
  	    return FALSE;
  	}
      }
!     line = bdfGetLine(file, lineBuf, BUFSIZ);
      pFont->info.firstRow = 256;
      pFont->info.lastRow = 0;
      pFont->info.firstCol = 256;
--- 265,271 ----
  	    return FALSE;
  	}
      }
!     line = bdfGetLine(file, lineBuf, BDFLINELEN);
      pFont->info.firstRow = 256;
      pFont->info.lastRow = 0;
      pFont->info.firstCol = 256;
***************
*** 294,300 ****
  	if (bitmapExtra)
  	    bitmapExtra->glyphNames[ndx] = bdfForceMakeAtom(charName, NULL);
  
! 	line = bdfGetLine(file, lineBuf, BUFSIZ);
  	if (!line || (t = sscanf((char *) line, "ENCODING %d %d", &enc, &enc2)) < 1) {
  	    bdfError("bad 'ENCODING' in BDF file\n");
  	    goto BAILOUT;
--- 292,298 ----
  	if (bitmapExtra)
  	    bitmapExtra->glyphNames[ndx] = bdfForceMakeAtom(charName, NULL);
  
! 	line = bdfGetLine(file, lineBuf, BDFLINELEN);
  	if (!line || (t = sscanf((char *) line, "ENCODING %d %d", &enc, &enc2)) < 1) {
  	    bdfError("bad 'ENCODING' in BDF file\n");
  	    goto BAILOUT;
***************
*** 342,348 ****
  	    }
  	}
  
! 	line = bdfGetLine(file, lineBuf, BUFSIZ);
  	if ((!line) || (sscanf((char *) line, "SWIDTH %d %d", &wx, &wy) != 2)) {
  	    bdfError("bad 'SWIDTH'\n");
  	    goto BAILOUT;
--- 340,346 ----
  	    }
  	}
  
! 	line = bdfGetLine(file, lineBuf, BDFLINELEN);
  	if ((!line) || (sscanf((char *) line, "SWIDTH %d %d", &wx, &wy) != 2)) {
  	    bdfError("bad 'SWIDTH'\n");
  	    goto BAILOUT;
***************
*** 357,363 ****
  /* 5/31/89 (ef) -- we should be able to ditch the character and recover */
  /*		from all of these.					*/
  
! 	line = bdfGetLine(file, lineBuf, BUFSIZ);
  	if ((!line) || (sscanf((char *) line, "DWIDTH %d %d", &wx, &wy) != 2)) {
  	    bdfError("bad 'DWIDTH'\n");
  	    goto BAILOUT;
--- 355,361 ----
  /* 5/31/89 (ef) -- we should be able to ditch the character and recover */
  /*		from all of these.					*/
  
! 	line = bdfGetLine(file, lineBuf, BDFLINELEN);
  	if ((!line) || (sscanf((char *) line, "DWIDTH %d %d", &wx, &wy) != 2)) {
  	    bdfError("bad 'DWIDTH'\n");
  	    goto BAILOUT;
***************
*** 366,372 ****
  	    bdfError("DWIDTH y value must be zero\n");
  	    goto BAILOUT;
  	}
! 	line = bdfGetLine(file, lineBuf, BUFSIZ);
  	if ((!line) || (sscanf((char *) line, "BBX %d %d %d %d", &bw, &bh, &bl, &bb) != 4)) {
  	    bdfError("bad 'BBX'\n");
  	    goto BAILOUT;
--- 364,370 ----
  	    bdfError("DWIDTH y value must be zero\n");
  	    goto BAILOUT;
  	}
! 	line = bdfGetLine(file, lineBuf, BDFLINELEN);
  	if ((!line) || (sscanf((char *) line, "BBX %d %d %d %d", &bw, &bh, &bl, &bb) != 4)) {
  	    bdfError("bad 'BBX'\n");
  	    goto BAILOUT;
***************
*** 376,382 ****
  		     charName, bw, bh);
  	    goto BAILOUT;
  	}
! 	line = bdfGetLine(file, lineBuf, BUFSIZ);
  	if ((line) && (bdfIsPrefix(line, "ATTRIBUTES"))) {
  	    for (p = line + strlen("ATTRIBUTES ");
  		    (*p == ' ') || (*p == '\t');
--- 374,380 ----
  		     charName, bw, bh);
  	    goto BAILOUT;
  	}
! 	line = bdfGetLine(file, lineBuf, BDFLINELEN);
  	if ((line) && (bdfIsPrefix(line, "ATTRIBUTES"))) {
  	    for (p = line + strlen("ATTRIBUTES ");
  		    (*p == ' ') || (*p == '\t');
***************
*** 383,389 ****
  		    p++)
  		 /* empty for loop */ ;
  	    ci->metrics.attributes = bdfHexByte(p) << 8 + bdfHexByte(p + 2);
! 	    line = bdfGetLine(file, lineBuf, BUFSIZ);
  	} else
  	    ci->metrics.attributes = 0;
  
--- 381,387 ----
  		    p++)
  		 /* empty for loop */ ;
  	    ci->metrics.attributes = bdfHexByte(p) << 8 + bdfHexByte(p + 2);
! 	    line = bdfGetLine(file, lineBuf, BDFLINELEN);
  	} else
  	    ci->metrics.attributes = 0;
  
***************
*** 413,419 ****
  	} else
  	    bdfSkipBitmap(file, bh);
  
! 	line = bdfGetLine(file, lineBuf, BUFSIZ);	/* get STARTCHAR or
  							 * ENDFONT */
      }
  
--- 411,417 ----
  	} else
  	    bdfSkipBitmap(file, bh);
  
! 	line = bdfGetLine(file, lineBuf, BDFLINELEN);	/* get STARTCHAR or
  							 * ENDFONT */
      }
  
***************
*** 473,486 ****
      for (i = 0; i < 256; i++)
  	if (bdfEncoding[i])
  	    xfree(bdfEncoding[i]);
!     for (i = 0; i < ndx; i++)
! 	if (bitmapFont->metrics[i].bits)
! 	    xfree(bitmapFont->metrics[i].bits);
!     xfree(bitmapFont->metrics);
!     if (bitmapExtra) {
! 	xfree(bitmapExtra->glyphNames);
! 	xfree(bitmapExtra->sWidths);
!     }
      return (FALSE);
  }
  
--- 471,477 ----
      for (i = 0; i < 256; i++)
  	if (bdfEncoding[i])
  	    xfree(bdfEncoding[i]);
!     /* bdfFreeFontBits will clean up the rest */
      return (FALSE);
  }
  
***************
*** 492,513 ****
      bdfFileState *pState;
  {
      unsigned char *line;
!     char        namebuf[BUFSIZ];
      int         tmp;
!     char        lineBuf[BUFSIZ];
  
!     line = bdfGetLine(file, lineBuf, BUFSIZ);
      if (!line || sscanf((char *) line, "STARTFONT %s", namebuf) != 1 ||
  	    !bdfStrEqual(namebuf, "2.1")) {
  	bdfError("bad 'STARTFONT'\n");
  	return (FALSE);
      }
!     line = bdfGetLine(file, lineBuf, BUFSIZ);
      if (!line || sscanf((char *) line, "FONT %[^\n]", pState->fontName) != 1) {
  	bdfError("bad 'FONT'\n");
  	return (FALSE);
      }
!     line = bdfGetLine(file, lineBuf, BUFSIZ);
      if (!line || !bdfIsPrefix(line, "SIZE")) {
  	bdfError("missing 'SIZE'\n");
  	return (FALSE);
--- 483,504 ----
      bdfFileState *pState;
  {
      unsigned char *line;
!     char        namebuf[BDFLINELEN];
      int         tmp;
!     char        lineBuf[BDFLINELEN];
  
!     line = bdfGetLine(file, lineBuf, BDFLINELEN);
      if (!line || sscanf((char *) line, "STARTFONT %s", namebuf) != 1 ||
  	    !bdfStrEqual(namebuf, "2.1")) {
  	bdfError("bad 'STARTFONT'\n");
  	return (FALSE);
      }
!     line = bdfGetLine(file, lineBuf, BDFLINELEN);
      if (!line || sscanf((char *) line, "FONT %[^\n]", pState->fontName) != 1) {
  	bdfError("bad 'FONT'\n");
  	return (FALSE);
      }
!     line = bdfGetLine(file, lineBuf, BDFLINELEN);
      if (!line || !bdfIsPrefix(line, "SIZE")) {
  	bdfError("missing 'SIZE'\n");
  	return (FALSE);
***************
*** 522,528 ****
  	bdfError("SIZE values must be > 0\n");
  	return (FALSE);
      }
!     line = bdfGetLine(file, lineBuf, BUFSIZ);
      if (!line || !bdfIsPrefix(line, "FONTBOUNDINGBOX")) {
  	bdfError("missing 'FONTBOUNDINGBOX'\n");
  	return (FALSE);
--- 513,519 ----
  	bdfError("SIZE values must be > 0\n");
  	return (FALSE);
      }
!     line = bdfGetLine(file, lineBuf, BDFLINELEN);
      if (!line || !bdfIsPrefix(line, "FONTBOUNDINGBOX")) {
  	bdfError("missing 'FONTBOUNDINGBOX'\n");
  	return (FALSE);
***************
*** 542,555 ****
                  nextProp;
      char       *stringProps;
      FontPropPtr props;
!     char        namebuf[BUFSIZ],
!                 secondbuf[BUFSIZ],
!                 thirdbuf[BUFSIZ];
      unsigned char *line;
!     char        lineBuf[BUFSIZ];
      BitmapFontPtr  bitmapFont = (BitmapFontPtr) pFont->fontPrivate;
  
!     line = bdfGetLine(file, lineBuf, BUFSIZ);
      if (!line || !bdfIsPrefix(line, "STARTPROPERTIES")) {
  	bdfError(file, "missing 'STARTPROPERTIES'\n");
  	return (FALSE);
--- 533,546 ----
                  nextProp;
      char       *stringProps;
      FontPropPtr props;
!     char        namebuf[BDFLINELEN],
!                 secondbuf[BDFLINELEN],
!                 thirdbuf[BDFLINELEN];
      unsigned char *line;
!     char        lineBuf[BDFLINELEN];
      BitmapFontPtr  bitmapFont = (BitmapFontPtr) pFont->fontPrivate;
  
!     line = bdfGetLine(file, lineBuf, BDFLINELEN);
      if (!line || !bdfIsPrefix(line, "STARTPROPERTIES")) {
  	bdfError(file, "missing 'STARTPROPERTIES'\n");
  	return (FALSE);
***************
*** 577,583 ****
      }
      nextProp = 0;
      while (nProps-- > 0) {
! 	line = bdfGetLine(file, lineBuf, BUFSIZ);
  	if (line == NULL || bdfIsPrefix(line, "ENDPROPERTIES")) {
  	    bdfError("%d too few properites\n", nProps + 1);
  	    goto BAILOUT;
--- 568,574 ----
      }
      nextProp = 0;
      while (nProps-- > 0) {
! 	line = bdfGetLine(file, lineBuf, BDFLINELEN);
  	if (line == NULL || bdfIsPrefix(line, "ENDPROPERTIES")) {
  	    bdfError("%d too few properites\n", nProps + 1);
  	    goto BAILOUT;
***************
*** 600,605 ****
--- 591,598 ----
  		stringProps[nextProp] = TRUE;
  		props[nextProp].value =
  		    bdfGetPropertyValue(line + strlen(namebuf) + 1);
+ 		if (!props[nextProp].value)
+ 		    goto BAILOUT;
  		break;
  	    } else if (bdfIsInteger(secondbuf)) {
  		stringProps[nextProp] = FALSE;
***************
*** 619,624 ****
--- 612,619 ----
  		stringProps[nextProp] = TRUE;
  		props[nextProp].value =
  		    bdfGetPropertyValue(line + strlen(namebuf) + 1);
+ 		if (!props[nextProp].value)
+ 		    goto BAILOUT;
  		break;
  	    } else {
  		bdfError("invalid '%s' parameter value\n", namebuf);
***************
*** 635,642 ****
  	    nextProp++;
      }
  
!     line = bdfGetLine(file, lineBuf, BUFSIZ);
!     if (!bdfIsPrefix(line, "ENDPROPERTIES")) {
  	bdfError("missing 'ENDPROPERTIES'\n");
  	goto BAILOUT;
      }
--- 630,637 ----
  	    nextProp++;
      }
  
!     line = bdfGetLine(file, lineBuf, BDFLINELEN);
!     if (!line || !bdfIsPrefix(line, "ENDPROPERTIES")) {
  	bdfError("missing 'ENDPROPERTIES'\n");
  	goto BAILOUT;
      }
***************
*** 717,723 ****
  	pFont->info.props = NULL;
      }
      while (line && bdfIsPrefix(line, "ENDPROPERTIES"))
! 	line = bdfGetLine(file, lineBuf, BUFSIZ);
      return (FALSE);
  }
  
--- 712,718 ----
  	pFont->info.props = NULL;
      }
      while (line && bdfIsPrefix(line, "ENDPROPERTIES"))
! 	line = bdfGetLine(file, lineBuf, BDFLINELEN);
      return (FALSE);
  }
  
***************
*** 755,760 ****
--- 750,757 ----
      bitmapFont->encoding = 0;
      bitmapFont->pDefault = NULL;
      bitmapFont->bitmapExtra = (BitmapExtraPtr) xalloc(sizeof(BitmapExtraRec));
+     bitmapFont->bitmapExtra->glyphNames = 0;
+     bitmapFont->bitmapExtra->sWidths = 0;
  
      if (!bdfReadProperties(file, pFont, &state))
  	goto BAILOUT;
***************
*** 763,771 ****
  	goto BAILOUT;
  
      if (state.haveDefaultCh) {
! 	int         r,
! 	            c,
! 	            cols;
  
  	r = pFont->info.defaultCh >> 8;
  	c = pFont->info.defaultCh & 0xFF;
--- 760,766 ----
  	goto BAILOUT;
  
      if (state.haveDefaultCh) {
! 	unsigned int r, c, cols;
  
  	r = pFont->info.defaultCh >> 8;
  	c = pFont->info.defaultCh & 0xFF;
***************
*** 813,820 ****
      if (state.weightProp && (state.weightProp->value == -1))
  	state.weightProp->value = bitmapComputeWeight(pFont);
  
-     pFont->get_bitmaps = bitmapGetBitmaps;
-     pFont->get_extents = bitmapGetExtents;
      pFont->get_glyphs = bitmapGetGlyphs;
      pFont->get_metrics = bitmapGetMetrics;
      pFont->unload_font = bdfUnloadFont;
--- 808,813 ----
***************
*** 829,842 ****
--- 822,843 ----
      FontPtr pFont;
  {
      BitmapFontPtr  bitmapFont;
+     BitmapExtraPtr bitmapExtra;
      int         i;
  
      bitmapFont = (BitmapFontPtr) pFont->fontPrivate;
+     bitmapExtra = (BitmapExtraPtr) bitmapFont->bitmapExtra;
      xfree(bitmapFont->ink_metrics);
      xfree(bitmapFont->encoding);
      for (i = 0; i < bitmapFont->num_chars; i++)
  	xfree(bitmapFont->metrics[i].bits);
      xfree(bitmapFont->metrics);
+     if (bitmapExtra)
+     {
+ 	xfree (bitmapExtra->glyphNames);
+ 	xfree (bitmapExtra->sWidths);
+ 	xfree (bitmapExtra);
+     }
      xfree(pFont->info.props);
      xfree(bitmapFont);
  }
*** /tmp/da26013	Tue Jul 14 18:03:58 1992
--- mit/fonts/lib/font/bitmap/bdfutils.c	Tue Jul 14 18:03:57 1992
***************
*** 22,28 ****
  
  ************************************************************************/
  
! /* $XConsortium: bdfutils.c,v 1.3 91/07/17 20:43:53 rws Exp $ */
  
  #include <ctype.h>
  
--- 22,28 ----
  
  ************************************************************************/
  
! /* $XConsortium: bdfutils.c,v 1.6 92/04/16 09:20:57 gildea Exp $ */
  
  #include <ctype.h>
  
***************
*** 85,91 ****
  /***====================================================================***/
  
  /*
!  * read the next (non-comment) line and keep a count for error messages
   */
  
  unsigned char *
--- 85,92 ----
  /***====================================================================***/
  
  /*
!  * read the next (non-comment) line and keep a count for error messages.
!  * Returns buf, or NULL if EOF.
   */
  
  unsigned char *
***************
*** 109,114 ****
--- 110,117 ----
  	    *b++ = c;
  	}
  	*b = '\0';
+ 	if (c == FontFileEOF)
+ 	    return NULL;
  	if (b != buf && !bdfIsPrefix(buf, "COMMENT"))
  	    break;
      }
***************
*** 142,147 ****
--- 145,151 ----
  {
      register char *p,
                 *pp;
+     char *orig_s = s;
      Atom        atom;
  
      /* strip leading white space */
***************
*** 148,154 ****
      while (*s && (*s == ' ' || *s == '\t'))
  	s++;
      if (*s == 0) {
! 	return None;
      }
      if (*s != '"') {
  	pp = s;
--- 152,158 ----
      while (*s && (*s == ' ' || *s == '\t'))
  	s++;
      if (*s == 0) {
! 	return bdfForceMakeAtom(s, NULL);
      }
      if (*s != '"') {
  	pp = s;
***************
*** 167,178 ****
  	if (*s == '"') {
  	    if (*(s + 1) != '"') {
  		*p++ = 0;
! 		if (strlen(pp)) {
! 		    atom = bdfForceMakeAtom(pp, NULL);
! 		} else {
! 		    atom = None;
! 		}
! 		free(pp);
  		return atom;
  	    } else {
  		s++;
--- 171,178 ----
  	if (*s == '"') {
  	    if (*(s + 1) != '"') {
  		*p++ = 0;
! 		atom = bdfForceMakeAtom(pp, NULL);
! 		xfree(pp);
  		return atom;
  	    } else {
  		s++;
***************
*** 180,185 ****
--- 180,187 ----
  	}
  	*p++ = *s++;
      }
+     xfree (pp);
+     bdfError("unterminated quoted string property: %s\n", orig_s);
      return None;
  }
  
*** /tmp/da26100	Tue Jul 14 18:04:06 1992
--- mit/fonts/lib/font/bitmap/bitscale.c	Tue Jul 14 18:04:05 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: bitscale.c,v 1.9 91/07/22 20:46:06 keith Exp $
   *
   * Copyright 1991 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: bitscale.c,v 1.11 92/05/12 18:07:44 gildea Exp $
   *
   * Copyright 1991 Massachusetts Institute of Technology
   *
***************
*** 241,253 ****
  	    }
  	}
      }
!     if (best_scaled)
!     {
! 	*best = best_scaled->vals;
! 	*fpep = best_fpe;
! 	*dxp = best_dx;
! 	*dyp = best_dy;
!     }
      return best_scaled->bitmap;
  }
  
--- 241,253 ----
  	    }
  	}
      }
!     if (!best_scaled)
! 	return NULL;
! 
!     *best = best_scaled->vals;
!     *fpep = best_fpe;
!     *dxp = best_dx;
!     *dyp = best_dy;
      return best_scaled->bitmap;
  }
  
***************
*** 434,441 ****
      pf->glyph = opf->glyph;
      pf->scan = opf->scan;
  
-     pf->get_bitmaps = bitmapGetBitmaps;
-     pf->get_extents = bitmapGetExtents;
      pf->get_glyphs = bitmapGetGlyphs;
      pf->get_metrics = bitmapGetMetrics;
      pf->unload_font = bitmapUnloadScalable;
--- 434,439 ----
***************
*** 479,486 ****
      pfi->anamorphic = FALSE;
      if (heightMult != widthMult)
  	pfi->anamorphic = TRUE;
!     pfi->fontDescent *= heightMult;
!     pfi->fontAscent *= heightMult;
      pfi->minbounds.leftSideBearing = MAXSHORT;
      pfi->minbounds.rightSideBearing = MAXSHORT;
      pfi->minbounds.ascent = MAXSHORT;
--- 477,487 ----
      pfi->anamorphic = FALSE;
      if (heightMult != widthMult)
  	pfi->anamorphic = TRUE;
! 
!     newHeight = (opfi->fontAscent + opfi->fontDescent) * heightMult;
!     pfi->fontAscent = opfi->fontAscent * heightMult;
!     pfi->fontDescent = newHeight - pfi->fontAscent;
! 
      pfi->minbounds.leftSideBearing = MAXSHORT;
      pfi->minbounds.rightSideBearing = MAXSHORT;
      pfi->minbounds.ascent = MAXSHORT;
***************
*** 616,621 ****
--- 617,623 ----
  	    	glyphBytes += BYTES_FOR_GLYPH(pci, glyph);
  	    }
      	}
+ 	FontComputeInfoAccelerators (pfi);
      	xfree(scratch);
      }
  
***************
*** 728,735 ****
      if (pink) {
  	pink->leftSideBearing = MAXSHORT;
  	pink->rightSideBearing = MINSHORT;
! 	pink->ascent = 0;
! 	pink->descent = 0;
  	pink->characterWidth = pci->metrics.characterWidth;
  	pink->attributes = pci->metrics.attributes;
      }
--- 730,737 ----
      if (pink) {
  	pink->leftSideBearing = MAXSHORT;
  	pink->rightSideBearing = MINSHORT;
! 	pink->ascent = MINSHORT;
! 	pink->descent = MINSHORT;
  	pink->characterWidth = pci->metrics.characterWidth;
  	pink->attributes = pci->metrics.attributes;
      }
***************
*** 851,866 ****
  		if (newHeight >= pink->ascent)
  		    pink->ascent = newHeight;
  		pink->descent = newHeight;
  	    }
- 	    newBit = pci->metrics.leftSideBearing + newWidth - newBit - 1;
- 	    if (newBit < pink->leftSideBearing)
- 		pink->leftSideBearing = newBit;
  	    for (acc = scratch + newWidth, newBit = newWidth;
  		    --newBit >= 0 && *--acc >= 0;
  		);
! 	    newBit = pci->metrics.leftSideBearing + newBit + 1;
! 	    if (newBit > pink->rightSideBearing)
! 		pink->rightSideBearing = newBit;
  	}
      }
  #define MINMAX(field) \
--- 853,871 ----
  		if (newHeight >= pink->ascent)
  		    pink->ascent = newHeight;
  		pink->descent = newHeight;
+ 		newBit = pci->metrics.leftSideBearing + newWidth - newBit - 1;
+ 		if (newBit < pink->leftSideBearing)
+ 		    pink->leftSideBearing = newBit;
  	    }
  	    for (acc = scratch + newWidth, newBit = newWidth;
  		    --newBit >= 0 && *--acc >= 0;
  		);
! 	    if (newBit >= 0)
! 	    {
! 	    	newBit = pci->metrics.leftSideBearing + newBit + 1;
! 	    	if (newBit > pink->rightSideBearing)
! 		    pink->rightSideBearing = newBit;
! 	    }
  	}
      }
  #define MINMAX(field) \
***************
*** 870,875 ****
--- 875,889 ----
  	pFont->info.ink_maxbounds.field = pink->field
  
      if (pink) {
+ 	if (pink->ascent == MINSHORT)
+ 	{
+ 	    /* hack to make computation below work */
+ 	    pink->ascent = pci->metrics.descent;
+ 	    /* these would also have not been set as this character is empty */
+ 	    pink->descent = pink->ascent + 1;
+ 	    pink->leftSideBearing = 0;
+ 	    pink->rightSideBearing = 0;
+ 	}
  	height = pink->ascent - pink->descent + 1;
  	pink->ascent = pci->metrics.ascent -
  	    (GLYPHHEIGHTPIXELS(pci) - pink->ascent);
***************
*** 1045,1050 ****
--- 1059,1066 ----
  
      propCount = ComputeScaledProperties (&scaleInfo, fontName->name, vals, dx, dy,
  					&props, &isStringProp);
+     xfree (scaleInfo.isStringProp);
+     xfree (scaleInfo.props);
      if (propCount && (!props || !isStringProp))
  	return AllocError;
  
*** /tmp/da26164	Tue Jul 14 18:04:13 1992
--- mit/fonts/lib/font/bitmap/pcfread.c	Tue Jul 14 18:04:12 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: pcfread.c,v 1.7 91/07/22 22:58:57 keith Exp $
   *
   * Copyright 1990 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: pcfread.c,v 1.10 92/05/12 18:07:47 gildea Exp $
   *
   * Copyright 1990 Massachusetts Institute of Technology
   *
***************
*** 169,175 ****
      for (i = 0; i < ntables; i++)
  	if (tables[i].type == type) {
  	    if (position > tables[i].offset)
! 		abort ();
  	    if (!FontFileSkip(file, tables[i].offset - position))
  		return FALSE;
  	    position = tables[i].offset;
--- 169,175 ----
      for (i = 0; i < ntables; i++)
  	if (tables[i].type == type) {
  	    if (position > tables[i].offset)
! 		return FALSE;
  	    if (!FontFileSkip(file, tables[i].offset - position))
  		return FALSE;
  	    position = tables[i].offset;
***************
*** 348,360 ****
      CharInfoPtr metrics = 0;
      xCharInfo  *ink_metrics = 0;
      char       *bitmaps = 0;
!     CharInfoPtr *encoding;
      int         nencoding;
      int         encodingOffset;
      CARD32      bitmapSizes[GLYPHPADOPTIONS];
!     CARD32     *offsets;
      Bool	hasBDFAccelerators;
  
      if (!(tables = pcfReadTOC(file, &ntables)))
  	goto Bail;
  
--- 348,361 ----
      CharInfoPtr metrics = 0;
      xCharInfo  *ink_metrics = 0;
      char       *bitmaps = 0;
!     CharInfoPtr *encoding = 0;
      int         nencoding;
      int         encodingOffset;
      CARD32      bitmapSizes[GLYPHPADOPTIONS];
!     CARD32     *offsets = 0;
      Bool	hasBDFAccelerators;
  
+     pFont->info.props = 0;
      if (!(tables = pcfReadTOC(file, &ntables)))
  	goto Bail;
  
***************
*** 557,564 ****
      }
      bitmapFont->bitmapExtra = (BitmapExtraPtr) 0;
      pFont->fontPrivate = (pointer) bitmapFont;
-     pFont->get_bitmaps = bitmapGetBitmaps;
-     pFont->get_extents = bitmapGetExtents;
      pFont->get_glyphs = bitmapGetGlyphs;
      pFont->get_metrics = bitmapGetMetrics;
      pFont->unload_font = pcfUnloadFont;
--- 558,563 ----
***************
*** 572,577 ****
--- 571,577 ----
      xfree(ink_metrics);
      xfree(encoding);
      xfree(bitmaps);
+     xfree(offsets);
      xfree(metrics);
      xfree(pFont->info.props);
      pFont->info.props = 0;
***************
*** 592,597 ****
--- 592,600 ----
      int         nencoding;
      Bool	hasBDFAccelerators;
  
+     pFontInfo->isStringProp = NULL;
+     pFontInfo->props = NULL;
+ 
      if (!(tables = pcfReadTOC(file, &ntables)))
  	goto Bail;
  
***************
*** 639,644 ****
--- 642,649 ----
      xfree(tables);
      return Successful;
  Bail:
+     xfree (pFontInfo->props);
+     xfree (pFontInfo->isStringProp);
      xfree(tables);
      return AllocError;
  }
*** /tmp/da26186	Tue Jul 14 18:04:15 1992
--- mit/fonts/lib/font/bitmap/snfread.c	Tue Jul 14 18:04:14 1992
***************
*** 22,28 ****
  
  ************************************************************************/
  
! /* $XConsortium: snfread.c,v 1.10 91/07/22 22:59:00 keith Exp $ */
  
  #include <ctype.h>
  #include "fontfilest.h"
--- 22,28 ----
  
  ************************************************************************/
  
! /* $XConsortium: snfread.c,v 1.11 92/05/12 18:07:49 gildea Exp $ */
  
  #include <ctype.h>
  #include "fontfilest.h"
***************
*** 358,365 ****
      }
      bitmapFont->bitmapExtra = (BitmapExtraPtr) 0;
      pFont->fontPrivate = (pointer) bitmapFont;
-     pFont->get_bitmaps = bitmapGetBitmaps;
-     pFont->get_extents = bitmapGetExtents;
      pFont->get_glyphs = bitmapGetGlyphs;
      pFont->get_metrics = bitmapGetMetrics;
      pFont->unload_font = snfUnloadFont;
--- 358,363 ----
*** /tmp/da26443	Tue Jul 14 18:04:39 1992
--- mit/fonts/lib/font/util/format.c	Tue Jul 14 18:04:38 1992
***************
*** 1,4 ****
! /* $XConsortium: format.c,v 1.2 91/05/13 16:38:48 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
--- 1,4 ----
! /* $XConsortium: format.c,v 1.3 92/04/15 16:16:08 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
***************
*** 20,28 ****
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  *
-  * @(#)format.c	4.1	91/05/02
-  *
   */
  
  #include	"FSproto.h"
--- 20,25 ----
***************
*** 29,39 ****
  #include	"font.h"
  
  int
! CheckFSFormat(format, fmask, bit, byte, scan, glyph, image)
      fsBitmapFormat format;
      fsBitmapFormatMask fmask;
!     int        *bit,
!                *byte,
                 *scan,
                 *glyph,
                 *image;
--- 26,36 ----
  #include	"font.h"
  
  int
! CheckFSFormat(format, fmask, bit_order, byte_order, scan, glyph, image)
      fsBitmapFormat format;
      fsBitmapFormatMask fmask;
!     int        *bit_order,
!                *byte_order,
                 *scan,
                 *glyph,
                 *image;
***************
*** 40,51 ****
  {
      /* convert format to what the low levels want */
      if (fmask & BitmapFormatMaskBit) {
! 	*bit = format & BitmapFormatBitOrderMask;
! 	*bit = (*bit == BitmapFormatBitOrderMSB) ? MSBFirst : LSBFirst;
      }
      if (fmask & BitmapFormatMaskByte) {
! 	*byte = format & BitmapFormatByteOrderMask;
! 	*byte = (*byte == BitmapFormatByteOrderMSB) ? MSBFirst : LSBFirst;
      }
      if (fmask & BitmapFormatMaskScanLineUnit) {
  	*scan = format & BitmapFormatScanlineUnitMask;
--- 37,50 ----
  {
      /* convert format to what the low levels want */
      if (fmask & BitmapFormatMaskBit) {
! 	*bit_order = format & BitmapFormatBitOrderMask;
! 	*bit_order = (*bit_order == BitmapFormatBitOrderMSB)
! 	    	     ? MSBFirst : LSBFirst;
      }
      if (fmask & BitmapFormatMaskByte) {
! 	*byte_order = format & BitmapFormatByteOrderMask;
! 	*byte_order = (*byte_order == BitmapFormatByteOrderMSB)
! 	    	      ? MSBFirst : LSBFirst;
      }
      if (fmask & BitmapFormatMaskScanLineUnit) {
  	*scan = format & BitmapFormatScanlineUnitMask;
*** /tmp/da26570	Tue Jul 14 18:04:50 1992
--- mit/fonts/lib/font/util/Imakefile	Tue Jul 14 18:04:49 1992
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.8 91/10/18 11:22:58 keith Exp $
  #include <Server.tmpl>
  
          INCLUDES = -I$(FONTSRC)/include -I../include -I$(FONTSERVERSRC)/include
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.9 92/05/15 11:15:42 gildea Exp $
  #include <Server.tmpl>
  
          INCLUDES = -I$(FONTSRC)/include -I../include -I$(FONTSERVERSRC)/include
***************
*** 7,16 ****
       FORMAT_DEFS = FontFormatDefines
  #endif
              SRCS = bitmaputil.c fontnames.c fontutil.c fontxlfd.c format.c \
! 		   fontaccel.c atom.c miscutil.c private.c patcache.c fsfuncs.c
  
              OBJS = bitmaputil.o fontnames.o fontutil.o fontxlfd.o format.o \
! 		   fontaccel.o atom.o miscutil.o private.o patcache.o fsfuncs.o
  
  SubdirLibraryRule($(OBJS))
  NormalLibraryObjectRule()
--- 7,16 ----
       FORMAT_DEFS = FontFormatDefines
  #endif
              SRCS = bitmaputil.c fontnames.c fontutil.c fontxlfd.c format.c \
! 		   fontaccel.c atom.c miscutil.c private.c patcache.c
  
              OBJS = bitmaputil.o fontnames.o fontutil.o fontxlfd.o format.o \
! 		   fontaccel.o atom.o miscutil.o private.o patcache.o
  
  SubdirLibraryRule($(OBJS))
  NormalLibraryObjectRule()
*** /tmp/da26634	Tue Jul 14 18:04:56 1992
--- mit/fonts/lib/font/util/patcache.c	Tue Jul 14 18:04:56 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: patcache.c,v 1.2 91/06/14 10:58:11 rws Exp $
   *
   * Copyright 1991 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: patcache.c,v 1.3 92/03/23 16:46:12 keith Exp $
   *
   * Copyright 1991 Massachusetts Institute of Technology
   *
***************
*** 63,73 ****
      if (!cache)
  	return 0;
      for (i = 0; i < NENTRIES; i++)
-     {
- 	cache->entries[i].patlen = 0;
  	cache->entries[i].pattern = 0;
- 	cache->entries[i].pFont = 0;
-     }
      EmptyFontPatternCache (cache);
      return cache;
  }
--- 63,69 ----
***************
*** 113,118 ****
--- 109,117 ----
  	cache->entries[i].next = &cache->entries[i+1];
  	cache->entries[i].prev = 0;
  	cache->entries[i].pFont = 0;
+ 	xfree (cache->entries[i].pattern);
+ 	cache->entries[i].pattern = 0;
+ 	cache->entries[i].patlen = 0;
      }
      cache->free = &cache->entries[0];
      cache->entries[i].next = 0;
*** /tmp/da26702	Tue Jul 14 18:05:05 1992
--- mit/fonts/lib/font/fc/fserve.c	Tue Jul 14 18:05:03 1992
***************
*** 1,30 ****
! /* $XConsortium: fserve.c,v 1.14 91/07/26 20:59:30 keith Exp $ */
  /*
-  *
   * Copyright 1990 Network Computing Devices
   *
!  * Permission to use, copy, modify, distribute, and sell this software and its
!  * documentation for any purpose is hereby granted without fee, provided that
!  * the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
!  * documentation, and that the name of Network Computing Devices not be
!  * used in advertising or publicity pertaining to distribution of the
!  * software without specific, written prior permission.  Network Computing
!  * Devices makes no representations about the suitability of this software
!  * for any purpose.  It is provided "as is" without express or implied
!  * warranty.
   *
!  * NETWORK COMPUTING DEVICES DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
!  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
!  * IN NO EVENT SHALL NETWORK COMPUTING DEVICES BE LIABLE FOR ANY SPECIAL,
!  * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
!  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
!  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
!  * OR PERFORMANCE OF THIS SOFTWARE.
   *
   * Author:  	Dave Lemke, Network Computing Devices, Inc
-  *
-  * $NCDId: @(#)fserve.c,v 1.19 1991/07/10 14:20:31 lemke Exp $
   */
  /*
   * font server specific font access
--- 1,25 ----
! /* $XConsortium: fserve.c,v 1.25 92/07/09 16:08:03 gildea Exp $ */
  /*
   * Copyright 1990 Network Computing Devices
   *
!  * Permission to use, copy, modify, distribute, and sell this software and
!  * its documentation for any purpose is hereby granted without fee, provided
!  * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
!  * documentation, and that the names of Network Computing Devices, Digital or
!  * M.I.T. not be used in advertising or publicity pertaining to distribution
!  * of the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND M.I.T. DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
!  * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES,
!  * DIGITAL OR M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
!  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
!  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
!  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
!  * THIS SOFTWARE.
   *
   * Author:  	Dave Lemke, Network Computing Devices, Inc
   */
  /*
   * font server specific font access
***************
*** 43,52 ****
--- 38,57 ----
  #include	<ncd/nvram.h>
  #endif
  
+ #ifndef NULL
+ #define NULL 0
+ #endif
+ 
  #ifndef MIN
  #define MIN(a,b)    ((a)<(b)?(a):(b))
  #endif
  
+ #define NONZEROMETRICS(pci) ((pci)->leftSideBearing || \
+ 			     (pci)->rightSideBearing || \
+ 			     (pci)->ascent || \
+ 			     (pci)->descent || \
+ 			     (pci)->characterWidth)
+ 
  extern int  errno;
  
  
***************
*** 61,67 ****
  static int  fs_font_type;
  extern unsigned long fs_fd_mask[];
  
! static int  fs_block_handler();
  static int  fs_wakeup();
  
  static FSFpePtr awaiting_reconnect;
--- 66,72 ----
  static int  fs_font_type;
  extern unsigned long fs_fd_mask[];
  
! static void fs_block_handler();
  static int  fs_wakeup();
  
  static FSFpePtr awaiting_reconnect;
***************
*** 117,123 ****
  fs_name_check(name)
      char       *name;
  {
!     return (!strncmp(name, "tcp/", MIN(4, strlen(name))));
  }
  
  /*
--- 122,128 ----
  fs_name_check(name)
      char       *name;
  {
!     return (!strncmp(name, "tcp/", MIN(4, (int) strlen(name))));
  }
  
  /*
***************
*** 254,259 ****
--- 259,287 ----
      return err;
  }
  
+ /* 
+  * close font server and remove any state associated with
+  * this connection - this includes any client records.
+  */
+ 
+ static void
+ fs_close_conn(conn)
+     FSFpePtr	conn;
+ {
+     FSClientPtr	client, nclient;
+ 
+     (void) close(conn->fs_fd);
+ 
+     _fs_bit_clear(fs_fd_mask, conn->fs_fd);
+ 
+     for (client = conn->clients; client; client = nclient) 
+     {
+ 	nclient = client->next;
+ 	xfree (client);
+     }
+     conn->clients = NULL;
+ }
+ 
  /*
   * the wakeup handlers have to be set when the FPE is open, and not
   * removed until it is freed, in order to handle unexpected data, like
***************
*** 285,294 ****
  	fpe->private = (pointer) conn;
  	err = fs_send_init_packets(conn);
  	if (err != Successful) {
! 	    (void) close(conn->fs_fd);
! 	    xfree(conn->servername);
! 	    xfree(conn->alts);
! 	    xfree(conn);
  	    return err;
  	}
  	if (init_fs_handlers(fpe, fs_block_handler) != Successful)
--- 313,322 ----
  	fpe->private = (pointer) conn;
  	err = fs_send_init_packets(conn);
  	if (err != Successful) {
! 	    fs_close_conn(conn);
!     	    xfree(conn->servername);
!     	    xfree(conn->alts);
!     	    xfree(conn);
  	    return err;
  	}
  	if (init_fs_handlers(fpe, fs_block_handler) != Successful)
***************
*** 335,343 ****
      FSFpePtr    conn = (FSFpePtr) fpe->private;
      FSFpePtr    recon,
                 *prev;
- 
      prev = &awaiting_reconnect;
!     while (recon = *prev) {
  	if (conn == recon) {
  	    *prev = recon->next_reconnect;
  	    break;
--- 363,371 ----
      FSFpePtr    conn = (FSFpePtr) fpe->private;
      FSFpePtr    recon,
                 *prev;
      prev = &awaiting_reconnect;
!     while (*prev) {
! 	recon = *prev;
  	if (conn == recon) {
  	    *prev = recon->next_reconnect;
  	    break;
***************
*** 345,355 ****
  	prev = &recon->next_reconnect;
      }
  
!     /* close font server */
!     (void) close(conn->fs_fd);
  
!     _fs_bit_clear(fs_fd_mask, conn->fs_fd);
!     remove_fs_handlers(fpe, fs_block_handler, !_fs_any_bit_set(fs_fd_mask));
  
      xfree(conn->alts);
      xfree(conn->servername);
--- 373,382 ----
  	prev = &recon->next_reconnect;
      }
  
!     fs_close_conn(conn);
  
!     remove_fs_handlers(fpe, fs_block_handler,
! 		       !_fs_any_bit_set(fs_fd_mask) && !awaiting_reconnect);
  
      xfree(conn->alts);
      xfree(conn->servername);
***************
*** 578,584 ****
  	return StillWorking;
      }
      /* move the data over */
!     (void) fs_convert_header(&rep.header, &bfont->pfont->info);
      if (bfont->pfont->info.terminalFont)
      {
  	bfont->format =
--- 605,611 ----
  	return StillWorking;
      }
      /* move the data over */
!     (void) fs_convert_header(conn, &rep.header, &bfont->pfont->info);
      if (bfont->pfont->info.terminalFont)
      {
  	bfont->format =
***************
*** 609,615 ****
  	fs_free_font(bfont);
  	return StillWorking;
      }
!     (void) fs_convert_props(&pi, po, pd, &bfont->pfont->info);
      xfree(po);
      xfree(pd);
  
--- 636,648 ----
  	fs_free_font(bfont);
  	return StillWorking;
      }
!     if (fs_convert_props(&pi, po, pd, &bfont->pfont->info) == -1)
!     {
!     	xfree(po);
!     	xfree(pd);
! 	(void) fs_cleanup_font(bfont);
! 	return AllocError;
!     }
      xfree(po);
      xfree(pd);
  
***************
*** 628,633 ****
--- 661,668 ----
      FSFpePtr    conn = (FSFpePtr) fpe->private;
      fsQueryXExtents8Reply rep;
      int         i;
+     int		numInfos;
+     Bool	haveInk = FALSE; /* need separate ink metrics? */
      CharInfoPtr ci,
                  pCI;
      FSFontPtr   fsfont = (FSFontPtr) bfont->pfont->fontPrivate;
***************
*** 642,648 ****
  	return StillWorking;
      }
      /* move the data over */
!     ci = pCI = (CharInfoPtr) xalloc(sizeof(CharInfoRec) * rep.num_extents);
  /* XXX this could be done with an ALLOCATE_LOCAL */
      fsci = (fsCharInfo *) xalloc(sizeof(fsCharInfo) * rep.num_extents);
      if (!pCI || !fsci) {
--- 677,690 ----
  	return StillWorking;
      }
      /* move the data over */
!     /* need separate inkMetrics for fixed font server protocol version */
!     numInfos =  rep.num_extents;
!     if (bfont->pfont->info.terminalFont && conn->fsMajorVersion > 1)
!     {
! 	numInfos *= 2;
! 	haveInk = TRUE;
!     }
!     ci = pCI = (CharInfoPtr) xalloc(sizeof(CharInfoRec) * numInfos);
  /* XXX this could be done with an ALLOCATE_LOCAL */
      fsci = (fsCharInfo *) xalloc(sizeof(fsCharInfo) * rep.num_extents);
      if (!pCI || !fsci) {
***************
*** 654,661 ****
  	return AllocError;
      }
      fsfont->encoding = pCI;
! /* XXX - hack - use real default char */
!     fsfont->pDefault = &pCI[0];
  
      if (_fs_read_pad(conn, (char *) fsci,
  		     sizeof(fsCharInfo) * rep.num_extents) == -1) {
--- 696,705 ----
  	return AllocError;
      }
      fsfont->encoding = pCI;
!     if (haveInk)
! 	fsfont->inkMetrics = pCI + rep.num_extents;
!     else
!         fsfont->inkMetrics = pCI;
  
      if (_fs_read_pad(conn, (char *) fsci,
  		     sizeof(fsCharInfo) * rep.num_extents) == -1) {
***************
*** 662,672 ****
--- 706,767 ----
  	fs_free_font(bfont);
  	return StillWorking;
      }
+     ci = fsfont->inkMetrics;
      for (i = 0, fscip = fsci; i < rep.num_extents; i++, ci++, fscip++) {
  	fs_convert_char_info(fscip, ci);
      }
  
      xfree(fsci);
+ 
+     /* build bitmap metrics, ImageRectMax style */
+     if (haveInk)
+     {
+ 	FontInfoRec *fi = &bfont->pfont->info;
+ 	CharInfoPtr ii;
+ 
+ 	ci = fsfont->encoding;
+ 	ii = fsfont->inkMetrics;
+ 	for (i = 0; i < rep.num_extents; i++, ci++, ii++)
+ 	{
+ 	    if (NONZEROMETRICS(&ii->metrics))
+ 	    {
+ 		ci->metrics.leftSideBearing = FONT_MIN_LEFT(fi);
+ 		ci->metrics.rightSideBearing = FONT_MAX_RIGHT(fi);
+ 		ci->metrics.ascent = FONT_MAX_ASCENT(fi);
+ 		ci->metrics.descent = FONT_MAX_DESCENT(fi);
+ 		ci->metrics.characterWidth = FONT_MAX_WIDTH(fi);
+ 		ci->metrics.attributes = ii->metrics.attributes;
+ 	    }
+ 	    else
+ 	    {
+ 		ci->metrics = ii->metrics;
+ 	    }
+ 	}
+     }
+     {
+ 	unsigned int r, c, numCols, firstCol;
+ 
+ 	firstCol = bfont->pfont->info.firstCol;
+ 	numCols = bfont->pfont->info.lastCol - firstCol + 1;
+ 	c = bfont->pfont->info.defaultCh;
+ 	fsfont->pDefault = 0;
+ 	if (bfont->pfont->info.lastRow)
+ 	{
+ 	    r = c >> 8;
+ 	    r -= bfont->pfont->info.firstRow;
+ 	    c &= 0xff;
+ 	    c -= firstCol;
+ 	    if (r < bfont->pfont->info.lastRow-bfont->pfont->info.firstRow+1 &&
+ 		c < numCols)
+ 		fsfont->pDefault = &pCI[r * numCols + c];
+ 	}
+ 	else
+ 	{
+ 	    c -= firstCol;
+ 	    if (c < numCols)
+ 		fsfont->pDefault = &pCI[c];
+ 	}
+     }
      bfont->state = FS_GLYPHS_REPLY;
  
      if (bfont->flags & FontLoadBitmaps) {
***************
*** 787,793 ****
  }
  
  /* ARGSUSED */
! static int
  fs_block_handler(data, wt, LastSelectMask)
      pointer     data;
      struct timeval **wt;
--- 882,888 ----
  }
  
  /* ARGSUSED */
! static void
  fs_block_handler(data, wt, LastSelectMask)
      pointer     data;
      struct timeval **wt;
***************
*** 817,823 ****
  	    **wt = recon_timeout;
  	}
      }
-     return Successful;
  }
  
  static void
--- 912,917 ----
***************
*** 932,939 ****
      if (!conn->attemptReconnect)
  	return;
      conn->attemptReconnect = FALSE;
!     _fs_bit_clear(fs_fd_mask, conn->fs_fd);
!     close(conn->fs_fd);
      conn->time_to_try = time((long *) 0) + FS_RECONNECT_WAIT;
      conn->reconnect_delay = FS_RECONNECT_WAIT;
      conn->fs_fd = -1;
--- 1026,1032 ----
      if (!conn->attemptReconnect)
  	return;
      conn->attemptReconnect = FALSE;
!     fs_close_conn(conn);
      conn->time_to_try = time((long *) 0) + FS_RECONNECT_WAIT;
      conn->reconnect_delay = FS_RECONNECT_WAIT;
      conn->fs_fd = -1;
***************
*** 1318,1328 ****
      }
      /* adjust them */
      for (i = 0; i < rep.num_chars; i++) {
! 	if (ppbits[i].length)
  	    bits = (char *) pbitmaps + ppbits[i].position;
  	else
  	    bits = 0;
  	fsdata->encoding[i].bits = bits;
      }
  
      /* read glyphs according to the range */
--- 1411,1423 ----
      }
      /* adjust them */
      for (i = 0; i < rep.num_chars; i++) {
! 	if (ppbits[i].length || NONZEROMETRICS(&fsdata->encoding[i].metrics))
  	    bits = (char *) pbitmaps + ppbits[i].position;
  	else
  	    bits = 0;
  	fsdata->encoding[i].bits = bits;
+ 	/* copy the pointer into inkMetrics so _fs_get_metrics can use it */
+ 	fsdata->inkMetrics[i].bits = bits;
      }
  
      /* read glyphs according to the range */
***************
*** 1376,1381 ****
--- 1471,1477 ----
      blockedglyph = (FSBlockedGlyphPtr) blockrec->data;
      blockedglyph->pfont = pfont;
      blockedglyph->expected_range = range;
+     blockedglyph->done = FALSE;
  
      /* send the request */
      req.reqType = FS_QueryXBitmaps8;
***************
*** 1474,1562 ****
      return Successful;
  }
  
- static int
- fs_send_load_extents(client, pfont, flags, nranges, range)
-     pointer     client;
-     FontPtr     pfont;
-     int         nranges;
-     fsRange    *range;
- {
-     FSBlockDataPtr blockrec;
-     FSBlockedExtentPtr blockedextent;
-     int         res;
-     fsQueryXBitmaps8Req req;
-     FSFontDataPtr fsd = (FSFontDataPtr) (pfont->fpePrivate);
-     FontPathElementPtr fpe = fsd->fpe;
-     FSFpePtr    conn = (FSFpePtr) fpe->private;
  
-     /* make a new block record, and add it to the end of the list */
-     blockrec = fs_new_block_rec(fpe, client, FS_LOAD_EXTENTS);
-     if (!blockrec)
- 	return AllocError;
-     blockedextent = (FSBlockedExtentPtr) blockrec->data;
-     blockedextent->pfont = pfont;
-     blockedextent->expected_ranges = range;
-     blockedextent->nranges = nranges;
- 
-     /*
-      * see if the desired extents already exist, and return Successful if they
-      * do, otherwise build up character range/character string
-      */
-     res = fs_check_extents(pfont, flags, nranges, range, blockrec);
-     if (res == AccessDone)
- 	return Successful;
- 
-     /* send the request */
-     req.reqType = FS_QueryXExtents8;
-     req.fid = ((FSFontDataPtr) pfont->fpePrivate)->fontid;
-     req.range = TRUE;
-     req.length = (sizeof(fsQueryXExtents8Req) + sizeof(fsRange) * nranges) >> 2;
-     req.num_ranges = nranges;
-     _fs_add_req_log(conn, FS_QueryXExtents8);
-     _fs_write(conn, (char *) &req, sizeof(fsQueryXExtents8Req));
-     if (nranges)
- 	_fs_write(conn, (char *) range, sizeof(fsRange) * nranges);
- 
-     return Suspended;
- }
- 
- int
- fs_load_extents(client, pfont, flags, nranges, range,
- 		nextents, extents)
-     pointer     client;
-     FontPtr     pfont;
-     int         nranges;
-     fsRange    *range;
-     unsigned long *nextents;
-     fsCharInfo **extents;
- {
-     FSBlockDataPtr blockrec;
-     FSBlockedExtentPtr blockedextent;
-     FSFpePtr    conn = (FSFpePtr) pfont->fpe->private;
- 
-     /* see if the result is already there */
-     blockrec = (FSBlockDataPtr) conn->blocked_requests;
-     while (blockrec) {
- 	if (blockrec->type == FS_LOAD_EXTENTS && blockrec->client == client) {
- 	    blockedextent = (FSBlockedExtentPtr) blockrec->data;
- 	    if (blockedextent->pfont == pfont && blockedextent->done) {
- 
- 		/* copy the data */
- 		*nextents = blockedextent->nextents;
- 		*extents = blockedextent->extents;
- 
- 		fs_remove_blockrec(conn, blockrec);
- 		return Successful;
- 	    }
- 	}
- 	blockrec = blockrec->next;
-     }
- 
-     /* didn't find waiting record, so send a new one */
-     return fs_send_load_extents(client, pfont, flags, nranges, range);
- }
- 
- 
  /*
   * almost identical to the above, but meant for FS chaining
   */
--- 1570,1576 ----
***************
*** 1619,1712 ****
  }
  
  static int
- fs_send_load_bitmaps(client, pfont, format, flags, nranges, range)
-     pointer     client;
-     FontPtr     pfont;
-     fsBitmapFormat format;
-     int         nranges;
-     fsRange    *range;
- {
-     FSBlockDataPtr blockrec;
-     FSBlockedBitmapPtr blockedbitmap;
-     int         res;
-     fsQueryXBitmaps8Req req;
-     FSFontDataPtr fsd = (FSFontDataPtr) (pfont->fpePrivate);
-     FontPathElementPtr fpe = fsd->fpe;
-     FSFpePtr    conn = (FSFpePtr) fpe->private;
- 
-     /* make a new block record, and add it to the end of the list */
-     blockrec = fs_new_block_rec(fpe, client, FS_LOAD_BITMAPS);
-     if (!blockrec)
- 	return AllocError;
-     blockedbitmap = (FSBlockedBitmapPtr) blockrec->data;
-     blockedbitmap->pfont = pfont;
-     blockedbitmap->expected_ranges = range;
-     blockedbitmap->nranges = nranges;
- 
-     /*
-      * see if the desired glyphs already exist, and return Successful if they
-      * do, otherwise build up character range/character string
-      */
-     res = fs_check_bitmaps(pfont, format, flags, nranges, range, blockrec);
-     if (res == AccessDone)
- 	return Successful;
- 
-     /* send the request */
-     req.reqType = FS_QueryXBitmaps8;
-     req.fid = ((FSFontDataPtr) pfont->fpePrivate)->fontid;
-     req.format = format;
-     req.range = TRUE;
-     req.length = (sizeof(fsQueryXBitmaps8Req) + sizeof(fsRange) * nranges) >> 2;
-     req.num_ranges = nranges;
-     _fs_add_req_log(conn, FS_QueryXBitmaps8);
-     _fs_write(conn, (char *) &req, sizeof(fsQueryXBitmaps8Req));
-     _fs_write(conn, (char *) range, sizeof(fsRange) * nranges);
- 
-     return Suspended;
- }
- 
- int
- fs_load_bitmaps(client, pfont, format, flags, nranges, range,
- 		size, nglyphs, offsets, gdata)
-     pointer     client;
-     FontPtr     pfont;
-     fsBitmapFormat format;
-     int         nranges;
-     fsRange    *range;
-     unsigned long *size;
-     unsigned long *nglyphs;
-     fsOffset  **offsets;
-     pointer    *gdata;
- {
-     FSBlockDataPtr blockrec;
-     FSBlockedBitmapPtr blockedbitmap;
-     FSFpePtr    conn = (FSFpePtr) pfont->fpe->private;
- 
-     /* see if the result is already there */
-     blockrec = (FSBlockDataPtr) conn->blocked_requests;
-     while (blockrec) {
- 	if (blockrec->type == FS_LOAD_BITMAPS && blockrec->client == client) {
- 	    blockedbitmap = (FSBlockedBitmapPtr) blockrec->data;
- 	    if (blockedbitmap->pfont == pfont && blockedbitmap->done) {
- 
- 		/* copy the data */
- 		*size = blockedbitmap->size;
- 		*nglyphs = blockedbitmap->nglyphs;
- 		*offsets = blockedbitmap->offsets;
- 		*gdata = blockedbitmap->gdata;
- 
- 		fs_remove_blockrec(conn, blockrec);
- 		return Successful;
- 	    }
- 	}
- 	blockrec = blockrec->next;
-     }
- 
-     /* didn't find waiting record, so send a new one */
-     return fs_send_load_bitmaps(client, pfont, format, flags, nranges, range);
- }
- 
- static int
  fs_read_list(fpe, blockrec)
      FontPathElementPtr fpe;
      FSBlockDataPtr blockrec;
--- 1633,1638 ----
***************
*** 1840,1845 ****
--- 1766,1773 ----
      return fs_send_list_fonts(client, fpe, pattern, patlen, maxnames, newnames);
  }
  
+ static int  padlength[4] = {0, 3, 2, 1};
+ 
  static int
  fs_read_list_info(fpe, blockrec)
      FontPathElementPtr fpe;
***************
*** 1852,1863 ****
      fsPropOffset *po;
      char       *name;
      pointer     pd;
  
      /* clean up anything from the last trip */
!     if (binfo->pfi) {
  	xfree(binfo->name);
  	xfree(binfo->pfi->isStringProp);
  	xfree(binfo->pfi->props);
      }
      /* get reply header */
      bcopy((char *) &blockrec->header, (char *) &rep, sizeof(fsReplyHeader));
--- 1780,1798 ----
      fsPropOffset *po;
      char       *name;
      pointer     pd;
+     int		err;
  
      /* clean up anything from the last trip */
!     if (binfo->name)
!     {
  	xfree(binfo->name);
+ 	binfo->name = NULL;
+     }
+     if (binfo->pfi) {
  	xfree(binfo->pfi->isStringProp);
  	xfree(binfo->pfi->props);
+ 	xfree(binfo->pfi);
+ 	binfo->pfi = NULL;
      }
      /* get reply header */
      bcopy((char *) &blockrec->header, (char *) &rep, sizeof(fsReplyHeader));
***************
*** 1867,1872 ****
--- 1802,1811 ----
  	binfo->errcode = AllocError;
  	return AllocError;
      }
+     if (conn->fsMajorVersion > 1)
+ 	if (rep.nameLength == 0)
+ 	    goto done;
+     /* old protocol sent a full-length reply even for the last one */
      if (_fs_read(conn, (char *) &rep + sizeof(fsReplyHeader),
  	  sizeof(fsListFontsWithXInfoReply) - sizeof(fsReplyHeader)) == -1) {
  	goto done;
***************
*** 1880,1885 ****
--- 1819,1825 ----
      if (!name || !binfo->pfi) {
  	xfree(name);
  	xfree(binfo->pfi);
+ 	binfo->pfi = NULL;
  	_fs_drain_bytes(conn,
  			rep.length - (sizeof(fsListFontsWithXInfoReply) -
  				      sizeof(fsReplyHeader)));
***************
*** 1886,1895 ****
  	binfo->errcode = AllocError;
  	return AllocError;
      }
!     if (_fs_read_pad(conn, name, rep.nameLength) == -1 ||
! 	    _fs_read_pad(conn, (char *) &pi, sizeof(fsPropInfo)) == -1) {
! 	goto done;
!     }
      po = (fsPropOffset *) xalloc(sizeof(fsPropOffset) * pi.num_offsets);
      pd = (pointer) xalloc(pi.data_len);
      if (!po || !pd) {
--- 1826,1837 ----
  	binfo->errcode = AllocError;
  	return AllocError;
      }
!     if (conn->fsMajorVersion == 1)
! 	if (_fs_read_pad(conn, name, rep.nameLength) == -1)
! 	    goto done;
!     if (_fs_read_pad(conn, (char *) &pi, sizeof(fsPropInfo)) == -1)
! 	    goto done;
! 
      po = (fsPropOffset *) xalloc(sizeof(fsPropOffset) * pi.num_offsets);
      pd = (pointer) xalloc(pi.data_len);
      if (!po || !pd) {
***************
*** 1896,1913 ****
  	xfree(name);
  	xfree(po);
  	xfree(pd);
  	binfo->errcode = AllocError;
  	return AllocError;
      }
!     if (_fs_read_pad(conn, (char *) po,
! 		     (pi.num_offsets * sizeof(fsPropOffset))) == -1 ||
! 	    _fs_read_pad(conn, (char *) pd, pi.data_len) == -1) {
  	xfree(name);
  	xfree(po);
  	xfree(pd);
  	goto done;
      }
!     fs_convert_lfwi_reply(binfo->pfi, &rep, &pi, po, pd);
      xfree(po);
      xfree(pd);
      binfo->name = name;
--- 1838,1882 ----
  	xfree(name);
  	xfree(po);
  	xfree(pd);
+ 	xfree (binfo->pfi);
+ 	binfo->pfi = NULL;
  	binfo->errcode = AllocError;
  	return AllocError;
      }
!     err = _fs_read_pad(conn, (char *) po,
! 		       (pi.num_offsets * sizeof(fsPropOffset)));
!     if (err != -1)
!     {
! 	if (conn->fsMajorVersion > 1)
! 	    err = _fs_read(conn, (char *) pd, pi.data_len);
! 	else
! 	    err = _fs_read_pad(conn, (char *) pd, pi.data_len);
!     }
!     if (err != -1  &&  conn->fsMajorVersion != 1)
!     {
! 	err = _fs_read(conn, name, rep.nameLength);
! 	if (err != -1)
! 	    err = _fs_drain_bytes(conn, padlength[(pi.data_len+rep.nameLength)&3]);
!     }
! 
!     if (err == -1) {
  	xfree(name);
  	xfree(po);
  	xfree(pd);
+ 	xfree (binfo->pfi);
+ 	binfo->pfi = NULL;
  	goto done;
      }
! 
!     if (fs_convert_lfwi_reply(conn, binfo->pfi, &rep, &pi, po, pd) != Successful)
!     {
! 	xfree(name);
! 	xfree(po);
! 	xfree(pd);
! 	xfree (binfo->pfi);
! 	binfo->pfi = NULL;
! 	goto done;
!     }
      xfree(po);
      xfree(pd);
      binfo->name = name;
***************
*** 2067,2076 ****
  	return;
      if (blockrec->type == FS_LIST_WITH_INFO)
      {
! 	FSBlockedListInfoPtr blockedinfo;
! 	blockedinfo = (FSBlockedListInfoPtr) blockrec->data;
! 	if (blockedinfo->status == FS_LFWI_REPLY)
  	    _fs_set_bit(fs_fd_mask, conn->fs_fd);
      }
      /* replace the client pointers in this block rec with the chained one */
      if (depending = blockrec->depending) {
--- 2036,2057 ----
  	return;
      if (blockrec->type == FS_LIST_WITH_INFO)
      {
! 	FSBlockedListInfoPtr binfo;
! 	binfo = (FSBlockedListInfoPtr) blockrec->data;
! 	if (binfo->status == FS_LFWI_REPLY)
  	    _fs_set_bit(fs_fd_mask, conn->fs_fd);
+     	if (binfo->name)
+ 	{
+ 	    xfree(binfo->name);
+ 	    binfo->name = NULL;
+ 	}
+     	if (binfo->pfi) 
+ 	{
+ 	    xfree(binfo->pfi->isStringProp);
+ 	    xfree(binfo->pfi->props);
+ 	    xfree(binfo->pfi);
+ 	    binfo->pfi = NULL;
+     	}
      }
      /* replace the client pointers in this block rec with the chained one */
      if (depending = blockrec->depending) {
*** /tmp/da26726	Tue Jul 14 18:05:08 1992
--- mit/fonts/lib/font/fc/fsconvert.c	Tue Jul 14 18:05:08 1992
***************
*** 1,4 ****
! /* $XConsortium: fsconvert.c,v 1.7 91/07/16 20:17:05 keith Exp $ */
  /*
   * Copyright 1990 Network Computing Devices
   *
--- 1,4 ----
! /* $XConsortium: fsconvert.c,v 1.9 92/05/12 18:07:31 gildea Exp $ */
  /*
   * Copyright 1990 Network Computing Devices
   *
***************
*** 22,32 ****
   * OR PERFORMANCE OF THIS SOFTWARE.
   *
   * Author:  	Dave Lemke, Network Computing Devices, Inc
-  *
-  *	@(#)fsconvert.c	4.2	91/05/14
-  *
-  * $NCDId: @(#)fsconvert.c,v 1.3 1991/06/10 13:21:52 lemke Exp $
-  *
   */
  /*
   * FS data conversion
--- 22,27 ----
***************
*** 59,65 ****
  }
  
  int
! fs_convert_header(hdr, pfi)
      fsFontHeader *hdr;
      FontInfoPtr pfi;
  {
--- 54,61 ----
  }
  
  int
! fs_convert_header(conn, hdr, pfi)
!     FSFpePtr    conn;
      fsFontHeader *hdr;
      FontInfoPtr pfi;
  {
***************
*** 69,80 ****
      pfi->drawDirection = (hdr->draw_direction == LeftToRightDrawDirection) ?
  	LeftToRight : RightToLeft;
      pfi->inkInside = (hdr->flags & FontInfoInkInside) != 0;
-     pfi->firstCol = hdr->char_range.min_char.low;
-     pfi->firstRow = hdr->char_range.min_char.high;
-     pfi->lastCol = hdr->char_range.max_char.low;
-     pfi->lastRow = hdr->char_range.max_char.high;
  
!     pfi->defaultCh = hdr->default_char.low + (hdr->default_char.high << 8);
  
      pfi->fontDescent = hdr->font_descent;
      pfi->fontAscent = hdr->font_ascent;
--- 65,84 ----
      pfi->drawDirection = (hdr->draw_direction == LeftToRightDrawDirection) ?
  	LeftToRight : RightToLeft;
      pfi->inkInside = (hdr->flags & FontInfoInkInside) != 0;
  
!     if (conn->fsMajorVersion > 1) {
! 	pfi->firstCol = hdr->char_range.min_char.low;
! 	pfi->firstRow = hdr->char_range.min_char.high;
! 	pfi->lastCol = hdr->char_range.max_char.low;
! 	pfi->lastRow = hdr->char_range.max_char.high;
! 	pfi->defaultCh = hdr->default_char.low + (hdr->default_char.high << 8);
!     } else {
! 	pfi->firstCol = hdr->char_range.min_char.high;
! 	pfi->firstRow = hdr->char_range.min_char.low;
! 	pfi->lastCol = hdr->char_range.max_char.high;
! 	pfi->lastRow = hdr->char_range.max_char.low;
! 	pfi->defaultCh = hdr->default_char.high + (hdr->default_char.low << 8);
!     }
  
      pfi->fontDescent = hdr->font_descent;
      pfi->fontAscent = hdr->font_ascent;
***************
*** 112,117 ****
--- 116,124 ----
                  nprops;
      char       *is_str;
  
+ /* stolen from server/include/resource.h */
+ #define BAD_RESOURCE 0xe0000000
+ 
      nprops = pfi->nprops = pi->num_offsets;
  
      dprop = (FontPropPtr) xalloc(sizeof(FontPropRec) * nprops);
***************
*** 133,138 ****
--- 140,153 ----
  	    *is_str = TRUE;
  	    dprop->value = (INT32) MakeAtom(&pd[po->value.position],
  					    po->value.length, 1);
+ 	    if (dprop->value == BAD_RESOURCE)
+ 	    {
+ 		xfree (pfi->props);
+ 		xfree (pfi->isStringProp);
+ 		pfi->props = 0;
+ 		pfi->isStringProp = 0;
+ 		return -1;
+ 	    }
  	}
      }
  
***************
*** 140,146 ****
  }
  
  int
! fs_convert_lfwi_reply(pfi, fsrep, pi, po, pd)
      FontInfoPtr pfi;
      fsListFontsWithXInfoReply *fsrep;
      fsPropInfo *pi;
--- 155,162 ----
  }
  
  int
! fs_convert_lfwi_reply(conn, pfi, fsrep, pi, po, pd)
!     FSFpePtr    conn;
      FontInfoPtr pfi;
      fsListFontsWithXInfoReply *fsrep;
      fsPropInfo *pi;
***************
*** 149,156 ****
  {
      fsFontHeader *hdr = &fsrep->header;
  
!     fs_convert_header(hdr, pfi);
!     fs_convert_props(pi, po, pd, pfi);
  
      return Successful;
  }
--- 165,173 ----
  {
      fsFontHeader *hdr = &fsrep->header;
  
!     fs_convert_header(conn, hdr, pfi);
!     if (fs_convert_props(pi, po, pd, pfi) == -1)
! 	return AllocError;
  
      return Successful;
  }
***************
*** 325,331 ****
      return Successful;
  }
  
! CharInfoRec junkDefault;
  
  static int
  _fs_get_metrics(pFont, count, chars, charEncoding, glyphCount, glyphs)
--- 342,348 ----
      return Successful;
  }
  
! static CharInfoRec junkDefault;
  
  static int
  _fs_get_metrics(pFont, count, chars, charEncoding, glyphCount, glyphs)
***************
*** 339,350 ****
      int         ret;
      FSFontPtr   fsfont;
      int         i;
! 
      fsfont = (FSFontPtr) pFont->fontPrivate;
      if (!fsfont->pDefault)
  	fsfont->pDefault = &junkDefault;
      ret = _fs_get_glyphs(pFont, count, chars, charEncoding,
  			 glyphCount, (CharInfoPtr *) glyphs);
  
      if (ret == Successful) {
  	if (fsfont->pDefault == &junkDefault) {
--- 356,373 ----
      int         ret;
      FSFontPtr   fsfont;
      int         i;
!     CharInfoPtr encoding;
!     
      fsfont = (FSFontPtr) pFont->fontPrivate;
      if (!fsfont->pDefault)
  	fsfont->pDefault = &junkDefault;
+ 
+     /* sleeze - smash the encoding so we get ink metrics */
+     encoding = fsfont->encoding;
+     fsfont->encoding = fsfont->inkMetrics;
      ret = _fs_get_glyphs(pFont, count, chars, charEncoding,
  			 glyphCount, (CharInfoPtr *) glyphs);
+     fsfont->encoding = encoding;
  
      if (ret == Successful) {
  	if (fsfont->pDefault == &junkDefault) {
***************
*** 377,388 ****
      FontPtr     pfont;
  {
      /* set font function pointers */
-     extern int  fs_load_bitmaps();
-     extern int  fs_load_extents();
- 
      pfont->get_glyphs = _fs_get_glyphs;
      pfont->get_metrics = _fs_get_metrics;
-     pfont->get_bitmaps = fs_load_bitmaps;
-     pfont->get_extents = fs_load_extents;
      pfont->unload_font = fs_unload_font;
  }
--- 400,406 ----
*** /tmp/da26769	Tue Jul 14 18:05:13 1992
--- mit/fonts/lib/font/fc/fsio.c	Tue Jul 14 18:05:12 1992
***************
*** 1,6 ****
! /* $XConsortium: fsio.c,v 1.21 91/07/19 20:55:30 rws Exp $ */
  /*
-  *
   * Copyright 1990 Network Computing Devices
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
--- 1,5 ----
! /* $XConsortium: fsio.c,v 1.23 92/05/14 16:52:27 gildea Exp $ */
  /*
   * Copyright 1990 Network Computing Devices
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
***************
*** 23,30 ****
   * OR PERFORMANCE OF THIS SOFTWARE.
   *
   * Author:  	Dave Lemke, Network Computing Devices, Inc
-  *
-  * $NCDId: @(#)fsio.c,v 1.7 1991/07/02 13:13:43 lemke Exp $
   */
  /*
   * font server i/o routines
--- 22,27 ----
***************
*** 213,220 ****
      conn->fs_fd = _fs_connect(servername, 5);
      if (conn->fs_fd < 0)
  	return FALSE;
-     conn->servername = (char *) xalloc(strlen(servername) + 1);
-     strcpy(conn->servername, servername);
  
      conn->generation = ++generationCount;
  
--- 210,215 ----
***************
*** 239,244 ****
--- 234,243 ----
      if (_fs_read(conn, (char *) &rep, sizeof(fsConnSetup)) == -1)
  	return FALSE;
  
+     conn->fsMajorVersion = rep.major_version;
+     if (rep.major_version > FS_PROTOCOL)
+ 	return FALSE;
+ 
      alts = 0;
      /* parse alternate list */
      if (nalts = rep.num_alternates) {
***************
*** 308,313 ****
--- 307,317 ----
      xfree(auth_data);
      xfree(vendor_string);
  
+     conn->servername = (char *) xalloc(strlen(servername) + 1);
+     if (conn->servername == NULL)
+ 	return FALSE;
+     strcpy(conn->servername, servername);
+ 
      return TRUE;
  }
  
***************
*** 392,397 ****
--- 396,402 ----
  		errno = EPIPE;
  		return -1;
  	    }
+ 	    errno = 0;
  	} else if (errno == EINTR) {
  	    continue;
  	} else {		/* something bad happened */
*** /tmp/da26791	Tue Jul 14 18:05:15 1992
--- mit/fonts/lib/font/fc/fservestr.h	Tue Jul 14 18:05:14 1992
***************
*** 1,10 ****
! /* $XConsortium: fservestr.h,v 1.6 91/06/21 18:15:45 keith Exp $ */
  /*
   * Copyright 1990 Network Computing Devices
   *
!  * Permission to use, copy, modify, distribute, and sell this software and its
!  * documentation for any purpose is hereby granted without fee, provided that
!  * the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the name of Network Computing Devices not be
   * used in advertising or publicity pertaining to distribution of the
--- 1,10 ----
! /* $XConsortium: fservestr.h,v 1.8 92/07/09 16:11:10 gildea Exp $ */
  /*
   * Copyright 1990 Network Computing Devices
   *
!  * Permission to use, copy, modify, distribute, and sell this software and
!  * its documentation for any purpose is hereby granted without fee, provided
!  * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the name of Network Computing Devices not be
   * used in advertising or publicity pertaining to distribution of the
***************
*** 22,29 ****
   * OR PERFORMANCE OF THIS SOFTWARE.
   *
   * Author:  	Dave Lemke, Network Computing Devices, Inc
-  *
-  * $NCDId: @(#)fservestr.h,v 1.2 1991/05/24 15:03:06 lemke Exp $
   */
  
  #ifndef _FSERVESTR_H_
--- 22,27 ----
***************
*** 48,53 ****
--- 46,52 ----
  typedef struct _fs_font {
      CharInfoPtr pDefault;
      CharInfoPtr encoding;
+     CharInfoPtr inkMetrics;
      pointer     bitmaps;
  }           FSFontRec, *FSFontPtr;
  
*** /tmp/da26813	Tue Jul 14 18:05:17 1992
--- mit/fonts/lib/font/fc/fsio.h	Tue Jul 14 18:05:16 1992
***************
*** 1,4 ****
! /* $XConsortium: fsio.h,v 1.9 91/07/18 22:40:50 keith Exp $ */
  /*
   * Copyright 1990 Network Computing Devices
   *
--- 1,4 ----
! /* $XConsortium: fsio.h,v 1.10 92/05/12 18:07:38 gildea Exp $ */
  /*
   * Copyright 1990 Network Computing Devices
   *
***************
*** 22,29 ****
   * OR PERFORMANCE OF THIS SOFTWARE.
   *
   * Author:  	Dave Lemke, Network Computing Devices, Inc
-  *
-  * $NCDId: @(#)fsio.h,v 1.4 1991/07/03 17:52:30 lemke Exp $
   */
  
  #ifndef	_FSIO_H_
--- 22,27 ----
***************
*** 56,61 ****
--- 54,60 ----
  
      int         generation;
      int         numAlts;
+     int		fsMajorVersion; /* font server major version number */
      FSFpeAltPtr alts;
  
      FSClientPtr	clients;
*** /tmp/da11492	Mon Jul 20 16:43:04 1992
--- mit/fonts/lib/font/Speedo/spfont.c	Mon Jul 20 16:43:03 1992
***************
*** 1,4 ****
! /* $XConsortium: spfont.c,v 1.13 91/09/16 11:42:28 keith Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
--- 1,4 ----
! /* $XConsortium: spfont.c,v 1.16 92/05/12 18:07:52 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
***************
*** 22,30 ****
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
   * Author: Dave Lemke, Network Computing Devices Inc
-  *
-  * $NCDId: @(#)spfont.c,v 4.9 1991/07/02 17:01:30 lemke Exp $
-  *
   */
  
  /*
--- 22,27 ----
***************
*** 47,55 ****
  
  extern void SpeedoCloseFont();
  static int  get_sp_glyphs(),
!             get_sp_bitmaps(),
!             get_sp_metrics(),
!             get_sp_extents();
  static int load_sp_font();
  
  static CharInfoRec junkDefault;
--- 44,50 ----
  
  extern void SpeedoCloseFont();
  static int  get_sp_glyphs(),
!             get_sp_metrics();
  static int load_sp_font();
  
  static CharInfoRec junkDefault;
***************
*** 69,455 ****
      dst->attributes = 0;
  }
  
- /* XXX -- may have to add in some work for setting default metrics values */
- 
- /* ARGSUSED */
  static int
- get_sp_extents(client, pfont, flags, num_ranges, range, num_extents, data)
-     pointer     client;
-     FontPtr     pfont;
-     Mask        flags;
-     unsigned long num_ranges;
-     fsRange    *range;
-     unsigned long *num_extents;
-     fsCharInfo **data;
- {
-     int         start,
-                 end,
-                 i,
-                 j;
-     unsigned long size;
-     fsCharInfo *ci,
-                *pci;
-     fsRange    *rp;
-     FontInfoPtr pinfo;
-     SpeedoFontPtr spf;
-     SpeedoMasterFontPtr master;
-     CharInfoRec src;
-     int		firstChar;
- 
-     assert(pfont);
-     pinfo = &pfont->info;
-     spf = (SpeedoFontPtr) pfont->fontPrivate;
-     master = spf->master;
- 
-     firstChar = master->first_char_id;
-     if (flags & LoadAll) {
- 	start = master->first_char_id;
- 	end = master->max_id;
- 
- 	*num_extents = end - start + 1;
- 	size = sizeof(fsCharInfo) * (*num_extents);
- 	pci = ci = (fsCharInfo *) xalloc(size);
- 	if (!ci)
- 	    return AllocError;
- 
- 	/* copy all the extents */
- 	for (i = start; i <= end; i++) {
- 	    src = spf->encoding[i - firstChar];
- 	    CopyCharInfo(&src, pci);
- 	    pci++;
- 	}
- 
- 	/* make sure it didn't go off the end */
- 	assert(pci == (fsCharInfo *) ((char *) ci + size));
- 	assert(pci == (ci + (end - start + 1)));
- 
- 	*data = ci;
- 	return Successful;
-     }
-     /* normal case */
-     /* figure out how big everything has to be */
-     *num_extents = 0;
-     for (i = 0, rp = range; i < num_ranges; i++, rp++) {
- 	start = (rp->min_char.high << 8) + rp->min_char.low;
- 	end = (rp->max_char.high << 8) + rp->max_char.low;
- 
- 	/* range check */
- 	if (end < start ||
- 		(end > (pinfo->lastRow << 8) + pinfo->lastCol)
- 		|| (end < (pinfo->firstRow << 8) + pinfo->firstCol)
- 		|| (start > (pinfo->lastRow << 8) + pinfo->lastCol)
- 		|| (start < (pinfo->firstRow << 8) + pinfo->firstCol))
- 	    return BadCharRange;
- 
- 	*num_extents += end - start + 1;
-     }
- 
-     size = sizeof(fsCharInfo) * (*num_extents);
-     pci = ci = (fsCharInfo *) xalloc(size);
-     if (!ci)
- 	return AllocError;
- 
-     /* copy all the extents */
-     for (i = 0, rp = range; i < num_ranges; i++, rp++) {
- 	start = (rp->min_char.high << 8) + rp->min_char.low;
- 	end = (rp->max_char.high << 8) + rp->max_char.low;
- 
- 	/* copy all the extents */
- 	for (j = start; j <= end; j++) {
- 	    src = spf->encoding[j - firstChar];
- 	    CopyCharInfo(&src, pci);
- 	    pci++;
- 	}
- 
- 	/* make sure it didn't go off the end */
- 	assert(pci == (fsCharInfo *) ((char *) ci + size));
- 	assert(pci == (ci + (end - start + 1)));
-     }
- 
-     *data = ci;
- 
-     return Successful;
- }
- 
- /*
-  * packs up the glyphs as requested by the format
-  */
- 
- static int
- pack_sp_glyphs(pfont, format, flags, num_ranges, range, tsize, num_glyphs,
- 	       offsets, data, freeData)
-     FontPtr     pfont;
-     int         format;
-     Mask        flags;
-     unsigned long num_ranges;
-     fsRange    *range;
-     unsigned long *tsize;
-     unsigned long *num_glyphs;
-     fsOffset  **offsets;
-     pointer    *data;
-     int		*freeData;
- {
-     unsigned long start,
-                 end;
-     int         i;
-     fsOffset   *lengths = (fsOffset *) 0,
-                *l;
-     unsigned long size = 0;
-     pointer     gdata,
-                 gd;
-     unsigned long ch;
-     int         bitorder,
-                 byteorder,
-                 scanlinepad,
-                 scanlineunit,
-                 mappad;
-     int         bpr,
-                 skiprows = 0;
-     fsRange    *rp;
-     FontInfoPtr pinfo = &pfont->info;
-     SpeedoFontPtr spf = (SpeedoFontPtr) pfont->fontPrivate;
-     SpeedoMasterFontPtr master = spf->master;
-     int         err;
-     int         src_glyph_pad;
-     int         src_bit_order;
-     int         src_byte_order;
-     int		firstChar;
-     int         max_ascent, max_descent;
-     int         min_left, max_right;
- 	
-     err = CheckFSFormat(format, (fsBitmapFormatMask) ~ 0,
- 		&bitorder, &byteorder, &scanlineunit, &scanlinepad, &mappad);
-     if (err != Successful)
- 	return err;
-     (void) CheckFSFormat(pfont->format, (fsBitmapFormatMask) ~ 0,
- 		&src_bit_order, &src_byte_order, &err, &src_glyph_pad, &err);
- 
-     if (!spf->pDefault)
- 	spf->pDefault = &junkDefault;
- 
-     *freeData = TRUE;
-     firstChar = master->first_char_id;
-     /* special case for all glyphs first */
-     if (flags & LoadAll) {
- 	start = master->first_char_id;
- 	end = master->max_id;
- 	*num_glyphs = end - start + 1;
- 	size = compute_sp_data_size(pfont, mappad, scanlinepad, start, end);;
- 	num_ranges = 1;
-     } else {
- 	*num_glyphs = 0;
- 	for (i = 0, rp = range; i < num_ranges; i++, rp++) {
- 	    start = (rp->min_char.high << 8) + rp->min_char.low;
- 	    end = (rp->max_char.high << 8) + rp->max_char.low;
- 
- 	    /* range check */
- 	    if (end < start ||
- 		    (end > (pinfo->lastRow << 8) + pinfo->lastCol)
- 		    || (end < (pinfo->firstRow << 8) + pinfo->firstCol)
- 		    || (start > (pinfo->lastRow << 8) + pinfo->lastCol)
- 		    || (start < (pinfo->firstRow << 8) + pinfo->firstCol))
- 		return BadCharRange;
- 
- 	    *num_glyphs += end - start + 1;
- 	    size += compute_sp_data_size(pfont, mappad, scanlinepad, start, end);
- 	}
-     }
- 
-     gd = gdata = (pointer) xalloc(size);
-     if (!gdata)
- 	return AllocError;
-     if (mappad == BitmapFormatImageRectMax)
- 	bzero((char *) gdata, size);
- 
-     /* get space for glyph offsets */
-     l = lengths = (fsOffset *) xalloc(sizeof(fsOffset) *
- 				      *num_glyphs);
-     if (!lengths) {
- 	xfree((char *) gdata);
- 	return AllocError;
-     }
-     /* compute bpr for padded out fonts */
-     switch (mappad)
-     {
-     case BitmapFormatImageRectMax:
- 	max_ascent = FONT_MAX_ASCENT(pinfo);
- 	max_descent = FONT_MAX_DESCENT(pinfo);
- 	/* fall through */
-     case BitmapFormatImageRectMaxWidth:
- 	min_left = FONT_MIN_LEFT(pinfo);
- 	max_right = FONT_MAX_RIGHT(pinfo);
- 	bpr = GLWIDTHBYTESPADDED(max_right - min_left, scanlinepad);
- 	break;
-     case BitmapFormatImageRectMin:
- 	break;
-     }
-     /* finally do the work */
-     for (i = 0, rp = range; i < num_ranges; i++, rp++) {
- 	/*
- 	 * compute start & end.  if all_glyphs is set, we still have them
- 	 * laying around
- 	 */
- 	if (!(flags & LoadAll)) {
- 	    start = (rp->min_char.high << 8) + rp->min_char.low;
- 	    end = (rp->max_char.high << 8) + rp->max_char.low;
- 	}
- 	for (ch = start; ch <= end; ch++) {
- 	    CharInfoPtr ci;
- 	    xCharInfo  *cim;
- 	    int         srcbpr;
- 	    unsigned char	*src, *dst;
- 	    unsigned int	bits1, bits2;
- 	    int         r,
- 			lshift = 0,
- 			rshift = 0,
- 			width,
- 			w,
- 			src_extra,
- 			dst_extra;
- 
- 	    l->position = gd - gdata;
- 	    ci = &spf->encoding[ch - firstChar];
- 
- 	    /* ignore missing chars */
- 	    if (!ci) 
- 	    {
- 		l->length = 0;
- 		l++;
- 		continue;
- 	    }
- 
- 	    cim = &ci->metrics;
- 
- 	    /* sanity check */
- 	    assert((cim->rightSideBearing - cim->leftSideBearing) <= (pinfo->maxbounds.rightSideBearing - pinfo->minbounds.leftSideBearing));
- 
- 	    srcbpr = GLWIDTHBYTESPADDED(cim->rightSideBearing -
- 					cim->leftSideBearing, src_glyph_pad);
- 
- 
- 	    /*
- 	     * caculate bytes-per-row for PadNone (others done in allocation
- 	     * phase), what (if anything) to ignore or add as padding
- 	     */
- 	    switch (mappad) {
- 	    case BitmapFormatImageRectMin:
- 		bpr = GLYPH_SIZE(ci, scanlinepad);
- 		break;
- 	    case BitmapFormatImageRectMax:
- 		/* leave the first padded rows blank */
- 		gd += bpr * (max_ascent - cim->ascent);
- 		skiprows = bpr * (max_descent - cim->descent);
- 		/* fall thru */
- 	    case BitmapFormatImageRectMaxWidth:
- 		rshift = cim->leftSideBearing - min_left;
- 		lshift = 8 - lshift;
- 		break;
- 	    }
- 	    src = (unsigned char *) ci->bits;
- 	    dst = gd;
- 
- 	    width = srcbpr;
- 	    if (srcbpr > bpr)
- 		width = bpr;
- 	    src_extra = srcbpr - width;
- 	    dst_extra = bpr - width;
- 
- #if (DEFAULTBITORDER == MSBFirst)
- #define BitLeft(b,c)	((b) << (c))
- #define BitRight(b,c)	((b) >> (c))
- #else
- #define BitLeft(b,c)	((b) >> (c))
- #define BitRight(b,c)	((b) << (c))
- #endif
- 
- 	    if (!rshift)
- 	    {
- 		if (srcbpr == bpr)
- 		{
- 		    r = (cim->ascent + cim->descent) * width;
- 		    bcopy (src, dst, r);
- 		    dst += r;
- 		}
- 		else
- 		{
- 		    for (r = cim->ascent + cim->descent; r; r--)
- 		    {
- 			for (w = width; w; w--)
- 			    *dst++ = *src++;
- 			dst += dst_extra;
- 			src += src_extra;
- 		    }
- 		}
- 	    }
- 	    else
- 	    {
- 		for (r = cim->ascent + cim->descent; r; r--)
- 		{
- 		    bits2 = 0;
- 		    for (w = width; w; w--)
- 		    {
- 			bits1 = *src++;
- 			*dst++ = BitRight(bits1, rshift) |
- 				 BitLeft (bits2, lshift);
- 			bits2 = bits1;
- 		    }
- 		    dst += dst_extra;
- 		    src += src_extra;
- 		}
- 	    }
- 	    dst += skiprows;
- 	    l->length = dst - gd;
- 	    gd = dst;
- 	    l++;
- 	}
-     }
- 
- 
-     bitorder = (bitorder == BitmapFormatBitOrderLSB) ?
- 	LSBFirst : MSBFirst;
-     byteorder = (byteorder == BitmapFormatByteOrderLSB) ?
- 	LSBFirst : MSBFirst;
- 
-     /* now do the bit, byte, word swapping */
-     if (bitorder != src_bit_order)
- 	BitOrderInvert(gdata, size);
-     if (byteorder != src_byte_order) {
- 	if (scanlineunit == 2)
- 	    TwoByteSwap(gdata, size);
- 	else if (scanlineunit == 4)
- 	    FourByteSwap(gdata, size);
-     }
-     *data = gdata;
-     *tsize = size;
-     *offsets = lengths;
- 
-     return Successful;
- }
- 
- /* ARGSUSED */
- static int
- get_sp_bitmaps(client, pfont, format, flags, num_ranges, range,
- 	       size, num_glyphs, offsets, data, freeData)
-     pointer     client;
-     FontPtr     pfont;
-     fsBitmapFormat format;
-     Mask        flags;
-     unsigned long num_ranges;
-     fsRange    *range;
-     unsigned long *size;
-     unsigned long *num_glyphs;
-     fsOffset  **offsets;
-     pointer    *data;
-     int		*freeData;
- {
-     *size = 0;
-     *data = (pointer) 0;
-     *num_glyphs = 0;
-     return pack_sp_glyphs(pfont, format, flags,
- 		  num_ranges, range, size, num_glyphs, offsets, data, freeData);
- }
- 
- static int
  get_sp_glyphs(pFont, count, chars, charEncoding, glyphCount, glyphs)
      FontPtr     pFont;
      unsigned long count;
--- 64,70 ----
***************
*** 626,632 ****
  {
      SpeedoFontPtr spf;
      SpeedoMasterFontPtr spmf;
-     FontPtr     mpfont;
      int         ret;
      char        tmpname[MAXFONTNAMELEN];
      specs_t     specs;
--- 241,246 ----
***************
*** 633,660 ****
      FontScalableRec vals;
      double      pointsize;
  
!     /* make a master if we don't have one */
!     if (entry) {
! 	mpfont = (FontPtr) entry->u.scalable.extra->private;
! 	if (!mpfont) {
! 	    mpfont = (FontPtr) xalloc(sizeof(FontRec));
! 	    if (!mpfont)
! 		return AllocError;
! 	    flags |= FontLoadBitmaps;	/* make sure a master is all there */
! 	    ret = load_sp_font(entry->name.name, filename, (FontEntryPtr) 0,
! 			       format, fmask, mpfont, flags);
! 	    if (ret != Successful) {
! 		xfree(mpfont);
! 		return ret;
! 	    }
! 	    entry->u.scalable.extra->private = (pointer) mpfont;
! 	}
! 	spf = (SpeedoFontPtr) mpfont->fontPrivate;
! 	spmf = spf->master;
!     } else {
  	ret = open_master(filename, &spmf);
  	if (ret != Successful)
  	    return ret;
      }
  
      spf = (SpeedoFontPtr) xalloc(sizeof(SpeedoFontRec));
--- 247,261 ----
      FontScalableRec vals;
      double      pointsize;
  
!     /* find a master (create it if necessary) */
!     spmf = (SpeedoMasterFontPtr) entry->u.scalable.extra->private;
!     if (!spmf)
!     {
  	ret = open_master(filename, &spmf);
  	if (ret != Successful)
  	    return ret;
+ 	entry->u.scalable.extra->private = (pointer) spmf;
+ 	spmf->entry = entry;
      }
  
      spf = (SpeedoFontPtr) xalloc(sizeof(SpeedoFontRec));
***************
*** 663,675 ****
--- 264,281 ----
      bzero((char *) spf, sizeof(SpeedoFontRec));
  
      spf->master = spmf;
+     spf->entry = entry;
      spmf->refcount++;
      sp_reset_master(spmf);
+     /* now we've done enough that if we bail out we must call close_sp_font */
  
      /* tear apart name to get sizes */
      strcpy(tmpname, fontname);
      if (!FontParseXLFDName(tmpname, &vals, FONT_XLFD_REPLACE_NONE))
+     {
+ 	close_sp_font(spf);
  	return BadFontName;
+     }
  
      fixup_vals(&vals);
      if (vals.point > 0)
***************
*** 697,709 ****
      specs.flags = MODE_SCREEN;
      specs.out_info = NULL;
  
      if (!sp_set_specs(&specs))
  	return BadFontName;
  
      spf->specs = specs;
  
      *spfont = spf;
- 
      return Successful;
  }
  
--- 303,334 ----
      specs.flags = MODE_SCREEN;
      specs.out_info = NULL;
  
+     /* When Speedo tries to generate a very small font bitmap, it
+        often crashes or goes into an infinite loop.
+        Don't know why this is so, but until we can fix it properly,
+        return BadFontName for anything smaller than 4 pixels.
+        */
+ #define TINY_FACTOR (4 << 16)
+     /* XXX may have to do more tweaking for ROTATED_TEXT */
+     if (specs.xxmult < TINY_FACTOR  ||  specs.yymult < TINY_FACTOR)
+     {
+ 	close_sp_font(spf);
+ 	return BadFontName;
+     }
+ 
+     /* clobber global state to avoid wrecking future obliqued fonts */
+     bzero ((char *) &sp_globals, sizeof(sp_globals));
+ 
      if (!sp_set_specs(&specs))
+     {
+ 	close_sp_font(spf);
  	return BadFontName;
+     }
  
      spf->specs = specs;
+     spf->master = spmf;
  
      *spfont = spf;
      return Successful;
  }
  
***************
*** 724,729 ****
--- 349,357 ----
  
      ret = open_sp_font(fontname, filename, entry, format, fmask, flags, &spf);
  
+     if (ret != Successful)
+ 	return ret;
+ 
      spmf = spf->master;
      sp_reset_master(spmf);
      esize = sizeof(CharInfoRec) * (spmf->max_id - spmf->first_char_id + 1);
***************
*** 759,773 ****
  
      pfont->format = format;
  
-     pfont->get_bitmaps = get_sp_bitmaps;
      pfont->get_metrics = get_sp_metrics;
      pfont->get_glyphs = get_sp_glyphs;
-     pfont->get_extents = get_sp_extents;
      pfont->unload_font = SpeedoCloseFont;
      pfont->refcnt = 0;
      pfont->maxPrivate = -1;
      pfont->devPrivates = (pointer *) 0;
  
      close_master_file(spmf);
  
      return ret;
--- 387,400 ----
  
      pfont->format = format;
  
      pfont->get_metrics = get_sp_metrics;
      pfont->get_glyphs = get_sp_glyphs;
      pfont->unload_font = SpeedoCloseFont;
      pfont->refcnt = 0;
      pfont->maxPrivate = -1;
      pfont->devPrivates = (pointer *) 0;
  
+     /* have to hold on to master for min/max id */
      close_master_file(spmf);
  
      return ret;
***************
*** 794,800 ****
  
      if (ret == Successful)
  	*ppfont = pfont;
! 
      return ret;
  }
  
--- 421,429 ----
  
      if (ret == Successful)
  	*ppfont = pfont;
!     else
! 	xfree (pfont);
!     
      return ret;
  }
  
***************
*** 805,817 ****
      SpeedoMasterFontPtr spmf;
  
      spmf = spf->master;
!     if (--spmf->refcount == 0) {
! 	if (spmf->state & MasterFileOpen) {
! 	    (void) fclose(spmf->fp);
! 	    xfree(spmf->f_buffer);
! 	    xfree(spmf->c_buffer);
! 	}
!     }
      xfree(spf->encoding);
      xfree(spf->bitmaps);
      xfree(spf);
--- 434,442 ----
      SpeedoMasterFontPtr spmf;
  
      spmf = spf->master;
!     --spmf->refcount;
!     if (spmf->refcount == 0)
! 	close_master_font (spmf);
      xfree(spf->encoding);
      xfree(spf->bitmaps);
      xfree(spf);
*** /tmp/da11514	Mon Jul 20 16:43:06 1992
--- mit/fonts/lib/font/Speedo/spfuncs.c	Mon Jul 20 16:43:06 1992
***************
*** 1,4 ****
! /* $XConsortium: spfuncs.c,v 1.5 91/09/16 11:42:30 keith Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
--- 1,4 ----
! /* $XConsortium: spfuncs.c,v 1.7 92/04/15 14:35:48 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
***************
*** 22,30 ****
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
   * Author: Dave Lemke, Network Computing Devices, Inc
-  *
-  * $NCDId: @(#)spfuncs.c,v 4.8 1991/07/02 17:01:44 lemke Exp $
-  *
   */
  
  #include	<X11/Xos.h>
--- 22,27 ----
***************
*** 72,79 ****
  
      err = open_sp_font(fontname, filename, entry,
  	       (fsBitmapFormat) 0, (fsBitmapFormatMask) 0, (unsigned long) 0,
! 		       spfont);
!     spf = *spfont;
  
      if (err != Successful)
  	return err;
--- 69,75 ----
  
      err = open_sp_font(fontname, filename, entry,
  	       (fsBitmapFormat) 0, (fsBitmapFormatMask) 0, (unsigned long) 0,
! 		       &spf);
  
      if (err != Successful)
  	return err;
***************
*** 90,95 ****
--- 86,93 ----
      /* compute remaining accelerators */
      FontComputeInfoAccelerators (pinfo);
  
+     *spfont = spf;
+ 
      return Successful;
  }
  
***************
*** 102,108 ****
      char		*fileName;
      FontScalablePtr	vals;
  {
!     SpeedoFontPtr spf;
      char        fullName[MAXFONTNAMELEN];
      int         err;
  
--- 100,106 ----
      char		*fileName;
      FontScalablePtr	vals;
  {
!     SpeedoFontPtr spf = NULL;
      char        fullName[MAXFONTNAMELEN];
      int         err;
  
***************
*** 113,119 ****
  
      err = get_font_info(pFontInfo, fullName, fileName, entry, &spf);
  
!     close_sp_font(spf);
      return err;
  }
  
--- 111,119 ----
  
      err = get_font_info(pFontInfo, fullName, fileName, entry, &spf);
  
!     if (spf)
! 	close_sp_font(spf);
! 
      return err;
  }
  
*** /tmp/da27273	Tue Jul 14 18:06:01 1992
--- mit/fonts/lib/font/Speedo/spfile.c	Tue Jul 14 18:06:00 1992
***************
*** 1,4 ****
! /* $XConsortium: spfile.c,v 1.4 91/07/15 18:16:46 keith Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
--- 1,4 ----
! /* $XConsortium: spfile.c,v 1.6 92/04/09 18:13:03 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
***************
*** 154,159 ****
--- 154,162 ----
      if (!spmf)
  	return AllocError;
      bzero(spmf, sizeof(SpeedoMasterFontRec));
+     spmf->entry = NULL;
+     spmf->f_buffer = NULL;
+     spmf->c_buffer = NULL;
  
      /* open font */
      spmf->fname = (char *) xalloc(strlen(filename) + 1);
***************
*** 265,270 ****
--- 268,275 ----
  	return;
      if (spmf->state & MasterFileOpen)
  	fclose(spmf->fp);
+     if (spmf->entry)
+ 	spmf->entry->u.scalable.extra->private = NULL;
      xfree(spmf->fname);
      xfree(spmf->f_buffer);
      xfree(spmf->c_buffer);
*** /tmp/da27342	Tue Jul 14 18:06:08 1992
--- mit/fonts/lib/font/Speedo/spglyph.c	Tue Jul 14 18:06:07 1992
***************
*** 1,4 ****
! /* $XConsortium: spglyph.c,v 1.10 91/07/31 01:08:59 keith Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
--- 1,4 ----
! /* $XConsortium: spglyph.c,v 1.12 92/05/13 16:03:30 keith Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
***************
*** 21,30 ****
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
-  * $NCDId: @(#)spglyph.c,v 4.7 1991/06/24 16:55:40 lemke Exp $
-  *
   * Author: Dave Lemke, Network Computing Devices Inc
-  *
   */
  
  #include	<X11/X.h>	/* for bit order #defines */
--- 21,27 ----
***************
*** 34,41 ****
  
  static CurrentFontValuesRec current_font_values;
  static CurrentFontValuesPtr cfv = &current_font_values;
! static int  bit,
!             byte,
              scan;
  
  unsigned long
--- 31,38 ----
  
  static CurrentFontValuesRec current_font_values;
  static CurrentFontValuesPtr cfv = &current_font_values;
! static int  bit_order,
!             byte_order,
              scan;
  
  unsigned long
***************
*** 165,171 ****
      nmiddle = (xbit2 >> 3);
      xbit1 &= 7;
      xbit2 &= 7;
!     if (bit == MSBFirst) {
  	startmask = ((CARD8) ~0) >> xbit1;
  	endmask = ~(((CARD8) ~0) >> xbit2);
      } else {
--- 162,168 ----
      nmiddle = (xbit2 >> 3);
      xbit1 &= 7;
      xbit2 &= 7;
!     if (bit_order == MSBFirst) {
  	startmask = ((CARD8) ~0) >> xbit1;
  	endmask = ~(((CARD8) ~0) >> xbit2);
      } else {
***************
*** 260,266 ****
  	finish_line(cur_spf);
  	cfv->last_y++;
      }
!     if (byte != bit) {
  	switch (scan) {
  	case 1:
  	    break;
--- 257,263 ----
  	finish_line(cur_spf);
  	cfv->last_y++;
      }
!     if (byte_order != bit_order) {
  	switch (scan) {
  	case 1:
  	    break;
***************
*** 293,300 ****
  
      scan = 1;
      ret = CheckFSFormat(format, fmask,
! 			&bit, &byte, &scan, &glyph, &image);
  
      if (ret != Successful)
  	return BadFontFormat;
  
--- 290,301 ----
  
      scan = 1;
      ret = CheckFSFormat(format, fmask,
! 			&bit_order, &byte_order, &scan, &glyph, &image);
  
+     pfont->bit = bit_order;
+     pfont->byte = byte_order;
+     pfont->glyph = glyph;
+     pfont->scan = scan;
      if (ret != Successful)
  	return BadFontFormat;
  
*** /tmp/da27386	Tue Jul 14 18:06:11 1992
--- mit/fonts/lib/font/Speedo/spint.h	Tue Jul 14 18:06:11 1992
***************
*** 1,4 ****
! /* $XConsortium: spint.h,v 1.4 91/07/16 20:20:32 keith Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
--- 1,4 ----
! /* $XConsortium: spint.h,v 1.5 92/03/25 18:45:51 keith Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
***************
*** 52,57 ****
--- 52,58 ----
  #define	MasterFileOpen	0x1
  
  typedef struct _sp_master {
+     FontEntryPtr    entry;	/* back pointer */
      FILE       *fp;
      char       *fname;
      ufix8      *f_buffer;
***************
*** 98,103 ****
--- 99,106 ----
  typedef struct _sp_font {
      struct _sp_master *master;
      specs_t     specs;
+ 
+     FontEntryPtr    entry;
  
      FontScalableRec vals;
  
*** /tmp/da27732	Tue Jul 14 18:06:41 1992
--- mit/fonts/lib/fs/FSFontInfo.c	Tue Jul 14 18:06:41 1992
***************
*** 1,6 ****
! /* $XConsortium: FSFontInfo.c,v 1.2 91/05/13 15:11:37 gildea Exp $ */
! 
! /* @(#)FSFontInfo.c	4.1	91/05/02
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
--- 1,5 ----
! /* $XConsortium: FSFontInfo.c,v 1.4 92/05/13 15:41:58 gildea Exp $ */
! /*
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
***************
*** 47,52 ****
--- 46,52 ----
      char      **flist = NULL;
      fsListFontsWithXInfoReply reply;
      fsListFontsWithXInfoReq *req;
+     Status status;
  
      GetReq(ListFontsWithXInfo, req);
      req->maxNames = maxNames;
***************
*** 55,63 ****
      _FSSend(svr, pattern, nbytes);
  
      for (i = 0;; i++) {
! 	if (!_FSReply(svr, (fsReply *) & reply,
! 		      ((SIZEOF(fsListFontsWithXInfoReply) -
! 			SIZEOF(fsGenericReply)) >> 2), fsFalse)) {
  	    for (j = (i - 1); j >= 0; j--) {
  		FSfree((char *) fhdr[j]);
  		FSfree((char *) pi[j]);
--- 55,75 ----
      _FSSend(svr, pattern, nbytes);
  
      for (i = 0;; i++) {
! 	if (FSProtocolVersion(svr) > 1)
! 	{
! 	    status = _FSReply(svr, (fsReply *) &reply, 0, fsFalse);
! 	    if (status != 0  &&  reply.nameLength == 0)	/* got last reply */
! 		break;
! 	    if (status)
! 		_FSRead(svr, (char *) &reply.nReplies,
! 			SIZEOF(fsListFontsWithXInfoReply) -
! 			SIZEOF(fsGenericReply));
! 	} else {
! 	    status = _FSReply(svr, (fsReply *) & reply,
! 			      ((SIZEOF(fsListFontsWithXInfoReply) -
! 				SIZEOF(fsGenericReply)) >> 2), fsFalse);
! 	}
! 	if (!status) {
  	    for (j = (i - 1); j >= 0; j--) {
  		FSfree((char *) fhdr[j]);
  		FSfree((char *) pi[j]);
***************
*** 79,85 ****
  	    SyncHandle();
  	    return (char **) NULL;
  	}
! 	if (reply.nameLength == 0)	/* got last reply */
  	    break;
  	if ((i + reply.nReplies) >= size) {
  	    size = i + reply.nReplies + 1;
--- 91,97 ----
  	    SyncHandle();
  	    return (char **) NULL;
  	}
! 	if (reply.nameLength == 0)	/* got last reply in version 1 */
  	    break;
  	if ((i + reply.nReplies) >= size) {
  	    size = i + reply.nReplies + 1;
***************
*** 172,187 ****
  	    goto badmem;
  	}
  	bcopy((char *) &reply.header, (char *) fhdr[i], sizeof(fsFontHeader));
  
! 	/* get the name */
  	flist[i] = (char *) FSmalloc((unsigned int) (reply.nameLength + 1));
! 	if (!flist[i]) {
! 	    nbytes = reply.nameLength + 3 & ~3;
! 	    _FSEatData(svr, (unsigned long) nbytes);
! 	    goto badmem;
  	}
- 	_FSReadPad(svr, flist[i], (long) reply.nameLength);
- 	flist[i][reply.nameLength] = '\0';
  
  	pi[i] = (fsPropInfo *) FSmalloc(sizeof(fsPropInfo));
  	if (!pi[i]) {
--- 184,212 ----
  	    goto badmem;
  	}
  	bcopy((char *) &reply.header, (char *) fhdr[i], sizeof(fsFontHeader));
+ 	if (FSProtocolVersion(svr) == 1)
+ 	{
+ 	    fhdr[i]->char_range.min_char.high = reply.header.char_range.min_char.low;
+ 	    fhdr[i]->char_range.min_char.low = reply.header.char_range.min_char.high;
+ 	    fhdr[i]->char_range.max_char.high = reply.header.char_range.max_char.low;
+ 	    fhdr[i]->char_range.max_char.low = reply.header.char_range.max_char.high;
+ 	    fhdr[i]->default_char.high = reply.header.default_char.low;
+ 	    fhdr[i]->default_char.low = reply.header.default_char.high;
+ 	}
  
! 	/* alloc space for the name */
  	flist[i] = (char *) FSmalloc((unsigned int) (reply.nameLength + 1));
! 	if (FSProtocolVersion(svr) == 1)
! 	{
! 	    /* get the name */
! 	    if (!flist[i]) {
! 		nbytes = reply.nameLength + 3 & ~3;
! 		_FSEatData(svr, (unsigned long) nbytes);
! 		goto badmem;
! 	    }
! 	    _FSReadPad(svr, flist[i], (long) reply.nameLength);
! 	    flist[i][reply.nameLength] = '\0';
  	}
  
  	pi[i] = (fsPropInfo *) FSmalloc(sizeof(fsPropInfo));
  	if (!pi[i]) {
***************
*** 208,215 ****
  	_FSReadPad(svr, (char *) po[i],
  		   (pi[i]->num_offsets * sizeof(fsPropOffset)));
  	/* get prop data */
! 	_FSReadPad(svr, (char *) pd[i], pi[i]->data_len);
  
      }
      *info = fhdr;
      *count = i;
--- 233,257 ----
  	_FSReadPad(svr, (char *) po[i],
  		   (pi[i]->num_offsets * sizeof(fsPropOffset)));
  	/* get prop data */
! 	if (FSProtocolVersion(svr) == 1)
! 	    _FSReadPad(svr, (char *) pd[i], pi[i]->data_len);
! 	else
! 	    _FSRead(svr, (char *) pd[i], pi[i]->data_len);
  
+ 	if (FSProtocolVersion(svr) != 1)
+ 	{
+ 	    /* get the name */
+ 	    if (!flist[i]) {
+ 		nbytes = reply.nameLength + 3 & ~3;
+ 		_FSEatData(svr, (unsigned long) nbytes);
+ 		goto badmem;
+ 	    }
+ 	    _FSRead(svr, flist[i], (long) reply.nameLength);
+ 	    flist[i][reply.nameLength] = '\0';
+ 
+ 	    nbytes = pi[i]->data_len + reply.nameLength;
+ 	    _FSEatData(svr, (unsigned long) (((nbytes+3)&~3) - nbytes));
+ 	}
      }
      *info = fhdr;
      *count = i;
*** /tmp/da27843	Tue Jul 14 18:06:50 1992
--- mit/fonts/lib/fs/FSQGlyphs.c	Tue Jul 14 18:06:49 1992
***************
*** 1,29 ****
! /* $XConsortium: FSQGlyphs.c,v 1.2 91/05/13 15:11:49 gildea Exp $ */
! 
! /* @(#)FSQGlyphs.c	4.1	91/05/02
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, and distribute this protoype software
!  * and its documentation to Members and Affiliates of the MIT X Consortium
!  * any purpose and without fee is hereby granted, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * MIT not be used in advertising or publicity pertaining to distribution of
!  * the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND MIT DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
!  * AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES, DIGITAL OR MIT BE
!  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
!  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
!  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   */
  
! #include	"FSlibint.h"
  
  int
  FSQueryXBitmaps8(svr, fid, format, range_type, str, str_len, offsets, glyphdata)
--- 1,28 ----
! /* $XConsortium: FSQGlyphs.c,v 1.4 92/05/26 17:27:39 gildea Exp $ */
! /*
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, distribute, and sell this software and
!  * its documentation for any purpose is hereby granted without fee, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * M.I.T. not be used in advertising or publicity pertaining to distribution
!  * of the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND M.I.T. DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
!  * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES,
!  * DIGITAL OR M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
!  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
!  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
!  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
!  * THIS SOFTWARE.
   */
  
! #include "FSlibint.h"
  
  int
  FSQueryXBitmaps8(svr, fid, format, range_type, str, str_len, offsets, glyphdata)
***************
*** 98,104 ****
      req->format = format;
      req->num_ranges = str_len;
      req->length += ((str_len * sizeof(fsChar2b)) + 3) >> 2;
!     _FSSend(svr, (char *) str, (str_len * sizeof(fsChar2b)));
  
      /* get back the info */
      if (!_FSReply(svr, (fsReply *) & reply,
--- 97,119 ----
      req->format = format;
      req->num_ranges = str_len;
      req->length += ((str_len * sizeof(fsChar2b)) + 3) >> 2;
!     if (FSProtocolVersion(svr) == 1)
!     {
! 	int i;
! 	fsChar2b_version1 *swapped_str;
! 
! 	swapped_str = (fsChar2b_version1 *)
! 	    FSmalloc(sizeof(fsChar2b_version1) * str_len);
! 	if (!swapped_str)
! 	    return FSBadAlloc;
! 	for (i = 0; i < str_len; i++) {
! 	    swapped_str[i].low = str[i].low;
! 	    swapped_str[i].high = str[i].high;
! 	}
! 	_FSSend(svr, (char *)swapped_str, (str_len*sizeof(fsChar2b_version1)));
! 	FSfree(swapped_str);
!     } else
! 	_FSSend(svr, (char *) str, (str_len * sizeof(fsChar2b)));
  
      /* get back the info */
      if (!_FSReply(svr, (fsReply *) & reply,
*** /tmp/da27865	Tue Jul 14 18:06:52 1992
--- mit/fonts/lib/fs/FSQXExt.c	Tue Jul 14 18:06:51 1992
***************
*** 1,29 ****
! /* $XConsortium: FSQXExt.c,v 1.2 91/05/13 15:11:50 gildea Exp $ */
! 
! /* @(#)FSQXExt.c	4.1	91/05/02
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, and distribute this protoype software
!  * and its documentation to Members and Affiliates of the MIT X Consortium
!  * any purpose and without fee is hereby granted, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * MIT not be used in advertising or publicity pertaining to distribution of
!  * the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND MIT DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
!  * AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES, DIGITAL OR MIT BE
!  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
!  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
!  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   */
  
! #include	"FSlibint.h"
  
  int
  FSQueryXExtents8(svr, fid, range_type, str, str_len, extents)
--- 1,28 ----
! /* $XConsortium: FSQXExt.c,v 1.4 92/05/26 17:26:53 gildea Exp $ */
! /*
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, distribute, and sell this software and
!  * its documentation for any purpose is hereby granted without fee, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * M.I.T. not be used in advertising or publicity pertaining to distribution
!  * of the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND M.I.T. DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
!  * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES,
!  * DIGITAL OR M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
!  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
!  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
!  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
!  * THIS SOFTWARE.
   */
  
! #include "FSlibint.h"
  
  int
  FSQueryXExtents8(svr, fid, range_type, str, str_len, extents)
***************
*** 83,89 ****
      req->range = range_type;
      req->num_ranges = str_len;
      req->length += ((str_len * sizeof(fsChar2b)) + 3) >> 2;
!     _FSSend(svr, (char *) str, (str_len * sizeof(fsChar2b)));
  
      /* get back the info */
      if (!_FSReply(svr, (fsReply *) & reply,
--- 82,103 ----
      req->range = range_type;
      req->num_ranges = str_len;
      req->length += ((str_len * sizeof(fsChar2b)) + 3) >> 2;
!     if (FSProtocolVersion(svr) == 1)
!     {
! 	fsChar2b_version1 *swapped_str;
! 
! 	swapped_str = (fsChar2b_version1 *)
! 	    FSmalloc(sizeof(fsChar2b_version1) * str_len);
! 	if (!swapped_str)
! 	    return FSBadAlloc;
! 	for (i = 0; i < str_len; i++) {
! 	    swapped_str[i].low = str[i].low;
! 	    swapped_str[i].high = str[i].high;
! 	}
! 	_FSSend(svr, (char *)swapped_str, (str_len*sizeof(fsChar2b_version1)));
! 	FSfree(swapped_str);
!     } else
! 	_FSSend(svr, (char *) str, (str_len * sizeof(fsChar2b)));
  
      /* get back the info */
      if (!_FSReply(svr, (fsReply *) & reply,
*** /tmp/da27887	Tue Jul 14 18:06:54 1992
--- mit/fonts/lib/fs/FSQXInfo.c	Tue Jul 14 18:06:53 1992
***************
*** 1,6 ****
! /* $XConsortium: FSQXInfo.c,v 1.2 91/05/13 15:11:51 gildea Exp $ */
! 
! /* @(#)FSQXInfo.c	4.1	91/05/02
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
--- 1,5 ----
! /* $XConsortium: FSQXInfo.c,v 1.3 92/05/12 18:07:24 gildea Exp $ */
! /*
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
***************
*** 53,58 ****
--- 52,66 ----
  	return FSBadAlloc;
      }
      bcopy((char *) &reply.header, (char *) info, sizeof(fsFontHeader));
+     if (FSProtocolVersion(svr) == 1)
+     {
+ 	info->char_range.min_char.high = reply.header.char_range.min_char.low;
+ 	info->char_range.min_char.low = reply.header.char_range.min_char.high;
+ 	info->char_range.max_char.high = reply.header.char_range.max_char.low;
+ 	info->char_range.max_char.low = reply.header.char_range.max_char.high;
+ 	info->default_char.high = reply.header.default_char.low;
+ 	info->default_char.low = reply.header.default_char.high;
+     }
      /* get the prop header */
      _FSReadPad(svr, (char *) props, sizeof(fsPropInfo));
      /* prepare for prop data */
*** /tmp/da27951	Tue Jul 14 18:06:59 1992
--- mit/fonts/lib/fs/FSSync.c	Tue Jul 14 18:06:59 1992
***************
*** 1,33 ****
! /* $XConsortium: FSSync.c,v 1.3 91/07/22 11:29:21 rws Exp $ */
! 
! /* @(#)FSSync.c	4.1	91/05/02
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, and distribute this protoype software
!  * and its documentation to Members and Affiliates of the MIT X Consortium
!  * any purpose and without fee is hereby granted, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * MIT not be used in advertising or publicity pertaining to distribution of
!  * the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND MIT DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
!  * AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES, DIGITAL OR MIT BE
!  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
!  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
!  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   */
  
! #include	"FSlibint.h"
  
  extern _FSQEvent *_FSqfree;
  
! /* synchronize withe errors and events */
  
  FSSync(svr, discard)
      FSServer     *svr;
--- 1,32 ----
! /* $XConsortium: FSSync.c,v 1.4 92/05/26 17:14:57 gildea Exp $ */
! /*
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, distribute, and sell this software and
!  * its documentation for any purpose is hereby granted without fee, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * M.I.T. not be used in advertising or publicity pertaining to distribution
!  * of the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND M.I.T. DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
!  * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES,
!  * DIGITAL OR M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
!  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
!  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
!  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
!  * THIS SOFTWARE.
   */
  
! #include "FSlibint.h"
  
  extern _FSQEvent *_FSqfree;
  
! /* synchronize with errors and events */
  
  FSSync(svr, discard)
      FSServer     *svr;
***************
*** 38,46 ****
  
      GetEmptyReq(ListExtensions, req);
      (void) _FSReply(svr, (fsReply *) & rep, 0, fsTrue);
-     if (rep.nExtensions) {
- 	_FSEatData(svr, (unsigned long) rep.length << 2);
-     }
  
      if (discard && svr->head) {
  	((_FSQEvent *) svr->tail)->next = _FSqfree;
--- 37,42 ----
*** /tmp/da28759	Tue Jul 14 18:08:08 1992
--- mit/fonts/server/os/access.c	Tue Jul 14 18:08:07 1992
***************
*** 1,28 ****
! /* $XConsortium: access.c,v 1.5 91/07/18 22:34:38 keith Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, and distribute this protoype software
!  * and its documentation to Members and Affiliates of the MIT X Consortium
!  * any purpose and without fee is hereby granted, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * MIT not be used in advertising or publicity pertaining to distribution of
!  * the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND MIT DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
!  * AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES, DIGITAL OR MIT BE
!  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
!  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
!  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  *
!  * $NCDId: @(#)access.c,v 4.5 1991/07/02 18:32:37 lemke Exp $
!  *
   */
  
  #include        <sys/param.h>
--- 1,25 ----
! /* $XConsortium: access.c,v 1.6 92/06/01 17:07:58 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, distribute, and sell this software and
!  * its documentation for any purpose is hereby granted without fee, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * M.I.T. not be used in advertising or publicity pertaining to distribution
!  * of the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND M.I.T. DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
!  * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES,
!  * DIGITAL OR M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
!  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
!  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
!  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
!  * THIS SOFTWARE.
   */
  
  #include        <sys/param.h>
***************
*** 91,105 ****
  {
      OsCommPtr	oc;
  
!     /* now that its connected, zero the connect time so it doesn't get killed */
      oc = (OsCommPtr)client->osPrivate;
      oc->conn_time = 0;
  
      *size = 0;
      *accept = AuthSuccess;
!     if (*index > 0)
! 	*index = 0;
!     else
! 	*index = -1;
      return FSSuccess;
  }
--- 88,100 ----
  {
      OsCommPtr	oc;
  
!     /* now that it's connected, zero the connect time
!        so it doesn't get killed */
      oc = (OsCommPtr)client->osPrivate;
      oc->conn_time = 0;
  
      *size = 0;
      *accept = AuthSuccess;
!     *index = 0;			/* we support no authorization protocols */
      return FSSuccess;
  }
*** /tmp/da28803	Tue Jul 14 18:08:12 1992
--- mit/fonts/server/os/io.c	Tue Jul 14 18:08:11 1992
***************
*** 1,7 ****
! /* $XConsortium: io.c,v 1.5 91/06/21 18:19:12 keith Exp $ */
  /*
   * i/o functions
-  *
   */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
--- 1,6 ----
! /* $XConsortium: io.c,v 1.9 92/05/18 13:50:44 gildea Exp $ */
  /*
   * i/o functions
   */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
***************
*** 24,32 ****
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  *
-  * @(#)io.c	4.2	5/3/91
-  *
   */
  
  #include	<stdio.h>
--- 23,28 ----
***************
*** 156,162 ****
  	    if (needed > oci->size) {
  		char       *ibuf;
  
! 		ibuf = (char *) fsrealloc(oci, needed);
  		if (!ibuf) {
  		    yield_control_death();
  		    return -1;
--- 152,158 ----
  	    if (needed > oci->size) {
  		char       *ibuf;
  
! 		ibuf = (char *) fsrealloc(oci->buffer, needed);
  		if (!ibuf) {
  		    yield_control_death();
  		    return -1;
***************
*** 320,333 ****
      }
  }
  
- static int  padlength[4] = {0, 3, 2, 1};
- 
  int
! FlushClient(client, oc, extraBuf, extraCount)
      ClientPtr   client;
      OsCommPtr   oc;
      char       *extraBuf;
      int         extraCount;
  {
      ConnectionOutputPtr oco = oc->output;
      int         fd = oc->fd;
--- 316,328 ----
      }
  }
  
  int
! FlushClient(client, oc, extraBuf, extraCount, padsize)
      ClientPtr   client;
      OsCommPtr   oc;
      char       *extraBuf;
      int         extraCount;
+     int         padsize;
  {
      ConnectionOutputPtr oco = oc->output;
      int         fd = oc->fd;
***************
*** 334,340 ****
      struct iovec iov[3];
      char        padBuffer[3];
      long        written;
-     long        padsize;
      long        notWritten;
      long        todo;
  
--- 329,334 ----
***************
*** 341,347 ****
      if (!oco)
  	return 0;
      written = 0;
-     padsize = padlength[extraCount & 3];
      notWritten = oco->count + extraCount + padsize;
      todo = notWritten;
      while (notWritten) {
--- 335,340 ----
***************
*** 484,503 ****
  		BITSET(OutputPending, oc->fd);
  		NewOutputPending = TRUE;
  	    } else {
! 		(void) FlushClient(client, oc, (char *) NULL, 0);
  	    }
  	}
      }
  }
  
! WriteToClient(client, count, buf)
      ClientPtr   client;
      int         count;
      char       *buf;
  {
      OsCommPtr   oc = (OsCommPtr) client->osPrivate;
      ConnectionOutputPtr oco = oc->output;
-     int         padBytes;
  
      if (!count)
  	return 0;
--- 477,500 ----
  		BITSET(OutputPending, oc->fd);
  		NewOutputPending = TRUE;
  	    } else {
! 		(void) FlushClient(client, oc, (char *) NULL, 0, 0);
  	    }
  	}
      }
  }
  
! /*
!  * returns number of bytes written
!  */
! static int
! write_to_client_internal(client, count, buf, padBytes)
      ClientPtr   client;
      int         count;
      char       *buf;
+     int         padBytes;
  {
      OsCommPtr   oc = (OsCommPtr) client->osPrivate;
      ConnectionOutputPtr oco = oc->output;
  
      if (!count)
  	return 0;
***************
*** 512,523 ****
  	}
  	oc->output = oco;
      }
-     padBytes = padlength[count & 3];
- 
      if (oco->count + count + padBytes > oco->size) {
  	BITCLEAR(OutputPending, oc->fd);
  	NewOutputPending = FALSE;
! 	return FlushClient(client, oc, buf, count);
      }
      NewOutputPending = TRUE;
      BITSET(OutputPending, oc->fd);
--- 509,518 ----
  	}
  	oc->output = oco;
      }
      if (oco->count + count + padBytes > oco->size) {
  	BITCLEAR(OutputPending, oc->fd);
  	NewOutputPending = FALSE;
! 	return FlushClient(client, oc, buf, count, padBytes);
      }
      NewOutputPending = TRUE;
      BITSET(OutputPending, oc->fd);
***************
*** 525,530 ****
--- 520,543 ----
      oco->count += count + padBytes;
  
      return count;
+ }
+ 
+ WriteToClientUnpadded(client, count, buf)
+     ClientPtr   client;
+     int         count;
+     char       *buf;
+ {
+     write_to_client_internal(client, count, buf, 0);
+ }
+ 
+ static int  padlength[4] = {0, 3, 2, 1};
+ 
+ WriteToClient(client, count, buf)
+     ClientPtr   client;
+     int         count;
+     char       *buf;
+ {
+      write_to_client_internal(client, count, buf, padlength[count & 3]);
  }
  
  static      ConnectionInputPtr
*** /tmp/da28825	Tue Jul 14 18:08:14 1992
--- mit/fonts/server/os/connection.c	Tue Jul 14 18:08:14 1992
***************
*** 1,4 ****
! /* $XConsortium: connection.c,v 1.17 91/09/09 18:56:03 rws Exp $ */
  /*
   * handles connections
   */
--- 1,4 ----
! /* $XConsortium: connection.c,v 1.19 92/05/18 13:51:29 gildea Exp $ */
  /*
   * handles connections
   */
***************
*** 23,31 ****
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  *
-  * $NCDId: @(#)connection.c,v 4.10 1991/07/03 17:19:22 lemke Exp $
-  *
   */
  
  /* sorry, streams support not here yet */
--- 23,28 ----
***************
*** 471,477 ****
      OsCommPtr   oc = (OsCommPtr) client->osPrivate;
  
      if (oc->output && oc->output->count)
! 	FlushClient(client, oc, (char *) NULL, 0);
      ConnectionTranslation[oc->fd] = 0;
      close_fd(oc);
      client->osPrivate = (pointer) NULL;
--- 468,474 ----
      OsCommPtr   oc = (OsCommPtr) client->osPrivate;
  
      if (oc->output && oc->output->count)
! 	FlushClient(client, oc, (char *) NULL, 0, 0);
      ConnectionTranslation[oc->fd] = 0;
      close_fd(oc);
      client->osPrivate = (pointer) NULL;
*** /tmp/da28868	Tue Jul 14 18:08:18 1992
--- mit/fonts/server/os/utils.c	Tue Jul 14 18:08:18 1992
***************
*** 1,4 ****
! /* $XConsortium: utils.c,v 1.7 91/07/25 12:15:52 keith Exp $ */
  /*
   * misc os utilities
   */
--- 1,4 ----
! /* $XConsortium: utils.c,v 1.9 92/01/31 17:45:40 eswu Exp $ */
  /*
   * misc os utilities
   */
***************
*** 32,37 ****
--- 32,38 ----
  #include	<X11/Xos.h>
  #include	"misc.h"
  #include	"globals.h"
+ #include	<signal.h>
  
  #ifndef X_NOT_POSIX
  #ifdef _POSIX_SOURCE
***************
*** 44,54 ****
--- 45,57 ----
  #endif /* X_NOT_POSIX */
  #ifndef PATH_MAX
  #include <sys/param.h>
+ #ifndef PATH_MAX
  #ifdef MAXPATHLEN
  #define PATH_MAX MAXPATHLEN
  #else
  #define PATH_MAX 1024
  #endif
+ #endif
  #endif /* PATH_MAX */
  
  #ifdef SIGNALRETURNSINT
***************
*** 73,78 ****
--- 76,85 ----
  
      dispatchException |= DE_RESET;
      isItTimeToYield = TRUE;
+ 
+ #ifdef SYSV
+     signal(SIGHUP, AutoResetServer);
+ #endif
  }
  
  SIGVAL
***************
*** 97,102 ****
--- 104,113 ----
  
      dispatchException |= DE_RECONFIG;
      isItTimeToYield = TRUE;
+ 
+ #ifdef SYSV
+     signal(SIGUSR1, ServerReconfig);
+ #endif
  }
  
  SIGVAL
***************
*** 109,114 ****
--- 120,129 ----
  
      dispatchException |= DE_FLUSH;
      isItTimeToYield = TRUE;
+ 
+ #ifdef SYSV
+     signal(SIGUSR2, ServerCacheFlush);
+ #endif
  }
  
  long
***************
*** 140,146 ****
--- 155,165 ----
  	extern pointer MemoryAllocationBase;
  
  	if (!MemoryAllocationBase)
+ #ifndef AIXV3
  	    MemoryAllocationBase = (pointer) sbrk(0);
+ #else
+ 	    MemoryAllocationBase = (pointer) 0x20000000;
+ #endif
      }
  #endif
  
*** /tmp/da28953	Tue Jul 14 18:08:25 1992
--- mit/fonts/server/os/osdep.h	Tue Jul 14 18:08:25 1992
***************
*** 1,4 ****
! /* $XConsortium: osdep.h,v 1.3 91/05/13 16:51:04 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
--- 1,4 ----
! /* $XConsortium: osdep.h,v 1.4 92/01/31 17:45:07 eswu Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
***************
*** 131,141 ****
  #define MASKANDSETBITS(dst, b1, b2)  \
  		      { int cri;			\
  			for (cri=0; cri<mskcnt; cri++)	\
! 		          dst[cri] = (b1[cri] & b2[cri]) }
  #define ORBITS(dst, b1, b2)  \
  		      { int cri;			\
  		      for (cri=0; cri<mskcnt; cri++)	\
! 		          dst[cri] = (b1[cri] | b2[cri]) }
  #define UNSETBITS(dst, b1) \
  		      { int cri;			\
  		      for (cri=0; cri<mskcnt; cri++)	\
--- 131,141 ----
  #define MASKANDSETBITS(dst, b1, b2)  \
  		      { int cri;			\
  			for (cri=0; cri<mskcnt; cri++)	\
! 		          dst[cri] = (b1[cri] & b2[cri]); }
  #define ORBITS(dst, b1, b2)  \
  		      { int cri;			\
  		      for (cri=0; cri<mskcnt; cri++)	\
! 		          dst[cri] = (b1[cri] | b2[cri]); }
  #define UNSETBITS(dst, b1) \
  		      { int cri;			\
  		      for (cri=0; cri<mskcnt; cri++)	\
*** /tmp/da29017	Tue Jul 14 18:08:31 1992
--- mit/fonts/server/os/error.c	Tue Jul 14 18:08:31 1992
***************
*** 1,4 ****
! /* $XConsortium: error.c,v 1.3 91/08/16 16:20:23 rws Exp $ */
  /*
   * error message handling
   */
--- 1,4 ----
! /* $XConsortium: error.c,v 1.4 91/12/09 16:49:23 converse Exp $ */
  /*
   * error message handling
   */
***************
*** 41,50 ****
--- 41,52 ----
  #endif
  #ifndef PATH_MAX
  #include <sys/param.h>
+ #ifndef PATH_MAX
  #ifdef MAXPATHLEN
  #define PATH_MAX MAXPATHLEN
  #else
  #define PATH_MAX 1024
+ #endif
  #endif
  #endif
  
*** /tmp/da29043	Tue Jul 14 18:08:34 1992
--- mit/fonts/server/difs/fontinfo.c	Tue Jul 14 18:08:33 1992
***************
*** 1,4 ****
! /* $XConsortium: fontinfo.c,v 1.7 91/07/25 12:24:51 keith Exp $ */
  /*
   * font data query
   */
--- 1,4 ----
! /* $XConsortium: fontinfo.c,v 1.8 92/05/12 18:08:08 gildea Exp $ */
  /*
   * font data query
   */
***************
*** 23,31 ****
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  *
-  * @(#)fontinfo.c	4.1	5/2/91
-  *
   */
  
  #include        "FS.h"
--- 23,28 ----
***************
*** 132,138 ****
  
  
  int
! LoadFontHeader(pinfo, hdr, pi)
      FontInfoPtr pinfo;
      fsFontHeader *hdr;
      fsPropInfo **pi;
--- 129,136 ----
  
  
  int
! LoadXFontInfo(client, pinfo, hdr, pi)
!     ClientPtr client;		/* for client version info */
      FontInfoPtr pinfo;
      fsFontHeader *hdr;
      fsPropInfo **pi;
***************
*** 147,158 ****
  
      if (pinfo->inkInside)
  	hdr->flags |= FontInfoInkInside;
!     hdr->char_range.min_char.low = pinfo->firstCol;
!     hdr->char_range.min_char.high = pinfo->firstRow;
!     hdr->char_range.max_char.low = pinfo->lastCol;
!     hdr->char_range.max_char.high = pinfo->lastRow;
!     hdr->default_char.low = pinfo->defaultCh & 0xff;
!     hdr->default_char.high = pinfo->defaultCh >> 8;
  
      CopyCharInfo(&pinfo->ink_minbounds, &hdr->min_bounds);
      CopyCharInfo(&pinfo->ink_maxbounds, &hdr->max_bounds);
--- 145,165 ----
  
      if (pinfo->inkInside)
  	hdr->flags |= FontInfoInkInside;
!     if (client->major_version > 1) {
! 	hdr->char_range.min_char.low = pinfo->firstCol;
! 	hdr->char_range.min_char.high = pinfo->firstRow;
! 	hdr->char_range.max_char.low = pinfo->lastCol;
! 	hdr->char_range.max_char.high = pinfo->lastRow;
! 	hdr->default_char.low = pinfo->defaultCh & 0xff;
! 	hdr->default_char.high = pinfo->defaultCh >> 8;
!     } else {
! 	hdr->char_range.min_char.high = pinfo->firstCol;
! 	hdr->char_range.min_char.low = pinfo->firstRow;
! 	hdr->char_range.max_char.high = pinfo->lastCol;
! 	hdr->char_range.max_char.low = pinfo->lastRow;
! 	hdr->default_char.high = pinfo->defaultCh & 0xff;
! 	hdr->default_char.low = pinfo->defaultCh >> 8;
!     }
  
      CopyCharInfo(&pinfo->ink_minbounds, &hdr->min_bounds);
      CopyCharInfo(&pinfo->ink_maxbounds, &hdr->max_bounds);
***************
*** 233,238 ****
--- 240,265 ----
      }
  }
  
+ /*
+  * provide backward compatibility with version 1, which had
+  * the bytes of char2b backwards
+  */
+ static void
+ swap_char2b (values, number)
+     fsChar2b *values;
+     int number;
+ {
+     fsChar2b temp;
+     int i;
+ 
+     for (i = 0; i < number; i++) {
+ 	temp.low = ((fsChar2b_version1 *)values)->low;
+ 	temp.high = ((fsChar2b_version1 *)values)->high;
+ 	*values++ = temp;
+     }
+ }
+ 
+ 
  static Bool
  do_query_extents(client, c)
      ClientPtr   client;
***************
*** 244,250 ****
      fsCharInfo *extents;
      fsQueryXExtents8Reply reply;
  
!     err = (*c->pfont->get_extents) ((pointer) c->client, c->pfont,
  		     c->flags, c->nranges, c->range, &num_extents, &extents);
      if (err == Suspended) {
  	if (!c->slept) {
--- 271,277 ----
      fsCharInfo *extents;
      fsQueryXExtents8Reply reply;
  
!     err = GetExtents (c->client, c->pfont,
  		     c->flags, c->nranges, c->range, &num_extents, &extents);
      if (err == Suspended) {
  	if (!c->slept) {
***************
*** 288,293 ****
--- 315,323 ----
      fsRange    *fixed_range;
      Bool        all_glyphs = FALSE;
  
+     if (item_size == 2  &&  client->major_version == 1)
+ 	swap_char2b (range_data, nranges);
+ 
      fixed_range = build_range(range_flag, range_data, item_size,
  			      &nranges, &all_glyphs);
  
***************
*** 322,328 ****
      fsQueryXBitmaps8Reply reply;
      int		freedata;
  
!     err = (*c->pfont->get_bitmaps) ((pointer) c->client, c->pfont, c->format,
  				    c->flags, c->nranges, c->range,
  			     &data_size, &num_glyphs, &offsets, &glyph_data, &freedata);
  
--- 352,358 ----
      fsQueryXBitmaps8Reply reply;
      int		freedata;
  
!     err = GetBitmaps (c->client, c->pfont, c->format,
  				    c->flags, c->nranges, c->range,
  			     &data_size, &num_glyphs, &offsets, &glyph_data, &freedata);
  
***************
*** 375,380 ****
--- 405,413 ----
      QBclosurePtr c;
      fsRange    *fixed_range;
      Bool        all_glyphs = FALSE;
+ 
+     if (item_size == 2  &&  client->major_version == 1)
+ 	swap_char2b (range_data, nranges);
  
      fixed_range = build_range(range_flag, range_data, item_size,
  			      &nranges, &all_glyphs);
*** /tmp/da29128	Tue Jul 14 18:08:42 1992
--- mit/fonts/server/difs/dispatch.c	Tue Jul 14 18:08:41 1992
***************
*** 1,4 ****
! /* $XConsortium: dispatch.c,v 1.7 91/07/27 02:29:05 keith Exp $ */
  /*
   * protocol dispatcher
   */
--- 1,4 ----
! /* $XConsortium: dispatch.c,v 1.15 92/06/02 14:15:53 gildea Exp $ */
  /*
   * protocol dispatcher
   */
***************
*** 7,31 ****
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, and distribute this protoype software
!  * and its documentation to Members and Affiliates of the MIT X Consortium
!  * any purpose and without fee is hereby granted, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * MIT not be used in advertising or publicity pertaining to distribution of
!  * the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND MIT DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
!  * AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES, DIGITAL OR MIT BE
!  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
!  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
!  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  *
!  * $NCDId: @(#)dispatch.c,v 4.11 1991/07/09 14:09:07 lemke Exp $
!  *
   */
  
  #include	"FS.h"
--- 7,28 ----
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, distribute, and sell this software and
!  * its documentation for any purpose is hereby granted without fee, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * M.I.T. not be used in advertising or publicity pertaining to distribution
!  * of the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND M.I.T. DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
!  * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES,
!  * DIGITAL OR M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
!  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
!  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
!  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
!  * THIS SOFTWARE.
   */
  
  #include	"FS.h"
***************
*** 138,143 ****
--- 135,141 ----
  		NoticeF("Re-reading config file\n");
  		if (ReadConfigFile(configfilename) != FSSuccess)
  		    ErrorF("couldn't parse config file");
+ 		SetConfigValues();
  		dispatchException &= ~DE_RECONFIG;
  	    }
  	    /* flush all the caches */
***************
*** 146,156 ****
  		CacheReset();
  		dispatchException &= ~DE_FLUSH;
  	    }
! 	    /* reset when no clients left */
! 	    if ((dispatchException & DE_RESET) && (nClients == 0)) {
! 		NoticeF("reseting\n");
  		break;
- 
  	    }
  	    /* die *now* */
  	    if (dispatchException & DE_TERMINATE) {
--- 144,153 ----
  		CacheReset();
  		dispatchException &= ~DE_FLUSH;
  	    }
! 	    /* reset */
! 	    if (dispatchException & DE_RESET) {
! 		NoticeF("resetting\n");
  		break;
  	    }
  	    /* die *now* */
  	    if (dispatchException & DE_TERMINATE) {
***************
*** 176,188 ****
      nClients++;
      prefix = (fsConnClientPrefix *) ((char *) stuff + sz_fsReq);
      if ((prefix->byteOrder != 'l') && (prefix->byteOrder != 'B'))
! 	return (client->noClientException = -1);
      if (((*(char *) &whichbyte) && (prefix->byteOrder == 'B')) ||
  	    (!(*(char *) &whichbyte) && (prefix->byteOrder == 'l'))) {
  	client->swapped = TRUE;
  	SwapConnClientPrefix(prefix);
      }
      stuff->reqType = 2;
      if (client->swapped) {
  	swaps(&stuff->length, whichbyte);
      }
--- 173,188 ----
      nClients++;
      prefix = (fsConnClientPrefix *) ((char *) stuff + sz_fsReq);
      if ((prefix->byteOrder != 'l') && (prefix->byteOrder != 'B'))
! 	return (client->noClientException = -2);
      if (((*(char *) &whichbyte) && (prefix->byteOrder == 'B')) ||
  	    (!(*(char *) &whichbyte) && (prefix->byteOrder == 'l'))) {
  	client->swapped = TRUE;
  	SwapConnClientPrefix(prefix);
      }
+     client->major_version = prefix->major_version;
+     client->minor_version = prefix->minor_version;
      stuff->reqType = 2;
+     stuff->length += prefix->auth_len;
      if (client->swapped) {
  	swaps(&stuff->length, whichbyte);
      }
***************
*** 221,227 ****
  /* XXXX -- this needs work for multiple auth replies */
  
      /* build up a list of the stuff */
!     for (i = 0, ad = auth_data; i < prefix->num_auths; i++) {
  	client_auth[i].namelen = *(short *) ad;
  	ad += 2;
  	client_auth[i].datalen = *(short *) ad;
--- 221,227 ----
  /* XXXX -- this needs work for multiple auth replies */
  
      /* build up a list of the stuff */
!     for (i = 0, ad = auth_data; i < (int)prefix->num_auths; i++) {
  	client_auth[i].namelen = *(short *) ad;
  	ad += 2;
  	client_auth[i].datalen = *(short *) ad;
***************
*** 248,254 ****
  	return FSBadAlloc;
      }
      csp.status = auth_accept;
!     csp.major_version = FS_PROTOCOL;
      csp.minor_version = FS_PROTOCOL_MINOR;
      csp.num_alternates = num_alts;
      csp.alternate_len = altlen;
--- 248,258 ----
  	return FSBadAlloc;
      }
      csp.status = auth_accept;
!     if (client->major_version == 1)
! 	/* we implement backwards compatibility for version 1.0 */
! 	csp.major_version = client->major_version;
!     else
! 	csp.major_version = FS_PROTOCOL;
      csp.minor_version = FS_PROTOCOL_MINOR;
      csp.num_alternates = num_alts;
      csp.alternate_len = altlen;
***************
*** 271,281 ****
  	(void) WriteToClient(client, altservers[i].namelen + 2, tmp);
      }
  
!     (void) WriteToClient(client, auth_len, (char *) server_auth_data);
  
      if (auth_accept != AuthSuccess) {
  	nClients--;
! 	return (client->noClientException = -1);
      }
      client->requestVector = client->swapped ? SwappedProcVector : ProcVector;
      client->sequence = 0;
--- 275,286 ----
  	(void) WriteToClient(client, altservers[i].namelen + 2, tmp);
      }
  
!     if (auth_len)
! 	(void) WriteToClient(client, auth_len, (char *) server_auth_data);
  
      if (auth_accept != AuthSuccess) {
  	nClients--;
! 	return (client->noClientException = -2);
      }
      client->requestVector = client->swapped ? SwappedProcVector : ProcVector;
      client->sequence = 0;
***************
*** 311,316 ****
--- 316,322 ----
      case FSBadFont:
      case FSBadAccessContext:
      case FSBadIDChoice:
+     case FSBadEventMask:
  	if (client->swapped)
  	    SwapLongs((long *) data, 1);
  	extralen = sizeof(Font);
***************
*** 496,502 ****
      	}
      }
      /* build up a list of the stuff */
!     for (i = 0, ad = (pointer) &stuff[1]; i < stuff->num_auths; i++) {
  	acp[i].namelen = *(short *) ad;
  	ad += 2;
  	acp[i].datalen = *(short *) ad;
--- 502,508 ----
      	}
      }
      /* build up a list of the stuff */
!     for (i = 0, ad = (pointer) &stuff[1]; i < (int)stuff->num_auths; i++) {
  	acp[i].namelen = *(short *) ad;
  	ad += 2;
  	acp[i].datalen = *(short *) ad;
***************
*** 524,533 ****
      }
      authp->authname = 0;
      authp->authdata = 0;
!     if (index >= 0)
      {
! 	authp->authname = (char *) fsalloc(acp[index].namelen + 1);
! 	authp->authdata = (char *) fsalloc(acp[index].datalen + 1);
  	if (!authp->authname || !authp->authdata) {
  	    fsfree((char *) authp->authname);
  	    fsfree((char *) authp->authdata);
--- 530,539 ----
      }
      authp->authname = 0;
      authp->authdata = 0;
!     if (index > 0)
      {
! 	authp->authname = (char *) fsalloc(acp[index - 1].namelen + 1);
! 	authp->authdata = (char *) fsalloc(acp[index - 1].datalen + 1);
  	if (!authp->authname || !authp->authdata) {
  	    fsfree((char *) authp->authname);
  	    fsfree((char *) authp->authdata);
***************
*** 534,542 ****
  	    fsfree((char *) authp);
  	    goto alloc_failure;
  	}
! 	bcopy(acp[index].name, authp->authname, acp[index].namelen);
! 	bcopy(acp[index].data, authp->authdata, acp[index].datalen);
      }
      authp->acid = stuff->acid;
      if (!AddResource(client->index, stuff->acid, RT_AUTHCONT,(pointer) authp)) 
      {
--- 540,550 ----
  	    fsfree((char *) authp);
  	    goto alloc_failure;
  	}
! 	bcopy(acp[index - 1].name, authp->authname, acp[index - 1].namelen);
! 	bcopy(acp[index - 1].data, authp->authdata, acp[index - 1].datalen);
      }
+     else
+ 	size = 0;
      authp->acid = stuff->acid;
      if (!AddResource(client->index, stuff->acid, RT_AUTHCONT,(pointer) authp)) 
      {
***************
*** 549,559 ****
      DEALLOCATE_LOCAL(acp);
      rep.type = FS_Reply;
      rep.status = accept;
-     if (index < 0)
-     {
- 	size = 0;
- 	index = 0;
-     }
      rep.auth_index = index;
      rep.sequenceNumber = client->sequence;
      rep.length = (sizeof(fsCreateACReply) + size) >> 2;
--- 557,562 ----
***************
*** 566,571 ****
--- 569,575 ----
      return client->noClientException;
  }
  
+ /* ARGSUSED */
  int
  DeleteAuthCont (value, id)
      pointer value;
***************
*** 659,667 ****
      WriteReplyToClient(client, sizeof(fsGetResolutionReply), &reply);
      if (client->swapped)
  	client->pSwapReplyFunc = CopySwap16Write;
-     WriteSwappedDataToClient(client, client->resolutions,
- 			   (client->num_resolutions * sizeof(fsResolution)));
  
      return client->noClientException;
  }
  
--- 663,672 ----
      WriteReplyToClient(client, sizeof(fsGetResolutionReply), &reply);
      if (client->swapped)
  	client->pSwapReplyFunc = CopySwap16Write;
  
+     WriteSwappedDataToClient(client,
+        (client->num_resolutions * sizeof(fsResolution)), client->resolutions);
+ 
      return client->noClientException;
  }
  
***************
*** 709,721 ****
      }
      if (stuff->format_hint != 0 &&
  	    stuff->format_hint & ~ALL_FORMAT_BITS) {
! 	SendErrToClient(client, FSBadFormat,
! 			(pointer) &stuff->format_hint);
  	return FSBadFormat;
      }
      if (stuff->format_mask & ~ALL_FORMAT_MASK_BITS) {
! 	SendErrToClient(client, FSBadFormat,
! 			(pointer) &stuff->format_mask);
  	return FSBadFormat;
      }
      err = OpenFont(client, stuff->fid, stuff->format_hint, stuff->format_mask,
--- 714,724 ----
      }
      if (stuff->format_hint != 0 &&
  	    stuff->format_hint & ~ALL_FORMAT_BITS) {
! 	SendErrToClient(client, FSBadFormat, (pointer) &stuff->format_hint);
  	return FSBadFormat;
      }
      if (stuff->format_mask & ~ALL_FORMAT_MASK_BITS) {
! 	SendErrToClient(client, FSBadFormat, (pointer) &stuff->format_mask);
  	return FSBadFormat;
      }
      err = OpenFont(client, stuff->fid, stuff->format_hint, stuff->format_mask,
***************
*** 750,760 ****
      reply.sequenceNumber = client->sequence;
  
      /* get the header */
!     err = LoadFontHeader(&cfp->font->info, &reply.header, &prop_info);
  
!     if (err != Successful) {
! 	SendErrToClient(client, FontToFSError(err), (pointer) NULL);
  	return err;
      }
      lendata = sizeof(fsPropInfo) +
  	prop_info->num_offsets * sizeof(fsPropOffset) +
--- 753,772 ----
      reply.sequenceNumber = client->sequence;
  
      /* get the header */
!     err = LoadXFontInfo(client, &cfp->font->info, &reply.header, &prop_info);
  
!     switch (err)
!     {
!     case Successful:
! 	break;
!     case AllocError:
! 	SendErrToClient(client, FSBadAlloc, (pointer) 0);
  	return err;
+     default:
+ 	ErrorF("ProcQueryXInfo: unexpected return val %d from LoadXFontInfo",
+ 	       err);
+ 	SendErrToClient(client, FSBadImplementation, (pointer) 0);
+ 	return err;
      }
      lendata = sizeof(fsPropInfo) +
  	prop_info->num_offsets * sizeof(fsPropOffset) +
***************
*** 772,778 ****
  }
  
  int
! ProcQueryXExtents8(client)
      ClientPtr   client;
  {
      ClientFontPtr cfp;
--- 784,790 ----
  }
  
  int
! ProcQueryXExtents(client)
      ClientPtr   client;
  {
      ClientFontPtr cfp;
***************
*** 801,807 ****
  }
  
  int
! ProcQueryXBitmaps8(client)
      ClientPtr   client;
  {
      ClientFontPtr cfp;
--- 813,819 ----
  }
  
  int
! ProcQueryXBitmaps(client)
      ClientPtr   client;
  {
      ClientFontPtr cfp;
***************
*** 858,889 ****
  CloseDownClient(client)
      ClientPtr   client;
  {
!     if (client->clientGone == CLIENT_ALIVE) {
  	client->clientGone = CLIENT_GONE;
  	CloseDownConnection(client);
! 	FreeClientResources(client);
! 	if (ClientIsAsleep(client))
! 	    ClientSignal(client);
! 	if (client->index < nextFreeClientID)
! 	    nextFreeClientID = client->index;
! 	clients[client->index] = NullClient;
! 	fsfree(client);
! 	--nClients;
  
  #ifdef NOTYET
  	/* reset server when last client goes away */
  	if (client->requestVector != InitialVector && nClients == 0)
  	    dispatchException |= DE_RESET;
  #endif
!     } else {
! 	FreeClientResources(client);
! 	if (ClientIsAsleep(client))
! 	    ClientSignal(client);
! 	if (client->index < nextFreeClientID)
! 	    nextFreeClientID = client->index;
! 	clients[client->index] = NullClient;
! 	fsfree(client);
!     }
  
  #ifdef DEBUG
      fprintf(stderr, "Shut down client\n");
--- 870,899 ----
  CloseDownClient(client)
      ClientPtr   client;
  {
!     int client_alive = client->clientGone == CLIENT_ALIVE;
! 
!     if (client_alive) {
  	client->clientGone = CLIENT_GONE;
  	CloseDownConnection(client);
!     }
!     FreeClientResources(client);
!     if (ClientIsAsleep(client))
! 	ClientSignal(client);
!     if (client->index < nextFreeClientID)
! 	nextFreeClientID = client->index;
!     clients[client->index] = NullClient;
  
+     if (client_alive) {
+ 	--nClients;
  #ifdef NOTYET
  	/* reset server when last client goes away */
  	if (client->requestVector != InitialVector && nClients == 0)
  	    dispatchException |= DE_RESET;
  #endif
!     } 
!     if (currentClient == client)
! 	currentClient = serverClient;
!     fsfree(client);
  
  #ifdef DEBUG
      fprintf(stderr, "Shut down client\n");
***************
*** 987,991 ****
  MarkClientException(client)
      ClientPtr   client;
  {
!     client->noClientException = -1;
  }
--- 997,1001 ----
  MarkClientException(client)
      ClientPtr   client;
  {
!     client->noClientException = -2;
  }
*** /tmp/da29150	Tue Jul 14 18:08:45 1992
--- mit/fonts/server/difs/fonts.c	Tue Jul 14 18:08:44 1992
***************
*** 1,4 ****
! /* $XConsortium: fonts.c,v 1.8 91/07/18 22:36:11 keith Exp $ */
  /*
   * font control
   */
--- 1,4 ----
! /* $XConsortium: fonts.c,v 1.13 92/05/28 17:17:15 gildea Exp $ */
  /*
   * font control
   */
***************
*** 7,31 ****
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, and distribute this protoype software
!  * and its documentation to Members and Affiliates of the MIT X Consortium
!  * any purpose and without fee is hereby granted, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * MIT not be used in advertising or publicity pertaining to distribution of
!  * the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND MIT DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
!  * AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES, DIGITAL OR MIT BE
!  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
!  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
!  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  *
!  * $NCDId: @(#)fonts.c,v 4.14 1991/06/27 19:01:42 lemke Exp $
!  *
   */
  
  #include        "FS.h"
--- 7,28 ----
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, distribute, and sell this software and
!  * its documentation for any purpose is hereby granted without fee, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * M.I.T. not be used in advertising or publicity pertaining to distribution
!  * of the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND M.I.T. DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
!  * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES,
!  * DIGITAL OR M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
!  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
!  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
!  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
!  * THIS SOFTWARE.
   */
  
  #include        "FS.h"
***************
*** 40,45 ****
--- 37,43 ----
  #include	"globals.h"
  
  extern void (*ReplySwapVector[NUM_PROC_VECTORS]) ();
+ extern FSID FakeClientID();
  
  static FontPathElementPtr *font_path_elements = (FontPathElementPtr *) 0;
  static int  num_fpes = 0;
***************
*** 153,159 ****
  }
  
  /* ARGSUSED */
! int
  FontWakeup(data, count, LastSelectMask)
      pointer     data;
      int         count;
--- 151,157 ----
  }
  
  /* ARGSUSED */
! void
  FontWakeup(data, count, LastSelectMask)
      pointer     data;
      int         count;
***************
*** 163,176 ****
      FontPathElementPtr fpe;
  
      if (count < 0)
! 	return FSSuccess;	/* ignore -1 return from select XXX */
      /* wake up any fpe's that may be waiting for information */
      for (i = 0; i < num_slept_fpes; i++) {
  	fpe = slept_fpes[i];
  	(void) (*fpe_functions[fpe->type].wakeup_fpe) (fpe, LastSelectMask);
      }
- 
-     return FSSuccess;
  }
  
  static Bool
--- 161,172 ----
      FontPathElementPtr fpe;
  
      if (count < 0)
! 	return;			/* ignore -1 return from select XXX */
      /* wake up any fpe's that may be waiting for information */
      for (i = 0; i < num_slept_fpes; i++) {
  	fpe = slept_fpes[i];
  	(void) (*fpe_functions[fpe->type].wakeup_fpe) (fpe, LastSelectMask);
      }
  }
  
  static Bool
***************
*** 581,587 ****
      int		len;
      int		type;
      char       *cp = paths;
-     char       *colon;
      FontPathElementPtr fpe,
                 *fplist;
  
--- 577,582 ----
***************
*** 705,713 ****
      ClientPtr   client;
      LFclosurePtr c;
  {
!     int         err;
      fsListFontsReply reply;
!     FontNamesPtr names;
      FontPathElementPtr fpe;
      int         stringLens,
                  i,
--- 700,708 ----
      ClientPtr   client;
      LFclosurePtr c;
  {
!     int         err = Successful;
      fsListFontsReply reply;
!     FontNamesPtr names = NULL;
      FontPathElementPtr fpe;
      int         stringLens,
                  i,
***************
*** 840,848 ****
  {
      LFclosurePtr c;
  
-     if (!num_fpes)
- 	return FSSuccess;
- 
      c = make_list_fonts_closure(client, pattern, length, maxnames);
      if (!c)
  	return FSBadAlloc;
--- 835,840 ----
***************
*** 851,856 ****
--- 843,851 ----
      return FSSuccess;
  }
  
+ static int padlength[4] = {0, 3, 2, 1};
+ static char padding[3];
+ 
  do_list_fonts_with_info(client, c)
      ClientPtr   client;
      LFWXIclosurePtr c;
***************
*** 966,972 ****
  		name = c->savedName;
  		namelen = strlen(name);
  	    }
! 	    err = LoadFontHeader(pFontInfo, &hdr, &prop_info);
  	    if (err != Successful)
  		break;
  	    lenpropdata = sizeof(fsPropInfo) +
--- 961,967 ----
  		name = c->savedName;
  		namelen = strlen(name);
  	    }
! 	    err = LoadXFontInfo(client, pFontInfo, &hdr, &prop_info);
  	    if (err != Successful)
  		break;
  	    lenpropdata = sizeof(fsPropInfo) +
***************
*** 975,981 ****
  
  	    reply->type = FS_Reply;
  	    reply->length =
! 		(sizeof(fsListFontsWithXInfoReply) + sizeof(fsFontHeader) +
  		 lenpropdata + namelen + 3) >> 2;
  	    reply->sequenceNumber = client->sequence;
  	    reply->nameLength = namelen;
--- 970,976 ----
  
  	    reply->type = FS_Reply;
  	    reply->length =
! 		(sizeof(fsListFontsWithXInfoReply) +
  		 lenpropdata + namelen + 3) >> 2;
  	    reply->sequenceNumber = client->sequence;
  	    reply->nameLength = namelen;
***************
*** 982,996 ****
  	    reply->nReplies = numFonts;
  	    reply->header = hdr;
  	    WriteReplyToClient(client, sizeof(fsListFontsWithXInfoReply), reply);
- 	    (void) WriteToClient(client, namelen, name);
  	    if (client->swapped)
  		SwapPropInfo(prop_info);
! 	    (void) WriteToClient(client, lenpropdata, (char *) prop_info);
  	    if (pFontInfo == &fontInfo) {
  		fsfree(fontInfo.props);
  		fsfree(fontInfo.isStringProp);
  	    }
  	    fsfree(prop_info);
  	    --c->current.max_names;
  	    if (c->current.max_names < 0)
  		abort();
--- 977,1001 ----
  	    reply->nReplies = numFonts;
  	    reply->header = hdr;
  	    WriteReplyToClient(client, sizeof(fsListFontsWithXInfoReply), reply);
  	    if (client->swapped)
  		SwapPropInfo(prop_info);
! 	    if (client->major_version > 1)
! 	    {
! 		(void)WriteToClientUnpadded(client, lenpropdata, (char *) prop_info);
! 		(void)WriteToClientUnpadded(client, namelen, name);
! 		(void)WriteToClientUnpadded(client,
! 					    padlength[(lenpropdata+namelen)&3],
! 					    padding);
! 	    } else {
! 		(void) WriteToClient(client, namelen, name);
! 		(void) WriteToClient(client, lenpropdata, (char *) prop_info);
! 	    }
  	    if (pFontInfo == &fontInfo) {
  		fsfree(fontInfo.props);
  		fsfree(fontInfo.isStringProp);
  	    }
  	    fsfree(prop_info);
+ 
  	    --c->current.max_names;
  	    if (c->current.max_names < 0)
  		abort();
***************
*** 997,1019 ****
  	}
      }
  
      if (err == Successful) {
! 	reply = c->reply;
! 	length = sizeof(fsListFontsWithXInfoReply);
  	if (c->length < length) {
! 	    reply = (fsListFontsWithXInfoReply *) fsrealloc(c->reply, length);
! 	    if (reply) {
! 		c->reply = reply;
  		c->length = length;
  	    } else
  		err = AllocError;
  	}
  	if (err == Successful) {
! 	    bzero((char *) reply, sizeof(fsListFontsWithXInfoReply));
! 	    reply->type = FS_Reply;
! 	    reply->sequenceNumber = client->sequence;
! 	    reply->length = sizeof(fsListFontsWithXInfoReply) >> 2;
! 	    WriteReplyToClient(client, length, reply);
  	}
      }
      if (err != Successful)
--- 1002,1032 ----
  	}
      }
  
+     /*
+      * send the final reply
+      */
      if (err == Successful) {
! 	fsGenericReply *final_reply;
! 
! 	final_reply = (fsGenericReply *)c->reply;
! 	if (client->major_version > 1)
! 	    length = sizeof(fsGenericReply);
! 	else
! 	    length = sizeof(fsListFontsWithXInfoReply);
  	if (c->length < length) {
! 	    final_reply = (fsGenericReply *) fsrealloc(c->reply, length);
! 	    if (final_reply) {
! 		c->reply = (fsListFontsWithXInfoReply *)final_reply;
  		c->length = length;
  	    } else
  		err = AllocError;
  	}
  	if (err == Successful) {
! 	    final_reply->type = FS_Reply;
! 	    final_reply->data1 = 0; /* notes that this is final */
! 	    final_reply->sequenceNumber = client->sequence;
! 	    final_reply->length = length >> 2;
! 	    WriteReplyToClient(client, length, final_reply);
  	}
      }
      if (err != Successful)
***************
*** 1128,1138 ****
  find_old_font(id)
      FSID        id;
  {
!     ClientFontPtr cfp;
! 
!     cfp = (ClientFontPtr) LookupIDByType(SERVER_CLIENT, id, RT_NONE);
! 
!     return cfp->font;
  }
  
  Font
--- 1141,1147 ----
  find_old_font(id)
      FSID        id;
  {
!     return (FontPtr) LookupIDByType(SERVER_CLIENT, id, RT_NONE);
  }
  
  Font
***************
*** 1160,1166 ****
  
  init_fs_handlers(fpe, block_handler)
      FontPathElementPtr fpe;
!     int         (*block_handler) ();
  {
      /* if server has reset, make sure the b&w handlers are reinstalled */
      if (last_server_gen < serverGeneration) {
--- 1169,1175 ----
  
  init_fs_handlers(fpe, block_handler)
      FontPathElementPtr fpe;
!     void         (*block_handler) ();
  {
      /* if server has reset, make sure the b&w handlers are reinstalled */
      if (last_server_gen < serverGeneration) {
***************
*** 1184,1190 ****
  
  remove_fs_handlers(fpe, block_handler, all)
      FontPathElementPtr fpe;
!     int         (*block_handler) ();
      Bool        all;
  {
      if (all) {
--- 1193,1199 ----
  
  remove_fs_handlers(fpe, block_handler, all)
      FontPathElementPtr fpe;
!     void        (*block_handler) ();
      Bool        all;
  {
      if (all) {
*** /tmp/da29246	Tue Jul 14 18:08:53 1992
--- mit/fonts/server/difs/Imakefile	Tue Jul 14 18:08:52 1992
***************
*** 1,13 ****
! XCOMM $XConsortium: Imakefile,v 1.8 91/07/17 16:06:01 gildea Exp $
  #undef ServerDefines
  #include <Server.tmpl>
  
  SRCS =	main.c dispatch.c extensions.c globals.c events.c tables.c \
! 	fontinfo.c swapreq.c swaprep.c resource.c \
  	fonts.c difsutils.c cache.c initfonts.c atom.c
  
  OBJS =  main.o dispatch.o extensions.o globals.o events.o tables.o \
! 	fontinfo.o swapreq.o swaprep.o resource.o \
  	fonts.o difsutils.o cache.o initfonts.o atom.o
  
  
--- 1,13 ----
! XCOMM $XConsortium: Imakefile,v 1.9 92/05/12 18:08:03 gildea Exp $
  #undef ServerDefines
  #include <Server.tmpl>
  
  SRCS =	main.c dispatch.c extensions.c globals.c events.c tables.c \
! 	fontinfo.c charinfo.c swapreq.c swaprep.c resource.c \
  	fonts.c difsutils.c cache.c initfonts.c atom.c
  
  OBJS =  main.o dispatch.o extensions.o globals.o events.o tables.o \
! 	fontinfo.o charinfo.o swapreq.o swaprep.o resource.o \
  	fonts.o difsutils.o cache.o initfonts.o atom.o
  
  
*** /tmp/da29310	Tue Jul 14 18:08:58 1992
--- mit/fonts/server/difs/swaprep.c	Tue Jul 14 18:08:57 1992
***************
*** 1,4 ****
! /* $XConsortium: swaprep.c,v 1.5 91/07/27 02:30:02 keith Exp $ */
  /*
   * font server reply swapping
   */
--- 1,4 ----
! /* $XConsortium: swaprep.c,v 1.7 92/05/28 16:43:00 gildea Exp $ */
  /*
   * font server reply swapping
   */
***************
*** 7,32 ****
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, and distribute this protoype software
!  * and its documentation to Members and Affiliates of the MIT X Consortium
!  * any purpose and without fee is hereby granted, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * MIT not be used in advertising or publicity pertaining to distribution of
!  * the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND MIT DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
!  * AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES, DIGITAL OR MIT BE
!  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
!  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
!  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  *
!  * $NCDId: @(#)swaprep.c,v 4.2 1991/06/27 16:34:43 lemke Exp $
!  *
   */
  #include	"FSproto.h"
  #include	"clientstr.h"
  #include	"misc.h"
--- 7,30 ----
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, distribute, and sell this software and
!  * its documentation for any purpose is hereby granted without fee, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * M.I.T. not be used in advertising or publicity pertaining to distribution
!  * of the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND M.I.T. DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
!  * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES,
!  * DIGITAL OR M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
!  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
!  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
!  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
!  * THIS SOFTWARE.
   */
+ 
  #include	"FSproto.h"
  #include	"clientstr.h"
  #include	"misc.h"
***************
*** 321,330 ****
  }
  
  void
! SQueryXExtents8Reply(client, size, pRep)
      ClientPtr   client;
      int         size;
!     fsQueryXExtents8Reply *pRep;
  {
      int         n;
  
--- 319,328 ----
  }
  
  void
! SQueryXExtentsReply(client, size, pRep)
      ClientPtr   client;
      int         size;
!     fsQueryXExtents8Reply *pRep; /* QueryXExtents16Reply is the same */
  {
      int         n;
  
***************
*** 335,344 ****
  }
  
  void
! SQueryXBitmaps8Reply(client, size, pRep)
      ClientPtr   client;
      int         size;
!     fsQueryXBitmaps8Reply *pRep;
  {
      int         n;
  
--- 333,342 ----
  }
  
  void
! SQueryXBitmapsReply(client, size, pRep)
      ClientPtr   client;
      int         size;
!     fsQueryXBitmaps8Reply *pRep; /* QueryXBitmaps16Reply is the same */
  {
      int         n;
  
***************
*** 376,382 ****
  
      pInfoT = pInfoTBase = (char *) ALLOCATE_LOCAL(size);
      if (!pInfoT) {
! 	client->noClientException = -1;
  	return;
      }
      SwapConnSetupAccept(pConnSetup, (fsConnSetupAccept *) pInfoT);
--- 374,380 ----
  
      pInfoT = pInfoTBase = (char *) ALLOCATE_LOCAL(size);
      if (!pInfoT) {
! 	client->noClientException = -2;
  	return;
      }
      SwapConnSetupAccept(pConnSetup, (fsConnSetupAccept *) pInfoT);
*** /tmp/da29353	Tue Jul 14 18:09:02 1992
--- mit/fonts/server/difs/swapreq.c	Tue Jul 14 18:09:02 1992
***************
*** 1,4 ****
! /* $XConsortium: swapreq.c,v 1.3 91/07/16 20:23:43 keith Exp $ */
  /*
   * swapped requests
   */
--- 1,4 ----
! /* $XConsortium: swapreq.c,v 1.5 92/05/28 16:43:04 gildea Exp $ */
  /*
   * swapped requests
   */
***************
*** 7,31 ****
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, and distribute this protoype software
!  * and its documentation to Members and Affiliates of the MIT X Consortium
!  * any purpose and without fee is hereby granted, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * MIT not be used in advertising or publicity pertaining to distribution of
!  * the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND MIT DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
!  * AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES, DIGITAL OR MIT BE
!  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
!  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
!  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  *
!  * $NCDId: @(#)swapreq.c,v 4.2 1991/06/27 16:34:49 lemke Exp $
!  *
   */
  
  #include	"misc.h"
--- 7,28 ----
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, distribute, and sell this software and
!  * its documentation for any purpose is hereby granted without fee, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * M.I.T. not be used in advertising or publicity pertaining to distribution
!  * of the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND M.I.T. DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
!  * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES,
!  * DIGITAL OR M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
!  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
!  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
!  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
!  * THIS SOFTWARE.
   */
  
  #include	"misc.h"
***************
*** 250,279 ****
  }
  
  int
! SProcQueryXExtents8(client)
      ClientPtr   client;
  {
      char        n;
  
!     REQUEST(fsQueryXExtents8Req);
      swaps(&stuff->length, n);
      swapl(&stuff->fid, n);
  
!     return ((*ProcVector[FS_QueryXExtents8]) (client));
  }
  
  int
! SProcQueryXBitmaps8(client)
      ClientPtr   client;
  {
      char        n;
  
!     REQUEST(fsQueryXBitmaps8Req);
      swaps(&stuff->length, n);
      swapl(&stuff->fid, n);
      swapl(&stuff->format, n);
  
!     return ((*ProcVector[FS_QueryXBitmaps8]) (client));
  }
  
  SwapConnClientPrefix(pCCP)
--- 247,278 ----
  }
  
  int
! SProcQueryXExtents(client)
      ClientPtr   client;
  {
      char        n;
  
!     REQUEST(fsQueryXExtents8Req); /* 8 and 16 are the same here */
      swaps(&stuff->length, n);
      swapl(&stuff->fid, n);
+     swapl(&stuff->num_ranges, n);
  
!     return ((*ProcVector[stuff->reqType]) (client));
  }
  
  int
! SProcQueryXBitmaps(client)
      ClientPtr   client;
  {
      char        n;
  
!     REQUEST(fsQueryXBitmaps8Req); /* 8 and 16 are the same here */
      swaps(&stuff->length, n);
      swapl(&stuff->fid, n);
      swapl(&stuff->format, n);
+     swapl(&stuff->num_ranges, n);
  
!     return ((*ProcVector[stuff->reqType]) (client));
  }
  
  SwapConnClientPrefix(pCCP)
*** /tmp/da29375	Tue Jul 14 18:09:04 1992
--- mit/fonts/server/difs/tables.c	Tue Jul 14 18:09:04 1992
***************
*** 1,4 ****
! /* $XConsortium: tables.c,v 1.3 91/07/16 20:23:45 keith Exp $ */
  /*
   * all the dispatch, error, event and reply vectors
   */
--- 1,4 ----
! /* $XConsortium: tables.c,v 1.5 92/05/28 16:43:08 gildea Exp $ */
  /*
   * all the dispatch, error, event and reply vectors
   */
***************
*** 7,42 ****
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, and distribute this protoype software
!  * and its documentation to Members and Affiliates of the MIT X Consortium
!  * any purpose and without fee is hereby granted, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * MIT not be used in advertising or publicity pertaining to distribution of
!  * the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND MIT DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
!  * AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES, DIGITAL OR MIT BE
!  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
!  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
!  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  *
!  * $NCDId: @(#)tables.c,v 4.2 1991/06/27 16:34:38 lemke Exp $
!  *
   */
- #include	"globals.h"
  
  extern int  ProcInitialConnection(), ProcEstablishConnection();
  
! extern int  ProcSetAuthorization(), ProcGetAuthorization(),
              ProcSetResolution(), ProcGetResolution(), ProcNoop(),
              ProcListExtensions(), ProcQueryExtension(),
              ProcListFonts(), ProcListFontsWithXInfo(),
!             ProcOpenBitmapFont(), ProcQueryXInfo(), ProcQueryXExtents8(),
!             ProcQueryXBitmaps8(), ProcCloseFont(),
              ProcListCatalogues(), ProcSetCatalogues(), ProcGetCatalogues(),
              ProcSetEventMask(), ProcGetEventMask(),
              ProcCreateAC(), ProcFreeAC();
--- 7,40 ----
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, distribute, and sell this software and
!  * its documentation for any purpose is hereby granted without fee, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * M.I.T. not be used in advertising or publicity pertaining to distribution
!  * of the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND M.I.T. DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
!  * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES,
!  * DIGITAL OR M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
!  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
!  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
!  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
!  * THIS SOFTWARE.
   */
  
+ #include "globals.h"
+ 
  extern int  ProcInitialConnection(), ProcEstablishConnection();
  
! extern int  ProcSetAuthorization(),
              ProcSetResolution(), ProcGetResolution(), ProcNoop(),
              ProcListExtensions(), ProcQueryExtension(),
              ProcListFonts(), ProcListFontsWithXInfo(),
!             ProcOpenBitmapFont(), ProcQueryXInfo(), ProcQueryXExtents(),
!             ProcQueryXBitmaps(), ProcCloseFont(),
              ProcListCatalogues(), ProcSetCatalogues(), ProcGetCatalogues(),
              ProcSetEventMask(), ProcGetEventMask(),
              ProcCreateAC(), ProcFreeAC();
***************
*** 43,53 ****
  
  extern int  SProcSimpleRequest(), SProcResourceRequest(),
  	    SProcListCatalogues(),
!             SProcSetResolution(), SProcGetResolution(),
!             SProcListExtensions(), SProcQueryExtension(),
              SProcListFonts(), SProcListFontsWithXInfo(),
!             SProcOpenBitmapFont(), SProcQueryXExtents8(),
!             SProcQueryXBitmaps8(),
              SProcCreateAC();
  
  extern void SErrorEvent();
--- 41,51 ----
  
  extern int  SProcSimpleRequest(), SProcResourceRequest(),
  	    SProcListCatalogues(),
!             SProcSetResolution(),
!             SProcQueryExtension(),
              SProcListFonts(), SProcListFontsWithXInfo(),
!             SProcOpenBitmapFont(), SProcQueryXExtents(),
!             SProcQueryXBitmaps(),
              SProcCreateAC();
  
  extern void SErrorEvent();
***************
*** 58,65 ****
              SQueryExtensionReply(),
              SListFontsReply(), SListFontsWithXInfoReply(),
              SOpenBitmapFontReply(),
!             SQueryXInfoReply(), SQueryXExtents8Reply(),
!             SQueryXBitmaps8Reply(),
              SGetEventMaskReply(), SCreateACReply(), SGetResolutionReply(),
              SOpenBitmapFontReply();
  
--- 56,63 ----
              SQueryExtensionReply(),
              SListFontsReply(), SListFontsWithXInfoReply(),
              SOpenBitmapFontReply(),
!             SQueryXInfoReply(), SQueryXExtentsReply(),
!             SQueryXBitmapsReply(),
              SGetEventMaskReply(), SCreateACReply(), SGetResolutionReply(),
              SOpenBitmapFontReply();
  
***************
*** 90,99 ****
      ProcListFontsWithXInfo,
      ProcOpenBitmapFont,		/* 15 */
      ProcQueryXInfo,
!     ProcQueryXExtents8,
!     ProcQueryXExtents8,
!     ProcQueryXBitmaps8,
!     ProcQueryXBitmaps8,		/* 20 */
      ProcCloseFont,
      0,
      0,
--- 88,97 ----
      ProcListFontsWithXInfo,
      ProcOpenBitmapFont,		/* 15 */
      ProcQueryXInfo,
!     ProcQueryXExtents,
!     ProcQueryXExtents,
!     ProcQueryXBitmaps,
!     ProcQueryXBitmaps,		/* 20 */
      ProcCloseFont,
      0,
      0,
***************
*** 104,110 ****
  {
      SProcSimpleRequest,		/* 0 */
      SProcSimpleRequest,
!     ProcQueryExtension,
      SProcListCatalogues,
      SProcSimpleRequest,		/* SetCatalogues */
      SProcSimpleRequest,		/* 5 */
--- 102,108 ----
  {
      SProcSimpleRequest,		/* 0 */
      SProcSimpleRequest,
!     SProcQueryExtension,
      SProcListCatalogues,
      SProcSimpleRequest,		/* SetCatalogues */
      SProcSimpleRequest,		/* 5 */
***************
*** 119,128 ****
      SProcListFontsWithXInfo,
      SProcOpenBitmapFont,	/* 15 */
      SProcResourceRequest,
!     SProcQueryXExtents8,
!     SProcQueryXExtents8,
!     SProcQueryXBitmaps8,
!     SProcQueryXBitmaps8,	/* 20 */
      SProcResourceRequest,
      0,
      0,
--- 117,126 ----
      SProcListFontsWithXInfo,
      SProcOpenBitmapFont,	/* 15 */
      SProcResourceRequest,
!     SProcQueryXExtents,
!     SProcQueryXExtents,
!     SProcQueryXBitmaps,
!     SProcQueryXBitmaps,		/* 20 */
      SProcResourceRequest,
      0,
      0,
***************
*** 160,169 ****
      SListFontsWithXInfoReply,
      SOpenBitmapFontReply,	/* 15 */
      SQueryXInfoReply,
!     SQueryXExtents8Reply,
!     SQueryXExtents8Reply,
!     SQueryXBitmaps8Reply,
!     SQueryXBitmaps8Reply,	/* 20 */
      NotImplemented,		/* Close */
      NotImplemented,
      NotImplemented
--- 158,167 ----
      SListFontsWithXInfoReply,
      SOpenBitmapFontReply,	/* 15 */
      SQueryXInfoReply,
!     SQueryXExtentsReply,
!     SQueryXExtentsReply,
!     SQueryXBitmapsReply,
!     SQueryXBitmapsReply,	/* 20 */
      NotImplemented,		/* Close */
      NotImplemented,
      NotImplemented
*** /dev/null	Tue Jul 14 18:06:05 1992
--- mit/fonts/server/difs/charinfo.c	Tue Jul 14 18:09:06 1992
***************
*** 0 ****
--- 1,592 ----
+ /* $XConsortium: charinfo.c,v 1.6 92/05/28 15:57:19 gildea Exp $ */
+ /*
+  * Copyright 1990, 1991 Network Computing Devices;
+  * Portions Copyright 1987 by Digital Equipment Corporation and the
+  * Massachusetts Institute of Technology
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the names of Network Computing Devices, Digital or
+  * M.I.T. not be used in advertising or publicity pertaining to distribution
+  * of the software without specific, written prior permission.
+  *
+  * NETWORK COMPUTING DEVICES, DIGITAL AND M.I.T. DISCLAIM ALL WARRANTIES WITH
+  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
+  * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES,
+  * DIGITAL OR M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
+  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
+  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+  * THIS SOFTWARE.
+  */
+ /*
+  * Defines GetExtents() and GetBitmaps(), which are
+  * called from routines in fontinfo.c.
+  * This file was once on the other side of
+  * the font library interface as util/fsfuncs.c.
+  */
+ 
+ #include <X11/Xos.h>
+ #include "misc.h"
+ #include "fontstruct.h"
+ #include "clientstr.h"
+ #define FSMD_H
+ #include "FSproto.h"
+ 
+ extern void TwoByteSwap();
+ extern void FourByteSwap();
+ 
+ #define GLWIDTHBYTESPADDED(bits,nbytes) \
+ 	((nbytes) == 1 ? (((bits)+7)>>3)        /* pad to 1 byte */ \
+ 	:(nbytes) == 2 ? ((((bits)+15)>>3)&~1)  /* pad to 2 bytes */ \
+ 	:(nbytes) == 4 ? ((((bits)+31)>>3)&~3)  /* pad to 4 bytes */ \
+ 	:(nbytes) == 8 ? ((((bits)+63)>>3)&~7)  /* pad to 8 bytes */ \
+ 	: 0)
+ 
+ #define GLYPH_SIZE(ch, nbytes)          \
+ 	GLWIDTHBYTESPADDED((ch)->metrics.rightSideBearing - \
+ 			(ch)->metrics.leftSideBearing, (nbytes))
+ 
+ #define n2dChars(pfi)   (((pfi)->lastRow - (pfi)->firstRow + 1) * \
+                          ((pfi)->lastCol - (pfi)->firstCol + 1))
+ 
+ static CharInfoRec  junkDefault;
+ 
+ static int
+ getCharInfos (pfont, num_ranges, range, ink_metrics, nump, retp)
+     FontPtr	pfont;
+     int		num_ranges;
+     fsRange	*range;
+     Bool	ink_metrics;
+     int		*nump;		/* return */
+     CharInfoPtr	**retp;		/* return */
+ {
+     CharInfoPtr	*xchars, *xci;
+     int		nchars;
+     FontInfoPtr pinfo = &pfont->info;
+     unsigned int r, c;
+     unsigned char   ch[2];
+     int         firstCol = pinfo->firstCol;
+     int         firstRow = pinfo->firstRow;
+     int         lastRow = pinfo->lastRow;
+     int         lastCol = pinfo->lastCol;
+     int		minCol, maxCol;
+     int         num_cols = lastCol - firstCol + 1;
+     fsRange	local_range, *rp;
+     int		i;
+     FontEncoding    encoding;
+     int		err;
+     unsigned long   glyphCount;
+     unsigned short  defaultCh;
+     CharInfoPtr	    defaultPtr;
+     int (*metrics_func) ();
+     
+     /*
+      * compute nchars
+      */
+     if (num_ranges == 0) {
+ 	if (lastRow)
+ 	    nchars = n2dChars(pinfo);
+ 	else
+ 	    nchars = lastCol - firstCol + 1;
+ 	local_range.min_char.low = firstCol;
+ 	local_range.min_char.high = firstRow;
+ 	local_range.max_char.low = lastCol;
+ 	local_range.max_char.high = lastRow;
+ 	range = &local_range;
+ 	num_ranges = 1;
+     } else {
+ 	nchars = 0;
+ 	for (i = 0, rp = range; i < num_ranges; i++, rp++) {
+ 	    if (rp->min_char.high > rp->max_char.high)
+ 		return BadCharRange;
+ 	    if (rp->min_char.high == rp->max_char.high)
+ 	    {
+ 		if (rp->min_char.low > rp->max_char.low)
+ 		    return BadCharRange;
+ 		nchars += rp->max_char.low - rp->min_char.low + 1;
+ 	    }
+ 	    else
+ 	    {
+ 		nchars += lastRow - rp->min_char.low + 1;
+ 		nchars += (rp->max_char.high - rp->min_char.high - 1) * num_cols;
+ 		nchars += rp->max_char.low - firstRow + 1;
+ 	    }
+ 	}
+     }
+ 
+     xchars = (CharInfoPtr *) fsalloc (sizeof (CharInfoPtr) * nchars);
+     if (!xchars)
+ 	return AllocError;
+ 
+     if (ink_metrics)
+ 	metrics_func = pfont->get_metrics;
+     else
+ 	metrics_func = pfont->get_glyphs;
+ 
+     xci = xchars;
+     encoding = Linear16Bit;
+     if (lastRow)
+ 	encoding = TwoD16Bit;
+     defaultCh = pinfo->defaultCh;
+     ch[0] = defaultCh >> 8;
+     ch[1] = defaultCh & 0xff;
+     /* get the default character */
+     (*metrics_func) (pfont, 1, ch, encoding,
+ 			  &glyphCount, &defaultPtr);
+     if (glyphCount != 1)
+ 	defaultPtr = 0;
+     
+     /* for each range, get each character individually, undoing the
+      default character substitution so we get zero metrics for
+      non-existent characters. */
+     for (i = 0, rp = range; i < num_ranges; i++, rp++) {
+ 	for (r = rp->min_char.high; r <= rp->max_char.high; r++)
+ 	{
+ 	    minCol = firstCol;
+ 	    if (r == rp->min_char.high)
+ 		minCol = rp->min_char.low;
+ 	    maxCol = lastCol;
+ 	    if (r == rp->max_char.high)
+ 		maxCol = rp->max_char.low;
+ 	    for (c = minCol; c <= maxCol; c++) {
+ 		ch[0] = r;
+ 		ch[1] = c;
+ 		err = (*metrics_func) (pfont, 1, ch, encoding,
+ 					    &glyphCount, xci);
+ 		if (err != Successful)
+ 		{
+ 		    fsfree (xchars);
+ 		    return err;
+ 		}
+ 		if (glyphCount != 1 || 
+ 		    *xci == defaultPtr && defaultCh != ((r<<8)+c))
+ 		    *xci = &junkDefault;
+ 		xci++;
+ 	    }
+ 	}
+     }
+     *retp = xchars;
+     *nump = nchars;
+     return Successful;
+ }
+ 
+ int
+ GetExtents(client, pfont, flags, num_ranges, range, num_extents, data)
+     ClientPtr     client;
+     FontPtr     pfont;
+     Mask        flags;
+     unsigned long num_ranges;
+     fsRange    *range;
+     unsigned long *num_extents;	/* return */
+     fsCharInfo **data;		/* return */
+ {
+     unsigned long size;
+     fsCharInfo *ci,
+     *pci;
+     CharInfoPtr	*xchars, *xcharsFree, xci;
+     int		nchars;
+     int		err;
+     
+     if (flags & LoadAll)
+ 	num_ranges = 0;
+     err = getCharInfos (pfont, num_ranges, range,
+ 			client->major_version > 1 ? TRUE : FALSE,
+ 			&nchars, &xchars);
+     if (err != Successful)
+ 	return err;
+     
+     size = sizeof(fsCharInfo) * nchars;
+     pci = ci = (fsCharInfo *) fsalloc(size);
+     if (!ci) {
+ 	fsfree (xchars);
+ 	return AllocError;
+     }
+     
+     *num_extents = nchars;
+     xcharsFree = xchars;
+     
+     while (nchars--) {
+ 	xci = *xchars++;
+ 	pci->ascent = xci->metrics.ascent;
+ 	pci->descent = xci->metrics.descent;
+ 	pci->left = xci->metrics.leftSideBearing;
+ 	pci->right = xci->metrics.rightSideBearing;
+ 	pci->width = xci->metrics.characterWidth;
+ 	pci->attributes = 0;
+ 	pci++;
+     }
+     
+     fsfree (xcharsFree);
+     
+     *data = ci;
+     
+     return Successful;
+ }
+ 
+ static int
+ packGlyphs (client, pfont, format, flags, num_ranges, range, tsize, num_glyphs,
+ 		offsets, data, freeData)
+     ClientPtr   client;
+     FontPtr     pfont;
+     int         format;
+     Mask        flags;
+     unsigned long num_ranges;
+     fsRange    *range;
+     int        *tsize;
+     unsigned long *num_glyphs;
+     fsOffset  **offsets;
+     pointer    *data;
+     int		*freeData;
+ {
+     int         i;
+     fsOffset	*lengths, *l;
+     unsigned long size = 0;
+     pointer     gdata,
+     gd;
+     int         bitorder, byteorder, scanlinepad, scanlineunit, mappad;
+     int		height, dstbpr, charsize;
+     int		dst_off, src_off;
+     Bool	contiguous, reformat;
+     int		nchars;
+     int         src_glyph_pad = pfont->glyph;
+     int         src_bit_order = pfont->bit;
+     int         src_byte_order = pfont->byte;
+     int         err;
+     int		max_ascent, max_descent;
+     int		min_left, max_right;
+     int		srcbpr;
+     int		lshift = 0, rshift = 0, dst_left_bytes = 0, src_left_bytes = 0;
+     unsigned char   *srcp;
+     unsigned char   *dstp;
+     unsigned char   bits1, bits2;
+     int		    width;
+     int		    src_extra;
+     int		    dst_extra;
+     int		    r, w;
+     CharInfoPtr	*bitChars, *bitCharsFree, bitc;
+     CharInfoPtr	*inkChars, *inkCharsFree = 0, inkc;
+     FontInfoPtr	pinfo = &pfont->info;
+     xCharInfo	*bitm, *inkm;
+     
+     err = CheckFSFormat(format, (fsBitmapFormatMask) ~ 0,
+ 			&bitorder, &byteorder, &scanlineunit, &scanlinepad, &mappad);
+     
+     if (err != Successful)
+ 	return err;
+     
+     if (flags & LoadAll)
+ 	num_ranges = 0;
+     
+     err = getCharInfos (pfont, num_ranges, range, FALSE, &nchars, &bitCharsFree);
+     
+     if (err != Successful)
+ 	return err;
+     
+     /* compute dstbpr for padded out fonts */
+     reformat = bitorder != src_bit_order || byteorder != src_byte_order;
+ 
+     /* we need the ink metrics when shrink-wrapping a TE font (sigh),
+      * but only for protocol version > 1 */
+     if (mappad != BitmapFormatImageRectMax &&
+ 	pinfo->inkMetrics &&
+ 	client->major_version > 1)
+     {
+ 	err = getCharInfos (pfont, num_ranges, range, TRUE, &nchars, &inkCharsFree);
+ 	if (err != Successful)
+ 	{
+ 	    fsfree (bitCharsFree);
+ 	    return err;
+ 	}
+ 	reformat = TRUE;
+     }
+ 
+     /* get space for glyph offsets */
+     lengths = (fsOffset *) fsalloc(sizeof(fsOffset) * nchars);
+     if (!lengths) {
+ 	fsfree (bitCharsFree);
+ 	fsfree (inkCharsFree);
+ 	return AllocError;
+     }
+     
+     switch (mappad)
+     {
+     case BitmapFormatImageRectMax:
+ 	max_ascent = FONT_MAX_ASCENT(pinfo);
+ 	max_descent = FONT_MAX_DESCENT(pinfo);
+ 	height = max_ascent + max_descent;
+ 	/* do font ascent and font descent match bitmap bounds ? */
+ 	if (height != pinfo->minbounds.ascent + pinfo->minbounds.descent)
+ 	    reformat = TRUE;
+ 	/* fall through */
+     case BitmapFormatImageRectMaxWidth:
+ 	min_left = FONT_MIN_LEFT(pinfo);
+ 	max_right = FONT_MAX_RIGHT(pinfo);
+ 	if (min_left != pinfo->maxbounds.leftSideBearing)
+ 	    reformat = TRUE;
+ 	if (max_right != pinfo->maxbounds.rightSideBearing)
+ 	    reformat = TRUE;
+ 	dstbpr = GLWIDTHBYTESPADDED(max_right - min_left, scanlinepad);
+ 	break;
+     case BitmapFormatImageRectMin:
+ 	break;
+     }
+     if (mappad == BitmapFormatImageRectMax)
+ 	charsize = dstbpr * height;
+     size = 0;
+     gdata = 0;
+     contiguous = TRUE;
+     l = lengths;
+     inkChars = inkCharsFree;
+     bitChars = bitCharsFree;
+     for (i = 0; i < nchars; i++)
+     {
+     	inkc = bitc = *bitChars++;
+ 	/* when ink metrics != bitmap metrics, use ink metrics */
+ 	if (inkChars)
+ 	    inkc = *inkChars++;
+     	l->position = size;
+     	if (bitc && bitc->bits) {
+ 	    if (!gdata)
+ 		gdata = (pointer) bitc->bits;
+ 	    if ((char *) gdata + size != bitc->bits)
+ 		contiguous = FALSE;
+ 	    if (mappad == BitmapFormatImageRectMin)
+ 		dstbpr = GLYPH_SIZE(inkc, scanlinepad);
+ 	    if (mappad != BitmapFormatImageRectMax)
+ 	    {
+ 		height = inkc->metrics.ascent + inkc->metrics.descent;
+ 		charsize = height * dstbpr;
+ 	    }
+ 	    l->length = charsize;
+ 	    size += charsize;
+ 	}
+ 	else
+ 	    l->length = 0;
+ 	l++;
+     }
+     if (contiguous && !reformat)
+     {
+ 	*num_glyphs = nchars;
+ 	*freeData = FALSE;
+ 	*data = gdata;
+ 	*tsize = size;
+ 	*offsets = lengths;
+ 	fsfree (bitCharsFree);
+ 	fsfree (inkCharsFree);
+ 	return Successful;
+     }
+     if (size)
+     {
+ 	gdata = (pointer) fsalloc(size);
+ 	if (!gdata) {
+ 	    fsfree (bitCharsFree);
+ 	    fsfree (inkCharsFree);
+ 	    fsfree (lengths);
+ 	    return AllocError;
+ 	}
+ 	bzero ((char *) gdata, size);
+     }
+     else
+ 	gdata = NULL;
+     
+     *freeData = TRUE;
+     l = lengths;
+     gd = gdata;
+     
+     /* finally do the work */
+     bitChars = bitCharsFree;
+     inkChars = inkCharsFree;
+     for (i = 0; i < nchars; i++, l++) 
+     {
+ 	inkc = bitc = *bitChars++;
+ 	if (inkChars)
+ 	    inkc = *inkChars++;
+ 
+ 	/* ignore missing chars */
+ 	if (l->length == 0)
+ 	    continue;
+ 	
+ 	bitm = &bitc->metrics;
+ 	inkm = &inkc->metrics;
+ 
+ 	/* start address for the destination of bits for this char */
+ 
+ 	dstp = gd;
+ 
+ 	/* adjust destination and calculate shift offsets */
+ 	switch (mappad) {
+ 	case BitmapFormatImageRectMax:
+ 	    /* leave the first padded rows blank */
+ 	    dstp += dstbpr * (max_ascent - inkm->ascent);
+ 	    /* fall thru */
+ 	case BitmapFormatImageRectMaxWidth:
+ 	    dst_off = inkm->leftSideBearing - min_left;
+ 	    break;
+ 	case BitmapFormatImageRectMin:
+ 	    dst_off = 0;
+ 	    dstbpr = GLYPH_SIZE(inkc, scanlinepad);
+ 	    break;
+ 	}
+ 
+ 	srcbpr = GLYPH_SIZE (bitc, src_glyph_pad);
+ 	srcp = (unsigned char *) bitc->bits;
+ 
+ 	/* adjust source */
+ 	src_off = 0;
+ 	if (inkm != bitm)
+ 	{
+ 	    srcp += (bitm->ascent - inkm->ascent) * srcbpr;
+ 	    src_off = inkm->leftSideBearing - bitm->leftSideBearing;
+ 	}
+ 
+ 	dst_left_bytes = dst_off >> 3;
+ 	dst_off &= 7;
+ 	src_left_bytes = src_off >> 3;
+ 	src_off &= 7;
+ 
+ 	/* minimum of source/dest bytes per row */
+ 	width = srcbpr;
+ 	if (srcbpr > dstbpr)
+ 	    width = dstbpr;
+ 	/* extra bytes in source and dest for padding */
+ 	src_extra = srcbpr - width - src_left_bytes;
+ 	dst_extra = dstbpr - width - dst_left_bytes;
+ 	
+ #define MSBBitLeft(b,c)	((b) << (c))
+ #define MSBBitRight(b,c)	((b) >> (c))
+ #define LSBBitLeft(b,c)	((b) >> (c))
+ #define LSBBitRight(b,c)	((b) << (c))
+ 
+ 	if (dst_off == src_off)
+ 	{
+ 	    if (srcbpr == dstbpr && src_left_bytes == dst_left_bytes)
+ 	    {
+ 		r = (inkm->ascent + inkm->descent) * width;
+ 		bcopy (srcp, dstp, r);
+ 		dstp += r;
+ 	    }
+ 	    else
+ 	    {
+ 		for (r = inkm->ascent + inkm->descent; r; r--)
+ 		{
+ 		    dstp += dst_left_bytes;
+ 		    srcp += src_left_bytes;
+ 		    for (w = width; w; w--)
+ 			*dstp++ = *srcp++;
+ 		    dstp += dst_extra;
+ 		    srcp += src_extra;
+ 		}
+ 	    }
+ 	}
+ 	else
+ 	{
+ 	    if (dst_off > src_off)
+ 	    {
+ 	    	rshift = dst_off - src_off;
+ 	    	lshift = 8 - rshift;
+ 	    }
+ 	    else
+ 	    {
+ 	    	lshift = src_off - dst_off;
+ 	    	rshift = 8 - lshift;
+ 		/* run the loop one fewer time if necessary */
+ 		if (src_extra <= dst_extra)
+ 		{
+ 		    dst_extra++;
+ 		    width--;
+ 		}
+ 		else
+ 		    src_extra--;
+ 	    }
+ 	    
+ 	    for (r = inkm->ascent + inkm->descent; r; r--)
+ 	    {
+ 		dstp += dst_left_bytes;
+ 		srcp += src_left_bytes;
+ 		bits2 = 0;
+ 		/* fetch first part of source when necessary */
+ 		if (dst_off < src_off)
+ 		    bits2 = *srcp++;
+ 		/*
+  		 * XXX I bet this does not work when
+ 		 * src_bit_order != src_byte_order && scanlineunit > 1
+ 		 */
+ 		for (w = width; w; w--)
+ 		{
+ 		    bits1 = *srcp++;
+ 		    if (src_bit_order == MSBFirst)
+ 		    {
+ 			*dstp++ = MSBBitRight(bits1, rshift) |
+ 				 MSBBitLeft (bits2, lshift);
+ 		    }
+ 		    else
+ 		    {
+ 			*dstp++ = LSBBitRight(bits1, rshift) |
+ 				 LSBBitLeft (bits2, lshift);
+ 		    }
+ 		    bits2 = bits1;
+ 		}
+ 		/* get the last few bits if we have a place to store them */
+ 		if (dst_extra > 0)
+ 		{
+ 		    if (src_bit_order == MSBFirst)
+ 			*dstp = MSBBitLeft (bits2, lshift);
+ 		    else
+ 			*dstp = LSBBitLeft (bits2, lshift);
+ 		}
+ 		dstp += dst_extra;
+ 		srcp += src_extra;
+ 	    }
+ 	}
+ 	/* skip the amount we just filled in */
+ 	gd += l->length;
+     }
+     
+     
+     /* now do the bit, byte, word swapping */
+     if (bitorder != src_bit_order)
+ 	BitOrderInvert(gdata, size);
+     if (byteorder != src_byte_order) 
+     {
+ 	if (scanlineunit == 2)
+ 	    TwoByteSwap(gdata, size);
+ 	else if (scanlineunit == 4)
+ 	    FourByteSwap(gdata, size);
+     }
+     fsfree (bitCharsFree);
+     fsfree (inkCharsFree);
+     *num_glyphs = nchars;
+     *data = gdata;
+     *tsize = size;
+     *offsets = lengths;
+     
+     return Successful;
+ }
+ 
+ /* ARGSUSED */
+ int
+ GetBitmaps(client, pfont, format, flags, num_ranges, range,
+ 		 size, num_glyphs, offsets, data, freeData)
+     ClientPtr     client;
+     FontPtr     pfont;
+     fsBitmapFormat format;
+     Mask        flags;
+     unsigned long num_ranges;
+     fsRange    *range;
+     int        *size;
+     unsigned long *num_glyphs;
+     fsOffset  **offsets;
+     pointer    *data;
+     int		*freeData;
+ {
+     assert(pfont);
+ 
+     *size = 0;
+     *data = (pointer) 0;
+     return packGlyphs (client, pfont, format, flags,
+ 			      num_ranges, range, size, num_glyphs,
+ 			      offsets, data, freeData);
+ }
*** /tmp/da28303	Tue Jul 14 18:07:30 1992
--- mit/fonts/server/include/clientstr.h	Tue Jul 14 18:07:29 1992
***************
*** 1,4 ****
! /* $XConsortium: clientstr.h,v 1.3 91/05/13 16:48:15 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
--- 1,4 ----
! /* $XConsortium: clientstr.h,v 1.4 92/05/12 18:07:58 gildea Exp $ */
  /*
   * Copyright 1990, 1991 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
***************
*** 20,28 ****
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  *
-  * @(#)clientstr.h	4.2	91/05/03
-  *
   */
  
  #ifndef _CLIENTSTR_H_
--- 20,25 ----
***************
*** 50,55 ****
--- 47,54 ----
      Mask        eventmask;
      fsResolution *resolutions;
      int         num_resolutions;
+     int		major_version;	/* client-major-protocol-version */
+     int		minor_version;
  }           ClientRec;
  
  typedef struct _WorkQueue {
*** /tmp/da28733	Tue Jul 14 18:08:04 1992
--- mit/fonts/server/include/servermd.h	Tue Jul 14 18:08:04 1992
***************
*** 1,4 ****
! /* $XConsortium: servermd.h,v 1.4 91/07/25 12:15:04 keith Exp $ */
  /* 
   * Copyright 1990, 1991 Network Computing Devices; 
   * Portions Copyright 1987 by Digital Equipment Corporation and the 
--- 1,4 ----
! /* $XConsortium: servermd.h,v 1.5 92/05/12 18:08:01 gildea Exp $ */
  /* 
   * Copyright 1990, 1991 Network Computing Devices; 
   * Portions Copyright 1987 by Digital Equipment Corporation and the 
***************
*** 20,34 ****
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  *
-  * @(#)servermd.h	4.1	91/05/02
-  *
   */
  #ifndef _SERVERMD_H_
  #define _SERVERMD_H_
  
  #ifndef VENDOR_RELEASE
! #define VENDOR_RELEASE 5000
  #endif
  
  #ifndef VENDOR_STRING
--- 20,31 ----
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   */
  #ifndef _SERVERMD_H_
  #define _SERVERMD_H_
  
  #ifndef VENDOR_RELEASE
! #define VENDOR_RELEASE 5001
  #endif
  
  #ifndef VENDOR_STRING
*** /tmp/da25067	Tue Jul 14 18:02:28 1992
--- mit/fonts/clients/Imakefile	Tue Jul 14 18:02:28 1992
***************
*** 1,12 ****
! XCOMM $XConsortium: Imakefile,v 1.3 91/07/18 15:51:59 rws Exp $
  #define IHaveSubdirs
  #define PassCDebugFlags 'CDEBUGFLAGS=$(CDEBUGFLAGS)'
  
! #if BuildFonts
! COMPDIRS = bdftopcf mkfontdir
! #endif
! 
!          SUBDIRS = $(COMPDIRS) fsinfo fslsfonts fstobdf showfont
  
  MakeSubdirs($(SUBDIRS))
  DependSubdirs($(SUBDIRS))
--- 1,8 ----
! XCOMM $XConsortium: Imakefile,v 1.4 91/12/23 10:58:08 rws Exp $
  #define IHaveSubdirs
  #define PassCDebugFlags 'CDEBUGFLAGS=$(CDEBUGFLAGS)'
  
!          SUBDIRS = bdftopcf mkfontdir fsinfo fslsfonts fstobdf showfont
  
  MakeSubdirs($(SUBDIRS))
  DependSubdirs($(SUBDIRS))
*** /tmp/da25524	Tue Jul 14 18:03:09 1992
--- mit/fonts/clients/showfont/showfont.c	Tue Jul 14 18:03:08 1992
***************
*** 1,28 ****
! /* $XConsortium: showfont.c,v 1.2 91/05/13 16:36:36 gildea Exp $ */
  /*
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, and distribute this protoype software
!  * and its documentation to Members and Affiliates of the MIT X Consortium
!  * any purpose and without fee is hereby granted, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * MIT not be used in advertising or publicity pertaining to distribution of
!  * the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND MIT DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
!  * AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES, DIGITAL OR MIT BE
!  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
!  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
!  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  *
!  * @(#)showfont.c	4.1	91/05/02
!  *
   */
  #include	<stdio.h>
  #include	<ctype.h>
--- 1,25 ----
! /* $XConsortium: showfont.c,v 1.7 92/05/19 17:10:30 gildea Exp $ */
  /*
   * Copyright 1990 Network Computing Devices;
   * Portions Copyright 1987 by Digital Equipment Corporation and the
   * Massachusetts Institute of Technology
   *
!  * Permission to use, copy, modify, distribute, and sell this software and
!  * its documentation for any purpose is hereby granted without fee, provided
   * that the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
   * documentation, and that the names of Network Computing Devices, Digital or
!  * M.I.T. not be used in advertising or publicity pertaining to distribution
!  * of the software without specific, written prior permission.
   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND M.I.T. DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
!  * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL NETWORK COMPUTING DEVICES,
!  * DIGITAL OR M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
!  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
!  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
!  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
!  * THIS SOFTWARE.
   */
  #include	<stdio.h>
  #include	<ctype.h>
***************
*** 44,54 ****
--- 41,55 ----
              bitmap_pad = 0,
              scan_unit = 8;
  
+ /* set from bitmap_pad to ImageRect, ImageMaxWidth, or ImageMax */
+ int	    bitmap_format;	
+ 
  int         bitorder = MSBFirst;
  int         byteorder = MSBFirst;
  int         first_ch = 0;
  int         end_ch = ~0;
  char       *cmd;
+ Bool	    no_props = False;	/* -noprops: don't show font properties */
  
  static fsBitmapFormat make_format();
  static Bool extents_only = False;
***************
*** 56,62 ****
  static void
  usage()
  {
!     fprintf(stderr, "%s: [-server servername] [-extents_only] [-l] [-m] [-L] -[M] [-unit #] [-pad #] [-bitmap_pad value] [-start first_char] [-end last_char] -fn fontname\n", cmd);
      exit(0);
  }
  
--- 57,63 ----
  static void
  usage()
  {
!     fprintf(stderr, "%s: [-server servername] [-extents_only] [-noprops] [-l] [-m] [-L] -[M] [-unit #] [-pad #] [-bitmap_pad value] [-start first_char] [-end last_char] -fn fontname\n", cmd);
      exit(0);
  }
  
***************
*** 89,94 ****
--- 90,97 ----
  		usage();
  	} else if (!strncmp(argv[i], "-ext", 4)) {
  	    extents_only = True;
+ 	} else if (!strncmp(argv[i], "-noprops", 7)) {
+ 	    no_props = True;
  	} else if (!strncmp(argv[i], "-l", 2)) {
  	    bitorder = LSBFirst;
  	} else if (!strncmp(argv[i], "-m", 2)) {
***************
*** 151,163 ****
  	show_info(fid, &hdr, &first, &last);
  	if (first_ch != 0 &&
  		(first_ch >= (first.low + (first.high << 8)))) {
! 	    first.low = first_ch % 0xff;
  	    first.high = first_ch >> 8;
  	    show_all = False;
  	}
  	if (end_ch != ~0 &&
  		(end_ch <= (last.low + (last.high << 8)))) {
! 	    last.low = end_ch % 0xff;
  	    last.high = end_ch >> 8;
  	    show_all = False;
  	}
--- 154,166 ----
  	show_info(fid, &hdr, &first, &last);
  	if (first_ch != 0 &&
  		(first_ch >= (first.low + (first.high << 8)))) {
! 	    first.low = first_ch & 0xff;
  	    first.high = first_ch >> 8;
  	    show_all = False;
  	}
  	if (end_ch != ~0 &&
  		(end_ch <= (last.low + (last.high << 8)))) {
! 	    last.low = end_ch & 0xff;
  	    last.high = end_ch >> 8;
  	    show_all = False;
  	}
***************
*** 230,270 ****
  	            bpr,
  	            charwidth;
  
! 	printf("char #%d ('%c')\n", ch + start,
! 	       (isprint(ch + start) ? (char) (ch + start) : '?'));
  	show_char_info(&extents[ch]);
! 	if (!extents_only) {
! 	    if (offset != offsets[ch].position)
! 		fprintf(stderr, "offset mismatch 0x%x != 0x%x\n",
! 			offset, offsets[ch].position);
  
! 	    switch (bitmap_pad) {
! 	    case BitmapFormatImageRectMin:
! 		bottom = extents[ch].descent + extents[ch].ascent;
! 		charwidth = extents[ch].right - extents[ch].left;
! 		break;
! 	    case BitmapFormatImageRectMaxWidth:
! 		bottom = extents[ch].descent + extents[ch].ascent;
! 		charwidth = hdr->max_bounds.right - hdr->min_bounds.left;
! 		break;
! 	    case BitmapFormatImageRectMax:
! 		bottom = hdr->max_bounds.ascent +
! 		    hdr->max_bounds.descent;
! 		charwidth = hdr->max_bounds.right - hdr->min_bounds.left;
! 		break;
! 	    }
  
! 	    bpr = GLWIDTHBYTESPADDED(charwidth, scanpad);
! 	    for (r = 0; r < bottom; r++) {
! 		unsigned char *row = glyphs + offset;
! 
! 		for (b = 0; b < charwidth; b++) {
! 		    putchar((row[b >> 3] &
! 			     (1 << (7 - (b & 7)))) ? '#' : '-');
! 		}
! 		putchar('\n');
! 		offset += bpr;
  	    }
  	}
      }
      FSFree((char *) extents);
--- 233,289 ----
  	            bpr,
  	            charwidth;
  
! 	printf("char #%d", ch + start);
! 	if (isprint(ch + start))
! 	    printf(" '%c'\n", (char) (ch + start));
! 	else
! 	    printf(" '\\%03o'\n", (ch + start)&0377);
  	show_char_info(&extents[ch]);
! 	if (extents_only)
! 	    continue;
! 	if (offset != offsets[ch].position)
! 	    fprintf(stderr, "offset mismatch: expected %d, got %d\n",
! 		    offset, offsets[ch].position);
! 	switch (bitmap_format) {
! 	case BitmapFormatImageRectMin:
! 	    bottom = extents[ch].descent + extents[ch].ascent;
! 	    charwidth = extents[ch].right - extents[ch].left;
! 	    break;
! 	case BitmapFormatImageRectMaxWidth:
! 	    bottom = extents[ch].descent + extents[ch].ascent;
! 	    charwidth = hdr->max_bounds.right - hdr->min_bounds.left;
! 	    break;
! 	case BitmapFormatImageRectMax:
! 	    bottom = hdr->max_bounds.ascent +
! 		hdr->max_bounds.descent;
! 	    charwidth = hdr->max_bounds.right - hdr->min_bounds.left;
! 	    break;
! 	}
  
! 	if (extents[ch].left == 0 &&
! 	    extents[ch].right == 0 &&
! 	    extents[ch].width == 0 &&
! 	    extents[ch].ascent == 0 &&
! 	    extents[ch].descent == 0)
! 	{
! 	    printf ("Nonexistent character\n");
! 	    continue;
! 	}
! 	bpr = GLWIDTHBYTESPADDED(charwidth, scanpad);
! 	if (offsets[ch].length != bottom * bpr) {
! 	    fprintf (stderr, "length mismatch: expected %d (%dx%d), got %d\n",
! 			 bottom * bpr, bpr, bottom, offsets[ch].length);
! 	}
! 	offset = offsets[ch].position;
! 	for (r = 0; r < bottom; r++) {
! 	    unsigned char *row = glyphs + offset;
  
! 	    for (b = 0; b < charwidth; b++) {
! 		putchar((row[b >> 3] &
! 			 (1 << (7 - (b & 7)))) ? '#' : '-');
  	    }
+ 	    putchar('\n');
+ 	    offset += bpr;
  	}
      }
      FSFree((char *) extents);
***************
*** 277,284 ****
  show_char_info(ci)
      fsCharInfo *ci;
  {
!     printf("Right: %d\tLeft: %d\tDescent: %d\tAscent: %d\tWidth: %d\n",
! 	   ci->right, ci->left, ci->descent, ci->ascent, ci->width);
  }
  
  show_info(fid, hdr, first, last)
--- 296,303 ----
  show_char_info(ci)
      fsCharInfo *ci;
  {
!     printf("Left: %-3d    Right: %-3d    Ascent: %-3d    Descent: %-3d    Width: %d\n",
! 	   ci->left, ci->right, ci->ascent, ci->descent, ci->width);
  }
  
  show_info(fid, hdr, first, last)
***************
*** 307,316 ****
      show_char_info(&hdr->min_bounds);
      printf("Max bounds: \n");
      show_char_info(&hdr->max_bounds);
!     printf("Font Ascent: %d\tFont Descent: %d\n",
  	   hdr->font_ascent, hdr->font_descent);
  
!     show_props(&pi, po, pd);
      FSFree((char *) po);
      FSFree((char *) pd);
  }
--- 326,336 ----
      show_char_info(&hdr->min_bounds);
      printf("Max bounds: \n");
      show_char_info(&hdr->max_bounds);
!     printf("Font Ascent: %d  Font Descent: %d\n",
  	   hdr->font_ascent, hdr->font_descent);
  
!     if (!no_props)
! 	show_props(&pi, po, pd);
      FSFree((char *) po);
      FSFree((char *) pd);
  }
***************
*** 385,405 ****
      }
      switch (bitmap_pad) {
      case 0:
! 	format |= BitmapFormatImageRectMin;
! 	bitmap_pad = BitmapFormatImageRectMin;
  	break;
      case 1:
! 	format |= BitmapFormatImageRectMaxWidth;
! 	bitmap_pad = BitmapFormatImageRectMaxWidth;
  	break;
      case 2:
! 	format |= BitmapFormatImageRectMax;
! 	bitmap_pad = BitmapFormatImageRectMax;
  	break;
      default:
  	fprintf(stderr, "bogus bitmap pad value: %d\n", bitmap_pad);
  	break;
      }
  
      format |= (bitorder == MSBFirst) ? BitmapFormatBitOrderMSB :
  	BitmapFormatBitOrderLSB;
--- 405,423 ----
      }
      switch (bitmap_pad) {
      case 0:
! 	bitmap_format = BitmapFormatImageRectMin;
  	break;
      case 1:
! 	bitmap_format = BitmapFormatImageRectMaxWidth;
  	break;
      case 2:
! 	bitmap_format = BitmapFormatImageRectMax;
  	break;
      default:
  	fprintf(stderr, "bogus bitmap pad value: %d\n", bitmap_pad);
  	break;
      }
+     format |= bitmap_format;
  
      format |= (bitorder == MSBFirst) ? BitmapFormatBitOrderMSB :
  	BitmapFormatBitOrderLSB;
*** /tmp/da03287	Tue Jul 14 18:52:58 1992
--- mit/doc/FSProtocol/protocol.ms	Thu Jul  9 18:16:48 1992
***************
*** 1,3 ****
--- 1,4 ----
+ .\" $XConsortium: protocol.ms,v 1.9 92/07/09 18:16:13 gildea Exp $
  .\" Use tbl, -ms, and macros.t
  .EH ''''
  .OH ''''
***************
*** 10,16 ****
  .ce 50
  \s+3\fBThe X Font Service Protocol\fP\s-3
  .sp
! \fBVersion 1.0\fP
  \fBMIT X Consortium Standard\fR
  .sp
  \fBX Version 11, Release 5\fR
--- 11,17 ----
  .ce 50
  \s+3\fBThe X Font Service Protocol\fP\s-3
  .sp
! \fBVersion 2.0\fP
  \fBMIT X Consortium Standard\fR
  .sp
  \fBX Version 11, Release 5\fR
***************
*** 307,313 ****
  .PN CreateAC ) 
  and switched among (with
  .PN SetAuthorization )
! to represent all of these "font users" properly.
  .LP
  ALTERNATESERVER:  [ name:  STRING8, 
  .br
--- 308,314 ----
  .PN CreateAC ) 
  and switched among (with
  .PN SetAuthorization )
! to represent all of these ``font users'' properly.
  .LP
  ALTERNATESERVER:  [ name:  STRING8, 
  .br
***************
*** 685,691 ****
  linear interpretation of MAX-CHAR is less than that of MIN-CHAR,
  or if MIN-CHAR is less than the font's
  XFONTINFO.CHAR-RANGE.MIN-CHAR, or if MAX-CHAR is greater than the
! font's XFONTINFO.CHAR-RANGE.MAX-CHAR, a Range error is returned.
  .LP
  RESOLUTION:	[ x-resolution:		CARD16,
  .br
--- 686,692 ----
  linear interpretation of MAX-CHAR is less than that of MIN-CHAR,
  or if MIN-CHAR is less than the font's
  XFONTINFO.CHAR-RANGE.MIN-CHAR, or if MAX-CHAR is greater than the
! font's XFONTINFO.CHAR-RANGE.MAX-CHAR, the range is invalid.
  .LP
  RESOLUTION:	[ x-resolution:		CARD16,
  .br
***************
*** 978,987 ****
  CLIENT-MINOR-PROTOCOL-VERSION specify which version of the
  font service protocol the client would like to use.  If the
  client can support multiple versions, the highest version
! should be given.  The first version of the protocol has a
! major version of 1 and a minor version of 0.
  .IP
! The AUTH-PROTOCOLS contains a list of protocol names and
  optional initial data for which the client can provide
  information.  The server may use this to determine which
  protocol to use or as part of the initial exchange of
--- 979,988 ----
  CLIENT-MINOR-PROTOCOL-VERSION specify which version of the
  font service protocol the client would like to use.  If the
  client can support multiple versions, the highest version
! should be given.  This version of the protocol has a
! major version of 2 and a minor version of 0.
  .IP
! The AUTHORIZATION-PROTOCOLS contains a list of protocol names and
  optional initial data for which the client can provide
  information.  The server may use this to determine which
  protocol to use or as part of the initial exchange of
***************
*** 1212,1218 ****
  last reply, which may contain zero or more names, this field
  is set to zero.
  .LP
! .IN "SetCatlogues" "" "@DEF@"
  .PN SetCatalogues
  .IP
  \fInames\fP\^:  LISTofSTRING8
--- 1213,1219 ----
  last reply, which may contain zero or more names, this field
  is set to zero.
  .LP
! .IN "SetCatalogues" "" "@DEF@"
  .PN SetCatalogues
  .IP
  \fInames\fP\^:  LISTofSTRING8
***************
*** 1243,1249 ****
  .LP
     =>
  .IP
! \fInames\fP\^:  PIPLISTofSTRING8
  .IP
  Errors:  
  .PN Alloc
--- 1244,1250 ----
  .LP
     =>
  .IP
! \fInames\fP\^:  LISTofSTRING8
  .IP
  Errors:  
  .PN Alloc
***************
*** 1268,1274 ****
  \fIevent-mask\fP\^:  EVENTMASK
  .IP
  Errors:
! .PN EventMask
  .IP
  This request specifies the set of maskable events that the
  extension indicated by EXTENSION-OPCODE (or zero for the core)
--- 1269,1276 ----
  \fIevent-mask\fP\^:  EVENTMASK
  .IP
  Errors:
! .PN EventMask ,
! .PN Request
  .IP
  This request specifies the set of maskable events that the
  extension indicated by EXTENSION-OPCODE (or zero for the core)
***************
*** 1299,1310 ****
  .IN "GetEventMask" "" "@DEF@"
  .PN GetEventMask
  .IP
! \fIextension-opcdoe\fP\^:  CARD8
  .LP
    =>
  .IP
  \fIevent-mask\fP\^:  EVENTMASK
  .IP
  This request returns the set of maskable core events the
  extension indicated by EXTENSION-OPCODE (or the core if zero)
  should generate for the client.  Non-maskable events are
--- 1301,1315 ----
  .IN "GetEventMask" "" "@DEF@"
  .PN GetEventMask
  .IP
! \fIextension-opcode\fP\^:  CARD8
  .LP
    =>
  .IP
  \fIevent-mask\fP\^:  EVENTMASK
  .IP
+ Errors:
+ .PN Request
+ .IP
  This request returns the set of maskable core events the
  extension indicated by EXTENSION-OPCODE (or the core if zero)
  should generate for the client.  Non-maskable events are
***************
*** 1322,1328 ****
  .IP
  \fIac\fP\^:  ACCESSCONTEXT
  .br
! \fIauthorization-protocols\fP\^:  STofAUTH
  .LP
    =>
  .IP
--- 1327,1333 ----
  .IP
  \fIac\fP\^:  ACCESSCONTEXT
  .br
! \fIauthorization-protocols\fP\^:  LISTofAUTH
  .LP
    =>
  .IP
***************
*** 1330,1335 ****
--- 1335,1343 ----
  	authorization-index:		CARD8
  	authorization-data:		LISTofBYTE
  .IP
+ Errors:
+ .PN IDChoice
+ .IP
  This request creates a new 
  .PN AccessContext 
  object within the
***************
*** 1544,1552 ****
  .IP
  \fIreplies-following-hint\fP\^:  CARD32
  .br
- \fIname\fP\^:  STRING8
- .br
  \fIinfo\fP\^:  XFONTINFO
  .IP
  Errors:  
  .PN Alloc
--- 1552,1560 ----
  .IP
  \fIreplies-following-hint\fP\^:  CARD32
  .br
  \fIinfo\fP\^:  XFONTINFO
+ .br
+ \fIname\fP\^:  STRING8
  .IP
  Errors:  
  .PN Alloc
***************
*** 1792,1800 ****
  .sp
  The extents for each character code in the resulting set (which
  may contain duplicates) are returned in the order in
! which the characters codes appear in the set.  If a character 
! is not encoded within the font, zero-filled metrics are 
! substituted.
  .sp
  If FONTID is not associated with any open fonts, a 
  .PN Font 
--- 1800,1811 ----
  .sp
  The extents for each character code in the resulting set (which
  may contain duplicates) are returned in the order in
! which the character codes appear in the set.
! At least one metric for each character shall be non-zero
! unless the character is not encoded in the font, in which case
! all-zero metrics are returned.
! A blank, zero-width character can be encoded
! with non-zero but equal left and right bearings.
  .sp
  If FONTID is not associated with any open fonts, a 
  .PN Font 
***************
*** 1876,1882 ****
  .sp
  If RANGE is False, then CHARS specifies the set of character
  codes for which bitmaps are returned.  If CHARS is of zero
! length, then a single reply containing a zero-length ist of
  offsets and bitmaps is returned.
  .sp
  If any of the resulting character ranges are invalid, a Range
--- 1887,1893 ----
  .sp
  If RANGE is False, then CHARS specifies the set of character
  codes for which bitmaps are returned.  If CHARS is of zero
! length, then a single reply containing a zero-length list of
  offsets and bitmaps is returned.
  .sp
  If any of the resulting character ranges are invalid, a Range
***************
*** 1901,1907 ****
  and clear bits represent inked and non-inked pixels,
  respectively.
  .sp
! Each scanline of a glyph image, from top to bottom, is padded
  on the right to a multiple of the number of bits specified by
  FORMAT.SCANLINE-PAD.  The scanline is then divided from left
  to right into a sequence of FORMAT.SCANLINE-UNIT bits.  The
--- 1912,1918 ----
  and clear bits represent inked and non-inked pixels,
  respectively.
  .sp
! Each scanline of a glyph image, from top to bottom, is zero-padded
  on the right to a multiple of the number of bits specified by
  FORMAT.SCANLINE-PAD.  The scanline is then divided from left
  to right into a sequence of FORMAT.SCANLINE-UNIT bits.  The
***************
*** 2325,2332 ****
--- 2336,2355 ----
  .XS
  \*(SN Data Types
  .XE
+ .sp 6p
  .LP
+ ACCESSCONTEXT
  .sp 6p
+ .TA .75i .75i .75i .75i
+ 4	CARD32	access context with at least one of the following bits set:
+ .sp 6p
+ #x1fffffff
+ .sp 6p
+ but none of the following bits set:
+ .sp 6p
+ #xe0000000		zero
+ .sp 18p
+ .LP
  .TS
  tab (@) ;
  l s s
***************
*** 2637,2645 ****
  1		CARD8		drawing direction
  .sp 6p
  		0		LeftToRight
  		1		RightToLeft
  .sp 6p
! 1			unused
  .br
  2		CHAR2B		default character
  .br
--- 2660,2669 ----
  1		CARD8		drawing direction
  .sp 6p
  		0		LeftToRight
+ .br
  		1		RightToLeft
  .sp 6p
! 1					unused
  .br
  2		CHAR2B		default character
  .br
***************
*** 2651,2657 ****
  .br
  2		INT16		font descent
  .br
! n		PROPINFO	property data
  .NH 2
  Requests
  .XS
--- 2675,2681 ----
  .br
  2		INT16		font descent
  .br
! n		PROPINFO		property data
  .NH 2
  Requests
  .XS
***************
*** 2668,2674 ****
  @#x42@Most Significant Byte first
  @#x6c@Least Significant Byte first
  1@CARD8@number of auth in auth-data
! 2@1@client-major-protocol-version
  2@0@client-minor-protocol-version
  2@a/4@length of auth-data
  a@LISTofAUTH@auth-data
--- 2692,2698 ----
  @#x42@Most Significant Byte first
  @#x6c@Least Significant Byte first
  1@CARD8@number of auth in auth-data
! 2@2@client-major-protocol-version
  2@0@client-minor-protocol-version
  2@a/4@length of auth-data
  a@LISTofAUTH@auth-data
***************
*** 2678,2684 ****
  @1@Continue
  @2@Busy
  @3@Denied
! 2@1@major version
  2@0@minor version
  1@CARD8@number of alternate-servers-hint
  1@CARD8@authorization-index
--- 2702,2708 ----
  @1@Continue
  @2@Busy
  @3@Denied
! 2@2@major version
  2@0@minor version
  1@CARD8@number of alternate-servers-hint
  1@CARD8@authorization-index
***************
*** 3056,3063 ****
  1@0@type reply
  1@BOOL@otherid-valid
  2@CARD16@sequence-number
! 4@3@length
  4@FONTID@otherid
  .TE
  .sp 12p
  .TS
--- 3080,3089 ----
  1@0@type reply
  1@BOOL@otherid-valid
  2@CARD16@sequence-number
! 4@4@length
  4@FONTID@otherid
+ 1@BOOL@cachable
+ 3@@unused
  .TE
  .sp 12p
  .TS
***************
*** 3287,3293 ****
  1@5@AccessContext
  2@CARD16@sequence-number
  4@5@length
! 4@TIMESTAMP2timestamp
  1@CARD8@major-opcode
  1@CARD8@minor-opcode
  2@@unused
--- 3313,3319 ----
  1@5@AccessContext
  2@CARD16@sequence-number
  4@5@length
! 4@TIMESTAMP@timestamp
  1@CARD8@major-opcode
  1@CARD8@minor-opcode
  2@@unused
***************
*** 3453,3459 ****
  or omissions.  The protocol presented here was primarily designed by Jim
  Fulton, Keith Packard, and Bob Scheifler.  Special thanks goes to Ned
  Batchelder, Jim Flowers, and Axel Deininger for their invigorating comments
! which never failed to make this a better document.  Finally, David Lemke 
  deserves great credit for designing and coding the sample implementation.
  .NH 1
  References
--- 3479,3487 ----
  or omissions.  The protocol presented here was primarily designed by Jim
  Fulton, Keith Packard, and Bob Scheifler.  Special thanks goes to Ned
  Batchelder, Jim Flowers, and Axel Deininger for their invigorating comments
! which never failed to make this a better document.
! Stephen Gildea edited version 2 of this document.
! Finally, David Lemke 
  deserves great credit for designing and coding the sample implementation.
  .NH 1
  References
***************
*** 3554,3558 ****
--- 3582,3592 ----
  to having the connection terminated), it should retry for an
  implementation-dependent length of time (see Xlib's 
  handling of ECONNREFUSED in XConnDis.c).
+ .\"
+ .\" print Table of Contents page
+ .EH ''''
+ .OH ''''
  .bp
+ .EF ''''
+ .OF ''''
  .PX
*** /tmp/da01727	Tue Jul 14 18:41:17 1992
--- mit/fonts/bdf/misc/9x15.bdf	Tue Jul 14 18:41:16 1992
***************
*** 1,4 ****
--- 1,5 ----
  STARTFONT 2.1
+ COMMENT $XConsortium: 9x15.bdf,v 1.14 92/04/02 14:25:52 gildea Exp $
  COMMENT ""
  COMMENT "Designed and made by"
  COMMENT "by Thomas Bagli (pyramid!pcsbst!tom@uunet.UU.NET)"
***************
*** 3732,3739 ****
  BBX 9 15 0 -3
  BITMAP
  0000
! 0400
! 1800
  0000
  7f00
  2000
--- 3733,3740 ----
  BBX 9 15 0 -3
  BITMAP
  0000
! 1000
! 0c00
  0000
  7f00
  2000
***************
*** 3754,3761 ****
  BBX 9 15 0 -3
  BITMAP
  0000
! 1000
! 0c00
  0000
  7f00
  2000
--- 3755,3762 ----
  BBX 9 15 0 -3
  BITMAP
  0000
! 0400
! 1800
  0000
  7f00
  2000
***************
*** 3952,3959 ****
  BBX 9 15 0 -3
  BITMAP
  0000
! 0400
! 1800
  0000
  3e00
  4100
--- 3953,3960 ----
  BBX 9 15 0 -3
  BITMAP
  0000
! 1000
! 0c00
  0000
  3e00
  4100
***************
*** 4084,4099 ****
  BBX 9 15 0 -3
  BITMAP
  0000
- 0000
- 0000
  0100
  3e00
  4500
  4900
  4900
- 4900
- 4900
  5100
  3e00
  4000
  0000
--- 4085,4100 ----
  BBX 9 15 0 -3
  BITMAP
  0000
  0100
  3e00
+ 4300
  4500
+ 4500
  4900
  4900
  5100
+ 5100
+ 6100
  3e00
  4000
  0000
***************
*** 4767,4782 ****
  BITMAP
  0000
  0000
! 0100
! 0200
! 0200
! 0400
  0800
  0800
! 1000
! 2000
! 2000
! 4000
  0000
  0000
  0000
--- 4768,4783 ----
  BITMAP
  0000
  0000
! 0000
  0800
+ 1c00
  0800
! 0000
! 7f00
! 0000
! 0800
! 1c00
! 0800
  0000
  0000
  0000
*** /tmp/da01749	Tue Jul 14 18:41:31 1992
--- mit/fonts/bdf/misc/8x13.bdf	Tue Jul 14 18:41:30 1992
***************
*** 1,4 ****
--- 1,5 ----
  STARTFONT 2.1
+ COMMENT $XConsortium: 8x13.bdf,v 1.13 92/04/02 14:25:48 gildea Exp $
  COMMENT ""
  COMMENT Characters above 127 designed and made by
  COMMENT by Thomas Bagli (pyramid!pcsbst!tom@uunet.UU.NET)
***************
*** 3716,3732 ****
  BBX 8 13 0 -2
  BITMAP
  0000
- 0000
  0200
! 7c00
! 8a00
! 9200
! 9200
! 9200
! 9200
! a200
! 7c00
! 8000
  0000
  ENDCHAR
  STARTCHAR 00d9
--- 3717,3733 ----
  BBX 8 13 0 -2
  BITMAP
  0000
  0200
! 3c00
! 4600
! 4a00
! 4a00
! 5200
! 5200
! 5200
! 6200
! 3c00
! 4000
  0000
  ENDCHAR
  STARTCHAR 00d9
***************
*** 4358,4372 ****
  0000
  0000
  0000
  0200
  3c00
  4600
  4a00
- 4200
  5200
  6200
! 7c00
! 8000
  0000
  ENDCHAR
  STARTCHAR 00f9
--- 4359,4373 ----
  0000
  0000
  0000
+ 0000
  0200
  3c00
  4600
  4a00
  5200
  6200
! 3c00
! 4000
  0000
  ENDCHAR
  STARTCHAR 00f9
*** /tmp/da01906	Tue Jul 14 18:41:54 1992
--- mit/fonts/bdf/misc/6x13.bdf	Tue Jul 14 18:41:53 1992
***************
*** 1,4 ****
--- 1,5 ----
  STARTFONT 2.1
+ COMMENT $XConsortium: 6x13.bdf,v 1.13 92/04/02 14:24:50 gildea Exp $
  COMMENT ""
  COMMENT Characters above 127 designed and made by
  COMMENT Thomas Bagli (pyramid!pcsbst!tom@uunet.UU.NET)
***************
*** 3716,3730 ****
  BBX 6 13 0 -2
  BITMAP
  00
- 00
  08
  70
  98
  a8
  a8
  a8
- a8
  c8
  70
  80
  00
--- 3717,3731 ----
  BBX 6 13 0 -2
  BITMAP
  00
  08
  70
  98
+ 98
  a8
  a8
  a8
  c8
+ c8
  70
  80
  00
***************
*** 4358,4367 ****
  00
  00
  00
  08
  70
  98
- a8
  a8
  a8
  c8
--- 4359,4368 ----
  00
  00
  00
+ 00
  08
  70
  98
  a8
  a8
  c8
*** /tmp/da01949	Tue Jul 14 18:42:07 1992
--- mit/fonts/bdf/misc/10x20.bdf	Tue Jul 14 18:42:06 1992
***************
*** 1,5 ****
--- 1,6 ----
  STARTFONT 2.1
  COMMENT ""
+ COMMENT $XConsortium: 10x20.bdf,v 1.12 92/04/02 14:25:55 gildea Exp $
  COMMENT "$NCDId: @(#)10x20.bdf,v 1.11 1991/07/02 14:50:48 jim Exp $"
  COMMENT  ""
  COMMENT  "Copyright 1989-1991 Network Computing Devices, Inc."
***************
*** 5024,5043 ****
  BBX 10 20 0 -5
  BITMAP
  0000
- 0000
- 0000
- 0000
  0080
! 1f80
  3300
  6380
  6580
  6580
  6980
  6980
  7180
  3300
! 7e00
  4000
  0000
  0000
--- 5025,5044 ----
  BBX 10 20 0 -5
  BITMAP
  0000
  0080
! 1f00
  3300
  6380
+ 6380
  6580
  6580
+ 6580
  6980
  6980
+ 6980
  7180
  3300
! 3e00
  4000
  0000
  0000
***************
*** 5893,5907 ****
  0000
  0000
  0000
! 0000
! 1e80
! 3380
! 6380
! 6780
! 6d80
! 7980
  3300
! 7e00
  4000
  0000
  0000
--- 5894,5908 ----
  0000
  0000
  0000
! 0080
! 1f00
  3300
! 6580
! 6580
! 6980
! 6980
! 3300
! 3e00
  4000
  0000
  0000
*** /tmp/da02040	Tue Jul 14 18:42:39 1992
--- mit/fonts/bdf/misc/7x13.bdf	Tue Jul 14 18:42:37 1992
***************
*** 1,4 ****
--- 1,5 ----
  STARTFONT 2.1
+ COMMENT $XConsortium: 7x13.bdf,v 1.11 92/04/02 14:25:38 gildea Exp $
  COMMENT  
  COMMENT  Copyright (c) 1990 Stephen Gildea
  COMMENT  
***************
*** 3731,3745 ****
  BBX 7 13 0 -2
  BITMAP
  00
- 00
  04
  78
  94
  94
- 94
  a4
  a4
  a4
  78
  80
  00
--- 3732,3746 ----
  BBX 7 13 0 -2
  BITMAP
  00
  04
  78
+ 8c
  94
  94
  a4
  a4
  a4
+ c4
  78
  80
  00
***************
*** 4373,4383 ****
  00
  00
  00
  04
  78
  8c
  94
- 84
  a4
  c4
  78
--- 4374,4384 ----
  00
  00
  00
+ 00
  04
  78
  8c
  94
  a4
  c4
  78

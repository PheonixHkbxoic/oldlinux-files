		      Release 5 Public Patch #8
			   MIT X Consortium

To apply this patch:

cd to the top of the source tree (to the directory containing the "mit"
and "contrib" subdirectories) and do:
	patch -p -s < ThisFile
Patch will work silently unless an error occurs.  You will likely get
the following warning messages, which can be ignored:
	mkdir: mit: File exists
	mkdir: mit/doc: File exists
	mkdir: mit/doc/I18N: File exists
	mkdir: mit/doc/I18N/Xsi: File exists
	mkdir: mit/doc/I18N/Xsi/Xim: File exists
If you want to watch patch do its thing, leave out the "-s" argument to patch.

This patch creates one new file, mit/doc/I18N/Xsi/Xim/LocalIM.man.
If you are using a symbolic link tree, you will need to create a new link.

Finally, to rebuild after applying this patch, cd to the "mit" subdirectory
and do (if you are on a Mac):
	make Everything >& every.log
or (if you are not on a Mac):
	make -k >& make.log
Note: this will *not* "clean" your tree.

Brief notes on what this patch fixes:

config: make World fails under A/UX
Xlib: XrmPutResource (and friends) fail to update type in some cases
Xlib: XmbTextProperyToTextList fails on unknown CT encodings
Xlib: compilation problem with XimpIM.c
Xlib: correct Xsi LocalIM handling
Xlib: MAXCHARSETS too small in Xlocaleint.h
Xlib: XGetIMValue sometimes fails to report an error
Xlib: XCreateFontSet dumps core on bad font
Xlib: XwcLookupString fails due to unterminated string
Xlib: _XipBackEndFilter loses some replies
Xlib: XmlCreateFontSet fails on bad font
Xlib: XGetICValues handles pointer values incorrectly
Xt: GetValues on callback list reallocates list w/o updating widget
Xt: GetValues on translations before they are bound dereferences NULL
Xt: resource converters with args can get bad cache retrievals
Xt: some Error.c function definitions need prototypes
Xt: invalid x and y after a resize of the Shell
Xt: AIX shared library definition of XtVaAppInitialize
editres: a function argument should be of type int, not Boolean
server: fails to shut down under xinit
server: XDrawRectangle draws in wrong place, but corners are right.
server: crashed by drawing wide zero-length on-off-dash 

Prereq: public-patch-7

*** /tmp/,RCSt1014851	Wed Dec 11 11:37:19 1991
--- mit/bug-report	Wed Dec 11 11:38:00 1991
***************
*** 2,8 ****
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-7
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:
--- 2,8 ----
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-8
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:

*** /tmp/,RCSt1005953	Tue Dec  3 09:28:32 1991
--- mit/config/Imakefile	Mon Dec  2 11:25:09 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: Imakefile,v 1.13 91/04/15 17:58:26 rws Exp $
   * 
   * This is used to recreate imake.  Makefile.ini is used to generate imake
   * the first time.
--- 1,5 ----
  /*
!  * $XConsortium: Imakefile,v 1.14 91/12/02 11:24:14 rws Exp $
   * 
   * This is used to recreate imake.  Makefile.ini is used to generate imake
   * the first time.
***************
*** 11,16 ****
--- 11,20 ----
  CPP_PROGRAM = CppCmd
  INCLUDES = -I$(BUILDINCDIR)
  DEFINES = $(SIGNAL_DEFINES) $(BOOTSTRAPCFLAGS) -DCPP_PROGRAM=\"$(CPP_PROGRAM)\"
+ 
+ #ifdef MacIIArchitecture
+ XBSDLIB = /**/
+ #endif
  
  #undef ImakeDependency
  #define ImakeDependency(dummy) @@\

*** /tmp/,RCSt1005948	Tue Dec  3 09:28:24 1991
--- mit/util/makedepend/Imakefile	Mon Dec  2 08:49:06 1991
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.14 91/07/16 23:07:25 gildea Exp $
  /*
   * NOTE: CppSourcesPresent IS NO LONGER TESTED OR SUPPORTED,
   * and is nearly guaranteed to not work.
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.15 91/12/02 08:48:08 rws Exp $
  /*
   * NOTE: CppSourcesPresent IS NO LONGER TESTED OR SUPPORTED,
   * and is nearly guaranteed to not work.
***************
*** 27,32 ****
--- 27,36 ----
  INCLUDES = -I$(CONFIGSRC)
   DEFINES = $(CPPDEFS) '-DINCLUDEDIR="/usr/include"' $(SIGNAL_DEFINES)
   DEPLIBS =
+ 
+ #ifdef MacIIArchitecture
+  XBSDLIB = /**/
+ #endif
  
  all:: makedepend
  
*** /tmp/,RCSt1005943	Tue Dec  3 09:28:13 1991
--- mit/lib/X/Imakefile	Mon Dec  2 09:40:55 1991
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.126 91/09/09 14:47:13 rws Exp $
  #define DoNormalLib NormalLibX
  #define DoSharedLib SharedLibX
  #define DoDebugLib DebugLibX
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.128 91/12/02 09:39:43 rws Exp $
  #define DoNormalLib NormalLibX
  #define DoSharedLib SharedLibX
  #define DoDebugLib DebugLibX
***************
*** 23,28 ****
--- 23,31 ----
  #endif
  #endif
  
+ #ifdef MacIIArchitecture
+ XBSDLIB = /**/
+ #endif
  #if Malloc0ReturnsNull
          DEFINES = -DMALLOC_0_RETURNS_NULL
  #endif
***************
*** 1055,1063 ****
  
  clean::
  	$(RM) ks_tables_h ks_tables.h makekeys
- 
- clean::
  	$(RM) $(AUTHSRCS) $(XDMAUTHSRCS) $(LCHDRS) $(LCSYMSRCS)
  
  DependTarget3($(SRCS1),$(SRCS2),$(SRCS3))
  
--- 1058,1067 ----
  
  clean::
  	$(RM) ks_tables_h ks_tables.h makekeys
  	$(RM) $(AUTHSRCS) $(XDMAUTHSRCS) $(LCHDRS) $(LCSYMSRCS)
+ 	$(RM) $(OBJS1)
+ 	$(RM) $(OBJS2)
+ 	$(RM) $(OBJS3)
  
  DependTarget3($(SRCS1),$(SRCS2),$(SRCS3))
  
*** /tmp/,RCSt1007645	Fri Nov 22 14:39:15 1991
--- mit/lib/X/Xrm.c	Thu Nov 21 19:19:18 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: Xrm.c,v 1.69 91/09/21 21:39:28 rws Exp $
   */
  
  /***********************************************************
--- 1,5 ----
  /*
!  * $XConsortium: Xrm.c,v 1.70 91/11/21 19:18:45 rws Exp $
   */
  
  /***********************************************************
***************
*** 861,867 ****
  		/* match, need to override */
  		if ((type == XrmQString) == entry->string &&
  		    entry->size == value->size) {
! 		    /* identical size and type, just overwrite */
  		    bcopy((char *)value->addr, RawValue(entry), value->size);
  		    return;
  		}
--- 861,870 ----
  		/* match, need to override */
  		if ((type == XrmQString) == entry->string &&
  		    entry->size == value->size) {
! 		    /* update type if not String, can be different */
! 		    if (!entry->string)
! 			RepType(entry) = type;
! 		    /* identical size, just overwrite value */
  		    bcopy((char *)value->addr, RawValue(entry), value->size);
  		    return;
  		}

*** /tmp/,RCSt1001316	Sun Nov 17 16:16:41 1991
--- mit/lib/X/Xsi/XCnvCTToWC.c	Sun Nov 17 16:15:35 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: XCnvCTToWC.c,v 1.20 91/09/18 16:29:28 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XCnvCTToWC.c,v 1.22 91/11/17 16:15:29 rws Exp $
   */
  
  /*
***************
*** 41,46 ****
--- 41,47 ----
  #include "Xlibint.h"
  #include "Xlocaleint.h"
  #include <X11/Xos.h>
+ #include <X11/Xutil.h>
  
  static int _XConvertCTextToWC();
  extern int _XParseISOEncoding();
***************
*** 276,281 ****
--- 277,283 ----
      _State		state_sv, state_ext;
      unsigned char      *ct_str_sv = NULL;
      int len_sv;
+     char *defstr = XDefaultString();
  
      if (!xlocale)
  	xlocale = _XFallBackConvert();
***************
*** 295,302 ****
              continue;
          }
          _XcwGetAll(xlocale, wc, &esc, &woffset, &stateinfo);
! 	if (woffset == 0)
! 	    Return (BadEncoding);
          if ((ctGLorGR = ctGetGLorGR(xlocale)) == GL &&
  		ctGetGLid(xlocale) != (state_sv & 0xff) ||
  	    ctGLorGR == GR &&
--- 297,313 ----
              continue;
          }
          _XcwGetAll(xlocale, wc, &esc, &woffset, &stateinfo);
! 	if (woffset == 0) {
! 	    int i;
! 	    /* XXX BUG: need to check/add designate sequence of default string.
! 	       But current default string is NULL, so OK. :-) */
! 	    for (i = 0; *(defstr + i) != 0; i++) {
! 		SaveStore(*(defstr + i))
! 	    }
! 	    error++;
! 	    wc_str++, wc_len--, wcnt++;
!             continue;
! 	}
          if ((ctGLorGR = ctGetGLorGR(xlocale)) == GL &&
  		ctGetGLid(xlocale) != (state_sv & 0xff) ||
  	    ctGLorGR == GR &&
***************
*** 434,440 ****
      ct_str += len; ctcnt += len; ct_bytes -=len;
  
      if (ct_bytes < textlen)
! 	Return(BadEncoding) /* Nor enough data. What should do? */
  
      _XcwIdGetWoffset(xlocale, &woffset);
  
--- 445,451 ----
      ct_str += len; ctcnt += len; ct_bytes -=len;
  
      if (ct_bytes < textlen)
! 	Return(BadTerminate); /* Nor enough data. What should do? */
  
      _XcwIdGetWoffset(xlocale, &woffset);
  
*** /tmp/,RCSt1001422	Sun Nov 17 16:22:48 1991
--- mit/lib/X/Xsi/XCnvWCToMB.c	Sun Nov 17 16:22:39 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: XCnvWCToMB.c,v 1.20 91/09/18 16:29:48 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XCnvWCToMB.c,v 1.22 91/11/17 16:22:31 rws Exp $
   */
  
  /*
***************
*** 40,45 ****
--- 40,46 ----
  #include "Xlibint.h"
  #include "Xlocaleint.h"
  #include <X11/Xos.h>
+ #include <X11/Xutil.h>
  
  #define ESC 0x1b
  #define CSI 0x9b
***************
*** 98,104 ****
  	    return (2);
  	} else if (*str >= 0x20 && *str <= 0x2f) {
  	    for (i++; len > 0; str++,i++, len--) {
! 		if (*str >= 0x40 && *str <= 0x7e)
  		    return(i);
  		if (*str < 0x20 || *str >= 0x7f)
  		    return (-1); /* Not valid Escape seqence */
--- 99,105 ----
  	    return (2);
  	} else if (*str >= 0x20 && *str <= 0x2f) {
  	    for (i++; len > 0; str++,i++, len--) {
! 		if (*str >= 0x30 && *str <= 0x7e)
  		    return(i);
  		if (*str < 0x20 || *str >= 0x7f)
  		    return (-1); /* Not valid Escape seqence */
***************
*** 229,235 ****
          SaveStore((code & 0x7f7f) | woffset);
          mb_str += codelen, mbcnt += codelen, mb_bytes -= codelen;
      }
-     /*error = 0;*/
      Return(Success);
  }
  
--- 230,235 ----
***************
*** 276,281 ****
--- 276,282 ----
      _State  state_sv;
      wchar   wc, woffset, newwoffset;
      extern void _XmbSetCsid();
+     char *defstr = XDefaultString();
     
      if (!xlocale)
  	xlocale = _XFallBackConvert();
***************
*** 296,306 ****
              continue;
          }
  	ctid = _XcwGetWoffset(*wc_str, &newwoffset);
! 	if(ctid == ND)
! 	    Return(BadEncoding);
! 	newcsid = _Xmbctidtocsid(xlocale, ctid);
! 	if(newcsid == ND)
! 	    Return(BadEncoding);
  	_XmbSetCsid(xlocale, newcsid);
          if (csid_sv != newcsid) {
  	    int mbGLorGR;
--- 297,313 ----
              continue;
          }
  	ctid = _XcwGetWoffset(*wc_str, &newwoffset);
! 	if (ctid == ND || (newcsid = _Xmbctidtocsid(xlocale, ctid)) == ND) {
! 	    /* XXX BUG: if stateful encoding, need to check/add
! 			designate sequence of default string.
! 	       But current default string is NULL, so OK. :-) */
! 	    for (i = 0; *(defstr + i) != 0; i++) {
! 		SaveStore(*(defstr + i))
! 	    }
! 	    error++;
! 	    wc_str++, wccnt++, wc_len--;
! 	    continue;
! 	}
  	_XmbSetCsid(xlocale, newcsid);
          if (csid_sv != newcsid) {
  	    int mbGLorGR;

*** /tmp/,RCSt1000707	Sun Nov 17 15:32:13 1991
--- mit/lib/X/Xsi/XmbTextPrp.c	Sun Nov 17 15:31:34 1991
***************
*** 1,4 ****
! /* $XConsortium: XmbTextPrp.c,v 1.5 91/08/12 17:18:39 rws Exp $ */
  /*
   * Copyright 1991 by OMRON Corporation
   * Copyright 1991 by the Massachusetts Institute of Technology
--- 1,4 ----
! /* $XConsortium: XmbTextPrp.c,v 1.6 91/11/17 15:31:30 rws Exp $ */
  /*
   * Copyright 1991 by OMRON Corporation
   * Copyright 1991 by the Massachusetts Institute of Technology
***************
*** 56,61 ****
--- 56,62 ----
      int i, scand;
      register unsigned int nbytes;
      XTextProperty proto;
+     int ret, error = 0;
  
      for (i = 0, nbytes = 0; i < count; i++) {
  	nbytes += (unsigned) ((list[i] ? strlen (list[i]) : 0) + 1);
***************
*** 74,85 ****
  	    for (i = 0; i < count; i++, list++) {
  		if (*list) {
  		    len = datalen;
! 		    if (_XConvertMBToString((unsigned char *)(*list),
  					    strlen(*list), buf,
! 					    &len, &scand) != Success) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
  		    buf += len + 1;
  		    datalen -= len + 1;
  		    proto.nitems += len + 1;
--- 75,87 ----
  	    for (i = 0; i < count; i++, list++) {
  		if (*list) {
  		    len = datalen;
! 		    if ((ret = _XConvertMBToString((unsigned char *)(*list),
  					    strlen(*list), buf,
! 					    &len, &scand)) < 0) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
+ 		    error += ret;
  		    buf += len + 1;
  		    datalen -= len + 1;
  		    proto.nitems += len + 1;
***************
*** 95,106 ****
  	    for (i = 0; i < count; i++, list++) {
  		if (*list) {
  		    len = datalen;
! 		    if (_XConvertMBToCT(0, (unsigned char *)(*list),
  					strlen(*list), buf,
! 					&len, &scand, 0) != Success) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
  		    buf += len + 1;
  		    datalen -= len + 1;
  		    proto.nitems += len + 1;
--- 97,109 ----
  	    for (i = 0; i < count; i++, list++) {
  		if (*list) {
  		    len = datalen;
! 		    if ((ret = _XConvertMBToCT(0, (unsigned char *)(*list),
  					strlen(*list), buf,
! 					&len, &scand, 0)) < 0) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
+ 		    error += ret;
  		    buf += len + 1;
  		    datalen -= len + 1;
  		    proto.nitems += len + 1;
***************
*** 133,144 ****
  	    for (i = 0; i < count; i++, list++) {
  		if (*list) {
  		    len = datalen;
! 		    if (_XConvertMBToCT(0, (unsigned char *)*list,
  					strlen(*list),
! 					buf, &len, &scand, 0) != Success) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
  		    if (is_xstring)
  			for (i = 0; *(buf+i); i++) {
  			    if (!_isXString(*(buf+i))) {
--- 136,148 ----
  	    for (i = 0; i < count; i++, list++) {
  		if (*list) {
  		    len = datalen;
! 		    if ((ret = _XConvertMBToCT(0, (unsigned char *)*list,
  					strlen(*list),
! 					buf, &len, &scand, 0)) < 0) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
+ 		    error += ret;
  		    if (is_xstring)
  			for (i = 0; *(buf+i); i++) {
  			    if (!_isXString(*(buf+i))) {
***************
*** 169,173 ****
  	proto.value = 0;
      }
      *text_prop = proto;
!     return (Success);
  }
--- 173,177 ----
  	proto.value = 0;
      }
      *text_prop = proto;
!     return (error);
  }

*** /tmp/,RCSt1000707	Sun Nov 17 15:32:15 1991
--- mit/lib/X/Xsi/XwcPrpText.c	Sun Nov 17 15:31:38 1991
***************
*** 1,4 ****
! /* $XConsortium: XwcPrpText.c,v 1.11 91/10/08 16:35:19 rws Exp $ */
  /*
   * Copyright 1991 by OMRON Corporation
   * Copyright 1991 by the Massachusetts Institute of Technology
--- 1,4 ----
! /* $XConsortium: XwcPrpText.c,v 1.12 91/11/17 15:31:34 rws Exp $ */
  /*
   * Copyright 1991 by OMRON Corporation
   * Copyright 1991 by the Massachusetts Institute of Technology
***************
*** 56,61 ****
--- 56,62 ----
      int i, j;
      int len, scand;
      unsigned int datalen = (int) tp->nitems;
+     int ret, error = 0;
  #ifndef X_WCHAR
      char *mbuf;
  #endif
***************
*** 101,119 ****
  		scand = strlen((char *)cp);
  #ifdef X_WCHAR
  	    len = datalen + 1;
! 	    if (_XConvertCTToWC(0, cp,  scand, start,
! 				&len, &scand, 0) != Success) {
  		XwcFreeStringList(list);
  		return (XConverterNotFound);
  	    }
  #else
  #ifdef macII
! 	    len = 0;
  #else
  	    len = scand * 2;
  	    mbuf = _XAllocScratch(dpy, len);
! 	    if (_XConvertCTToMB(0, cp, scand, mbuf,
! 				&len, &scand, 0) != Success) {
  		XwcFreeStringList(list);
  		return (XConverterNotFound);
  	    }
--- 102,120 ----
  		scand = strlen((char *)cp);
  #ifdef X_WCHAR
  	    len = datalen + 1;
! 	    if ((ret = _XConvertCTToWC(0, cp,  scand, start,
! 				&len, &scand, 0)) < 0) {
  		XwcFreeStringList(list);
  		return (XConverterNotFound);
  	    }
  #else
  #ifdef macII
! 	    len = 0; ret = 0;
  #else
  	    len = scand * 2;
  	    mbuf = _XAllocScratch(dpy, len);
! 	    if ((ret = _XConvertCTToMB(0, cp, scand, mbuf,
! 				&len, &scand, 0)) < 0) {
  		XwcFreeStringList(list);
  		return (XConverterNotFound);
  	    }
***************
*** 124,129 ****
--- 125,131 ----
  	    }
  #endif
  #endif
+ 	    error += ret;
  	    start += len + 1;
  	    datalen -= len + 1;
  	    cp += scand + 1;
***************
*** 138,148 ****
  		scand = datalen;
  	    else
  		scand = strlen((char *)cp);
! 	    if (_XConvertMBToWC(0, cp, scand, start,
! 				&len, &scand, 0) != Success) {
  		XwcFreeStringList(list);
  		return (XConverterNotFound);
  	    }
  #else
  #ifdef macII
  	    len = 0;
--- 140,151 ----
  		scand = datalen;
  	    else
  		scand = strlen((char *)cp);
! 	    if ((ret = _XConvertMBToWC(0, cp, scand, start,
! 				&len, &scand, 0)) < 0) {
  		XwcFreeStringList(list);
  		return (XConverterNotFound);
  	    }
+ 	    error += ret;
  #else
  #ifdef macII
  	    len = 0;
***************
*** 162,168 ****
  
      *list_return = list;
      *count_return = nelements;
!     return Success;
  }
  
  void XwcFreeStringList (list)
--- 165,171 ----
  
      *list_return = list;
      *count_return = nelements;
!     return error;
  }
  
  void XwcFreeStringList (list)

*** /tmp/,RCSt1001354	Sun Nov 17 16:19:01 1991
--- mit/lib/X/Xsi/XCnvMBToCT.c	Sun Nov 17 16:18:47 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: XCnvMBToCT.c,v 1.18 91/06/26 13:55:00 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XCnvMBToCT.c,v 1.20 91/11/17 16:18:34 rws Exp $
   */
  
  /*
***************
*** 39,44 ****
--- 39,45 ----
   */
  #include "Xlibint.h"
  #include "Xlocaleint.h"
+ #include <X11/Xutil.h>
  #include <X11/Xos.h>
  
  static int _XConvertCTextToMB();
***************
*** 125,135 ****
  	    Return(BadEncoding);
          /*
           * filter control characters.
-          * Suppose the space character is always in CODESET0.
           */
- 	/*
-         if (csid == C0 || csid == C1 || (csid == CODESET0 && c == SPACE)) {
- 	*/
          if (csid == C0 || csid == C1) {
              SaveStore(c);
              mb_str++, mb_bytes--, mbcnt++;
--- 126,132 ----
***************
*** 244,249 ****
--- 241,247 ----
      char 	seq[255];
      ISOStateInfo stateinfo;
      int tmp;
+     char *defstr = XDefaultString();
  
      if (!xlocale)
  	xlocale = _XFallBackConvert();
***************
*** 287,292 ****
--- 285,291 ----
  		    if((ret = _XConvertCTextToMB(xlocale, ct_str, ct_bytes,
  					mb_str, &tmplen, &len)) < 0)
  			Return(ret);
+ 		    error += ret;
  		    mb_str += tmplen;
  		    mbcnt +=tmplen;
  		    ct_str += len, ct_bytes -= len, ctcnt += len;
***************
*** 342,349 ****
  		    ctid = ctGetid(xlocale);
  		    newcsid = _Xmbctidtocsid(xlocale, ctid);
  		}
! 		if (newcsid == ND)
! 		    Return(BadEncoding);
  	    }
  	    _XmbSetCsid(xlocale, newcsid);
  	    if (newcsid != csid_sv) {
--- 341,359 ----
  		    ctid = ctGetid(xlocale);
  		    newcsid = _Xmbctidtocsid(xlocale, ctid);
  		}
! 		if (newcsid == ND) {
! 		    /* XXX BUG: if stateful encoding, need to check/add
! 				designate sequence of default string.
! 		       But current default string is NULL, so OK. :-) */
! 		    for (i = 0; *(defstr + i) != 0; i++) {
! 			SaveStore(*(defstr + i))
! 		    }
! 		    ct_str += stateinfo.code_bytes;
! 		    ct_bytes -= stateinfo.code_bytes;
! 		    ctcnt += stateinfo.code_bytes;
! 		    error++;
! 		    continue;
! 		}
  	    }
  	    _XmbSetCsid(xlocale, newcsid);
  	    if (newcsid != csid_sv) {
***************
*** 461,478 ****
      int bytes;
      _CSID csid, ctid;
      _State state_sv;
  
      state_sv = xlocale->ct_state;
      limit = *mb_bytes;
      mbcnt = ctcnt = error = 0;
  
!     if((len = _XctIsExtendSegment(xlocale, ct_str, &textlen, &bytes)) < 0)
  	/* not register encoding by X. */
  	Return(BadEncoding);
      ct_str += len; ctcnt += len; ct_bytes -=len;
  
      if (ct_bytes < textlen)
! 	Return(BadEncoding) /* Nor enough data. What should do? */
  
      if (_Xmbtype(xlocale) == CDS_STATEFUL) {
  	/* append designation of state-dependent codeset. */
--- 471,489 ----
      int bytes;
      _CSID csid, ctid;
      _State state_sv;
+     char *defstr = XDefaultString();
  
      state_sv = xlocale->ct_state;
      limit = *mb_bytes;
      mbcnt = ctcnt = error = 0;
  
!     if((len = _XctIsExtendSegment(xlocale, ct_str, &textlen, &bytes)) <= 0)
  	/* not register encoding by X. */
  	Return(BadEncoding);
      ct_str += len; ctcnt += len; ct_bytes -=len;
  
      if (ct_bytes < textlen)
! 	Return(BadTerminate) /* Nor enough data. What should do? */
  
      if (_Xmbtype(xlocale) == CDS_STATEFUL) {
  	/* append designation of state-dependent codeset. */
***************
*** 489,496 ****
  
      ctid = ctGetid(xlocale);
      csid = _Xmbctidtocsid(xlocale, ctid);
!     if (csid == ND)
!         Return(BadEncoding);
      _XmbSetCsid(xlocale, csid);
      codelen = _Xmblen(xlocale);
  
--- 500,516 ----
  
      ctid = ctGetid(xlocale);
      csid = _Xmbctidtocsid(xlocale, ctid);
!     if (csid == ND) {
! 	int j;
! 	for (j = textlen/bytes; j > 0; j--) {
! 	    for (i = 0; *(defstr + i) != 0; i++) {
! 		SaveStore(*(defstr + i));
! 	    }
! 	    error++;
! 	}
! 	ctcnt += textlen;
! 	Return(Success);
!     }
      _XmbSetCsid(xlocale, csid);
      codelen = _Xmblen(xlocale);
  
*** /tmp/,RCSt1000707	Sun Nov 17 15:32:21 1991
--- mit/lib/X/Xsi/XmbPrpText.c	Sun Nov 17 15:31:45 1991
***************
*** 1,4 ****
! /* $XConsortium: XmbPrpText.c,v 1.7 91/10/08 16:35:10 rws Exp $ */
  /*
   * Copyright 1991 by OMRON Corporation
   * Copyright 1991 by the Massachusetts Institute of Technology
--- 1,4 ----
! /* $XConsortium: XmbPrpText.c,v 1.8 91/11/17 15:31:41 rws Exp $ */
  /*
   * Copyright 1991 by OMRON Corporation
   * Copyright 1991 by the Massachusetts Institute of Technology
***************
*** 57,62 ****
--- 57,63 ----
      int len, scand;
      unsigned int datalen = (int) tp->nitems;
      XsiLCd lcd = (XsiLCd)_XlcCurrentLC();
+     int ret, error = 0;
  
      if (tp->format != 8 ||
  	(tp->encoding != XA_STRING &&
***************
*** 97,107 ****
  		scand = datalen;
  	    else
  		scand = strlen((char *)cp);
! 	    if (_XConvertCTToMB(0, cp, scand, start,
! 				&len, &scand, 0) != Success) {
  		XFreeStringList((char **)list);
  		return (XConverterNotFound);
  	    }
  	    start += len + 1;
  	    datalen -= len + 1;
  	    cp += scand + 1;
--- 98,109 ----
  		scand = datalen;
  	    else
  		scand = strlen((char *)cp);
! 	    if ((ret = _XConvertCTToMB(0, cp, scand, start,
! 				&len, &scand, 0)) < 0) {
  		XFreeStringList((char **)list);
  		return (XConverterNotFound);
  	    }
+ 	    error += ret;
  	    start += len + 1;
  	    datalen -= len + 1;
  	    cp += scand + 1;
***************
*** 121,125 ****
  
      *list_return = (char **)list;
      *count_return = nelements;
!     return Success;
  }
--- 123,127 ----
  
      *list_return = (char **)list;
      *count_return = nelements;
!     return error;
  }

*** /tmp/,RCSt1001585	Sun Nov 17 16:30:17 1991
--- mit/lib/X/Xsi/XwcDeGlyph.c	Sun Nov 17 16:30:07 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: XwcDeGlyph.c,v 1.13 91/09/18 16:30:03 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XwcDeGlyph.c,v 1.15 91/11/17 16:29:59 rws Exp $
   */
  
  /*
***************
*** 38,43 ****
--- 38,44 ----
  #include <X11/Xlibint.h>
  #include "Xlocaleint.h"
  #include <X11/Xos.h>
+ #include <X11/Xutil.h>
  
  #define MAGIC_NUMBER	(9999)
  
***************
*** 75,80 ****
--- 76,83 ----
      int             limit, error;
      ISOStateInfo    stateinfo;
      char	    *esc;
+     int i;
+     char *defstr = XDefaultString();
  
      limit = *cs_bytes;
      wccnt = cscnt = error = 0;
***************
*** 83,91 ****
  	/*
  	 * filter control characters.
  	 */
- 	/*
-         if (wc == WCHARSPACE || _Xiswcntrl(wc)) {
- 	*/
          if (_Xiswcntrl(wc)) {
  	    if (cscnt >= limit) 
  		Return(BadBuffer);
--- 86,91 ----
***************
*** 96,109 ****
  	}
  	if (woffset == MAGIC_NUMBER) {
      	    _XcwGetAll(xlocale, wc, &esc, &woffset, &stateinfo);
! 	    if (woffset == 0)
! 		Return(BadEncoding);
  	    if (ctid != NULL)
  		*ctid = ctGetid(xlocale);
  	    newwoffset = woffset;
! 	} else 
!             if(_XcwGetWoffset(wc, &newwoffset) == ND) /* MUST not change Status */
! 		Return(BadEncoding);
  	if (woffset != newwoffset)
  	    break;
          code = wc - woffset;
--- 96,128 ----
  	}
  	if (woffset == MAGIC_NUMBER) {
      	    _XcwGetAll(xlocale, wc, &esc, &woffset, &stateinfo);
! 	    if (woffset == 0) {
! 		/* XXX BUG: need to check designate sequence of default string.
! 		   But current default string is NULL, so OK. :-) */
! 		for (i = 0; *(defstr + i) != 0; i++) {
! 		    *cs_str++ = *(defstr + i);
! 		    cscnt++;
! 		}
! 		error++;
! 		wc_str++, wc_len--, wccnt++;
! 		continue;
! 	    }
  	    if (ctid != NULL)
  		*ctid = ctGetid(xlocale);
  	    newwoffset = woffset;
! 	} else {
!             if(_XcwGetWoffset(wc, &newwoffset) == ND) { /* MUST not change Status */
! 		/* XXX BUG: need to check designate sequence of default string.
! 		   But current default string is NULL, so OK. :-) */
! 		for (i = 0; *(defstr + i) != 0; i++) {
! 		    *cs_str++ = *(defstr + i);
! 		    cscnt++;
! 		}
! 		error++;
! 		wc_str++, wc_len--, wccnt++;
! 		continue;
! 	    }
! 	}
  	if (woffset != newwoffset)
  	    break;
          code = wc - woffset;

*** /tmp/,RCSt1000707	Sun Nov 17 15:32:27 1991
--- mit/lib/X/Xsi/XwcTextPrp.c	Sun Nov 17 15:31:51 1991
***************
*** 1,4 ****
! /* $XConsortium: XwcTextPrp.c,v 1.6 91/08/12 17:19:12 rws Exp $ */
  /*
   * Copyright 1991 by OMRON Corporation
   * Copyright 1991 by the Massachusetts Institute of Technology
--- 1,4 ----
! /* $XConsortium: XwcTextPrp.c,v 1.7 91/11/17 15:31:47 rws Exp $ */
  /*
   * Copyright 1991 by OMRON Corporation
   * Copyright 1991 by the Massachusetts Institute of Technology
***************
*** 67,72 ****
--- 67,73 ----
      int i, scand;
      register unsigned int nbytes;
      XTextProperty proto;
+     int ret, error = 0;
  #ifndef X_WCHAR
      char *mbuf;
      int mlen;
***************
*** 91,98 ****
  		if (*list) {
  		    len = datalen;
  #ifdef X_WCHAR
! 		    if (_XConvertWCToString(*list, _Xwcslen(*list), buf,
! 					    &len, &scand) != Success) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
--- 92,99 ----
  		if (*list) {
  		    len = datalen;
  #ifdef X_WCHAR
! 		    if ((ret = _XConvertWCToString(*list, _Xwcslen(*list), buf,
! 					    &len, &scand)) < 0) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
***************
*** 99,110 ****
  #else
  		    mlen = _Xsiwcstombs(dpy, (XLCd)NULL,
  					*list, _Xwcslen(*list), True, &mbuf);
! 		    if (_XConvertMBToString(mbuf, mlen, buf,
! 					    &len, &scand) != Success) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
  #endif
  		    buf += len + 1;
  		    datalen -= len + 1;
  		    proto.nitems += len + 1;
--- 100,112 ----
  #else
  		    mlen = _Xsiwcstombs(dpy, (XLCd)NULL,
  					*list, _Xwcslen(*list), True, &mbuf);
! 		    if ((ret = _XConvertMBToString(mbuf, mlen, buf,
! 					    &len, &scand)) < 0) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
  #endif
+ 		    error += ret;
  		    buf += len + 1;
  		    datalen -= len + 1;
  		    proto.nitems += len + 1;
***************
*** 121,128 ****
  		if (*list) {
  		    len = datalen;
  #ifdef X_WCHAR
! 		    if (_XConvertWCToCT(0, *list, _Xwcslen(*list), buf,
! 					&len, &scand, 0) != Success) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
--- 123,130 ----
  		if (*list) {
  		    len = datalen;
  #ifdef X_WCHAR
! 		    if ((ret = _XConvertWCToCT(0, *list, _Xwcslen(*list), buf,
! 					&len, &scand, 0)) < 0) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
***************
*** 129,140 ****
  #else
  		    mlen = _Xsiwcstombs(dpy, (XLCd)NULL,
  					*list, _Xwcslen(*list), True, &mbuf);
! 		    if (_XConvertMBToCT(0, mbuf, mlen, buf,
! 					&len, &scand, 0) != Success) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
  #endif
  		    buf += len + 1;
  		    datalen -= len + 1;
  		    proto.nitems += len + 1;
--- 131,143 ----
  #else
  		    mlen = _Xsiwcstombs(dpy, (XLCd)NULL,
  					*list, _Xwcslen(*list), True, &mbuf);
! 		    if ((ret = _XConvertMBToCT(0, mbuf, mlen, buf,
! 					&len, &scand, 0)) < 0) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
  #endif
+ 		    error += ret;
  		    buf += len + 1;
  		    datalen -= len + 1;
  		    proto.nitems += len + 1;
***************
*** 157,167 ****
  		if (*list) {
  		    len = datalen;
  #ifdef X_WCHAR
! 		    if (_XConvertWCToMB(0, *list, _Xwcslen(*list), buf,
! 					&len, &scand, 0) != Success) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
  #else
  #ifdef macII
  		    len = 0;
--- 160,171 ----
  		if (*list) {
  		    len = datalen;
  #ifdef X_WCHAR
! 		    if ((ret = _XConvertWCToMB(0, *list, _Xwcslen(*list), buf,
! 					&len, &scand, 0)) < 0) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
+ 		    error += ret;
  #else
  #ifdef macII
  		    len = 0;
***************
*** 189,196 ****
  		if (*list) {
  		    len = datalen;
  #ifdef X_WCHAR
! 		    if (_XConvertWCToCT(0, *list, _Xwcslen(*list), buf,
! 					&len, &scand, 0) != Success) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
--- 193,200 ----
  		if (*list) {
  		    len = datalen;
  #ifdef X_WCHAR
! 		    if ((ret = _XConvertWCToCT(0, *list, _Xwcslen(*list), buf,
! 					&len, &scand, 0)) < 0) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
***************
*** 197,208 ****
  #else
  		    mlen = _Xsiwcstombs(dpy, (XLCd)NULL,
  					*list, _Xwcslen(*list), True, &mbuf);
! 		    if (_XConvertMBToCT(0, mbuf, mlen, buf,
! 					&len, &scand, 0) != Success) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
  #endif
  		    if (is_xstring)
  			for (i = 0; *(buf+i); i++) {
  			    if(!_isXString(*(buf+i))) {
--- 201,213 ----
  #else
  		    mlen = _Xsiwcstombs(dpy, (XLCd)NULL,
  					*list, _Xwcslen(*list), True, &mbuf);
! 		    if ((ret = _XConvertMBToCT(0, mbuf, mlen, buf,
! 					&len, &scand, 0)) < 0) {
  			Xfree((char *)buf_sv);
  			return (XConverterNotFound);
  		    }
  #endif
+ 		    error += ret;
  		    if (is_xstring)
  			for (i = 0; *(buf+i); i++) {
  			    if(!_isXString(*(buf+i))) {
***************
*** 232,236 ****
  	proto.value = 0;
      }
      *text_prop = proto;
!     return (Success);
  }
--- 237,241 ----
  	proto.value = 0;
      }
      *text_prop = proto;
!     return (error);
  }

*** /tmp/,RCSt1014590	Wed Dec 11 10:51:49 1991
--- mit/lib/X/Xsi/ProtoFlt.c	Mon Dec  2 16:51:39 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: ProtoFlt.c,v 1.22 91/09/12 13:34:27 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: ProtoFlt.c,v 1.25 91/12/02 16:50:26 rws Exp $
   */
  
  /*
***************
*** 99,104 ****
--- 99,105 ----
  #ifdef macII
  		wc_len = 0;
  #else
+ 		mbuf[mb_len] = '\0';
  		wc_len = mbstowcs(ic->wc_buf, mbuf, ic->max_of_wc);
  #endif
  		if (wc_len == ic->max_of_wc)
***************
*** 259,264 ****
--- 260,266 ----
  #ifdef macII
  		    wc_len = 0;
  #else
+ 		    mbuf[mb_len] = '\0';
  		    wc_len = mbstowcs(ic->wc_buf, mbuf, ic->max_of_wc);
  #endif
  		    if (wc_len == ic->max_of_wc)
***************
*** 351,356 ****
--- 353,359 ----
      register int	i;
      XEvent		dummy_ev;
      int			ret;
+     int			first = 0;
  #ifdef	XML
      char		tmp_lc_name[32];
  #endif	/* XML */
***************
*** 417,423 ****
  		if (reply1.type == XIM_KEYSYM || reply1.type == XIM_STRING) {
  		    if (_XipPutICQueue(ic, (short)reply1.type,
  				       (int)reply1.length,
! 				       (KeySym)reply1.keysym, 0) < 0) {
  			return(-1);
  		    }
  		    count++;
--- 420,426 ----
  		if (reply1.type == XIM_KEYSYM || reply1.type == XIM_STRING) {
  		    if (_XipPutICQueue(ic, (short)reply1.type,
  				       (int)reply1.length,
! 				       (KeySym)reply1.keysym, 0, NULL) < 0) {
  			return(-1);
  		    }
  		    count++;
***************
*** 429,437 ****
  	    dummy_ev.type = KeyPress;
  	    dummy_ev.xkey.state = 0;
  	    dummy_ev.xkey.keycode = display->max_keycode + 1;
! 	    for (i = 0; i < (count - 1); i++) {
  		XPutBackEvent(display, &dummy_ev);
  	    }
  	    ev->xkey.state = 0;
  	    ev->xkey.keycode = display->max_keycode + 1;
  	    if (_XipTypeOfNextICQueue(ic) == XIM_KEYSYM &&
--- 432,444 ----
  	    dummy_ev.type = KeyPress;
  	    dummy_ev.xkey.state = 0;
  	    dummy_ev.xkey.keycode = display->max_keycode + 1;
! 	    if (first == 0) count--;
! 	    for (i = 0; i < count; i++) {
  		XPutBackEvent(display, &dummy_ev);
  	    }
+ 	    ret = False;
+ 	    if (first > 0) continue;
+ 	    first++;
  	    ev->xkey.state = 0;
  	    ev->xkey.keycode = display->max_keycode + 1;
  	    if (_XipTypeOfNextICQueue(ic) == XIM_KEYSYM &&
***************
*** 442,448 ****
  		    _XipFreeNextICQueue(ic);
  		}
  	    }
- 	    ret = False;
  	} else if (mode == XIM_CALLBACK) {
  	    /*
  	     * Calling callback routines.
--- 449,454 ----

*** /tmp/,RCSt1001143	Sun Nov 17 15:59:58 1991
--- mit/lib/X/Xsi/XIMQueue.c	Sun Nov 17 15:59:03 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: XIMQueue.c,v 1.8 91/06/29 13:38:44 xguest Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XIMQueue.c,v 1.9 91/11/17 15:58:54 rws Exp $
   */
  
  /*
***************
*** 59,64 ****
--- 59,72 ----
      return((KeySym)ic->out->keysym);
  }
  
+ char *
+ _XipStringOfNextICQueue(ic)
+     XipIC ic;
+ {
+     if (ic->out == NULL || ic->out->length == 0) return(0);
+     return((char *)ic->out->ptr);
+ }
+ 
  void
  _XipFreeNextICQueue(ic)
      XipIC ic;
***************
*** 76,87 ****
   * Stack 
   */
  int
! _XipPutICQueue(ic, type, length, keysym, state)
      XipIC ic;
      short type;
      int length;
      KeySym keysym;
      unsigned int state;
  {
      XipIM im = ipIMofIC(ic);
  
--- 84,96 ----
   * Stack 
   */
  int
! _XipPutICQueue(ic, type, length, keysym, state, str)
      XipIC ic;
      short type;
      int length;
      KeySym keysym;
      unsigned int state;
+     unsigned char *str;
  {
      XipIM im = ipIMofIC(ic);
  
***************
*** 113,118 ****
--- 122,130 ----
  
      ic->in->type = type;
      if (type == XIM_KEYSYM) {
+ 	if (str) {
+ 	    length = strlen((char *)str);
+ 	}
  	ic->in->length = length;
  	ic->in->keysym = keysym;
  	ic->in->state = state;
***************
*** 122,129 ****
  					       (unsigned)length);
  		ic->in->buf_max = length;
  	    }
! 	    if (_XipReadFromIM(im, ic->in->ptr, ic->in->length) < 0)
! 	        return(-1);
  	}
      } else if (type == XIM_STRING) {
  	ic->in->length = length;
--- 134,145 ----
  					       (unsigned)length);
  		ic->in->buf_max = length;
  	    }
! 	    if (!str) {
! 		if (_XipReadFromIM(im, ic->in->ptr, ic->in->length) < 0)
! 		    return(-1);
! 	    } else {
! 		(void) strcpy(ic->in->ptr, (char *)str);
! 	    }
  	}
      } else if (type == XIM_STRING) {
  	ic->in->length = length;

*** /tmp/,RCSt1001143	Sun Nov 17 16:00:04 1991
--- mit/lib/X/Xsi/XIMlibint.h	Sun Nov 17 15:59:07 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: XIMlibint.h,v 1.10 91/05/07 19:29:27 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XIMlibint.h,v 1.11 91/11/17 15:59:01 rws Exp $
   */
  
  /*
***************
*** 56,61 ****
--- 56,62 ----
  extern short	_XipTypeOfNextICQueue();
  extern KeySym	_XipKeySymOfNextICQueue();
  extern unsigned int	_XipStateOfNextICQueue();
+ extern char *	_XipStringOfNextICQueue();
  extern void	_XipFreeNextICQueue();
  extern int	_XipPutICQueue();
  extern void	_XipGetNextICQueue();

*** /tmp/,RCSt1001143	Sun Nov 17 16:00:10 1991
--- mit/lib/X/Xsi/XLocalIM.c	Sun Nov 17 15:59:14 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: XLocalIM.c,v 1.5 91/07/23 12:04:48 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XLocalIM.c,v 1.6 91/11/17 15:59:05 rws Exp $
   */
  
  /*
***************
*** 36,41 ****
--- 36,42 ----
  #include "Xi18nint.h"
  #include "XIMlibint.h"
  #include <X11/Xos.h>
+ #include <X11/keysymdef.h>
  #if NeedVarargsPrototypes
  # include <stdarg.h>
  # define Va_start(a,b) va_start(a,b)
***************
*** 185,198 ****
  } StateTbl;
  
  static StateTbl state_tbl[] = {
-     { "Shift",	ShiftMask },
      { "Lock",	LockMask },
      { "Control",	ControlMask },
      { "Mod1",	Mod1Mask },
!     { "Mod1",	Mod2Mask },
!     { "Mod1",	Mod3Mask },
!     { "Mod1",	Mod4Mask },
!     { "Mod1",	Mod5Mask },
      { NULL,	0 }
  };
  
--- 186,198 ----
  } StateTbl;
  
  static StateTbl state_tbl[] = {
      { "Lock",	LockMask },
      { "Control",	ControlMask },
      { "Mod1",	Mod1Mask },
!     { "Mod2",	Mod2Mask },
!     { "Mod3",	Mod3Mask },
!     { "Mod4",	Mod4Mask },
!     { "Mod5",	Mod5Mask },
      { NULL,	0 }
  };
  
***************
*** 225,231 ****
--- 225,343 ----
      return(0);
  }
  
+ static int
+ parse_bslash(buf, work)
+ register char *buf;
+ register unsigned char *work;
+ {
+     register int i;
+     switch(*buf) {
+ 	case 'x': /* 16 */
+ 	    for (buf++, *work = '\0', i = 1; i >= 0; i--, buf++) {
+ 		if (*buf >= '0' && *buf <= '9') {
+ 		    *work |= ((1 << (i * 4)) * (*buf - '0'));
+ 		} else if (*buf >= 'A' && *buf <= 'F') {
+ 		    *work |= ((1 << (i * 4)) * (*buf - 'A' + 10));
+ 		} else if (*buf >= 'a' && *buf <= 'f') {
+ 		    *work |= ((1 << (i * 4)) * (*buf - 'a' + 10));
+ 		} else {
+ 		    return(0);
+ 		}
+ 	    }
+ 	    return(3);
+ 	case 'o': /* 8 */
+ 	    for (buf++, *work = '\0', i = 2; i >= 0; i--, buf++) {
+ 		if (*buf >= '0' && *buf <= '7') {
+ 		    *work |= ((1 << (i * 3)) * (*buf - '0'));
+ 		} else {
+ 		    return(0);
+ 		}
+ 	    }
+ 	    return(4);
+ 	case 'n': /*  */
+ 	    *work = '\n'; return(1);
+ 	case 't': /* */
+ 	    *work = '\t'; return(1);
+ 	case 'b': /* */
+ 	    *work = '\b'; return(1);
+ 	case 'r': /* */
+ 	    *work = '\r'; return(1);
+ 	case 'f': /* */
+ 	    *work = '\f'; return(1);
+ 	case 'e': /* */
+ 	case 'E': /* */
+ 	    *work = '\033'; return(1);
+ 	case '\\': /* */
+ 	    *work = '\\'; return(1);
+ 	default:
+ 	    for (*work = '\0', i = 2; i >= 0; i--, buf++) {
+ 		if (*buf >= '0' && *buf <= '7') {
+ 		    *work |= ((1 << (i * 3)) * (*buf - '0'));
+ 		} else {
+ 		    return(*buf);
+ 		}
+ 	    }
+ 	    return(3);
+     }
+ }
+ 
  static XipLocalKeySymTbl *
+ get_string(buf, tbl)
+ register char *buf;
+ XipLocalKeySymTbl *tbl;
+ {
+     XipLocalKeySymTbl work_tbl[8], *p, *t;
+     unsigned char work[32], *str;
+     register int i = 0, j = 0, total = 0, ret;
+ 
+     for (p = work_tbl, total = 0; *buf; p++, total++, buf++) {
+ 	if ((buf = index(buf, '{')) == NULL) {
+ 	    break;
+ 	}
+ 	buf++;
+ 	for ( i = 0; *buf != '}';) {
+ 	    if (*buf == (char)0x5c) {
+ 		buf++;
+ 		if (!(ret = parse_bslash(buf, &work[i]))) {
+ 		    return(NULL);
+ 		}
+ 		buf += ret;
+ 		i++;
+ 	    } else {
+ 		work[i++] = *buf;
+ 		buf++;
+ 	    }
+ 	    if (!*buf) return(NULL);
+ 	}
+ 	if (i == 0) return(NULL);
+ 	work[i] = '\0';
+ 	str = (unsigned char *) Xmalloc(i + 1);
+ 	strcpy((char *)str, (char *)work);
+ 	p->str = str;
+ 	p->keysym = NoSymbol;
+ 	p->state = 0;
+ 	total++;
+     }
+     if (total < 1) return(NULL);
+     p->str = NULL;
+     p->keysym = XK_VoidSymbol;
+     p->state = 0;
+     if (tbl) {
+ 	for (i = 0, t = tbl, p = work_tbl;
+ 	     t->keysym != XK_VoidSymbol && i < total; i++, t++, p++) {
+ 	    t->str = p->str;
+ 	}
+     } else {
+ 	tbl = (XipLocalKeySymTbl *) Xmalloc((sizeof(XipLocalKeySymTbl)
+ 					    * (total + 1)));
+ 	if (!tbl) return (NULL);
+ 	bcopy((char *)work_tbl, (char *)tbl,
+ 	      sizeof(XipLocalKeySymTbl) * (total + 1));
+     }
+     return(tbl);
+ }
+ 
+ static XipLocalKeySymTbl *
  get_keysym(buf, len)
  char *buf;
  int *len;
***************
*** 258,266 ****
  		    "Can't convert to KeySym \"%s\".", k[i]);
  	    return (NULL);
  	}
  	total++;
      }
!     p->keysym = 0;
      total++;
      keysym_tbl = (XipLocalKeySymTbl *) Xmalloc((sizeof(XipLocalKeySymTbl)
  						* total));
--- 370,380 ----
  		    "Can't convert to KeySym \"%s\".", k[i]);
  	    return (NULL);
  	}
+ 	p->str = NULL;
  	total++;
      }
!     p->keysym = XK_VoidSymbol;
!     p->str = NULL;
      total++;
      keysym_tbl = (XipLocalKeySymTbl *) Xmalloc((sizeof(XipLocalKeySymTbl)
  						* total));
***************
*** 268,274 ****
  	return (NULL);
      bcopy((char *)work_tbl, (char *)keysym_tbl,
  	  sizeof(XipLocalKeySymTbl) * total);
!     *len = (total - 1);;
      return (keysym_tbl);
  }
  
--- 382,388 ----
  	return (NULL);
      bcopy((char *)work_tbl, (char *)keysym_tbl,
  	  sizeof(XipLocalKeySymTbl) * total);
!     *len = (total - 1);
      return (keysym_tbl);
  }
  
***************
*** 286,296 ****
  is_command(c)
  char c;
  {
!     if (c != '<')
  	return (1);
      return (0);
  }
  
  static FuncTbl *
  get_command(name)
  char *name;
--- 400,419 ----
  is_command(c)
  char c;
  {
!     if (c != '<' && c != '{')
  	return (1);
      return (0);
  }
  
+ static int
+ is_keysym(c)
+ char c;
+ {
+     if (c == '<')
+ 	return (1);
+     return (0);
+ }
+ 
  static FuncTbl *
  get_command(name)
  char *name;
***************
*** 327,349 ****
  }
  
  static Bool
! convert_on_init(xcvt, tbl)
  XipLocalCvt *xcvt;
  XipLocalCvtTbl *tbl;
  {
!     xcvt->off_tbl.fromkey = (XipLocalKeySymTbl *)
! 			    Xmalloc(sizeof(XipLocalKeySymTbl));
!     xcvt->off_tbl.fromkey->keysym = tbl->fromkey->keysym;
!     xcvt->off_tbl.fromkey->state = tbl->fromkey->state;
      xcvt->off_tbl.to.func = tbl->to.func;
      xcvt->off_tbl.com = True;
      return(True);
  }
  
  static Bool
! no_filter(xcvt, tbl)
  XipLocalCvt *xcvt;
  XipLocalCvtTbl *tbl;
  {
      XipLocalNestedKeySym *nested_keysym;
  
--- 450,481 ----
  }
  
  static Bool
! convert_on_init(xcvt, tbl, len)
  XipLocalCvt *xcvt;
  XipLocalCvtTbl *tbl;
+ int len;
  {
!     register XipLocalKeySymTbl *to, *from, *p;
! 
!     p = (XipLocalKeySymTbl *) Xmalloc(sizeof(XipLocalKeySymTbl) * (len + 1));
!     if (!to) return(False);
!     for (to = p, from = tbl->fromkey; len > 0; to++, from++, len--) {
! 	to->keysym = from->keysym;
! 	to->state = from->state;
!     }
!     to->keysym = XK_VoidSymbol;
!     to->state = 0;
      xcvt->off_tbl.to.func = tbl->to.func;
      xcvt->off_tbl.com = True;
+     xcvt->off_tbl.fromkey = p;
      return(True);
  }
  
  static Bool
! no_filter(xcvt, tbl, len)
  XipLocalCvt *xcvt;
  XipLocalCvtTbl *tbl;
+ int len;
  {
      XipLocalNestedKeySym *nested_keysym;
  
***************
*** 369,379 ****
  }
  
  static FILE *
! open_convert_file(lang)
  char *lang;
  {
      FILE	*fp;
-     char	filename[PATH_MAX];
      char	nlspath[PATH_MAX];
      char	*path;
      char	*dir;
--- 501,511 ----
  }
  
  static FILE *
! open_convert_file(lang, filename)
  char *lang;
+ char *filename;
  {
      FILE	*fp;
      char	nlspath[PATH_MAX];
      char	*path;
      char	*dir;
***************
*** 386,394 ****
      strcpy(path, env);
      while (1) {
  	if (path == NULL) {
! 	    fprintf(stderr, "%s \"%s\".\n%s%s%s.",
! 		    "Couldn't find any convert table for lang", lang,
! 		    "Please, create xnls_fir/", LOCAL_CVT_TBL_DIR, lang);
  	    return(NULL);
  	}
  	dir = path;
--- 518,526 ----
      strcpy(path, env);
      while (1) {
  	if (path == NULL) {
! 	    fprintf(stderr, "%s \"%s\".\n%s%s%s.\n",
! 		    "XIM: Couldn't find any convert table for lang", lang,
! 		    "Please, create xnls_dir", LOCAL_CVT_TBL_DIR, lang);
  	    return(NULL);
  	}
  	dir = path;
***************
*** 401,406 ****
--- 533,539 ----
  	if (fp = fopen(filename, "r")) {
  	    return(fp);
  	}
+ 	path = dir;
      }
  }
  
***************
*** 408,416 ****
  _XipLocalCvtSetUp(xlc)
  XLocale	xlc;
  {
      char	tmp_buf[32], *p;
      FILE	*fp;
!     char buf[256], tobuf[256], frombuf[256];
      int	 cnt = 0;
      int len;
      int k;
--- 541,550 ----
  _XipLocalCvtSetUp(xlc)
  XLocale	xlc;
  {
+     char	filename[PATH_MAX];
      char	tmp_buf[32], *p;
      FILE	*fp;
!     char buf[256], tobuf[256], frombuf[256], tostr[256];
      int	 cnt = 0;
      int len;
      int k;
***************
*** 417,422 ****
--- 551,557 ----
      XipLocalCvt *cvt;
      KeySym bs;
      FuncTbl *func_tbl;
+     int line = 0;
  
      strcpy(tmp_buf, xlc->xlc_db->lc_name);
      for (p = tmp_buf; *p && *p != '@'; p++);
***************
*** 423,431 ****
      if (*p)  *p = '\0';
  
      if(CHANGE_MAX < div_up(ENTRY_CNT, BITSIZ)){
! 	fprintf(stderr, "%s%s%d%s",
  		"Sorry, please set CHANGE_MAX(in file ",
! 		"conv/cvt_head.h) larger than ",
  		div_up(ENTRY_CNT, BITSIZ) - 1,
  		",\r\nand recompile.\r\n");
  	return(NULL);
--- 558,566 ----
      if (*p)  *p = '\0';
  
      if(CHANGE_MAX < div_up(ENTRY_CNT, BITSIZ)){
! 	fprintf(stderr, "XIM: %s%s%d%s",
  		"Sorry, please set CHANGE_MAX(in file ",
! 		"Xi18nint.h) larger than ",
  		div_up(ENTRY_CNT, BITSIZ) - 1,
  		",\r\nand recompile.\r\n");
  	return(NULL);
***************
*** 432,452 ****
      }
  
      
!     if(!(fp = open_convert_file(tmp_buf))) return(NULL);
!     if (!(cvt = (XipLocalCvt *) Xmalloc(sizeof(XipLocalCvt))))
  	goto _err_ret2;
!     if (!(cvt->tbl = (XipLocalCvtTbl *) Xmalloc(sizeof(XipLocalCvtTbl) * ENTRY_CNT)))
  	goto _err_ret1;
  
      cnt = 0;
      cvt->nmax = 0;
      cvt->no_filter = NULL;
      while(fgets(buf, BUFSIZ, fp)) {
  	if(is_comment(*buf) || 
! 	   (k = sscanf(buf, "%s %s", frombuf, tobuf)) <= 0)
  	    continue;
! 	if (k != 2) {
! 	    continue;
  	}
  	if(!(cvt->tbl[cnt].fromkey = get_keysym(frombuf, &len))){
  	    goto _err_ret;
--- 567,592 ----
      }
  
      
!     if(!(fp = open_convert_file(tmp_buf, filename))) return(NULL);
!     if (!(cvt = (XipLocalCvt *) Xmalloc(sizeof(XipLocalCvt)))) {
! 	fprintf(stderr, "XIM: Malloc failed\n");
  	goto _err_ret2;
!     }
!     if (!(cvt->tbl = (XipLocalCvtTbl *) Xmalloc(sizeof(XipLocalCvtTbl) * ENTRY_CNT))) {
! 	fprintf(stderr, "XIM: Malloc failed\n");
  	goto _err_ret1;
+     }
  
      cnt = 0;
      cvt->nmax = 0;
      cvt->no_filter = NULL;
      while(fgets(buf, BUFSIZ, fp)) {
+ 	line++;
  	if(is_comment(*buf) || 
! 	   (k = sscanf(buf, "%s %s %s", frombuf, tobuf, tostr)) <= 0)
  	    continue;
! 	if (k < 2) {
! 	    goto _err_ret;
  	}
  	if(!(cvt->tbl[cnt].fromkey = get_keysym(frombuf, &len))){
  	    goto _err_ret;
***************
*** 459,470 ****
  	    cvt->tbl[cnt].to.func = func_tbl->func;
  	    cvt->tbl[cnt].com = True;
  	    if (func_tbl->init_func) {
! 		if ((*func_tbl->init_func)(cvt, &cvt->tbl[cnt]) == True)
! 		    continue;
  	    }
  	} else {
! 	    if(!(cvt->tbl[cnt].to.tokey = get_keysym(tobuf, &len))){
! 		goto _err_ret;
  	    }
  	    cvt->tbl[cnt].com = False;
  	}
--- 599,621 ----
  	    cvt->tbl[cnt].to.func = func_tbl->func;
  	    cvt->tbl[cnt].com = True;
  	    if (func_tbl->init_func) {
! 		if ((*func_tbl->init_func)(cvt, &cvt->tbl[cnt], len) == False)
! 		    goto _err_ret;
  	    }
  	} else {
! 	    if (is_keysym(*tobuf)) {
! 		if(!(cvt->tbl[cnt].to.tokey = get_keysym(tobuf, &len))){
! 		    goto _err_ret;
! 		}
! 		if (k > 2) {
! 		    if(!(get_string(tostr, cvt->tbl[cnt].to.tokey))){
! 			goto _err_ret;
! 		    }
! 		}
! 	    } else {
! 		if(!(cvt->tbl[cnt].to.tokey = get_string(tobuf, NULL))){
! 		    goto _err_ret;
! 		}
  	    }
  	    cvt->tbl[cnt].com = False;
  	}
***************
*** 480,485 ****
--- 631,638 ----
      fclose(fp);
      return(cvt);
  _err_ret:
+     fprintf(stderr, "XIM: Error occurred at line %d in file \"%s\".\n",
+ 	    line, filename);
      Xfree(cvt->tbl);
  _err_ret1:
      Xfree(cvt);
***************
*** 514,527 ****
  _XipLocalFreeCvt(cvt)
  XipLocalCvt *cvt;
  {
!     register int i;
      XipLocalCvtTbl *tbl;
  
      tbl = cvt->tbl;
      for (i = 0; i < cvt->cnt; i++, tbl++) {
  	Xfree((*tbl).fromkey);
! 	if ((*tbl).com != True)
! 	  Xfree((*tbl).to.tokey);
      }
      Xfree(cvt->tbl);
      Xfree(cvt);
--- 667,683 ----
  _XipLocalFreeCvt(cvt)
  XipLocalCvt *cvt;
  {
!     register int i, j;
      XipLocalCvtTbl *tbl;
  
      tbl = cvt->tbl;
      for (i = 0; i < cvt->cnt; i++, tbl++) {
  	Xfree((*tbl).fromkey);
! 	if ((*tbl).com != True) {
! 	    for (j = 0; (*tbl).to.tokey[j].str; j++)
! 		Xfree((*tbl).to.tokey[j].str);
! 	    Xfree((*tbl).to.tokey);
! 	}
      }
      Xfree(cvt->tbl);
      Xfree(cvt);
***************
*** 624,641 ****
      XipLocalKeySymTbl	*code_p;
      int		i;
  
!     for(base = 0; cvt->buf[base].keysym != 0; base++) {
  	for(dist = 0; dist < cvt->cnt; dist++) {
  	    if(BITONP(cvt->check_flg, dist) &&
! 	       cvt->tbl[dist].fromkey->keysym != 0){
  		code_p = cvt->tbl[dist].fromkey + base;
  		if((code_p->keysym == cvt->buf[base].keysym) &&
! 		   ((code_p->state == 0) ||
! 		    (code_p->state == cvt->buf[base].state))) {
! 		    if((code_p + 1)->keysym == (KeySym)0){
  			/* matched */
  			for(i = 0, base++;
! 			    (cvt->buf[i].keysym = cvt->buf[base].keysym) != 0;
  			    i++, base++);
  			return(dist);
  		    }
--- 780,797 ----
      XipLocalKeySymTbl	*code_p;
      int		i;
  
!     for(base = 0; cvt->buf[base].keysym != XK_VoidSymbol; base++) {
  	for(dist = 0; dist < cvt->cnt; dist++) {
  	    if(BITONP(cvt->check_flg, dist) &&
! 	       cvt->tbl[dist].fromkey->keysym != XK_VoidSymbol){
  		code_p = cvt->tbl[dist].fromkey + base;
  		if((code_p->keysym == cvt->buf[base].keysym) &&
! 		   ((!(code_p->state | (cvt->buf[base].state & ~ShiftMask))) ||
! 		    (code_p->state == (cvt->buf[base].state & ~ShiftMask)))) {
! 		    if((code_p + 1)->keysym == (KeySym)XK_VoidSymbol){
  			/* matched */
  			for(i = 0, base++;
! 			    (cvt->buf[i].keysym = cvt->buf[base].keysym) != XK_VoidSymbol;
  			    i++, base++);
  			return(dist);
  		    }
***************
*** 665,677 ****
      XipLocalKeySymTbl	*code_p = cvt->off_tbl.fromkey;
      int		i;
  
!     for(base = 0; cvt->buf[base].keysym != 0; base++) {
  	if((code_p->keysym == cvt->buf[base].keysym) &&
! 	   (code_p->state == cvt->buf[base].state)) {
! 	    if((code_p + 1)->keysym == (KeySym)0){
  		/* matched */
  		for(i = 0, base++;
! 		    (cvt->buf[i].keysym = cvt->buf[base].keysym) != 0;
  		    i++, base++);
  		return(0);
  	    }
--- 821,834 ----
      XipLocalKeySymTbl	*code_p = cvt->off_tbl.fromkey;
      int		i;
  
!     for(base = 0; cvt->buf[base].keysym != XK_VoidSymbol; base++) {
  	if((code_p->keysym == cvt->buf[base].keysym) &&
! 	   ((!(code_p->state | (cvt->buf[base].state & ~ShiftMask))) ||
! 	   (code_p->state == (cvt->buf[base].state & ~ShiftMask)))) {
! 	    if((code_p + 1)->keysym == (KeySym)XK_VoidSymbol){
  		/* matched */
  		for(i = 0, base++;
! 		    (cvt->buf[i].keysym = cvt->buf[base].keysym) != XK_VoidSymbol;
  		    i++, base++);
  		return(0);
  	    }
***************
*** 712,718 ****
      if (ev->xkey.keycode == (display->max_keycode + 1)) {
  	if (_XipTypeOfNextICQueue((XipIC)ic) == XIM_KEYSYM){
  	    if ((keycode = XKeysymToKeycode(display,
! 			    _XipKeySymOfNextICQueue((XipIC)ic))) != 0){
  		ev->xkey.state = _XipStateOfNextICQueue((XipIC)ic);
  		ev->xkey.keycode = keycode;
  		_XipFreeNextICQueue((XipIC)ic);
--- 869,876 ----
      if (ev->xkey.keycode == (display->max_keycode + 1)) {
  	if (_XipTypeOfNextICQueue((XipIC)ic) == XIM_KEYSYM){
  	    if ((keycode = XKeysymToKeycode(display,
! 			    _XipKeySymOfNextICQueue((XipIC)ic))) != 0
! 		&& _XipStringOfNextICQueue((XipIC)ic) == NULL){
  		ev->xkey.state = _XipStateOfNextICQueue((XipIC)ic);
  		ev->xkey.keycode = keycode;
  		_XipFreeNextICQueue((XipIC)ic);
***************
*** 746,752 ****
      }
      xcvt->buf[xcvt->buf_cnt].keysym = keysym;
      xcvt->buf[xcvt->buf_cnt].state = ev->xkey.state;
!     xcvt->buf[++xcvt->buf_cnt].keysym = 0;
      bcopy((char *)ev, (char *)&dummy_ev, sizeof(XEvent));
      dummy_ev.type = KeyPress;
      dummy_ev.xkey.state = 0;
--- 904,910 ----
      }
      xcvt->buf[xcvt->buf_cnt].keysym = keysym;
      xcvt->buf[xcvt->buf_cnt].state = ev->xkey.state;
!     xcvt->buf[++xcvt->buf_cnt].keysym = XK_VoidSymbol;
      bcopy((char *)ev, (char *)&dummy_ev, sizeof(XEvent));
      dummy_ev.type = KeyPress;
      dummy_ev.xkey.state = 0;
***************
*** 768,780 ****
      case -2: /* No match */
  	for (i = 0; i < xcvt->buf_cnt; i++) {
  	     if (_XipPutICQueue(ic, XIM_KEYSYM, 0, xcvt->buf[i].keysym,
! 				xcvt->buf[i].state) < 0)
  	       return(False);
  	}
  	ev->xkey.state = 0;
  	ev->xkey.keycode = display->max_keycode + 1;
  	if ((keycode = XKeysymToKeycode(display,
! 				_XipKeySymOfNextICQueue((XipIC)ic))) != 0) {
  	    ev->xkey.state = _XipStateOfNextICQueue((XipIC)ic);
  	    ev->xkey.keycode = keycode;
  	    _XipFreeNextICQueue((XipIC)ic);
--- 926,939 ----
      case -2: /* No match */
  	for (i = 0; i < xcvt->buf_cnt; i++) {
  	     if (_XipPutICQueue(ic, XIM_KEYSYM, 0, xcvt->buf[i].keysym,
! 				xcvt->buf[i].state, NULL) < 0)
  	       return(False);
  	}
  	ev->xkey.state = 0;
  	ev->xkey.keycode = display->max_keycode + 1;
  	if ((keycode = XKeysymToKeycode(display,
! 				_XipKeySymOfNextICQueue((XipIC)ic))) != 0
! 	    && _XipStringOfNextICQueue((XipIC)ic) == NULL) {
  	    ev->xkey.state = _XipStateOfNextICQueue((XipIC)ic);
  	    ev->xkey.keycode = keycode;
  	    _XipFreeNextICQueue((XipIC)ic);
***************
*** 793,813 ****
  		return(True);
  	    }
  	}
! 	for (i = 0; xcvt->tbl[c].to.tokey[i].keysym; i++) {
  	     if (_XipPutICQueue(ic, XIM_KEYSYM, 0,
  				xcvt->tbl[c].to.tokey[i].keysym,
! 				xcvt->tbl[c].to.tokey[i].state) < 0)
  	       return(False);
  	}
  	ev->xkey.state = 0;
  	ev->xkey.keycode = display->max_keycode + 1;
  	if ((keycode = XKeysymToKeycode(display,
! 				_XipKeySymOfNextICQueue((XipIC)ic))) != 0) {
  	    ev->xkey.state = _XipStateOfNextICQueue((XipIC)ic);
  	    ev->xkey.keycode = keycode;
  	    _XipFreeNextICQueue((XipIC)ic);
  	}
! 	for (i = 1; xcvt->tbl[c].to.tokey[i].keysym; i++) {
  	    XPutBackEvent(display, &dummy_ev);
  	}
  	xcvt->buf_cnt = 0;
--- 952,974 ----
  		return(True);
  	    }
  	}
! 	for (i = 0; xcvt->tbl[c].to.tokey[i].keysym != XK_VoidSymbol; i++) {
  	     if (_XipPutICQueue(ic, XIM_KEYSYM, 0,
  				xcvt->tbl[c].to.tokey[i].keysym,
! 				xcvt->tbl[c].to.tokey[i].state,
! 				xcvt->tbl[c].to.tokey[i].str) < 0)
  	       return(False);
  	}
  	ev->xkey.state = 0;
  	ev->xkey.keycode = display->max_keycode + 1;
  	if ((keycode = XKeysymToKeycode(display,
! 				_XipKeySymOfNextICQueue((XipIC)ic))) != 0
! 	    && _XipStringOfNextICQueue((XipIC)ic) == NULL) {
  	    ev->xkey.state = _XipStateOfNextICQueue((XipIC)ic);
  	    ev->xkey.keycode = keycode;
  	    _XipFreeNextICQueue((XipIC)ic);
  	}
! 	for (i = 1; xcvt->tbl[c].to.tokey[i].keysym != XK_VoidSymbol; i++) {
  	    XPutBackEvent(display, &dummy_ev);
  	}
  	xcvt->buf_cnt = 0;
***************
*** 967,972 ****
--- 1128,1135 ----
      register XrmName		Name;
      register XIMrmResourceList	xrmres;
      unsigned int		num_resources = im->num_resources;
+     XrmQuark			query_input =
+ 				     XrmPermStringToQuark(XNQueryInputStyle);
  
      for (arg = args; arg->name && *(arg->name); arg++) {
  	Name = XrmStringToName(arg->name);
***************
*** 973,981 ****
  	for (xrmres = im->resources, i = 0;
  	     i < num_resources; i++, xrmres++) {
  	    if (Name == xrmres->xrm_name) {
! 		(void) _XCopyToArg((char *)im - xrmres->xrm_offset - 1,
! 				   &arg->value,
! 				   (unsigned int)xrmres->xrm_size);
  		break;
  	    }
  	}
--- 1136,1163 ----
  	for (xrmres = im->resources, i = 0;
  	     i < num_resources; i++, xrmres++) {
  	    if (Name == xrmres->xrm_name) {
! 		if (Name == query_input) {
! 		    char *p;
! 		    XIMStyles *styles;
! 		    int size = sizeof(XIMStyle)
! 			       * im->values.input_styles.count_styles;
! 		    int all_size = sizeof(XIMStyles) + size;
! 		    if ((p = Xmalloc((unsigned)all_size)) == NULL) {
! 			continue;
! 		    }
! 		    styles = (XIMStyles *)p;
! 		    styles->count_styles = im->values.input_styles.count_styles;
! 		    styles->supported_styles =
! 					(XIMStyle *)(p + sizeof(XIMStyles));
! 		    bcopy((char *)im->values.input_styles.supported_styles,
! 			  (char *)styles->supported_styles, size);
! 		    bcopy((char *)&styles, (char *)arg->value,
! 			  sizeof(XIMStyles *));
! 		} else {
! 		    (void) _XCopyToArg((char *)im - xrmres->xrm_offset - 1,
! 				       &arg->value,
! 				       (unsigned int)xrmres->xrm_size);
! 		}
  		break;
  	    }
  	}

*** /tmp/,RCSt1001143	Sun Nov 17 16:00:19 1991
--- mit/lib/X/Xsi/Xi18nint.h	Sun Nov 17 15:59:20 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: Xi18nint.h,v 1.17 91/05/07 21:29:46 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: Xi18nint.h,v 1.18 91/11/17 15:59:13 rws Exp $
   */
  
  /*
***************
*** 82,87 ****
--- 82,88 ----
  typedef struct {
      KeySym	keysym;
      unsigned int	state;
+     unsigned char	*str;
  } XipLocalKeySymTbl;
  
  typedef struct _XipLocalNestedKeySym {

*** /tmp/,RCSt1001283	Sun Nov 17 16:13:00 1991
--- mit/lib/X/Xsi/Xlocaleint.h	Sun Nov 17 16:11:56 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: Xlocaleint.h,v 1.33 91/06/29 13:37:00 xguest Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: Xlocaleint.h,v 1.34 91/11/17 16:11:44 rws Exp $
   */
  
  /*
***************
*** 46,52 ****
  #include <X11/Xlocale.h>
  #include "Xlcint.h"
  
! #define MAXCHARSETS         10
  #define MAXSEQUENCELENGTH   255
  
  #define XDEFAULT_STATE 0xffffff  /* to specify default _State for XConvertXXToXX */
--- 46,52 ----
  #include <X11/Xlocale.h>
  #include "Xlcint.h"
  
! #define MAXCHARSETS         16
  #define MAXSEQUENCELENGTH   255
  
  #define XDEFAULT_STATE 0xffffff  /* to specify default _State for XConvertXXToXX */
***************
*** 68,73 ****
--- 68,79 ----
  #define CODESET7     7   /* Charset 7 */
  #define CODESET8     8   /* Charset 8 */
  #define CODESET9     9   /* Charset 9 */
+ #define CODESETA     10   /* Charset A */
+ #define CODESETB     11   /* Charset B */
+ #define CODESETC     12   /* Charset C */
+ #define CODESETD     13   /* Charset D */
+ #define CODESETE     14   /* Charset E */
+ #define CODESETF     15   /* Charset F */
  #define C0      16  /* Control Set 0 */
  #define C1      17  /* Control Set 1 */
  #define ND      127 /* Not Defined */

*** /tmp/,RCSt1001283	Sun Nov 17 16:13:03 1991
--- mit/lib/X/Xsi/XlcLoad.c	Sun Nov 17 16:12:22 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: XlcLoad.c,v 1.37 91/07/19 11:47:42 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XlcLoad.c,v 1.38 91/11/17 16:12:06 rws Exp $
   */
  
  /*
***************
*** 475,480 ****
--- 475,486 ----
      if (!strncmp(s, "CS7", 3)) return CODESET7;
      if (!strncmp(s, "CS8", 3)) return CODESET8;
      if (!strncmp(s, "CS9", 3)) return CODESET9;
+     if (!strncmp(s, "CSA", 3)) return CODESETA;
+     if (!strncmp(s, "CSB", 3)) return CODESETB;
+     if (!strncmp(s, "CSC", 3)) return CODESETC;
+     if (!strncmp(s, "CSD", 3)) return CODESETD;
+     if (!strncmp(s, "CSE", 3)) return CODESETE;
+     if (!strncmp(s, "CSF", 3)) return CODESETF;
      if (!strncmp(s, "C0", 2)) return C0;
      if (!strncmp(s, "C1", 2)) return C1;
      if (!strncmp(s, "ND", 2)) return ND;

*** /tmp/,RCSt1014597	Wed Dec 11 10:53:29 1991
--- mit/lib/X/Xsi/XCrFntSet.c	Mon Dec  2 16:51:07 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: XCrFntSet.c,v 1.40 91/06/26 11:05:15 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XCrFntSet.c,v 1.43 91/12/02 16:49:48 rws Exp $
   */
  
  /*
***************
*** 442,448 ****
  		ret++;
  		f_tmp[i] = fn;
  #ifdef PRELOAD
! 		s_tmp[i] = XLoadQueryFont(dpy, fn);
  #else /* PRELOAD */
  		if (!info)
  		    list = XListFontsWithInfo(dpy, fname, 1, &count, &info);
--- 442,448 ----
  		ret++;
  		f_tmp[i] = fn;
  #ifdef PRELOAD
! 		if (!(s_tmp[i] = XLoadQueryFont(dpy, fn))) ret--;
  #else /* PRELOAD */
  		if (!info)
  		    list = XListFontsWithInfo(dpy, fname, 1, &count, &info);
***************
*** 607,613 ****
  	    XFontStruct  *info;
  	    char	**info_list;
  	    int		  count_list;
! 	    if (found >= MAXCHARSETS)
  		break;
  	    info = NULL;
  	    if (isXLFDname(list[j]) ) {
--- 607,613 ----
  	    XFontStruct  *info;
  	    char	**info_list;
  	    int		  count_list;
! 	    if (found >= (MAXCHARSETS - 1))
  		break;
  	    info = NULL;
  	    if (isXLFDname(list[j]) ) {
***************
*** 619,625 ****
  		info_list = XListFontsWithInfo(dpy, list[j], 1, &count_list, &info);
  		if (count_list != 1) {
  		    /* never go to here. */
! 		    break;
  		}
  		f_tmp[found] = getXLFDName(dpy, &info[0]);
  	    }
--- 619,625 ----
  		info_list = XListFontsWithInfo(dpy, list[j], 1, &count_list, &info);
  		if (count_list != 1) {
  		    /* never go to here. */
! 		    continue;
  		}
  		f_tmp[found] = getXLFDName(dpy, &info[0]);
  	    }
***************
*** 649,655 ****
  			info_list = XListFontsWithInfo(dpy, list[j], 1, &count_list, &info);
  		    if (count_list != 1)
  			/* never go to here. */
! 			return NULL;
  
  		    f_tmp[found+1] = f_tmp[found];
  		    found += TryLoad(s_tmp, id_tmp, found, info, charset, GL);
--- 649,655 ----
  			info_list = XListFontsWithInfo(dpy, list[j], 1, &count_list, &info);
  		    if (count_list != 1)
  			/* never go to here. */
! 			continue;
  
  		    f_tmp[found+1] = f_tmp[found];
  		    found += TryLoad(s_tmp, id_tmp, found, info, charset, GL);
***************
*** 658,664 ****
  		    info_list = XListFontsWithInfo(dpy, list[j], 1, &count_list, &info);
  		if (count_list != 1)
  		    /* never go to here. */
! 		    return NULL;
  		found += TryLoad(s_tmp, id_tmp, found, info, charset, GR);
  		notfound = 0;
  		if (info)
--- 658,664 ----
  		    info_list = XListFontsWithInfo(dpy, list[j], 1, &count_list, &info);
  		if (count_list != 1)
  		    /* never go to here. */
! 		    continue;
  		found += TryLoad(s_tmp, id_tmp, found, info, charset, GR);
  		notfound = 0;
  		if (info)

*** /tmp/,RCSt1004855	Mon Dec  2 16:32:51 1991
--- mit/lib/X/Xsi/XGetIMVal.c	Mon Dec  2 16:33:18 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: XGetIMVal.c,v 1.15 91/08/12 17:21:10 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XGetIMVal.c,v 1.16 91/12/02 16:31:34 rws Exp $
   */
  
  /*
***************
*** 185,191 ****
      err = _IMGetValues(im, args, &mask);
      if (err) return err;
  
!     if (!_ReceiveIMValues(im, mask))
! 	(void)_IMGetValues(im, args, (unsigned long *)NULL);
!     return(NULL);
  }
--- 185,195 ----
      err = _IMGetValues(im, args, &mask);
      if (err) return err;
  
!     if (!_ReceiveIMValues(im, mask)) {
! 	return(_IMGetValues(im, args, (unsigned long *)NULL));
!     } else if (args) {
! 	return(args->name);
!     } else {
! 	return((char *)"SomethingErrorOccured");
!     }
  }

*** /tmp/,RCSt1004983	Mon Dec  2 16:45:23 1991
--- mit/lib/X/Xsi/XIMKeyBind.c	Mon Dec  2 16:45:36 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: XIMKeyBind.c,v 1.20 91/07/23 12:00:27 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XIMKeyBind.c,v 1.21 91/12/02 16:42:44 rws Exp $
   */
  
  /*
***************
*** 71,76 ****
--- 71,77 ----
  #ifdef macII
  		ret_len = 0;
  #else
+ 		mbuf[ret_len] = '\0';
  		ret_len = mbstowcs(buffer, mbuf, nchars);
  #endif
  		if (ret_len == nchars)
***************
*** 112,117 ****
--- 113,119 ----
  #ifdef macII
  	    ret_len = 0;
  #else
+ 	    buf[ret_len] = '\0';
  	    ret_len = mbstowcs(buffer, (char *)buf, nchars);
  #endif
  #endif

*** /tmp/,RCSt1005270	Mon Dec  2 17:30:36 1991
--- mit/lib/X/Xsi/XICGetVal.c	Mon Dec  2 17:31:11 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: XICGetVal.c,v 1.15 91/05/07 19:25:42 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XICGetVal.c,v 1.16 91/12/02 17:29:37 rws Exp $
   */
  
  /*
***************
*** 56,64 ****
--- 56,69 ----
      register int		i;
      register XrmName		Name;
      register XIMrmResourceList	xrmres;
+     XPointer 			*location;
      register unsigned int	num_resources = im->core.ic_num_attr_resources;
      XrmQuark			spot_name =
  				    XrmPermStringToQuark(XNSpotLocation);
+     XrmQuark			area_needed_name =
+ 				    XrmPermStringToQuark(XNAreaNeeded);
+     XrmQuark			area_name =
+ 				    XrmPermStringToQuark(XNArea);
  
      for (arg = args; arg && arg->name && *(arg->name) ; arg++) {
  	Name = XrmStringToName(arg->name);
***************
*** 69,87 ****
  		    return(arg->name);
  		}
  		if (!mask_only) {
! 		    /*
! 		     * Size of XPoint is not bigger than XPointer, so
! 		     * could not call CopyFromArg();
! 		     */
! 		    if (Name == spot_name) {
! 		       XPoint *p = (XPoint*)arg->value;
! 		       p->x = attr->spot_location.x;
! 		       p->y = attr->spot_location.y;
  		    } else {
! 			(void)_XCopyToArg((char *)attr - xrmres->xrm_offset - 1,
! 					   &arg->value,
! 					   (unsigned int)xrmres->xrm_size);
  		    }
  		}
  		if (xrmres->mask >= 0) {
  		    *mask |= (1L << (xrmres->mask + offset));
--- 74,89 ----
  		    return(arg->name);
  		}
  		if (!mask_only) {
! 		    if (Name == area_needed_name || Name == area_name ||
! 						    Name == spot_name) {
! 			location = (XPointer*)arg->value;
! 			*location = (XPointer)Xmalloc(xrmres->xrm_size);
  		    } else {
! 			location = (XPointer *)&arg->value;
  		    }
+ 		    (void)_XCopyToArg((char *)attr - xrmres->xrm_offset - 1,
+ 				       location,
+ 				       (unsigned int)xrmres->xrm_size);
  		}
  		if (xrmres->mask >= 0) {
  		    *mask |= (1L << (xrmres->mask + offset));

*** /tmp/,RCSt1000969	Sun Nov 17 15:49:22 1991
--- mit/lib/X/Ximp/XimpIM.c	Sun Nov 17 15:37:02 1991
***************
*** 1,4 ****
! /* $XConsortium: XimpIM.c,v 1.4 91/10/07 17:48:51 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: XimpIM.c,v 1.5 91/11/17 15:36:42 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by FUJITSU LIMITED
***************
*** 56,62 ****
  				_Ximp_CreateIC, 	/* create_ic */
  				};
  
! static char	*strstr( src, dest )
  register char	*src, *dest;
  {
      register	len;
--- 56,62 ----
  				_Ximp_CreateIC, 	/* create_ic */
  				};
  
! static char	*Strstr( src, dest )
  register char	*src, *dest;
  {
      register	len;
***************
*** 218,224 ****
   
   		(void)strcpy(IMname, _XIMP_BASE);
   		(void)strcat(IMname, LCname);
!  		mod = strstr(lcd->core.modifiers, MODIFIER);
   		if (mod) {
   			(void)strcat(IMname, "@");
   			mod += strlen(MODIFIER);
--- 218,224 ----
   
   		(void)strcpy(IMname, _XIMP_BASE);
   		(void)strcat(IMname, LCname);
!  		mod = Strstr(lcd->core.modifiers, MODIFIER);
   		if (mod) {
   			(void)strcat(IMname, "@");
   			mod += strlen(MODIFIER);

*** /tmp/,RCSt1014702	Wed Dec 11 11:07:47 1991
--- mit/lib/nls/Xsi/local_im_tbl/lt_LN.bit7	Wed Dec 11 11:02:17 1991
***************
*** 1,3 ****
--- 1,18 ----
+ # $XConsortium: lt_LN.bit7,v 1.3 91/12/11 11:01:15 rws Exp $
+ #
+ #	Conversion file for Local Input Method
+ #
+ # The format of this file follows.
+ #
+ #	<from>[<from>...]	[<to>[<to>...]]	[{to_string}[{to_string}...]
+ #  or
+ #	<from>[<from>...]	Command
+ #
+ #  from : Input keysym
+ #  to_keysym : Output keysym
+ #  to_string : Output string
+ #  Command : Special commad (NoFilter/ConvertOn/ConvertOff)
+ 
  <Shift_L>			NoFilter
  <Shift_R>			NoFilter
  <Control_L>			NoFilter
***************
*** 14,119 ****
  <Hyper_R>			NoFilter
  <Execute>			ConvertOn
  <Execute>			ConvertOff
! # <backslash>NBSP		<nobreakspace>
! <backslash><exclam>:		<exclamdown>
! # <backslash>cen		<cent>       	
! # <backslash>pou		<sterling>
! # <backslash>cur		<currency>
! # <backslash>yen		<yen>
! <backslash><bar>:		<brokenbar>
! # <backslash>sec		<section>
! <backslash><quotedbl>:		<diaeresis>
! <backslash><C>:			<copyright>
! ##<backslash><a>:			<ordfeminine>
! <backslash><less>:		<guillemotleft>
! # <backslash>not		<notsign>
! # <backslash>shy		<hyphen>
! <backslash><R>:			<registered>
! # <backslash>mac		<macron>
  
! # <backslash>deg		<degree>
! <backslash><plus><minus>:	<plusminus>
! <backslash><2>:			<twosuperior>
! <backslash><3>:			<threesuperior>
! <backslash><apostrophe>:		<acute>
! <backslash><u>:			<mu>
! ##<backslash><P>:			<paragraph>
! <backslash><period>:		<periodcentered>
! ##<backslash><S>:			<cedilla>
! <backslash><1>:			<onesuperior>
! ##<backslash><o>:			<masculine>
! <backslash><greater>:		<guillemotright>
! ##<backslash><1><slash><4>:	<onequarter>
! ##<backslash><1><slash><2>:	<onehalf>
! ##<backslash><3><slash><4>:	<threequarters>
! <backslash><question>:		<questiondown>
  
! <grave><A>:			<Agrave>
! <apostrophe><A>:		<Aacute>
! <asciicircum><A>:		<Acircumflex>
! <asciitilde><A>:		<Atilde>
! <quotedbl><A>:			<Adiaeresis>
! <backslash><o><A>:		<Aring>
! <backslash><A><E>:		<AE>
! <backslash><S><C>:		<Ccedilla>
! <grave><E>:			<Egrave>
! <apostrophe><E>:		<Eacute>
! <asciicircum><E>:		<Ecircumflex>
! <quotedbl><E>:			<Ediaeresis>
! <grave><I>:			<Igrave>
! <apostrophe><I>:		<Iacute>
! <asciicircum><I>:		<Icircumflex>
! <quotedbl><I>:			<Idiaeresis>
! <backslash><D>:			<Eth>                
! <asciitilde><N>:		<Ntilde>             
! <grave><O>:			<Ograve>             
! <apostrophe><O>:		<Oacute>             
! <asciicircum><O>:		<Ocircumflex>        
! <asciitilde><O>:		<Otilde>             
! <quotedbl><O>:			<Odiaeresis>         
! <backslash><X>:			<multiply>           
! <backslash><O><slash>:		<Ooblique>           
! <grave><U>:			<Ugrave>             
! <apostrophe><U>:		<Uacute>             
! <asciicircum><U>:		<Ucircumflex>        
! <quotedbl><U>:			<Udiaeresis>         
! <apostrophe><Y>:		<Yacute>             
! <backslash><P>:			<Thorn>              
! <backslash><s><s>:		<ssharp>             
  
! <grave><a>:			<agrave>             
! <apostrophe><a>:		<aacute>             
! <asciicircum><a>:		<acircumflex>        
! <asciitilde><a>:		<atilde>             
! <quotedbl><a>:			<adiaeresis>         
! <backslash><o><a>:		<aring>              
! <backslash><a><e>:		<ae>                 
! <backslash><s><c>:		<ccedilla>           
! <grave><e>:			<egrave>             
! <apostrophe><e>:		<eacute>             
! <asciicircum><e>:		<ecircumflex>        
! <quotedbl><e>:			<ediaeresis>         
! <grave><i>:			<igrave>             
! <apostrophe><i>:		<iacute>             
! <asciicircum><i>:		<icircumflex>        
! <quotedbl><i>:			<idiaeresis>         
  
! <backslash><d>:			<eth>                
! <asciitilde><n>:		<ntilde>             
! <grave><o>:			<ograve>             
! <apostrophe><o>:		<oacute>             
! <asciicircum><o>:		<ocircumflex>        
! <asciitilde><o>:		<otilde>             
! <quotedbl><o>:			<odiaeresis>         
! <backslash><slash>:		<division>           
! <backslash><o><slash>:		<oslash>             
! <grave><u>:			<ugrave>             
! <apostrophe><u>:		<uacute>             
! <asciicircum><u>:		<ucircumflex>        
! <quotedbl><u>:			<udiaeresis>         
! <apostrophe><y>:		<yacute>             
! <backslash><p>:			<thorn>             
! <quotedbl><y>:			<ydiaeresis>         
  
  # BackSpace		
  # Clear		
--- 29,136 ----
  <Hyper_R>			NoFilter
  <Execute>			ConvertOn
  <Execute>			ConvertOff
! <backslash><backslash>		<backslash>	{\E-A\x5c}
! <backslash><space>		<nobreakspace>	{\E-A\xa0}
! <backslash><exclam>		<exclamdown>	{\E-A\xa1}
! <backslash><Mod1><C>		<cent>       	{\E-A\xa2}
! <backslash><Mod1><p>		<sterling>	{\E-A\xa3}
! <backslash><Mod1><c>		<currency>	{\E-A\xa4}
! <backslash><Mod1><y>		<yen>		{\E-A\xa5}
! <backslash><Mod1><b>		<brokenbar>	{\E-A\xa6}
! <backslash><Mod1><s>		<section>	{\E-A\xa7}
! <backslash><quotedbl>		<diaeresis>	{\E-A\xa8}
! <backslash><Mod1><r>		<copyright>	{\E-A\xa9}
! <backslash><Mod1><a>		<ordfeminine>	{\E-A\xaa}
! <backslash><less>		<guillemotleft>	{\E-A\xab}
! <backslash><Mod1><n>		<notsign>	{\E-A\xac}
! <backslash><Mod1><h>		<hyphen>	{\E-A\xad}
! <backslash><Mod1><R>		<registered>	{\E-A\xae}
! <backslash><Mod1><m>		<macron>	{\E-A\xaf}
  
! <backslash><Mod1><d>		<degree>	{\E-A\xb0}
! <backslash><plus><minus>	<plusminus>	{\E-A\xb1}
! <backslash><Mod1><2>		<twosuperior>	{\E-A\xb2}
! <backslash><Mod1><3>		<threesuperior> {\E-A\xb3}
! <backslash><apostrophe>		<acute>		{\E-A\xb4}
! <backslash><Mod1><u>		<mu>		{\E-A\xb5}
! <backslash><Mod1><P>		<paragraph>	{\E-A\xb6}
! <backslash><period>		<periodcentered>	{\E-A\xb7}
! <backslash><Mod1><S>		<cedilla>	{\E-A\xb8}
! <backslash><Mod1><1>		<onesuperior>	{\E-A\xb9}
! <backslash><Mod1><o>		<masculine>	{\E-A\xba}
! <backslash><greater>		<guillemotright>	{\E-A\xbb}
! <backslash><1><slash><4>	<onequarter>	{\E-A\xbc}
! <backslash><1><slash><2>	<onehalf>	{\E-A\xbd}
! <backslash><3><slash><4>	<threequarters>	{\E-A\xbe}
! <backslash><question>		<questiondown>	{\E-A\xbf}
  
! <grave><A>			<Agrave>	{\E-A\xc0}
! <apostrophe><A>			<Aacute>	{\E-A\xc1}
! <asciicircum><A>		<Acircumflex>	{\E-A\xc2}
! <asciitilde><A>			<Atilde>	{\E-A\xc3}
! <quotedbl><A>			<Adiaeresis>	{\E-A\xc4}
! <backslash><o><A>		<Aring>		{\E-A\xc5}
! <backslash><A><E>		<AE>		{\E-A\xc6}
! <backslash><S><C>		<Ccedilla>	{\E-A\xc7}
! <grave><E>			<Egrave>	{\E-A\xc8}
! <apostrophe><E>			<Eacute>	{\E-A\xc9}
! <asciicircum><E>		<Ecircumflex>	{\E-A\xca}
! <quotedbl><E>			<Ediaeresis>	{\E-A\xcb}
! <grave><I>			<Igrave>	{\E-A\xcc}
! <apostrophe><I>			<Iacute>	{\E-A\xcd}
! <asciicircum><I>		<Icircumflex>	{\E-A\xce}
! <quotedbl><I>			<Idiaeresis>	{\E-A\xcf}
  
! <backslash><D>			<Eth>		{\E-A\xd0}
! <asciitilde><N>			<Ntilde>	{\E-A\xd1}
! <grave><O>			<Ograve>	{\E-A\xd2}
! <apostrophe><O>			<Oacute>	{\E-A\xd3}
! <asciicircum><O>		<Ocircumflex>	{\E-A\xd4}
! <asciitilde><O>			<Otilde>	{\E-A\xd5}
! <quotedbl><O>			<Odiaeresis>	{\E-A\xd6}
! <backslash><X>			<multiply>	{\E-A\xd7}
! <backslash><O><slash>		<Ooblique>	{\E-A\xd8}
! <grave><U>			<Ugrave>	{\E-A\xd9}
! <apostrophe><U>			<Uacute>	{\E-A\xda}
! <asciicircum><U>		<Ucircumflex>	{\E-A\xdb}
! <quotedbl><U>			<Udiaeresis>	{\E-A\xdc}
! <apostrophe><Y>			<Yacute>	{\E-A\xdd}
! <backslash><P>			<Thorn>		{\E-A\xde}
! <backslash><s><s>		<ssharp>	{\E-A\xdf}
  
! <grave><a>			<agrave>	{\E-A\xe0}
! <apostrophe><a>			<aacute>	{\E-A\xe1}
! <asciicircum><a>		<acircumflex>	{\E-A\xe2}
! <asciitilde><a>			<atilde>	{\E-A\xe3}
! <quotedbl><a>			<adiaeresis>	{\E-A\xe4}
! <backslash><o><a>		<aring>		{\E-A\xe5}
! <backslash><a><e>		<ae>		{\E-A\xe6}
! <backslash><s><c>		<ccedilla>	{\E-A\xe7}
! <grave><e>			<egrave>	{\E-A\xe8}
! <apostrophe><e>			<eacute>	{\E-A\xe9}
! <asciicircum><e>		<ecircumflex>	{\E-A\xea}
! <quotedbl><e>			<ediaeresis>	{\E-A\xeb}
! <grave><i>			<igrave>	{\E-A\xec}
! <apostrophe><i>			<iacute>	{\E-A\xed}
! <asciicircum><i>		<icircumflex>	{\E-A\xee}
! <quotedbl><i>			<idiaeresis>	{\E-A\xef}
! 
! <backslash><d>			<eth>		{\E-A\xf0}
! <asciitilde><n>			<ntilde>	{\E-A\xf1}
! <grave><o>			<ograve>	{\E-A\xf2}
! <apostrophe><o>			<oacute>	{\E-A\xf3}
! <asciicircum><o>		<ocircumflex>	{\E-A\xf4}
! <asciitilde><o>			<otilde>	{\E-A\xf5}
! <quotedbl><o>			<odiaeresis>	{\E-A\xf6}
! <backslash><slash>		<division>	{\E-A\xf7}
! <backslash><o><slash>		<oslash>	{\E-A\xf8}
! <grave><u>			<ugrave>	{\E-A\xf9}
! <apostrophe><u>			<uacute>	{\E-A\xfa}
! <asciicircum><u>		<ucircumflex>	{\E-A\xfb}
! <quotedbl><u>			<udiaeresis>	{\E-A\xfc}
! <apostrophe><y>			<yacute>	{\E-A\xfd}
! <backslash><p>			<thorn>		{\E-A\xfe}
! <quotedbl><y>			<ydiaeresis>	{\E-A\xff}
  
  # BackSpace		
  # Clear		

*** /tmp/,RCSt1014702	Wed Dec 11 11:07:50 1991
--- mit/lib/nls/Xsi/local_im_tbl/lt_LN.bit8	Wed Dec 11 11:02:20 1991
***************
*** 1,3 ****
--- 1,18 ----
+ # $XConsortium: lt_LN.bit8,v 1.3 91/12/11 11:01:22 rws Exp $
+ #
+ #	Conversion file for Local Input Method
+ #
+ # The format of this file follows.
+ #
+ #	<from>[<from>...]	[<to>[<to>...]]	[{to_string}[{to_string}...]
+ #  or
+ #	<from>[<from>...]	Command
+ #
+ #  from : Input keysym
+ #  to_keysym : Output keysym
+ #  to_string : Output string
+ #  Command : Special commad (NoFilter/ConvertOn/ConvertOff)
+ 
  <Shift_L>			NoFilter
  <Shift_R>			NoFilter
  <Control_L>			NoFilter
***************
*** 14,119 ****
  <Hyper_R>			NoFilter
  <Execute>			ConvertOn
  <Execute>			ConvertOff
! # <backslash>NBSP		<nobreakspace>
! <backslash><exclam>:		<exclamdown>
! # <backslash>cen		<cent>       	
! # <backslash>pou		<sterling>
! # <backslash>cur		<currency>
! # <backslash>yen		<yen>
! <backslash><bar>:		<brokenbar>
! # <backslash>sec		<section>
! <backslash><quotedbl>:		<diaeresis>
! <backslash><C>:			<copyright>
! ##<backslash><a>:			<ordfeminine>
! <backslash><less>:		<guillemotleft>
! # <backslash>not		<notsign>
! # <backslash>shy		<hyphen>
! <backslash><R>:			<registered>
! # <backslash>mac		<macron>
  
! # <backslash>deg		<degree>
! <backslash><plus><minus>:	<plusminus>
! <backslash><2>:			<twosuperior>
! <backslash><3>:			<threesuperior>
! <backslash><apostrophe>:		<acute>
! <backslash><u>:			<mu>
! ##<backslash><P>:			<paragraph>
! <backslash><period>:		<periodcentered>
! ##<backslash><S>:			<cedilla>
! <backslash><1>:			<onesuperior>
! ##<backslash><o>:			<masculine>
! <backslash><greater>:		<guillemotright>
! ##<backslash><1><slash><4>:	<onequarter>
! ##<backslash><1><slash><2>:	<onehalf>
! ##<backslash><3><slash><4>:	<threequarters>
! <backslash><question>:		<questiondown>
  
! <grave><A>:			<Agrave>
! <apostrophe><A>:		<Aacute>
! <asciicircum><A>:		<Acircumflex>
! <asciitilde><A>:		<Atilde>
! <quotedbl><A>:			<Adiaeresis>
! <backslash><o><A>:		<Aring>
! <backslash><A><E>:		<AE>
! <backslash><S><C>:		<Ccedilla>
! <grave><E>:			<Egrave>
! <apostrophe><E>:		<Eacute>
! <asciicircum><E>:		<Ecircumflex>
! <quotedbl><E>:			<Ediaeresis>
! <grave><I>:			<Igrave>
! <apostrophe><I>:		<Iacute>
! <asciicircum><I>:		<Icircumflex>
! <quotedbl><I>:			<Idiaeresis>
! <backslash><D>:			<Eth>                
! <asciitilde><N>:		<Ntilde>             
! <grave><O>:			<Ograve>             
! <apostrophe><O>:		<Oacute>             
! <asciicircum><O>:		<Ocircumflex>        
! <asciitilde><O>:		<Otilde>             
! <quotedbl><O>:			<Odiaeresis>         
! <backslash><X>:			<multiply>           
! <backslash><O><slash>:		<Ooblique>           
! <grave><U>:			<Ugrave>             
! <apostrophe><U>:		<Uacute>             
! <asciicircum><U>:		<Ucircumflex>        
! <quotedbl><U>:			<Udiaeresis>         
! <apostrophe><Y>:		<Yacute>             
! <backslash><P>:			<Thorn>              
! <backslash><s><s>:		<ssharp>             
  
! <grave><a>:			<agrave>             
! <apostrophe><a>:		<aacute>             
! <asciicircum><a>:		<acircumflex>        
! <asciitilde><a>:		<atilde>             
! <quotedbl><a>:			<adiaeresis>         
! <backslash><o><a>:		<aring>              
! <backslash><a><e>:		<ae>                 
! <backslash><s><c>:		<ccedilla>           
! <grave><e>:			<egrave>             
! <apostrophe><e>:		<eacute>             
! <asciicircum><e>:		<ecircumflex>        
! <quotedbl><e>:			<ediaeresis>         
! <grave><i>:			<igrave>             
! <apostrophe><i>:		<iacute>             
! <asciicircum><i>:		<icircumflex>        
! <quotedbl><i>:			<idiaeresis>         
  
! <backslash><d>:			<eth>                
! <asciitilde><n>:		<ntilde>             
! <grave><o>:			<ograve>             
! <apostrophe><o>:		<oacute>             
! <asciicircum><o>:		<ocircumflex>        
! <asciitilde><o>:		<otilde>             
! <quotedbl><o>:			<odiaeresis>         
! <backslash><slash>:		<division>           
! <backslash><o><slash>:		<oslash>             
! <grave><u>:			<ugrave>             
! <apostrophe><u>:		<uacute>             
! <asciicircum><u>:		<ucircumflex>        
! <quotedbl><u>:			<udiaeresis>         
! <apostrophe><y>:		<yacute>             
! <backslash><p>:			<thorn>             
! <quotedbl><y>:			<ydiaeresis>         
  
  # BackSpace		
  # Clear		
--- 29,136 ----
  <Hyper_R>			NoFilter
  <Execute>			ConvertOn
  <Execute>			ConvertOff
! <backslash><backslash>		<backslash>	{\x5c}
! <backslash><space>		<nobreakspace>	{\xa0}
! <backslash><exclam>		<exclamdown>	{\xa1}
! <backslash><Mod1><C>		<cent>       	{\xa2}
! <backslash><Mod1><p>		<sterling>	{\xa3}
! <backslash><Mod1><c>		<currency>	{\xa4}
! <backslash><Mod1><y>		<yen>		{\xa5}
! <backslash><Mod1><b>		<brokenbar>	{\xa6}
! <backslash><Mod1><s>		<section>	{\xa7}
! <backslash><quotedbl>		<diaeresis>	{\xa8}
! <backslash><Mod1><r>		<copyright>	{\xa9}
! <backslash><Mod1><a>		<ordfeminine>	{\xaa}
! <backslash><less>		<guillemotleft>	{\xab}
! <backslash><Mod1><n>		<notsign>	{\xac}
! <backslash><Mod1><h>		<hyphen>	{\xad}
! <backslash><Mod1><R>		<registered>	{\xae}
! <backslash><Mod1><m>		<macron>	{\xaf}
  
! <backslash><Mod1><d>		<degree>	{\xb0}
! <backslash><plus><minus>	<plusminus>	{\xb1}
! <backslash><Mod1><2>		<twosuperior>	{\xb2}
! <backslash><Mod1><3>		<threesuperior> {\xb3}
! <backslash><apostrophe>		<acute>		{\xb4}
! <backslash><Mod1><u>		<mu>		{\xb5}
! <backslash><Mod1><P>		<paragraph>	{\xb6}
! <backslash><period>		<periodcentered>	{\xb7}
! <backslash><Mod1><S>		<cedilla>	{\xb8}
! <backslash><Mod1><1>		<onesuperior>	{\xb9}
! <backslash><Mod1><o>		<masculine>	{\xba}
! <backslash><greater>		<guillemotright>	{\xbb}
! <backslash><1><slash><4>	<onequarter>	{\xbc}
! <backslash><1><slash><2>	<onehalf>	{\xbd}
! <backslash><3><slash><4>	<threequarters>	{\xbe}
! <backslash><question>		<questiondown>	{\xbf}
  
! <grave><A>			<Agrave>	{\xc0}
! <apostrophe><A>			<Aacute>	{\xc1}
! <asciicircum><A>		<Acircumflex>	{\xc2}
! <asciitilde><A>			<Atilde>	{\xc3}
! <quotedbl><A>			<Adiaeresis>	{\xc4}
! <backslash><o><A>		<Aring>		{\xc5}
! <backslash><A><E>		<AE>		{\xc6}
! <backslash><S><C>		<Ccedilla>	{\xc7}
! <grave><E>			<Egrave>	{\xc8}
! <apostrophe><E>			<Eacute>	{\xc9}
! <asciicircum><E>		<Ecircumflex>	{\xca}
! <quotedbl><E>			<Ediaeresis>	{\xcb}
! <grave><I>			<Igrave>	{\xcc}
! <apostrophe><I>			<Iacute>	{\xcd}
! <asciicircum><I>		<Icircumflex>	{\xce}
! <quotedbl><I>			<Idiaeresis>	{\xcf}
  
! <backslash><D>			<Eth>		{\xd0}
! <asciitilde><N>			<Ntilde>	{\xd1}
! <grave><O>			<Ograve>	{\xd2}
! <apostrophe><O>			<Oacute>	{\xd3}
! <asciicircum><O>		<Ocircumflex>	{\xd4}
! <asciitilde><O>			<Otilde>	{\xd5}
! <quotedbl><O>			<Odiaeresis>	{\xd6}
! <backslash><X>			<multiply>	{\xd7}
! <backslash><O><slash>		<Ooblique>	{\xd8}
! <grave><U>			<Ugrave>	{\xd9}
! <apostrophe><U>			<Uacute>	{\xda}
! <asciicircum><U>		<Ucircumflex>	{\xdb}
! <quotedbl><U>			<Udiaeresis>	{\xdc}
! <apostrophe><Y>			<Yacute>	{\xdd}
! <backslash><P>			<Thorn>		{\xde}
! <backslash><s><s>		<ssharp>	{\xdf}
  
! <grave><a>			<agrave>	{\xe0}
! <apostrophe><a>			<aacute>	{\xe1}
! <asciicircum><a>		<acircumflex>	{\xe2}
! <asciitilde><a>			<atilde>	{\xe3}
! <quotedbl><a>			<adiaeresis>	{\xe4}
! <backslash><o><a>		<aring>		{\xe5}
! <backslash><a><e>		<ae>		{\xe6}
! <backslash><s><c>		<ccedilla>	{\xe7}
! <grave><e>			<egrave>	{\xe8}
! <apostrophe><e>			<eacute>	{\xe9}
! <asciicircum><e>		<ecircumflex>	{\xea}
! <quotedbl><e>			<ediaeresis>	{\xeb}
! <grave><i>			<igrave>	{\xec}
! <apostrophe><i>			<iacute>	{\xed}
! <asciicircum><i>		<icircumflex>	{\xee}
! <quotedbl><i>			<idiaeresis>	{\xef}
! 
! <backslash><d>			<eth>		{\xf0}
! <asciitilde><n>			<ntilde>	{\xf1}
! <grave><o>			<ograve>	{\xf2}
! <apostrophe><o>			<oacute>	{\xf3}
! <asciicircum><o>		<ocircumflex>	{\xf4}
! <asciitilde><o>			<otilde>	{\xf5}
! <quotedbl><o>			<odiaeresis>	{\xf6}
! <backslash><slash>		<division>	{\xf7}
! <backslash><o><slash>		<oslash>	{\xf8}
! <grave><u>			<ugrave>	{\xf9}
! <apostrophe><u>			<uacute>	{\xfa}
! <asciicircum><u>		<ucircumflex>	{\xfb}
! <quotedbl><u>			<udiaeresis>	{\xfc}
! <apostrophe><y>			<yacute>	{\xfd}
! <backslash><p>			<thorn>		{\xfe}
! <quotedbl><y>			<ydiaeresis>	{\xff}
  
  # BackSpace		
  # Clear		

*** /dev/null	Wed Dec 11 16:03:33 1991
--- mit/doc/I18N/Xsi/Xim/LocalIM.man	Wed Dec 11 15:58:48 1991
***************
*** 0 ****
--- 1,85 ----
+ .\" $XConsortium: LocalIM.man,v 1.3 91/12/11 15:57:44 rws Exp $
+ .\" Copyright 1991 by OMRON Corp.  All Rights Reserved.
+ .TH LocalIM 3X11 "Release 5" "X Version 11" "XSI FUNCTIONS"
+ .SH NAME
+ LocalIM \- Conversion table of Local Input Method
+ .SH DESCRIPTION
+ .PP
+ Converts keysyms to some keysym and strings.
+ .PP
+ If the modifier @im is defined "\fILocal\fP", this table is loaded
+ by the input method.
+ .PP
+ .B Coding format:
+ .sp
+ .RS
+ <from>[<from>...]  [<to>[<to>...]]  [{str}[{str}...]
+ .br
+ or
+ .br
+ <from>[<from>...]  Command
+ .sp
+ .RE
+ .IP \fBfrom\fP 1i
+ Specifies a input keysym name which is enclosed with '<' and '>'.
+ .IP \fBto\fP 1i
+ Specifies a output keysym name which is enclosed with '<' and '>'.
+ .IP \fBstr\fP 1i
+ Specifies output string name which is enclosed with '{' and '}'.
+ the number of \fIstr\fP must equal to the number of \fIto.\fP
+ .IP \fBCommand\fP 1i
+ Specifies which command (NoFilter/ConvertOn/ConvertOff).
+ .br
+ .sp
+ .RS
+ .IP NoFilter 1i
+ The input keysym(s) (from) is(are) not filtered by the input method.
+ .IP ConvertOn 1i
+ If the input keysym(s) (from) is(are) pressed, the input method
+ move in a conversion \fBon\fP state.
+ .IP ConvertOn 1i
+ If the input keysym(s) (from) is(are) pressed, the input method
+ move in a conversion \fBoff\fP state.
+ .sp
+ .RE
+ .PP
+ It is possible to omit \fIto\fP or \fIstr\fP. But either must be set.
+ .PP
+ .B Code notation of str:
+ .sp
+ .RS
+ \\n	--> NewLine
+ .br
+ \\t	--> Tab
+ .br
+ \\b	--> BackSpace
+ .br
+ \\r	--> CarriageReturn
+ .br
+ \\f	--> FormFeed
+ .br
+ \\e or \\E	--> Escape
+ .br
+ \\\\	--> BackSlash
+ .br
+ \\??? or \\o???	--> Octal
+ .br
+ \\x??	--> Hexadecimal
+ .br
+ other	--> raw code
+ .sp
+ .RE
+ .SH EXAMPLE
+ .sp
+ .RS
+ <Meta_L>                NoFilter
+ .br
+ <Execute>               ConvertOn
+ .br
+ <Execute>               ConvertOff
+ .br
+ <backslash><Mod1><C>    <cent>          {\\E-A\\xa2}
+ .br
+ <grave><A>              <Agrave>        {\\E-A\\xc0}
+ .sp
+ .RE

*** /tmp/,RCSt1a03751	Thu Nov 21 15:17:45 1991
--- mit/lib/Xt/Callback.c	Thu Nov 21 14:38:34 1991
***************
*** 1,4 ****
! /* $XConsortium: Callback.c,v 1.34 91/10/30 14:16:58 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Callback.c,v 1.35 91/11/21 14:36:30 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 432,437 ****
--- 432,438 ----
      icl->is_padded = 1;
      cl->callback = (XtCallbackProc) NULL;
      cl->closure = NULL;
+     *callbacks = icl;
      return ToList(icl);
  }
  

*** /tmp/,RCSt1a08085	Tue Nov 26 14:06:56 1991
--- mit/lib/Xt/Convert.c	Tue Nov 26 13:55:51 1991
***************
*** 1,4 ****
! /* $XConsortium: Convert.c,v 1.62 91/06/17 11:46:17 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Convert.c,v 1.63 91/11/26 13:54:29 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 598,605 ****
  		while (i) {
  		    i--; /* do not move to while test, broken compilers */
  		    if (pargs[i].size != args[i].size ||
! 			XtBCmp(pargs[i].addr, args[i].addr, args[i].size))
  			break;
  		}
  	    }
  	    if (!i) {
--- 598,607 ----
  		while (i) {
  		    i--; /* do not move to while test, broken compilers */
  		    if (pargs[i].size != args[i].size ||
! 			XtBCmp(pargs[i].addr, args[i].addr, args[i].size)) {
! 			i++;
  			break;
+ 		    }
  		}
  	    }
  	    if (!i) {
***************
*** 686,693 ****
  		    while (i) {
  			i--; /* do not move to while test, broken compilers */
  			if (pargs[i].size != args[i].size ||
! 			    XtBCmp(pargs[i].addr, args[i].addr, args[i].size))
  			    break;
  		    }
  		}
  		if (!i) {
--- 688,697 ----
  		    while (i) {
  			i--; /* do not move to while test, broken compilers */
  			if (pargs[i].size != args[i].size ||
! 			    XtBCmp(pargs[i].addr, args[i].addr, args[i].size)){
! 			    i++;
  			    break;
+ 			}
  		    }
  		}
  		if (!i) {

*** /tmp/,RCSt1a02291	Tue Dec  3 18:02:25 1991
--- mit/lib/Xt/TMstate.c	Tue Dec  3 16:35:04 1991
***************
*** 1,4 ****
! /* $XConsortium: TMstate.c,v 1.158 91/08/21 11:04:40 converse Exp $ */
  /*LINTLIBRARY*/
  
  /***********************************************************
--- 1,4 ----
! /* $XConsortium: TMstate.c,v 1.159 91/12/03 16:33:34 converse Exp $ */
  /*LINTLIBRARY*/
  
  /***********************************************************
***************
*** 1962,1968 ****
      TMComplexBindData	cBindData = (TMComplexBindData) tmRecPtr->proc_table;
      XtTranslations	xlations = tmRecPtr->translations;
  
!     if (!xlations || !cBindData->isComplex)
  	return xlations;
  
      /* Walk the list looking to see if we already have generated a
--- 1962,1968 ----
      TMComplexBindData	cBindData = (TMComplexBindData) tmRecPtr->proc_table;
      XtTranslations	xlations = tmRecPtr->translations;
  
!     if (!xlations || !cBindData || !cBindData->isComplex)
  	return xlations;
  
      /* Walk the list looking to see if we already have generated a

*** /tmp/,RCSt1a05180	Fri Dec  6 17:45:19 1991
--- mit/lib/Xt/Error.c	Fri Nov  8 15:38:54 1991
***************
*** 1,4 ****
! /* $XConsortium: Error.c,v 1.32 91/04/12 11:37:18 rws Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Error.c,v 1.33 91/11/09 15:38:01 keith Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 329,337 ****
--- 329,343 ----
  #endif /* GLOBALERRORS */
  }
  
+ #if NeedFunctionPrototypes
+ XtErrorMsgHandler XtAppSetErrorMsgHandler(
+     XtAppContext app,
+     XtErrorMsgHandler handler)
+ #else
  XtErrorMsgHandler XtAppSetErrorMsgHandler(app,handler)
      XtAppContext app;
      XtErrorMsgHandler handler;
+ #endif
  {
      XtErrorMsgHandler old;
  #if GLOBALERRORS
***************
*** 357,365 ****
--- 363,377 ----
  #endif /* GLOBALERRORS */
  }
  
+ #if NeedFunctionPrototypes
+ XtErrorMsgHandler XtAppSetWarningMsgHandler(
+     XtAppContext app,
+     XtErrorMsgHandler handler)
+ #else
  XtErrorMsgHandler XtAppSetWarningMsgHandler(app,handler)
      XtAppContext app;
      XtErrorMsgHandler handler;
+ #endif
  {
      XtErrorMsgHandler old;
  #if GLOBALERRORS
***************
*** 459,466 ****
--- 471,482 ----
  #endif /* GLOBALERRORS */
  }
  
+ #if NeedFunctionPrototypes
+ void XtSetErrorHandler(XtErrorHandler handler)
+ #else
  void XtSetErrorHandler(handler)
      XtErrorHandler handler;
+ #endif
  {
  #if GLOBALERRORS
      if (handler != NULL) errorHandler = handler;
***************
*** 470,478 ****
--- 486,500 ----
  #endif /* GLOBALERRORS */
  }
  
+ #if NeedFunctionPrototypes
+ XtErrorHandler XtAppSetErrorHandler(
+     XtAppContext app,
+     XtErrorHandler handler)
+ #else
  XtErrorHandler XtAppSetErrorHandler(app,handler)
      XtAppContext app;
      XtErrorHandler handler;
+ #endif
  {
      XtErrorHandler old;
  #if GLOBALERRORS
***************
*** 487,494 ****
--- 509,520 ----
      return old;
  }
  
+ #if NeedFunctionPrototypes
+ void XtSetWarningHandler(XtErrorHandler handler)
+ #else
  void XtSetWarningHandler(handler)
      XtErrorHandler handler;
+ #endif
  {
  #if GLOBALERRORS
      if (handler != NULL) warningHandler = handler;
***************
*** 498,506 ****
--- 524,538 ----
  #endif /* GLOBALERRORS */
  }
  
+ #if NeedFunctionPrototypes
+ XtErrorHandler XtAppSetWarningHandler(
+     XtAppContext app,
+     XtErrorHandler handler)
+ #else
  XtErrorHandler XtAppSetWarningHandler(app,handler)
      XtAppContext app;
      XtErrorHandler handler;
+ #endif
  {
      XtErrorHandler old;
  #if GLOBALERRORS

*** /tmp/,RCSt1a08260	Mon Dec  9 18:03:51 1991
--- mit/lib/Xt/Shell.c	Fri Dec  6 16:17:27 1991
***************
*** 1,4 ****
! /* $XConsortium: Shell.c,v 1.119 91/07/26 15:49:52 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Shell.c,v 1.120 91/12/06 16:16:40 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 116,121 ****
--- 116,122 ----
  static void Realize();
  static void Resize();
  static Boolean SetValues();
+ static void GetValuesHook();
  static void ChangeManaged(); /* XXX */
  static XtGeometryResult GeometryManager(), RootGeometryManager();
  static void Destroy();
***************
*** 154,160 ****
      /* set_values	  */	SetValues,
      /* set_values_hook	  */	NULL,			
      /* set_values_almost  */	XtInheritSetValuesAlmost,  
!     /* get_values_hook	  */	NULL,			
      /* accept_focus	  */	NULL,
      /* intrinsics version */	XtVersion,
      /* callback offsets	  */	NULL,
--- 155,161 ----
      /* set_values	  */	SetValues,
      /* set_values_hook	  */	NULL,			
      /* set_values_almost  */	XtInheritSetValuesAlmost,  
!     /* get_values_hook	  */	GetValuesHook,
      /* accept_focus	  */	NULL,
      /* intrinsics version */	XtVersion,
      /* callback offsets	  */	NULL,
***************
*** 2063,2068 ****
--- 2064,2095 ----
      *y = w->core.y;
  }
  
+ static void GetValuesHook(widget, args, num_args)
+     Widget	widget;
+     ArgList	args;
+     Cardinal*	num_args;
+ {
+     ShellWidget w = (ShellWidget) widget;
+     extern void _XtCopyToArg();
+ 
+     /* x and y resource values may be invalid after a shell resize */
+     if (! (w->shell.client_specified & _XtShellPositionValid)) {
+ 	Cardinal	n;
+ 	Position	x, y;
+ 
+ 	for (n = *num_args; n; n--, args++) {
+ 	    if (strcmp(XtNx, args->name) == 0) {
+ 		 if (! (w->shell.client_specified & _XtShellPositionValid))
+ 		     _XtShellGetCoordinates(widget, &x, &y);
+ 		_XtCopyToArg((char *) &x, &args->value, sizeof(Position));
+ 	    } else if (strcmp(XtNy, args->name) == 0) {
+ 		 if (! (w->shell.client_specified & _XtShellPositionValid))
+ 		     _XtShellGetCoordinates(widget, &x, &y);
+ 		_XtCopyToArg((char *) &y, &args->value, sizeof(Position));
+ 	    }
+ 	}
+     }
+ }
  
  static void ApplicationShellInsertChild(widget)
      Widget widget;

*** /tmp/,RCSt1a09253	Tue Dec 10 20:15:31 1991
--- mit/lib/Xt/VarCreate.c	Tue Dec 10 20:00:51 1991
***************
*** 1,4 ****
! /* $XConsortium: VarCreate.c,v 1.23 91/07/23 12:21:39 rws Exp $ */
  
  /*
  
--- 1,4 ----
! /* $XConsortium: VarCreate.c,v 1.24 91/12/10 18:57:25 converse Exp $ */
  
  /*
  
***************
*** 346,352 ****
      return(root);
  }
  
! #if !(defined(SUNSHLIB) && defined(SHAREDCODE))
  
  /*
   * If not used as a shared library, we still need a front end to 
--- 346,352 ----
      return(root);
  }
  
! #if !((defined(SUNSHLIB) || defined(AIXSHLIB)) && defined(SHAREDCODE))
  
  /*
   * If not used as a shared library, we still need a front end to 
***************
*** 386,390 ****
  			      fallback_resources, var);
  }
  
! #endif /* !(SUNSHLIB && SHAREDCODE) */
  
--- 386,390 ----
  			      fallback_resources, var);
  }
  
! #endif /* !((SUNSHLIB || AIXSHLIB) && SHAREDCODE) */
  

*** /tmp/,RCSt1a14303	Fri Dec  6 17:25:02 1991
--- mit/clients/editres/widgets.c	Fri Dec  6 17:19:36 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: widgets.c,v 1.18 91/07/09 09:46:52 rws Exp $
   *
   * Copyright 1989 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: widgets.c,v 1.19 91/12/06 17:20:00 dave Exp $
   *
   * Copyright 1989 Massachusetts Institute of Technology
   *
***************
*** 549,555 ****
  static void
  MakeBoxLookNice(dot, star, any, single, name, class, endbox)
  Widget dot, star, any, single, name, class;
! Boolean endbox;
  {
  
  #define MAX_HDIST 3
--- 549,555 ----
  static void
  MakeBoxLookNice(dot, star, any, single, name, class, endbox)
  Widget dot, star, any, single, name, class;
! int endbox;
  {
  
  #define MAX_HDIST 3




*** /tmp/,RCSt1004725	Mon Dec  2 16:07:40 1991
--- mit/clients/xinit/xinit.c	Fri Nov 29 15:21:31 1991
***************
*** 1,5 ****
  #ifndef lint
! static char *rcsid_xinit_c = "$XConsortium: xinit.c,v 11.51 91/07/20 10:41:04 rws Exp $";
  #endif /* lint */
  
  /* Copyright    Massachusetts Institute of Technology    1986	*/
--- 1,5 ----
  #ifndef lint
! static char *rcsid_xinit_c = "$XConsortium: xinit.c,v 11.52 91/11/29 15:20:35 rws Exp $";
  #endif /* lint */
  
  /* Copyright    Massachusetts Institute of Technology    1986	*/
***************
*** 49,55 ****
  #define vfork() fork()
  #endif /* SYSV and not hpux */
  
! #if defined(SVR4) || defined(sgi) || defined(_POSIX_SOURCE)
  #define setpgrp setpgid
  #endif
  
--- 49,55 ----
  #define vfork() fork()
  #endif /* SYSV and not hpux */
  
! #ifndef X_NOT_POSIX
  #define setpgrp setpgid
  #endif
  
***************
*** 499,505 ****
  	return (clientpid);
  }
  
! #if defined(SYSV) || defined(SVR4) || defined(_POSIX_SOURCE)
  #define killpg(pgrp, sig) kill(-(pgrp), sig)
  #endif
  
--- 499,505 ----
  	return (clientpid);
  }
  
! #if !defined(X_NOT_POSIX) || defined(SYSV)
  #define killpg(pgrp, sig) kill(-(pgrp), sig)
  #endif
  

*** /tmp/,RCSt1004733	Mon Dec  2 16:09:06 1991
--- mit/server/os/osinit.c	Fri Nov 29 15:22:04 1991
***************
*** 21,27 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: osinit.c,v 1.39 91/10/30 15:27:39 rws Exp $ */
  #include "X.h"
  #include "os.h"
  #include "osdep.h"
--- 21,27 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: osinit.c,v 1.40 91/11/29 15:21:07 rws Exp $ */
  #include "X.h"
  #include "os.h"
  #include "osdep.h"
***************
*** 95,101 ****
  	}
  
  #ifndef X_NOT_POSIX
! 	setsid();
  #else
  #ifndef SYSV
  	if (getpgrp (0) == 0)
--- 95,102 ----
  	}
  
  #ifndef X_NOT_POSIX
! 	if (getpgrp () == 0)
! 	    setpgid (0, 0);
  #else
  #ifndef SYSV
  	if (getpgrp (0) == 0)

*** /tmp/,RCSt1014604	Wed Dec 11 10:54:56 1991
--- mit/server/ddx/mi/miwideline.c	Wed Dec 11 10:54:58 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: miwideline.c,v 1.43 91/11/01 15:52:03 keith Exp $
   *
   * Copyright 1988 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: miwideline.c,v 1.45 91/11/20 15:33:19 keith Exp $
   *
   * Copyright 1988 Massachusetts Institute of Technology
   *
***************
*** 224,229 ****
--- 224,234 ----
  	ppt = spanRec.points;
  	pwidth = spanRec.widths;
  
+     	if (pGC->miTranslate)
+     	{
+ 	    y += pDrawable->y;
+ 	    x += pDrawable->x;
+     	}
  	while (h--)
  	{
  	    ppt->x = x;
***************
*** 2126,2146 ****
      {
  	/* not the same as endIsFg computation above */
  	pixel = (dashIndex & 1) ? pGC->bgPixel : pGC->fgPixel;
! 	projectLeft = pGC->capStyle == CapProjecting;
! 	miWideDashSegment (pDrawable, pGC, spanData, &dashOffset, &dashIndex,
! 			    x1, y1, x2, y2,
! 			    projectLeft, projectRight, &leftFace, &rightFace);
! 	if (pGC->capStyle == CapRound)
! 	{
  	    miLineArc (pDrawable, pGC, pixel, spanData,
! 		       &leftFace, (LineFacePtr) NULL,
! 		       (double)0.0, (double)0.0,
! 		       TRUE);
! 	    rightFace.dx = -1;	/* sleezy hack to make it work */
! 	    miLineArc (pDrawable, pGC, pixel, spanData,
! 		       (LineFacePtr) NULL, &rightFace,
!  		       (double)0.0, (double)0.0,
! 		       TRUE);
  	}
      }
      if (spanData)
--- 2131,2148 ----
      {
  	/* not the same as endIsFg computation above */
  	pixel = (dashIndex & 1) ? pGC->bgPixel : pGC->fgPixel;
! 	switch (pGC->capStyle) {
! 	case CapRound:
  	    miLineArc (pDrawable, pGC, pixel, spanData,
! 		       (LineFacePtr) NULL, (LineFacePtr) NULL,
! 		       (double)x1, (double)y1,
! 		       FALSE);
! 	    break;
! 	case CapProjecting:
! 	    x2 = pGC->lineWidth;
! 	    miFillRectPolyHelper (pDrawable, pGC, pixel, spanData,
! 				  x1 - (x2 >> 1), y1 - (x2 >> 1), x2, x2);
! 	    break;
  	}
      }
      if (spanData)

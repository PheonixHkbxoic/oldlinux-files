		      Release 5 Public Patch #10
			   MIT X Consortium

To apply this patch:

cd to the top of the source tree (to the directory containing the "mit"
and "contrib" subdirectories) and do:
	patch -p -s < ThisFile
Patch will work silently unless an error occurs.
If you want to watch patch do its thing, leave out the "-s" argument to patch.

If you are running SunOS 4.1.2, change OSTeenyVersion in mit/config/sun.cf to
have a value of 2.

Finally, to rebuild after applying this patch, cd to the "mit" subdirectory
and do (if you are on a Sun running SunOS 4.1.2, or are running SunOS 4.1.1
and have set SunPost411FCSLd to YES (see Patch #9)):
	make Everything >& every.log
or do (if you are on an SGI or Cray):
	make Everything >& every.log
otherwise do:
	make -k >& make.log

Brief notes on what this patch fixes:

config: new SunOS ld (post-4.1.1 or 4.1.2) is still causing stupid problems
Xlib: XrmGetQSearchList fails if db has only terminal resources
Xlib: _XcmsResolveColorString fails to apply white adjust procedure
Xlib: CIELuv conversion sometimes off by factor of 100
Xlib: XListFonts gets lost if font name length >= 128 chars
Xlib: GC flushing doesn't give extension access to dirty bits
Xlib: (Xsi) XCreateFontSet doesn't free work area
Xlib: (Xsi) XwcLookupString discards partial conversions
Xlib: (Xsi) XOpenIM fails when network is disabled
Xlib: (Xsi) UDC area incorrect in ja_JP.ujis
Xlib: (Xsi) cannot draw JISX0212/CNS11643 2nd plane character
Xlib: (Ximp) XGetICValues wrong for Area, AreaNeeded, SpotLocation
Xlib: (Ximp) error in parsing CT extended segment
Xt: shell RootGeometryManager missing resize in GeometryDone case
Xt: shell RootGeometryManager does not implement Done semantics
Xt: caching of failed conversions causes problems
Xt: SetValues on override and transient resources has problems
Xt: fails to set some WM_NORMAL_HINTS fields to reasonable values
Xt: event handler setting cont_to_dispatch = False does not stop TM actions
Xt: hangs while parsing certain translations
Xt: fails to parse productions with event count and detail
Xt: fails parsing translations with atom details on multiple displays
Xt: obscure typo involving converters & multiple application contexts
Xaw: Panner realize method envelops superclass method incorrectly
xterm: public patch 9 introduced SGI pty problems
xterm: fails to update menu when keyboard grab is forcibly deactivated
xterm: ESC seq not updating App Cursor Keys menu
xterm: restore ESC seq not updating Margin Bell menu
xauth: use of getchar fails on some systems
editres: will sometimes refuse to pop up the resource box


Prereq: public-patch-9

*** /tmp/,RCSt1001439	Wed Mar 18 12:16:10 1992
--- mit/bug-report	Wed Mar 18 12:16:45 1992
***************
*** 2,8 ****
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-9
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:
--- 2,8 ----
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-10
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:
*** /tmp/,RCSt1001488	Wed Mar 18 13:14:29 1992
--- mit/config/sun.cf	Wed Mar 18 13:14:30 1992
***************
*** 1,9 ****
! XCOMM platform:  $XConsortium: sun.cf,v 1.71 91/12/20 11:18:34 rws Exp $
  
  #define OSName            SunOS 4.1.1
  XCOMM operating system:  OSName
  #define OSMajorVersion    4
  #define OSMinorVersion    1
  
  #if OSMajorVersion < 4 || (OSMajorVersion == 4 && OSMinorVersion < 1)
  /* We do not guarantee this will work */
--- 1,10 ----
! XCOMM platform:  $XConsortium: sun.cf,v 1.72.1.1 92/03/18 13:13:37 rws Exp $
  
  #define OSName            SunOS 4.1.1
  XCOMM operating system:  OSName
  #define OSMajorVersion    4
  #define OSMinorVersion    1
+ #define OSTeenyVersion    1
  
  #if OSMajorVersion < 4 || (OSMajorVersion == 4 && OSMinorVersion < 1)
  /* We do not guarantee this will work */
***************
*** 11,18 ****
  #define StandardDefines   -DNOSTDHDRS
  #endif
  
! /* You ALSO need this if you have Sun ld patch 100170-06 to 4.1.1 */
! #if OSMajorVersion == 4 && OSMinorVersion > 1
  #define SunPost411FCSLd	  YES
  #endif
  
--- 12,19 ----
  #define StandardDefines   -DNOSTDHDRS
  #endif
  
! /* You ALSO need this if you have Sun ld patch 100170-06 or later to 4.1.1 */
! #if OSMajorVersion == 4 && (OSMinorVersion > 1 || (OSMinorVersion == 1 && OSTeenyVersion > 1))
  #define SunPost411FCSLd	  YES
  #endif
  
*** /tmp/,RCSt1000717	Tue Mar 17 14:59:21 1992
--- mit/config/sunLib.tmpl	Tue Mar 17 14:59:24 1992
***************
*** 1,4 ****
! XCOMM $XConsortium: sunLib.tmpl,v 1.14 91/12/20 11:19:05 rws Exp $
  
  /*
   * SunOS shared library template
--- 1,4 ----
! XCOMM $XConsortium: sunLib.tmpl,v 1.14.1.1 92/03/17 14:58:46 rws Exp $
  
  /*
   * SunOS shared library template
***************
*** 48,54 ****
  /* Sun shared libraries are deficient in link semantics */
          DEPXMULIB = _UseCat($(USRLIBDIR),$(XMUSRC),/libXmu.sa.$(SOXMUREV))
         XMULIBONLY = _Use(-lXmu,-L$(XMUSRC) -lXmu)
!            XMULIB = _Use(-lXmu,-L$(XMUSRC) -lXmu -L$(TOOLKITSRC))
  #if !defined(UseInstalled) && !defined(XawClientLibs)
  #define XawClientLibs $(XAWLIB) $(XMULIBONLY) $(XTOOLLIB) $(XLIB)
  #endif
--- 48,54 ----
  /* Sun shared libraries are deficient in link semantics */
          DEPXMULIB = _UseCat($(USRLIBDIR),$(XMUSRC),/libXmu.sa.$(SOXMUREV))
         XMULIBONLY = _Use(-lXmu,-L$(XMUSRC) -lXmu)
!            XMULIB = _Use(-lXmu,-L$(XMUSRC) -lXmu -L$(TOOLKITSRC) -L$(EXTENSIONSRC)/lib -L$(XLIBSRC))
  #if !defined(UseInstalled) && !defined(XawClientLibs)
  #define XawClientLibs $(XAWLIB) $(XMULIBONLY) $(XTOOLLIB) $(XLIB)
  #endif
*** /tmp/,RCSt1029830	Tue Mar 17 11:34:54 1992
--- mit/lib/X/Xrm.c	Fri Jan 10 17:25:50 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: Xrm.c,v 1.70 91/11/21 19:18:45 rws Exp $
   */
  
  /***********************************************************
--- 1,5 ----
  /*
!  * $XConsortium: Xrm.c,v 1.72 92/01/10 14:21:12 rws Exp $
   */
  
  /***********************************************************
***************
*** 1004,1009 ****
--- 1004,1010 ----
   *	Arguments: db - the database.
   *                 str - a pointer to the string containing the database.
   *                 filename - source filename, if any.
+  *                 doall - whether to do all lines or just one
   */
  
  /*
***************
*** 1019,1028 ****
  
  static void GetIncludeFile();
  
! static void GetDatabase(db, str, filename)
      XrmDatabase db;
      register char *str;
      char *filename;
  {
      register char *ptr;
      register XrmBits bits = 0;
--- 1020,1030 ----
  
  static void GetIncludeFile();
  
! static void GetDatabase(db, str, filename, doall)
      XrmDatabase db;
      register char *str;
      char *filename;
+     Bool doall;
  {
      register char *ptr;
      register XrmBits bits = 0;
***************
*** 1039,1044 ****
--- 1041,1047 ----
      XrmBinding bindings[LIST_SIZE];
      XrmValue value;
      Bool only_pcs;
+     Bool dolines;
  
      if (!db)
  	return;
***************
*** 1048,1054 ****
  
      (*db->methods->mbinit)(db->mbstate);
      str--;
!     while (!is_EOF(bits)) {
  
  	/*
  	 * First: Remove extra whitespace. 
--- 1051,1059 ----
  
      (*db->methods->mbinit)(db->mbstate);
      str--;
!     dolines = True;
!     while (!is_EOF(bits) && dolines) {
! 	dolines = doall;
  
  	/*
  	 * First: Remove extra whitespace. 
***************
*** 1441,1447 ****
  #endif
  {
      if (!*pdb) *pdb = NewDatabase();
!     GetDatabase(*pdb, line, (char *)NULL);
  }
  
  #if NeedFunctionPrototypes
--- 1446,1452 ----
  #endif
  {
      if (!*pdb) *pdb = NewDatabase();
!     GetDatabase(*pdb, line, (char *)NULL, False);
  }
  
  #if NeedFunctionPrototypes
***************
*** 1455,1461 ****
      XrmDatabase     db;
  
      db = NewDatabase();
!     GetDatabase(db, data, (char *)NULL);
      return db;
  }
  
--- 1460,1466 ----
      XrmDatabase     db;
  
      db = NewDatabase();
!     GetDatabase(db, data, (char *)NULL, True);
      return db;
  }
  
***************
*** 1520,1526 ****
      }
      if (!(str = ReadInFile(realfname)))
  	return;
!     GetDatabase(db, str, realfname);
      Xfree(str);
  }
  
--- 1525,1531 ----
      }
      if (!(str = ReadInFile(realfname)))
  	return;
!     GetDatabase(db, str, realfname, True);
      Xfree(str);
  }
  
***************
*** 1539,1545 ****
  	return (XrmDatabase)NULL;
  
      db = NewDatabase();
!     GetDatabase(db, str, filename);
      Xfree(str);
      return db;
  }
--- 1544,1550 ----
  	return (XrmDatabase)NULL;
  
      db = NewDatabase();
!     GetDatabase(db, str, filename, True);
      Xfree(str);
      return db;
  }
***************
*** 1567,1573 ****
  	    *target = db = NewDatabase();
      } else
  	db = NewDatabase();
!     GetDatabase(db, str, filename);
      Xfree(str);
      if (!override)
  	XrmCombineDatabase(db, target, False);
--- 1572,1578 ----
  	    *target = db = NewDatabase();
      } else
  	db = NewDatabase();
!     GetDatabase(db, str, filename, True);
      Xfree(str);
      if (!override)
  	XrmCombineDatabase(db, target, False);
***************
*** 2127,2134 ****
      if (db) {
  	table = db->table;
  	if (*names) {
! 	    if (table && !table->leaf &&
! 		SearchNEntry(table, names, classes, &closure))
  		return False;
  	} else {
  	    if (table && !table->leaf)
--- 2132,2143 ----
      if (db) {
  	table = db->table;
  	if (*names) {
! 	    if (table && !table->leaf) {
! 		if (SearchNEntry(table, names, classes, &closure))
! 		    return False;
! 	    } else if (table && table->hasloose &&
! 		       AppendLooseLEntry((LTable)table, names, classes,
! 					 &closure))
  		return False;
  	} else {
  	    if (table && !table->leaf)
***************
*** 2393,2402 ****
  	    if (table && !table->leaf) {
  		if (GetNEntry(table, names, classes, &closure))
  		    return True;
! 		table = table->next;
! 	    }
! 	    if (table && table->hasloose &&
! 		GetLooseVEntry((LTable)table, names, classes, &closure))
  		return True;
  	} else {
  	    if (table && !table->leaf)
--- 2402,2409 ----
  	    if (table && !table->leaf) {
  		if (GetNEntry(table, names, classes, &closure))
  		    return True;
! 	    } else if (table && table->hasloose &&
! 		       GetLooseVEntry((LTable)table, names, classes, &closure))
  		return True;
  	} else {
  	    if (table && !table->leaf)
*** /tmp/,RCSt1000469	Tue Mar 17 12:04:43 1992
--- mit/lib/X/CIELuv.c	Tue Mar  3 14:16:34 1992
***************
*** 1,4 ****
! /* $XConsortium: CIELuv.c,v 1.9 91/07/25 01:07:28 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: CIELuv.c,v 1.10 92/03/03 14:15:02 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 366,372 ****
  	Luv_return.L_star = 
  	    (pColor->spec.CIEuvY.Y < 0.008856)
  	    ?
! 	    (pColor->spec.CIEuvY.Y * 9.0329)
  	    :
  	    ((XcmsFloat)(XCMS_CUBEROOT(pColor->spec.CIEuvY.Y) * 116.0) - 16.0);
  	tmpVal = 13.0 * (Luv_return.L_star / 100.0);
--- 366,372 ----
  	Luv_return.L_star = 
  	    (pColor->spec.CIEuvY.Y < 0.008856)
  	    ?
! 	    (pColor->spec.CIEuvY.Y * 903.29)
  	    :
  	    ((XcmsFloat)(XCMS_CUBEROOT(pColor->spec.CIEuvY.Y) * 116.0) - 16.0);
  	tmpVal = 13.0 * (Luv_return.L_star / 100.0);
*** /tmp/,RCSt1000489	Tue Mar 17 12:06:40 1992
--- mit/lib/X/XFontNames.c	Tue Mar  3 14:22:26 1992
***************
*** 1,4 ****
! /* $XConsortium: XFontNames.c,v 11.25 91/01/29 08:39:45 rws Exp $ */
  /* Copyright    Massachusetts Institute of Technology    1986	*/
  
  /*
--- 1,4 ----
! /* $XConsortium: XFontNames.c,v 11.26 92/03/03 14:21:22 rws Exp $ */
  /* Copyright    Massachusetts Institute of Technology    1986	*/
  
  /*
***************
*** 68,79 ****
  	/*
  	 * unpack into null terminated strings.
  	 */
! 	length = *ch;
  	*ch = 1; /* make sure it is non-zero for XFreeFontNames */
  	for (i = 0; i < rep.nFonts; i++) {
  	    flist[i] = ch + 1;  /* skip over length */
  	    ch += length + 1;  /* find next length ... */
! 	    length = *ch;
  	    *ch = '\0';  /* and replace with null-termination */
  	}
      }
--- 68,79 ----
  	/*
  	 * unpack into null terminated strings.
  	 */
! 	length = *(unsigned char *)ch;
  	*ch = 1; /* make sure it is non-zero for XFreeFontNames */
  	for (i = 0; i < rep.nFonts; i++) {
  	    flist[i] = ch + 1;  /* skip over length */
  	    ch += length + 1;  /* find next length ... */
! 	    length = *(unsigned char *)ch;
  	    *ch = '\0';  /* and replace with null-termination */
  	}
      }
*** /tmp/,RCSt1000509	Tue Mar 17 12:07:37 1992
--- mit/lib/X/XCrGC.c	Wed Mar  4 09:23:07 1992
***************
*** 1,4 ****
! /* $XConsortium: XCrGC.c,v 11.36 91/04/14 13:53:01 rws Exp $ */
  /* Copyright    Massachusetts Institute of Technology    1986	*/
  
  /*
--- 1,4 ----
! /* $XConsortium: XCrGC.c,v 11.38 92/03/04 09:22:18 rws Exp $ */
  /* Copyright    Massachusetts Institute of Technology    1986	*/
  
  /*
***************
*** 47,52 ****
--- 47,54 ----
      4		/* dashes (list [4,4]) */
  };
  
+ static void _XGenerateGCList();
+ 
  GC XCreateGC (dpy, d, valuemask, values)
       register Display *dpy;
       Drawable d;		/* Window or Pixmap for which depth matches */
***************
*** 80,88 ****
          _XGenerateGCList (dpy, gc, (xReq *) req);
      ext = dpy->ext_procs;
      while (ext) {		/* call out to any extensions interested */
! 	if (ext->create_GC != NULL) (*ext->create_GC)(dpy, gc, &ext->codes);
  	ext = ext->next;
  	}    
      UnlockDisplay(dpy);
      SyncHandle();
      return (gc);
--- 82,91 ----
          _XGenerateGCList (dpy, gc, (xReq *) req);
      ext = dpy->ext_procs;
      while (ext) {		/* call out to any extensions interested */
! 	if (ext->create_GC) (*ext->create_GC)(dpy, gc, &ext->codes);
  	ext = ext->next;
  	}    
+     gc->dirty = 0L; /* allow extensions to see dirty bits */
      UnlockDisplay(dpy);
      SyncHandle();
      return (gc);
***************
*** 90,99 ****
  
  /*
   * GenerateGCList looks at the GC dirty bits, and appends all the required
!  * long words to the request being generated.  Clears the dirty bits in
!  * the GC.
   */
  
  _XGenerateGCList (dpy, gc, req)
      register Display *dpy;
      xReq *req;
--- 93,102 ----
  
  /*
   * GenerateGCList looks at the GC dirty bits, and appends all the required
!  * long words to the request being generated.
   */
  
+ static void
  _XGenerateGCList (dpy, gc, req)
      register Display *dpy;
      xReq *req;
***************
*** 145,151 ****
  
      nvalues <<= 2;
      Data32 (dpy, (long *) values, nvalues);
-     gc->dirty = 0L;
  
      }
  
--- 148,153 ----
***************
*** 315,323 ****
          _XGenerateGCList (dpy, gc, (xReq *) req);
  	ext = dpy->ext_procs;
  	while (ext) {		/* call out to any extensions interested */
! 		if (ext->flush_GC != NULL) (*ext->flush_GC)(dpy, gc, &ext->codes);
  		ext = ext->next;
  	}    
      }
  }
  
--- 317,326 ----
          _XGenerateGCList (dpy, gc, (xReq *) req);
  	ext = dpy->ext_procs;
  	while (ext) {		/* call out to any extensions interested */
! 		if (ext->flush_GC) (*ext->flush_GC)(dpy, gc, &ext->codes);
  		ext = ext->next;
  	}    
+ 	gc->dirty = 0L; /* allow extensions to see dirty bits */
      }
  }
  
*** /tmp/,RCSt1000428	Tue Mar 17 12:02:16 1992
--- mit/lib/X/XcmsColNm.c	Tue Mar  3 12:17:04 1992
***************
*** 1,4 ****
! /* $XConsortium: XcmsColNm.c,v 1.24 91/11/06 17:55:19 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: XcmsColNm.c,v 1.25 92/03/03 12:16:07 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 1014,1022 ****
  			ScreenWhitePointOfCCC(ccc), result_format,
  			pColor_exact_return, 1, (Bool *)NULL));
  	    } else {
! 		if (_XcmsDIConvertColors(ccc, pColor_exact_return,
! 			&dbWhitePt, 1, XcmsCIEXYZFormat) == XcmsFailure) {
! 		    return(XcmsFailure);
  		}
  		return (_XcmsDDConvertColors(ccc, pColor_exact_return, 1,
  			result_format, (Bool *)NULL));
--- 1014,1024 ----
  			ScreenWhitePointOfCCC(ccc), result_format,
  			pColor_exact_return, 1, (Bool *)NULL));
  	    } else {
! 		if (pColor_exact_return->format != XcmsCIEXYZFormat) {
! 		    if (_XcmsDIConvertColors(ccc, pColor_exact_return,
! 			    &dbWhitePt, 1, XcmsCIEXYZFormat) == XcmsFailure) {
! 			return(XcmsFailure);
! 		    }
  		}
  		return (_XcmsDDConvertColors(ccc, pColor_exact_return, 1,
  			result_format, (Bool *)NULL));
***************
*** 1025,1044 ****
  	    /*
  	     * Target format is Device-Independent
  	     *	Therefore, DI --> DI conversion
- 	     *
- 	     * Since DI->DI, we don't apply WhiteAdjustProc.
  	     */
! 	    if (_XcmsEqualWhitePts(ccc,
  		    &dbWhitePt, pClientWhitePt)) {
! 		return (_XcmsDIConvertColors(ccc, pColor_exact_return,
! 			&dbWhitePt, 1, result_format));
  	    } else {
! 		if (_XcmsDIConvertColors(ccc, pColor_exact_return,
! 			&dbWhitePt, 1, XcmsCIEXYZFormat) == XcmsFailure) {
! 		    return(XcmsFailure);
  		}
! 		return(_XcmsDIConvertColors(ccc, pColor_exact_return,
! 			pClientWhitePt, 1, result_format));
  	    }
  	}
      }
--- 1027,1080 ----
  	    /*
  	     * Target format is Device-Independent
  	     *	Therefore, DI --> DI conversion
  	     */
! 	    if (ccc->whitePtAdjProc && !_XcmsEqualWhitePts(ccc,
  		    &dbWhitePt, pClientWhitePt)) {
! 		/*
! 		 * The calling routine wants to resolve this color
! 		 * in terms if it's white point (i.e. Client White Point).
! 		 * Therefore, apply white adjustment for the displacement
! 		 * between dbWhitePt to clientWhitePt.
! 		 */
! 		return((*ccc->whitePtAdjProc)(ccc, &dbWhitePt,
! 			pClientWhitePt, result_format,
! 			pColor_exact_return, 1, (Bool *)NULL));
! 	    } else if (_XcmsEqualWhitePts(ccc,
! 		    &dbWhitePt, pClientWhitePt)) {
! 		/*
! 		 * Can use either dbWhitePt or pClientWhitePt to
! 		 * convert to the result_format.
! 		 */
! 		if (pColor_exact_return->format == result_format) {
! 		    return(XcmsSuccess);
! 		} else {
! 		    return (_XcmsDIConvertColors(ccc, pColor_exact_return,
! 			    &dbWhitePt, 1, result_format));
! 		}
  	    } else {
! 		/*
! 		 * Need to convert to a white point independent color
! 		 * space (let's choose CIEXYZ) then convert to the
! 		 * target color space.  Why? Lets assume that
! 		 * pColor_exact_return->format and result format
! 		 * are white point dependent format (e.g., CIELUV, CIELAB,
! 		 * TekHVC ... same or any combination). If so, we'll
! 		 * need to convert the color with dbWhitePt to an absolute
! 		 * spec (i.e.  non-white point dependent) then convert that
! 		 * absolute value with clientWhitePt to the result_format.
! 		 */
! 		if (pColor_exact_return->format != XcmsCIEXYZFormat) {
! 		    if (_XcmsDIConvertColors(ccc, pColor_exact_return,
! 			    &dbWhitePt, 1, XcmsCIEXYZFormat) == XcmsFailure) {
! 			return(XcmsFailure);
! 		    }
  		}
! 		if (result_format == XcmsCIEXYZFormat) {
! 		    return(XcmsSuccess);
! 		} else {
! 		    return(_XcmsDIConvertColors(ccc, pColor_exact_return,
! 			    pClientWhitePt, 1, result_format));
! 		}
  	    }
  	}
      }
*** /tmp/,RCSt1000153	Tue Mar 17 11:52:11 1992
--- mit/lib/X/Xsi/ProtoFlt.c	Tue Mar  3 10:02:26 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: ProtoFlt.c,v 1.25 91/12/02 16:50:26 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: ProtoFlt.c,v 1.26 92/03/03 10:01:17 rws Exp $
   */
  
  /*
***************
*** 95,101 ****
  	    ret = _XConvertCTToMB(ic->mb, (unsigned char *)ic->ct_buf, length,
  				  mbuf, &mb_len, &scanned_bytes,
  				  (_State *)NULL);
! 	    if (ret == Success) {
  #ifdef macII
  		wc_len = 0;
  #else
--- 95,101 ----
  	    ret = _XConvertCTToMB(ic->mb, (unsigned char *)ic->ct_buf, length,
  				  mbuf, &mb_len, &scanned_bytes,
  				  (_State *)NULL);
! 	    if (ret >= 0) {
  #ifdef macII
  		wc_len = 0;
  #else
***************
*** 106,112 ****
  		    return;
  	    }
  #endif
! 	    if (ret != Success) {
  		return;
  	    }
  	} else {
--- 106,112 ----
  		    return;
  	    }
  #endif
! 	    if (ret < 0) {
  		return;
  	    }
  	} else {
***************
*** 256,262 ****
  		ret = _XConvertCTToMB(ic->mb, (unsigned char *)ic->ct_buf,
  				      length, mbuf, &mb_len, &scanned_bytes,
  				      (_State *)NULL);
! 		if (ret == Success) {
  #ifdef macII
  		    wc_len = 0;
  #else
--- 256,262 ----
  		ret = _XConvertCTToMB(ic->mb, (unsigned char *)ic->ct_buf,
  				      length, mbuf, &mb_len, &scanned_bytes,
  				      (_State *)NULL);
! 		if (ret >= 0) {
  #ifdef macII
  		    wc_len = 0;
  #else
***************
*** 267,273 ****
  			return;
  		}
  #endif
! 		if (ret != Success) {
  		    return;
  		}
  	    } else {
--- 267,273 ----
  			return;
  		}
  #endif
! 		if (ret < 0) {
  		    return;
  		}
  	    } else {
*** /tmp/,RCSt1000172	Tue Mar 17 11:52:21 1992
--- mit/lib/X/Xsi/XConnIM.c	Tue Mar  3 10:03:10 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XConnIM.c,v 1.16 91/08/12 17:22:22 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XConnIM.c,v 1.17 92/03/03 10:02:09 rws Exp $
   */
  
  /*
***************
*** 61,69 ****
      im->fd = -1;
      return(False);
  #else
- #ifdef	UNIXCONN
-     char		hostname[256];	/* My host name buffer */
- #endif
      char		im_hostname[256];/* Input manager host name buffer */
      Atom		actual_type;
      int			actual_format;
--- 61,66 ----
***************
*** 84,89 ****
--- 81,87 ----
      ximNormalReply	reply;
      unsigned long	i;
      unsigned short	s;
+     int			inet_ok = 0;
  
      im->fd = -1;
      /*
***************
*** 109,123 ****
      if (im->major_version != XIM_MAJOR_VERSION) return(False);
      if (!(im->minor_version >= XIM_MINOR_VERSION)) return(False);
  
! #ifdef	UNIXCONN
!     if (gethostname(hostname, 256) < 0) {
! 	hostname[0] = '\0';
      }
      /*
!      * If the hostname of gethostname is null or the hostname of the input
!      * manager is null, attempts to open UNIX domain socket.
       */
!     if ((hostname[0] == '\0') || (im_hostname[0] == '\0')) {
  	saddr.sun_family = AF_UNIX;
  	strcpy(saddr.sun_path, XIM_UNIX_PATH);
  	if ((sd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
--- 107,136 ----
      if (im->major_version != XIM_MAJOR_VERSION) return(False);
      if (!(im->minor_version >= XIM_MINOR_VERSION)) return(False);
  
! #ifdef TCPCONN
!     /*
!      * Attempts to open INET domain socket.
!      */
!     if (hp = gethostbyname(im_hostname)) {
! 	bzero((char *)&saddr_in, (int)sizeof(saddr_in));
! 	bcopy(hp->h_addr, (char *)&saddr_in.sin_addr, hp->h_length);
! 	saddr_in.sin_family = AF_INET;
! 	saddr_in.sin_port = htons(port);
! 	if ((sd = socket(AF_INET, SOCK_STREAM, 0)) >= 0) {
! 	    if (connect(sd, &saddr_in, sizeof(saddr_in)) >= 0) {
! 		inet_ok = 1;
! 	    } else {
! 		close(sd);
! 		sd = -1;
! 	    }
! 	}
      }
+ #endif
+ #ifdef	UNIXCONN
      /*
!      * Attempts to open UNIX domain socket.
       */
!     if (inet_ok == 0) {
  	saddr.sun_family = AF_UNIX;
  	strcpy(saddr.sun_path, XIM_UNIX_PATH);
  	if ((sd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
***************
*** 127,156 ****
  	    close(sd);
  	    return(False);
  	}
-     } else {
- #endif	/* UNIXCONN */
- #ifdef TCPCONN
- 	/*
- 	 * Attempts to open INET domain socket.
- 	 */
- 	if ((hp = gethostbyname(im_hostname)) == NULL) {
- 	    return(False);
- 	}
- 	bzero((char *)&saddr_in, (int)sizeof(saddr_in));
- 	bcopy(hp->h_addr, (char *)&saddr_in.sin_addr, hp->h_length);
- 	saddr_in.sin_family = AF_INET;
- 	saddr_in.sin_port = htons(port);
- 	if ((sd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
- 	    return(False);
- 	}
- 	if (connect(sd, &saddr_in, sizeof(saddr_in)) < 0) {
- 	    close(sd);
- 	    return(False);
- 	}
- #endif
- #ifdef	UNIXCONN
      }
  #endif	/* UNIXCONN */
  
      /*
       * Send the display name to the input manager. 
--- 140,148 ----
  	    close(sd);
  	    return(False);
  	}
      }
  #endif	/* UNIXCONN */
+     if (sd == -1) return(False);
  
      /*
       * Send the display name to the input manager. 
*** /tmp/,RCSt1000191	Tue Mar 17 11:52:32 1992
--- mit/lib/X/Xsi/XCrFntSet.c	Tue Mar  3 10:01:24 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XCrFntSet.c,v 1.43 91/12/02 16:49:48 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XCrFntSet.c,v 1.44 92/03/03 10:00:34 rws Exp $
   */
  
  /*
***************
*** 440,453 ****
  	    if (matchCharset(fn, cset->cs_name, cset->cs_GLorGR) == True) {
  		dbg_printf("findFont: matched\n", 0, 0);
  		ret++;
- 		f_tmp[i] = fn;
  #ifdef PRELOAD
  		if (!(s_tmp[i] = XLoadQueryFont(dpy, fn))) ret--;
  #else /* PRELOAD */
  		if (!info)
  		    list = XListFontsWithInfo(dpy, fname, 1, &count, &info);
! 		if(! (s_tmp[i] = (XFontStruct *) Xmalloc(sizeof(XFontStruct))))
  		    return ret;
  # ifndef MUSTCOPY
  		s_tmp[i] = info[0];
  # else /* MUSTCOPY */
--- 440,454 ----
  	    if (matchCharset(fn, cset->cs_name, cset->cs_GLorGR) == True) {
  		dbg_printf("findFont: matched\n", 0, 0);
  		ret++;
  #ifdef PRELOAD
  		if (!(s_tmp[i] = XLoadQueryFont(dpy, fn))) ret--;
  #else /* PRELOAD */
  		if (!info)
  		    list = XListFontsWithInfo(dpy, fname, 1, &count, &info);
! 		if(! (s_tmp[i] = (XFontStruct *) Xmalloc(sizeof(XFontStruct)))){
! 		    Xfree((char *)fn);
  		    return ret;
+ 		}
  # ifndef MUSTCOPY
  		s_tmp[i] = info[0];
  # else /* MUSTCOPY */
***************
*** 457,462 ****
--- 458,468 ----
  		s_tmp[i]->fid = 0;
  #endif /* PRELOAD */
  		id_tmp[i] = cset->cs_id;
+ 		if(! (f_tmp[i] = (char *) Xmalloc(strlen(fn) + 1))) {
+ 		    Xfree((char *)fn);
+ 		    return --ret;
+ 		}
+ 		strcpy(f_tmp[i], fn);
  	    } else {
  		f_tmp[i] = NULL;
  	    }
***************
*** 466,471 ****
--- 472,478 ----
      if (info) {
  	XFreeFontInfo(list, info, count);
      }
+     Xfree((char *)fn);
      return ret;
  
  }
***************
*** 678,684 ****
      }
  
      if (!loadASCIIFONT) {
! 	f_tmp[0] = "fixed";	/* use defalt font */
  	s_tmp[0] = XLoadQueryFont(dpy, f_tmp[0]);
      }
  
--- 685,693 ----
      }
  
      if (!loadASCIIFONT) {
! 	if(! (f_tmp[0] = (char *)Xmalloc(strlen("fixed") + 1)))
! 	    return NULL;
! 	strcpy(f_tmp[0], "fixed");	/* use defalt font */
  	s_tmp[0] = XLoadQueryFont(dpy, f_tmp[0]);
      }
  
***************
*** 704,709 ****
--- 713,721 ----
  		      &font_set->min_bounds, &font_set->max_bounds,
  		      &font_set->ascent, &font_set->descent);
      font_set->core.default_string = NULL;
+     for (i = 0; (int)i < found; i++) {
+ 	Xfree((char *)f_tmp[i]);
+     }
  
      /*
       * set the ink bounding box of font_set.
***************
*** 867,872 ****
--- 879,887 ----
  		      &font_set->min_bounds, &font_set->max_bounds,
  		      &font_set->ascent, &font_set->descent);
      font_set->core.default_string = NULL;
+     for (i = 0; (int)i < found; i++) {
+ 	Xfree((char *)f_tmp[i]);
+     }
  
      /*
       * set the ink bounding box of font_set.
*** /tmp/,RCSt1000211	Tue Mar 17 11:52:41 1992
--- mit/lib/X/Xsi/XIMKeyBind.c	Tue Mar  3 10:02:30 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XIMKeyBind.c,v 1.21 91/12/02 16:42:44 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XIMKeyBind.c,v 1.22 92/03/03 10:01:53 rws Exp $
   */
  
  /*
***************
*** 67,73 ****
  	    mbuf = _XAllocScratch(ev->display, ret_len);
  	    ret = _XConvertCTToMB(ic->mb, ptr, length, mbuf,
  				  &ret_len, &scanned_bytes, (_State *)NULL);
! 	    if (ret == Success) {
  #ifdef macII
  		ret_len = 0;
  #else
--- 67,73 ----
  	    mbuf = _XAllocScratch(ev->display, ret_len);
  	    ret = _XConvertCTToMB(ic->mb, ptr, length, mbuf,
  				  &ret_len, &scanned_bytes, (_State *)NULL);
! 	    if (ret >= 0) {
  #ifdef macII
  		ret_len = 0;
  #else
***************
*** 78,84 ****
  		    ret = XBufferOverflow;
  	    }
  #endif
! 	    if (ret != Success) {
  		*status = XBufferOverflow;
  		return(0);
  	    }
--- 78,84 ----
  		    ret = XBufferOverflow;
  	    }
  #endif
! 	    if (ret < 0) {
  		*status = XBufferOverflow;
  		return(0);
  	    }
***************
*** 104,112 ****
  	    }
  #ifdef X_WCHAR
  	    /* XXX BUG Need to save current status */
! 	    _XConvertMBToWC(ic->wc, (unsigned char *)buf, ret_len,
  			    (wchar *)buffer, &nchars, &scanned_bytes,
  			    (_State *)NULL);
  	    ret_len = nchars;
  	    /* XXX BUG Need to restore saved status */
  #else
--- 104,116 ----
  	    }
  #ifdef X_WCHAR
  	    /* XXX BUG Need to save current status */
! 	    ret = _XConvertMBToWC(ic->wc, (unsigned char *)buf, ret_len,
  			    (wchar *)buffer, &nchars, &scanned_bytes,
  			    (_State *)NULL);
+ 	    if (ret < 0) {
+ 		*status = XBufferOverflow;
+ 		return(0);
+ 	    }
  	    ret_len = nchars;
  	    /* XXX BUG Need to restore saved status */
  #else
***************
*** 150,156 ****
  	    ret_len = nbytes;
  	    ret = _XConvertCTToMB(ic->mb, ptr, length, (unsigned char *)buffer,
  				  &ret_len, &scanned_bytes, (_State *)NULL);
! 	    if (ret != Success) {
  		*status = XBufferOverflow;
  		return(0);
  	    }
--- 154,160 ----
  	    ret_len = nbytes;
  	    ret = _XConvertCTToMB(ic->mb, ptr, length, (unsigned char *)buffer,
  				  &ret_len, &scanned_bytes, (_State *)NULL);
! 	    if (ret < 0) {
  		*status = XBufferOverflow;
  		return(0);
  	    }
***************
*** 163,169 ****
  				      (unsigned char *)buffer,
  				      &ret_len, &scanned_bytes,
  				      (_State *)NULL);
! 		if (ret != Success) {
  		    *status = XBufferOverflow;
  		    return(0);
  		}
--- 167,173 ----
  				      (unsigned char *)buffer,
  				      &ret_len, &scanned_bytes,
  				      (_State *)NULL);
! 		if (ret < 0) {
  		    *status = XBufferOverflow;
  		    return(0);
  		}
*** /tmp/,RCSt1000782	Tue Mar 17 15:30:58 1992
--- mit/lib/X/Xsi/XInitCT.c	Tue Mar  3 10:04:01 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XInitCT.c,v 1.16 91/09/18 16:29:54 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XInitCT.c,v 1.17 92/03/03 10:02:52 rws Exp $
   */
  
  /*
***************
*** 546,554 ****
      _CSID			ind, i;
      _CSID 			n = ISOStateTableNum;
  
! #define PosSub(s1, s2) ((s1 >= s2) ? (s1 - s2) : ~0L)
  
      *woffset = ptr->state_woffset;
      ind = CODESET0;
      disp_min = PosSub(wc, ptr->state_woffset);
      if (disp_min == (wchar) ~0L) {
--- 546,555 ----
      _CSID			ind, i;
      _CSID 			n = ISOStateTableNum;
  
! #define PosSub(s1, s2) (((s1) >= (s2)) ? ((s1) - (s2)) : ~0L)
  
      *woffset = ptr->state_woffset;
+     wc &= ~0x7f;
      ind = CODESET0;
      disp_min = PosSub(wc, ptr->state_woffset);
      if (disp_min == (wchar) ~0L) {
***************
*** 558,566 ****
      if (disp_min < 0x80)
  	return(CODESET0);
      for (i = 1, ptr++; i < n; i++, ptr++) {
!         if (((new = PosSub(wc, ptr->state_woffset)) > 0) && (new < disp_min)) {
              *woffset = ptr->state_woffset;
! 	    if ((new < 0x80) || (ptr->state_length == 2 && new < 0x8000))
  		return(i);
              ind = i;
              disp_min = new;
--- 559,571 ----
      if (disp_min < 0x80)
  	return(CODESET0);
      for (i = 1, ptr++; i < n; i++, ptr++) {
! 	if (ptr->state_length == 2)
! 	    new = PosSub(wc & ~0x7f00, ptr->state_woffset);
! 	else
! 	    new = PosSub(wc, ptr->state_woffset);
!         if ((new >= 0) && (new < disp_min)) {
              *woffset = ptr->state_woffset;
! 	    if (new < 0x80)
  		return(i);
              ind = i;
              disp_min = new;
*** /tmp/,RCSt1000246	Tue Mar 17 11:54:17 1992
--- mit/lib/nls/Xsi/ja_JP.ujis	Tue Mar  3 10:00:18 1992
***************
*** 1,5 ****
  #
! # $XConsortium: ja_JP.ujis,v 1.7 91/06/29 20:02:02 xguest Exp $
  #
  # Copyright 1990, 1991 by OMRON Corporation, NTT Software Corporation,
  #                      and Nippon Telegraph and Telephone Corporation
--- 1,5 ----
  #
! # $XConsortium: ja_JP.ujis,v 1.8 92/03/03 09:59:32 rws Exp $
  #
  # Copyright 1990, 1991 by OMRON Corporation, NTT Software Corporation,
  #                      and Nippon Telegraph and Telephone Corporation
***************
*** 103,109 ****
  (8fa1a1=2121:7e7e)
  #
  # UDC
! (f5a1=2121:2d7e)
  END XLC_CODESET
  #
  # END OF FILE
--- 103,109 ----
  (8fa1a1=2121:7e7e)
  #
  # UDC
! (f5a1=2121:2a7e)
  END XLC_CODESET
  #
  # END OF FILE
*** /tmp/,RCSt1000330	Tue Mar 17 11:57:46 1992
--- mit/lib/X/Ximp/XimpIC.c	Tue Mar  3 11:03:57 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpIC.c,v 1.4 91/10/07 17:48:30 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: XimpIC.c,v 1.5 92/03/03 11:03:14 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by FUJITSU LIMITED
***************
*** 58,63 ****
--- 58,71 ----
  static void 		_Ximp_AttributesSetL();
  extern void 		_Ximp_IM_SendMessage();
  
+ #if NeedFunctionPrototypes
+ extern Bool _Ximp_XimFilter_Keypress (
+ 	Display *d, 
+ 	Window w, 
+ 	XEvent *ev, 
+ 	XPointer client_data);
+ #endif
+ 
  static XICMethodsRec Ximp_ic_methods = {
  				_Ximp_DestroyIC, 	/* destroy */
  				_Ximp_SetFocus,  	/* set_focus */
***************
*** 75,81 ****
  	Display		*d;
  	Window		w;
  	XEvent		*ev;
! 	XPointer	*client_data;
  {
  	extern Bool	_Ximp_Keypress ();
  
--- 83,89 ----
  	Display		*d;
  	Window		w;
  	XEvent		*ev;
! 	XPointer	client_data;
  {
  	extern Bool	_Ximp_Keypress ();
  
***************
*** 138,144 ****
  				ic->core.focus_window,
  				KeyPress, KeyPress,
  				_Ximp_XimFilter_Keypress,
! 				ic);
  		current_xic = ic;
  	}
  	return((XIC)ic);
--- 146,152 ----
  				ic->core.focus_window,
  				KeyPress, KeyPress,
  				_Ximp_XimFilter_Keypress,
! 				(XPointer)ic);
  		current_xic = ic;
  	}
  	return((XIC)ic);
***************
*** 159,165 ****
  			_XUnregisterFilter (ic->core.im->core.display,
  					ic->core.focus_window,
  					_Ximp_XimFilter_Keypress,
! 					current_xic);
  			current_xic = 0;
  		}
  	}
--- 167,173 ----
  			_XUnregisterFilter (ic->core.im->core.display,
  					ic->core.focus_window,
  					_Ximp_XimFilter_Keypress,
! 					(XPointer)current_xic);
  			current_xic = 0;
  		}
  	}
***************
*** 177,188 ****
  			_XUnregisterFilter (ic->core.im->core.display,
  						ic->core.focus_window,
  						_Ximp_XimFilter_Keypress,
! 						current_xic);
  		_XRegisterFilterByType (ic->core.im->core.display,
  					ic->core.focus_window,
  					KeyPress, KeyPress,
  					_Ximp_XimFilter_Keypress,
! 					ic);
  		current_xic = ic;
  	}
  	return;
--- 185,196 ----
  			_XUnregisterFilter (ic->core.im->core.display,
  						ic->core.focus_window,
  						_Ximp_XimFilter_Keypress,
! 						(XPointer)current_xic);
  		_XRegisterFilterByType (ic->core.im->core.display,
  					ic->core.focus_window,
  					KeyPress, KeyPress,
  					_Ximp_XimFilter_Keypress,
! 					(XPointer)ic);
  		current_xic = ic;
  	}
  	return;
***************
*** 198,204 ****
  			_XUnregisterFilter (ic->core.im->core.display,
  					ic->core.focus_window,
  					_Ximp_XimFilter_Keypress,
! 					current_xic);
  			current_xic = 0;
  		}
  	}
--- 206,212 ----
  			_XUnregisterFilter (ic->core.im->core.display,
  					ic->core.focus_window,
  					_Ximp_XimFilter_Keypress,
! 					(XPointer)current_xic);
  			current_xic = 0;
  		}
  	}
*** /tmp/,RCSt1000347	Tue Mar 17 11:57:56 1992
--- mit/lib/X/Ximp/XimpLkup.c	Tue Mar  3 11:04:03 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpLkup.c,v 1.5 91/10/07 17:49:03 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by Sony Corporation
--- 1,4 ----
! /* $XConsortium: XimpLkup.c,v 1.6 92/03/03 11:03:23 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by Sony Corporation
***************
*** 71,76 ****
--- 71,84 ----
  static void		_Ximp_CallCallback();
  static void		_Ximp_ProcError();
  
+ #if NeedFunctionPrototypes
+ static Bool
+ _Ximp_ResetPredicate(
+ 	Display *d,
+ 	XEvent *ev,
+ 	XPointer parg);
+ #endif
+ 
  typedef struct {
  	Atom type;
  	ICID icid;
***************
*** 78,88 ****
  } XimpResetPredArgRec, *XimpResetPredArg;
  
  static Bool
! _Ximp_ResetPredicate(d, ev, arg)
  Display *d;
  XEvent *ev;
! XimpResetPredArg arg;
  {
  	if (ev->type == ClientMessage) {
  		if (ev->xclient.message_type == arg->type) {
  			if ((ev->xclient.format == 32) &&
--- 86,97 ----
  } XimpResetPredArgRec, *XimpResetPredArg;
  
  static Bool
! _Ximp_ResetPredicate(d, ev, parg)
  Display *d;
  XEvent *ev;
! XPointer parg;
  {
+ 	XimpResetPredArg arg = (XimpResetPredArg)parg;
  	if (ev->type == ClientMessage) {
  		if (ev->xclient.message_type == arg->type) {
  			if ((ev->xclient.format == 32) &&
***************
*** 128,134 ****
  		Arg.icid = ic->ximp_icpart->icid;
  		Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
  		while(_time_flag != 1) {
! 			if( (XCheckIfEvent(ic->core.im->core.display, &event, _Ximp_ResetPredicate, &Arg)) == False) {
  #ifdef XIMP_SIGNAL
  				sleep(1);
  #endif /* XIMP_SIGNAL */
--- 137,143 ----
  		Arg.icid = ic->ximp_icpart->icid;
  		Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
  		while(_time_flag != 1) {
! 			if( (XCheckIfEvent(ic->core.im->core.display, &event, _Ximp_ResetPredicate, (XPointer)&Arg)) == False) {
  #ifdef XIMP_SIGNAL
  				sleep(1);
  #endif /* XIMP_SIGNAL */
***************
*** 198,204 ****
  
  	if (!ct) return(NULL);
  	mb = Xmalloc(length);
! 	_Ximp_cttombs(ic->core.im->core.lcd, ct, strlen(ct), mb, &length, NULL);
  	mb[length] = '\0';
  	return(mb);
  }
--- 207,213 ----
  
  	if (!ct) return(NULL);
  	mb = Xmalloc(length);
! 	_Ximp_cttombs(ic->core.im->core.lcd, ct, strlen((char *)ct), mb, &length, NULL);
  	mb[length] = '\0';
  	return(mb);
  }
***************
*** 213,219 ****
  
  	if (!ct) return(NULL);
  	wc = (wchar_t *)Xmalloc(length * sizeof(wchar_t));
! 	_Ximp_cttowcs(ic->core.im->core.lcd, ct, strlen(ct), wc, &length, NULL);
  	wc[length] = (wchar_t)0;
  	return(wc);
  }
--- 222,228 ----
  
  	if (!ct) return(NULL);
  	wc = (wchar_t *)Xmalloc(length * sizeof(wchar_t));
! 	_Ximp_cttowcs(ic->core.im->core.lcd, ct, strlen((char *)ct), wc, &length, NULL);
  	wc[length] = (wchar_t)0;
  	return(wc);
  }
***************
*** 547,553 ****
  	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
  			((Ximp_XIM)ic->core.im)->ximp_impart->version_id,
  			XA_STRING, 8, PropModeReplace,
! 			XIMP_PROTOCOL_VERSION, strlen(XIMP_PROTOCOL_VERSION));
  	XFlush(ic->core.im->core.display);
  
  	mask = ic->ximp_icpart->proto_mask;
--- 556,562 ----
  	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
  			((Ximp_XIM)ic->core.im)->ximp_impart->version_id,
  			XA_STRING, 8, PropModeReplace,
! 			(unsigned char *)XIMP_PROTOCOL_VERSION, strlen(XIMP_PROTOCOL_VERSION));
  	XFlush(ic->core.im->core.display);
  
  	mask = ic->ximp_icpart->proto_mask;
***************
*** 849,855 ****
  			_Ximp_ProcKeypress (d, w, ev);
  			_Ximp_MakeKeypress (d, w, ev);
  			ev->send_event = False ;
! 			XPutBackEvent(d, ev);
  			break ;
  		case XIMP_CREATE_RETURN:
  			_Ximp_ProcCreateReturn (d, w, ev);
--- 858,864 ----
  			_Ximp_ProcKeypress (d, w, ev);
  			_Ximp_MakeKeypress (d, w, ev);
  			ev->send_event = False ;
! 			XPutBackEvent(d, (XEvent *)ev);
  			break ;
  		case XIMP_CREATE_RETURN:
  			_Ximp_ProcCreateReturn (d, w, ev);
***************
*** 864,870 ****
  			_Ximp_ProcReadProperty (d, w, ev);
  			_Ximp_MakeKeypress (d, w, ev);
  			ev->send_event = False ;
! 			XPutBackEvent(d, ev);
  			break ;
  		case XIMP_ERROR:
  			_Ximp_ProcError (d, w, ev);
--- 873,879 ----
  			_Ximp_ProcReadProperty (d, w, ev);
  			_Ximp_MakeKeypress (d, w, ev);
  			ev->send_event = False ;
! 			XPutBackEvent(d, (XEvent *)ev);
  			break ;
  		case XIMP_ERROR:
  			_Ximp_ProcError (d, w, ev);
***************
*** 891,897 ****
  		_Ximp_ProcReadMessage (d, w, ev);
  		_Ximp_MakeKeypress (d, w, ev);
  		ev->send_event = False ;
! 		XPutBackEvent(d, ev);
          }
  	return (True);
  }
--- 900,906 ----
  		_Ximp_ProcReadMessage (d, w, ev);
  		_Ximp_MakeKeypress (d, w, ev);
  		ev->send_event = False ;
! 		XPutBackEvent(d, (XEvent *)ev);
          }
  	return (True);
  }
*** /tmp/,RCSt1000365	Tue Mar 17 11:58:07 1992
--- mit/lib/X/Ximp/XimpCT.c	Tue Mar  3 11:03:18 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpCT.c,v 1.2 91/07/30 14:27:12 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpCT.c,v 1.3 92/03/03 11:02:11 rws Exp $ */
  /*
   * Copyright 1990, 1991 by TOSHIBA Corp.
   * Copyright 1990, 1991 by SORD Computer Corp.
***************
*** 213,219 ****
  	    if (ctext_len < 1)
  		return -1;
  
! 	    if (ctext_len > 4 && *ctptr++ == '%') {
  		ch = *ctptr++;
  		if (ch < 0x30 || ch > 0x3f)
  		    goto unknown;
--- 213,219 ----
  	    if (ctext_len < 1)
  		return -1;
  
! 	    if (ctext_len > 4 && *ctptr++ == '/') {
  		ch = *ctptr++;
  		if (ch < 0x30 || ch > 0x3f)
  		    goto unknown;
*** /tmp/,RCSt1000382	Tue Mar 17 11:58:16 1992
--- mit/lib/X/Ximp/XimpICG.c	Tue Mar  3 11:02:23 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpICG.c,v 1.5 91/10/10 20:08:25 rws Exp $ */
  /******************************************************************
  
      Copyright 1991, by FUJITSU LIMITED.
--- 1,4 ----
! /* $XConsortium: XimpICG.c,v 1.6 92/03/03 11:01:06 rws Exp $ */
  /******************************************************************
  
      Copyright 1991, by FUJITSU LIMITED.
***************
*** 153,158 ****
--- 153,159 ----
  	int		 im_font_flag    = 0;
  	Ximp_PreeditPropRec	*preedit_data;
  	XIMCallback 	*p_callback;
+ 	XPointer	*xptr;
  
  	if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver) {
  		for(mask = 0, p = vl; p->name != NULL; p++) {
***************
*** 209,221 ****
  			}
  		} else if(strcmp(p->name, XNAreaNeeded)==0) {
  			if(im_preedit_flag) {
! 				p_rect =  (XRectangle *)(p->value) ;
  				p_rect->x  = p_rect->y  = 0;
  				p_rect->width   = preedit_data->AreaNeeded.width;
  				p_rect->height  = preedit_data->AreaNeeded.height;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_AREANEED_MASK) {
! 				        p_rect = (XRectangle *)(p->value) ;
  					p_rect->x  = p_rect->y  = 0;
  					p_rect->width   = ic->core.preedit_attr.area_needed.width;
  					p_rect->height  = ic->core.preedit_attr.area_needed.height;
--- 210,226 ----
  			}
  		} else if(strcmp(p->name, XNAreaNeeded)==0) {
  			if(im_preedit_flag) {
! 				p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle));
! 				xptr = (XPointer *)p->value;
! 				*xptr = (XPointer)p_rect;
  				p_rect->x  = p_rect->y  = 0;
  				p_rect->width   = preedit_data->AreaNeeded.width;
  				p_rect->height  = preedit_data->AreaNeeded.height;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_AREANEED_MASK) {
! 					p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle));
! 					xptr = (XPointer *)p->value;
! 					*xptr = (XPointer)p_rect;
  					p_rect->x  = p_rect->y  = 0;
  					p_rect->width   = ic->core.preedit_attr.area_needed.width;
  					p_rect->height  = ic->core.preedit_attr.area_needed.height;
***************
*** 226,237 ****
  			}
  		} else if(strcmp(p->name, XNSpotLocation)==0) {
  			if(im_preedit_flag) {
! 			        p_point = (XPoint *)(p->value);
  				p_point->x = preedit_data->SpotLocation.x;
  				p_point->y = preedit_data->SpotLocation.y;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_SPOTL_MASK) {
! 				        p_point = (XPoint *)(p->value);
  					p_point->x = ic->core.preedit_attr.spot_location.x;
  					p_point->y = ic->core.preedit_attr.spot_location.y;
  				} else {
--- 231,246 ----
  			}
  		} else if(strcmp(p->name, XNSpotLocation)==0) {
  			if(im_preedit_flag) {
! 				p_point = (XPoint *)Xmalloc(sizeof(XPoint));
! 				xptr = (XPointer *)p->value;
! 				*xptr = (XPointer)p_point;
  				p_point->x = preedit_data->SpotLocation.x;
  				p_point->y = preedit_data->SpotLocation.y;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_SPOTL_MASK) {
! 					p_point = (XPoint *)Xmalloc(sizeof(XPoint));
! 					xptr = (XPointer *)p->value;
! 					*xptr = (XPointer)p_point;
  					p_point->x = ic->core.preedit_attr.spot_location.x;
  					p_point->y = ic->core.preedit_attr.spot_location.y;
  				} else {
***************
*** 391,396 ****
--- 400,406 ----
  	int		 im_font_flag    = 0;
  	Ximp_StatusPropRec	*status_data;
  	XIMCallback 	*p_callback;
+ 	XPointer	*xptr;
  
  	if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver) {
  		for(mask = 0, p = vl; p->name != NULL; p++) {
***************
*** 446,458 ****
  			}
  		} else if(strcmp(p->name, XNAreaNeeded)==0) {
  			if(im_status_flag) {
! 				p_rect =  (XRectangle *)(p->value) ;
  				p_rect->x  = p_rect->y  = 0;
  				p_rect->width   = status_data->AreaNeeded.width;
  				p_rect->height  = status_data->AreaNeeded.height;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_AREANEED_MASK) {
! 					p_rect =  (XRectangle *)(p->value) ;
  					p_rect->x  = p_rect->y  = 0;
  					p_rect->width   = ic->core.status_attr.area_needed.width;
  					p_rect->height  = ic->core.status_attr.area_needed.height;
--- 456,472 ----
  			}
  		} else if(strcmp(p->name, XNAreaNeeded)==0) {
  			if(im_status_flag) {
! 				p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle));
! 				xptr = (XPointer *)p->value;
! 				*xptr = (XPointer)p_rect;
  				p_rect->x  = p_rect->y  = 0;
  				p_rect->width   = status_data->AreaNeeded.width;
  				p_rect->height  = status_data->AreaNeeded.height;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_AREANEED_MASK) {
! 					p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle));
! 					xptr = (XPointer *)p->value;
! 					*xptr = (XPointer)p_rect;
  					p_rect->x  = p_rect->y  = 0;
  					p_rect->width   = ic->core.status_attr.area_needed.width;
  					p_rect->height  = ic->core.status_attr.area_needed.height;
*** /tmp/,RCSt1000399	Tue Mar 17 11:58:24 1992
--- mit/lib/X/Ximp/XimpRm.c	Tue Mar  3 11:04:09 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpRm.c,v 1.2 91/10/07 17:50:27 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: XimpRm.c,v 1.3 92/03/03 11:03:30 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, by FUJITSU LIMITED
***************
*** 124,130 ****
  	XColor		 screen_def, exact_def;
  	int		 num;
  
! 	im = (Ximp_XIM)XIMOfIC(ic);
  	if(im->core.rdb == NULL)
  		return;
  
--- 124,130 ----
  	XColor		 screen_def, exact_def;
  	int		 num;
  
! 	im = (Ximp_XIM)XIMOfIC((XIC)ic);
  	if(im->core.rdb == NULL)
  		return;
  
*** /tmp/,RCSt1029884	Tue Mar 17 11:38:34 1992
--- mit/lib/Xt/Shell.c	Fri Feb 21 12:42:37 1992
***************
*** 1,4 ****
! /* $XConsortium: Shell.c,v 1.120 91/12/06 16:16:40 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Shell.c,v 1.124 92/02/21 12:34:32 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 1104,1111 ****
  	    || sizep->max_aspect.y != XtUnspecifiedShellInt) {
  	    sizep->flags |= PAspect;
  	}
! 	if(w->wm.base_width != XtUnspecifiedShellInt
! 	   || w->wm.base_height != XtUnspecifiedShellInt) {
  	    sizep->flags |= PBaseSize;
  	    if (w->wm.base_width == XtUnspecifiedShellInt)
  		w->wm.base_width = 0;
--- 1104,1112 ----
  	    || sizep->max_aspect.y != XtUnspecifiedShellInt) {
  	    sizep->flags |= PAspect;
  	}
! 	if (sizep->flags & PBaseSize
! 	    || w->wm.base_width != XtUnspecifiedShellInt
! 	    || w->wm.base_height != XtUnspecifiedShellInt) {
  	    sizep->flags |= PBaseSize;
  	    if (w->wm.base_width == XtUnspecifiedShellInt)
  		w->wm.base_width = 0;
***************
*** 1112,1124 ****
  	    if (w->wm.base_height == XtUnspecifiedShellInt)
  		w->wm.base_height = 0;
  	}
! 	if (sizep->width_inc != XtUnspecifiedShellInt
  	    || sizep->height_inc != XtUnspecifiedShellInt) {
  	    if (sizep->width_inc < 1) sizep->width_inc = 1;
  	    if (sizep->height_inc < 1) sizep->height_inc = 1;
  	    sizep->flags |= PResizeInc;
  	}
! 	if (sizep->max_width != XtUnspecifiedShellInt
  	    || sizep->max_height != XtUnspecifiedShellInt) {
  	    sizep->flags |= PMaxSize;
  	    if (sizep->max_width == XtUnspecifiedShellInt)
--- 1113,1127 ----
  	    if (w->wm.base_height == XtUnspecifiedShellInt)
  		w->wm.base_height = 0;
  	}
! 	if (sizep->flags & PResizeInc
! 	    || sizep->width_inc != XtUnspecifiedShellInt
  	    || sizep->height_inc != XtUnspecifiedShellInt) {
  	    if (sizep->width_inc < 1) sizep->width_inc = 1;
  	    if (sizep->height_inc < 1) sizep->height_inc = 1;
  	    sizep->flags |= PResizeInc;
  	}
! 	if (sizep->flags & PMaxSize
! 	    || sizep->max_width != XtUnspecifiedShellInt
  	    || sizep->max_height != XtUnspecifiedShellInt) {
  	    sizep->flags |= PMaxSize;
  	    if (sizep->max_width == XtUnspecifiedShellInt)
***************
*** 1126,1133 ****
  	    if (sizep->max_height == XtUnspecifiedShellInt)
  		sizep->max_height = BIGSIZE;
  	}
! 	if(sizep->min_width != XtUnspecifiedShellInt
! 	   || sizep->min_height != XtUnspecifiedShellInt) {
  	    sizep->flags |= PMinSize;
  	    if (sizep->min_width == XtUnspecifiedShellInt)
  		sizep->min_width = 1;
--- 1129,1137 ----
  	    if (sizep->max_height == XtUnspecifiedShellInt)
  		sizep->max_height = BIGSIZE;
  	}
! 	if (sizep->flags & PMinSize
! 	    || sizep->min_width != XtUnspecifiedShellInt
! 	    || sizep->min_height != XtUnspecifiedShellInt) {
  	    sizep->flags |= PMinSize;
  	    if (sizep->min_width == XtUnspecifiedShellInt)
  		sizep->min_width = 1;
***************
*** 1766,1777 ****
  	_SetWMSizeHints((WMShellWidget)w);
      }
  
!     if (w->shell.override_redirect) return XtGeometryDone;
  
      /* If no non-stacking bits are set, there's no way to tell whether
         or not this worked, so assume it did */
  
!     if (!(mask & ~(CWStackMode | CWSibling))) return XtGeometryDone;
  
      if (wm && ((WMShellWidget)w)->wm.wait_for_wm == FALSE) {
  	    /* the window manager is sick
--- 1770,1781 ----
  	_SetWMSizeHints((WMShellWidget)w);
      }
  
!     if (w->shell.override_redirect) return XtGeometryYes;
  
      /* If no non-stacking bits are set, there's no way to tell whether
         or not this worked, so assume it did */
  
!     if (!(mask & ~(CWStackMode | CWSibling))) return XtGeometryYes;
  
      if (wm && ((WMShellWidget)w)->wm.wait_for_wm == FALSE) {
  	    /* the window manager is sick
***************
*** 1818,1824 ****
  		    w->shell.client_specified |= _XtShellPositionValid;
  		}
  		else w->shell.client_specified &= ~_XtShellPositionValid;
! 		return XtGeometryDone;
  	    }
  	} else if (!wm ||
  		   (event.type == ClientMessage &&
--- 1822,1828 ----
  		    w->shell.client_specified |= _XtShellPositionValid;
  		}
  		else w->shell.client_specified &= ~_XtShellPositionValid;
! 		return XtGeometryYes;
  	    }
  	} else if (!wm ||
  		   (event.type == ClientMessage &&
***************
*** 1830,1836 ****
  	    w->core.x = event.xclient.data.s[0];
  	    w->core.y = event.xclient.data.s[1];
  	    w->shell.client_specified |= _XtShellPositionValid;
! 	    return XtGeometryDone;
  	} else XtAppWarningMsg(XtWidgetToApplicationContext((Widget)w),
  			       "internalError", "shell", XtCXtToolkitError,
  			       "Shell's window manager interaction is broken",
--- 1834,1840 ----
  	    w->core.x = event.xclient.data.s[0];
  	    w->core.y = event.xclient.data.s[1];
  	    w->shell.client_specified |= _XtShellPositionValid;
! 	    return XtGeometryYes;
  	} else XtAppWarningMsg(XtWidgetToApplicationContext((Widget)w),
  			       "internalError", "shell", XtCXtToolkitError,
  			       "Shell's window manager interaction is broken",
***************
*** 1948,1956 ****
  	}
  #undef NEQ
  
!  	if (set_prop && nwmshell->wm.transient != owmshell->wm.transient) {
   	    if (nwmshell->wm.transient) {
  		if (!XtIsTransientShell(new) &&
  		    nwmshell->wm.wm_hints.window_group != 
  		       XtUnspecifiedWindowGroup)
  		    XSetTransientForHint(XtDisplay(new), XtWindow(new),
--- 1952,1962 ----
  	}
  #undef NEQ
  
!  	if (XtIsRealized(new) &&
! 	    nwmshell->wm.transient != owmshell->wm.transient) {
   	    if (nwmshell->wm.transient) {
  		if (!XtIsTransientShell(new) &&
+ 		    !nwmshell->shell.override_redirect &&
  		    nwmshell->wm.wm_hints.window_group != 
  		       XtUnspecifiedWindowGroup)
  		    XSetTransientForHint(XtDisplay(new), XtWindow(new),
***************
*** 1973,1982 ****
      TransientShellWidget new = (TransientShellWidget)newW;
      
      if (XtIsRealized(newW)
! 	&& ((new->transient.transient_for != old->transient.transient_for)
! 	    || (new->transient.transient_for == NULL
! 		&& (new->wm.wm_hints.window_group
! 		    != old->wm.wm_hints.window_group)))) {
  
  	_SetTransientForHint(new, True);
      }
--- 1979,1989 ----
      TransientShellWidget new = (TransientShellWidget)newW;
      
      if (XtIsRealized(newW)
! 	&& ((new->wm.transient && !old->wm.transient)
! 	    || ((new->transient.transient_for != old->transient.transient_for)
! 		|| (new->transient.transient_for == NULL
! 		    && (new->wm.wm_hints.window_group
! 			!= old->wm.wm_hints.window_group))))) {
  
  	_SetTransientForHint(new, True);
      }
*** /tmp/,RCSt1029904	Tue Mar 17 11:40:32 1992
--- mit/lib/Xt/Geometry.c	Tue Feb 11 17:14:44 1992
***************
*** 1,4 ****
! /* $XConsortium: Geometry.c,v 1.54 91/09/23 11:09:45 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Geometry.c,v 1.55 92/02/11 17:13:18 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 68,74 ****
      XtGeometryResult returnCode;
      Widget parent = widget->core.parent;
      XtGeometryMask	changeMask;
!     Boolean managed, parentRealized;
      XWindowChanges changes;
  
      *clear_rect_obj = FALSE;
--- 68,74 ----
      XtGeometryResult returnCode;
      Widget parent = widget->core.parent;
      XtGeometryMask	changeMask;
!     Boolean managed, parentRealized, rgm = False;
      XWindowChanges changes;
  
      *clear_rect_obj = FALSE;
***************
*** 84,89 ****
--- 84,90 ----
  	    if (  ext->version == XtShellExtensionVersion
  		  && ext->record_size == sizeof(ShellClassExtensionRec)) {
  		manager = ext->root_geometry_manager;
+ 		rgm = True;
  	    } else {
  		String params[1];
  		Cardinal num_params = 1;
***************
*** 215,220 ****
--- 216,224 ----
      }
  
      if (XtIsWidget(widget)) {	/* reconfigure the window (if needed) */
+ 
+ 	if (rgm) return returnCode;
+ 
  	if (changes.x != widget->core.x) {
   	    changeMask |= CWX;
   	    changes.x = widget->core.x;
*** /tmp/,RCSt1029924	Tue Mar 17 11:41:32 1992
--- mit/lib/Xt/Convert.c	Thu Feb 27 17:09:51 1992
***************
*** 1,4 ****
! /* $XConsortium: Convert.c,v 1.63 91/11/26 13:54:29 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Convert.c,v 1.65 92/02/27 17:08:12 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 64,70 ****
  	ConverterPtr rec;
  	int i;
  	XtCacheType cache_type;
! 	for (i = CONVERTHASHSIZE; --i >- 0; ) {
  	    for (rec = *globalConverterTable++; rec; rec = rec->next) {
  		cache_type = rec->cache_type;
  		if (rec->do_ref_count)
--- 64,70 ----
  	ConverterPtr rec;
  	int i;
  	XtCacheType cache_type;
! 	for (i = CONVERTHASHSIZE; --i >= 0; ) {
  	    for (rec = *globalConverterTable++; rec; rec = rec->next) {
  		cache_type = rec->cache_type;
  		if (rec->do_ref_count)
***************
*** 738,747 ****
--- 738,755 ----
      {
  	Heap *heap;
  	XtPointer closure = NULL;
+ 	unsigned int supplied_size = to->size;
  	Boolean do_ref = cP->do_ref_count && cache_ref_return;
  	Boolean do_free = False;
  	Boolean retval =
  	    (*(XtTypeConverter)converter)(dpy, args, &num_args, from, to, &closure);
+ 
+ 	if (retval == False && supplied_size < to->size) {
+ 	    /* programmer error: caller must allocate sufficient storage */
+ 	    *cache_ref_return = NULL;
+ 	    return False;
+ 	}
+ 
  	if ((cP->cache_type == XtCacheNone) || do_ref) {
  	    heap = NULL;
  	    do_free = True;
*** /tmp/,RCSt1029964	Tue Mar 17 11:44:10 1992
--- mit/lib/Xt/Event.c	Fri Feb 21 15:56:45 1992
***************
*** 1,4 ****
! /* $XConsortium: Event.c,v 1.135 91/10/25 13:19:23 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Event.c,v 1.136 92/02/21 15:54:06 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 510,516 ****
  
  #define EHMAXSIZE 25 /* do not make whopping big */
  
! static void CallEventHandlers(widget, event, mask)
      Widget     widget;
      XEvent    *event;
      EventMask  mask;
--- 510,516 ----
  
  #define EHMAXSIZE 25 /* do not make whopping big */
  
! static Boolean CallEventHandlers(widget, event, mask)
      Widget     widget;
      XEvent    *event;
      EventMask  mask;
***************
*** 551,556 ****
--- 551,557 ----
  	(*(proc[i]))(widget, closure[i], event, &cont_to_disp);
      if (numprocs > EHMAXSIZE)
  	XtFree((char *)proc);
+     return cont_to_disp;
  }
  
  static Region nullRegion;
***************
*** 574,579 ****
--- 575,581 ----
      XEvent nextEvent;
      Boolean was_dispatched = XtDidNothing;
      Boolean call_tm = XtDidNothing;
+     Boolean cont_to_disp;
  
      if (XFilterEvent(event, XtWindow(widget)))
  	return XtDidFilter;
***************
*** 652,657 ****
--- 654,661 ----
      if (widget->core.tm.translations &&
  	(mask & widget->core.tm.translations->eventMask))
  	call_tm = XtDidDispatch;
+ 
+     cont_to_disp = True;
      p=widget->core.event_table;
      if (p) {
  	if (p->next) {
***************
*** 673,682 ****
  	    }
  	    if (numprocs) {
  		if (p) {
! 		    CallEventHandlers(widget, event, mask);
  		} else {
  		    int i;
- 		    Boolean cont_to_disp = True;
  		    for (i = 0; i < numprocs && cont_to_disp; i++)
  			(*(proc[i]))(widget, closure[i], event, &cont_to_disp);
  		}
--- 677,685 ----
  	    }
  	    if (numprocs) {
  		if (p) {
! 		    cont_to_disp = CallEventHandlers(widget, event, mask);
  		} else {
  		    int i;
  		    for (i = 0; i < numprocs && cont_to_disp; i++)
  			(*(proc[i]))(widget, closure[i], event, &cont_to_disp);
  		}
***************
*** 683,694 ****
  		was_dispatched = XtDidDispatch;
  	    }
  	} else if (mask & p->mask) {
  	    was_dispatched = XtDidDispatch;
- 	    (*p->proc)(widget, p->closure, event, &was_dispatched);
- 	    was_dispatched = XtDidDispatch;
  	}
      }
!     if (call_tm)
  	_XtTranslateEvent(widget, event);
      return (was_dispatched|call_tm);
  }
--- 686,696 ----
  		was_dispatched = XtDidDispatch;
  	    }
  	} else if (mask & p->mask) {
+ 	    (*p->proc)(widget, p->closure, event, &cont_to_disp);
  	    was_dispatched = XtDidDispatch;
  	}
      }
!     if (call_tm && cont_to_disp)
  	_XtTranslateEvent(widget, event);
      return (was_dispatched|call_tm);
  }
*** /tmp/,RCSt1029986	Tue Mar 17 11:45:45 1992
--- mit/lib/Xt/TranslateI.h	Mon Feb 24 17:44:54 1992
***************
*** 1,4 ****
! /* $XConsortium: TranslateI.h,v 1.42 91/06/14 17:58:41 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: TranslateI.h,v 1.43 92/02/24 17:42:20 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 59,64 ****
--- 59,65 ----
  typedef struct _LateBindings {
      unsigned int knot:1;
      unsigned int pair:1;
+     unsigned short ref_count;	/* garbage collection */
      KeySym keysym;
  } LateBindings, *LateBindingsPtr;
  
*** /tmp/,RCSt1000106	Tue Mar 17 11:47:21 1992
--- mit/lib/Xt/TMparse.c	Thu Mar  5 18:49:55 1992
***************
*** 1,4 ****
! /* $XConsortium: TMparse.c,v 1.123 91/07/28 11:52:14 swick Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: TMparse.c,v 1.128 92/03/05 18:48:55 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 528,533 ****
--- 528,535 ----
          *lateBindings = temp;
          temp[count].knot = notL;
          temp[count].pair = pair;
+ 	if (count == 0)
+ 	    temp[count].ref_count = 1;
          temp[count++].keysym = keysymL;
          if (keysymR){
              temp[count].knot = notR;
***************
*** 1012,1019 ****
      EventPtr event;
      Boolean* error;
  {
-     char atomName[1000], *start;
- 
      ScanWhitespace(str);
  
      if (*str == ',' || *str == ':') {
--- 1014,1019 ----
***************
*** 1021,1026 ****
--- 1021,1027 ----
  	event->event.eventCode = 0L;
          event->event.eventCodeMask = 0L;
      } else {
+ 	char *start, atomName[1000];
  	start = str;
  	while (
  		*str != ','
***************
*** 1037,1043 ****
  	bcopy(start, atomName, str-start);
  	atomName[str-start] = '\0';
  	event->event.eventCode = XrmStringToQuark(atomName);
- 	event->event.eventCodeMask = ~0L;
  	event->event.matchEvent = _XtMatchAtom;
      }
      return str;
--- 1038,1043 ----
***************
*** 1046,1055 ****
  static ModifierMask buttonModifierMasks[] = {
      0, Button1Mask, Button2Mask, Button3Mask, Button4Mask, Button5Mask
  };
  
! static String ParseEvent(str, event,error)
      register String str;
      EventPtr	event;
      Boolean* error;
  {
      Cardinal	tmEvent;
--- 1046,1058 ----
  static ModifierMask buttonModifierMasks[] = {
      0, Button1Mask, Button2Mask, Button3Mask, Button4Mask, Button5Mask
  };
+ static String ParseRepeat();
  
! static String ParseEvent(str, event, reps, plus, error)
      register String str;
      EventPtr	event;
+     int*	reps;
+     Boolean*	plus;
      Boolean* error;
  {
      Cardinal	tmEvent;
***************
*** 1070,1075 ****
--- 1073,1082 ----
           return PanicModeRecovery(str);
      }
      else str++;
+     if (*str == '(') {
+ 	str = ParseRepeat(str, reps, plus, error);
+ 	if (*error) return str;
+     }
      str = (*(events[tmEvent].parseDetail))(
          str, events[tmEvent].closure, event,error);
      if (*error) return str;
***************
*** 1136,1141 ****
--- 1143,1156 ----
      return str;
  }
  
+ 
+ static EventSeqRec timerEventRec = {
+     {0, 0, NULL, _XtEventTimerEventType, 0L, 0L, NULL},
+     /* (StatePtr) -1 */ NULL,
+     NULL,
+     NULL
+ };
+ 
  static void RepeatDown(eventP, reps, actionsP)
      EventPtr *eventP;
      int reps;
***************
*** 1146,1158 ****
      EventPtr upEvent = &upEventRec;
      register int i;
  
-     static EventSeqRec timerEventRec = {
- 	{0, 0,NULL, _XtEventTimerEventType, 0L, 0L,NULL},
- 	/* (StatePtr) -1 */ NULL,
- 	NULL,
- 	NULL
-     };
- 
      downEvent = event = *eventP;
      *upEvent = *downEvent;
      upEvent->event.eventType = ((event->event.eventType == ButtonPress) ?
--- 1161,1166 ----
***************
*** 1163,1168 ****
--- 1171,1179 ----
  	upEvent->event.modifiers
  	    |= buttonModifierMasks[event->event.eventCode];
  
+     if (event->event.lateModifiers)
+ 	event->event.lateModifiers->ref_count += (reps - 1) * 2;
+ 
      for (i=1; i<reps; i++) {
  
  	/* up */
***************
*** 1197,1209 ****
      EventPtr upEvent = &upEventRec;
      register int i;
  
-     static EventSeqRec timerEventRec = {
- 	{0, 0,NULL, _XtEventTimerEventType, 0L, 0L,NULL},
- 	/* (StatePtr) -1 */ NULL,
- 	NULL,
- 	NULL
-     };
- 
      downEvent = event = *eventP;
      *upEvent = *downEvent;
      upEvent->event.eventType = ((event->event.eventType == ButtonPress) ?
--- 1208,1213 ----
***************
*** 1214,1219 ****
--- 1218,1226 ----
  	upEvent->event.modifiers
  	    |= buttonModifierMasks[event->event.eventCode];
  
+     if (event->event.lateModifiers)
+ 	event->event.lateModifiers->ref_count += reps * 2 - 1;
+ 
      for (i=0; i<reps; i++) {
  
  	if (i > 0) {
***************
*** 1251,1263 ****
      EventPtr upEvent = &upEventRec;
      register int i;
  
-     static EventSeqRec timerEventRec = {
- 	{0, 0,NULL, _XtEventTimerEventType, 0L, 0L,NULL},
- 	/* (StatePtr) -1 */ NULL,
- 	NULL,
- 	NULL
-     };
- 
      /* the event currently sitting in *eventP is an "up" event */
      /* we want to make it a "down" event followed by an "up" event, */
      /* so that sequence matching on the "state" side works correctly. */
--- 1258,1263 ----
***************
*** 1272,1277 ****
--- 1272,1280 ----
  	downEvent->event.modifiers
  	    &= ~buttonModifierMasks[event->event.eventCode];
  
+     if (event->event.lateModifiers)
+ 	event->event.lateModifiers->ref_count += reps * 2 - 1;
+ 
      /* up */
      event->next = XtNew(EventSeqRec);
      event = event->next;
***************
*** 1311,1323 ****
      EventPtr upEvent = &upEventRec;
      register int i;
  
-     static EventSeqRec timerEventRec = {
- 	{0, 0,NULL, _XtEventTimerEventType, 0L, 0L,NULL},
- 	/* (StatePtr) -1 */ NULL,
- 	NULL,
- 	NULL
-     };
- 
      /* the event currently sitting in *eventP is an "up" event */
      /* we want to make it a "down" event followed by an "up" event, */
      /* so that sequence matching on the "state" side works correctly. */
--- 1314,1319 ----
***************
*** 1332,1337 ****
--- 1328,1336 ----
  	downEvent->event.modifiers
  	    &= ~buttonModifierMasks[event->event.eventCode];
  
+     if (event->event.lateModifiers)
+ 	event->event.lateModifiers->ref_count += reps * 2;
+ 
      for (i=0; i<reps; i++) {
  
  	/* up */
***************
*** 1366,1371 ****
--- 1365,1373 ----
  
      tempEvent = event = *eventP;
  
+     if (event->event.lateModifiers)
+ 	event->event.lateModifiers->ref_count += reps - 1;
+ 
      for (i=1; i<reps; i++) {
  	event->next = XtNew(EventSeqRec);
  	event = event->next;
***************
*** 1386,1391 ****
--- 1388,1396 ----
  
      tempEvent = event = *eventP;
  
+     if (event->event.lateModifiers)
+ 	event->event.lateModifiers->ref_count += reps - 1;
+ 
      for (i=1; i<reps; i++) {
  	event->next = XtNew(EventSeqRec);
  	event = event->next;
***************
*** 1423,1445 ****
      }
  }
  
! static String ParseRepeat(str, eventP, actionsP)
      register String str;
!     EventPtr *eventP;
!     ActionPtr **actionsP;
  {
-     int reps;
-     Boolean plus = FALSE;
-     String right_paren;
  
      /*** Parse the repetitions, for double click etc... ***/
!     if (*str != '(') return str;
      str++;
!     right_paren = str;
!     ScanFor(right_paren, ')');
!     if (isascii(*str) && isdigit(*str)) {
  	String start = str;
! 	char repStr[100];
  	int len;
  
  	ScanNumeric(str);
--- 1428,1446 ----
      }
  }
  
! static String ParseRepeat(str, reps, plus, error)
      register String str;
!     int	*reps;
!     Boolean *plus, *error;
  {
  
      /*** Parse the repetitions, for double click etc... ***/
!     if (*str != '(' || !(isdigit(str[1]) || str[1] == '+' || str[1] == ')'))
! 	return str;
      str++;
!     if (isdigit(*str)) {
  	String start = str;
! 	char repStr[7];
  	int len;
  
  	ScanNumeric(str);
***************
*** 1447,1464 ****
  	if (len < sizeof repStr) {
  	    bcopy(start, repStr, len);
  	    repStr[len] = '\0';
! 	    reps = StrToNum(repStr);
  	} else {
! 	    Syntax ("Repeat count too large; ignored.", "");
! 	    return right_paren;
  	}
!     } else {
  	Syntax("Missing repeat count.","");
! 	return right_paren;
      }
  
      if (*str == '+') {
! 	plus = TRUE;
  	str++;
      }
      if (*str == ')')
--- 1448,1468 ----
  	if (len < sizeof repStr) {
  	    bcopy(start, repStr, len);
  	    repStr[len] = '\0';
! 	    *reps = StrToNum(repStr);
  	} else {
! 	    Syntax("Repeat count too large.", "");
! 	    *error = True;
! 	    return str;
  	}
!     }
!     if (*reps == 0) {
  	Syntax("Missing repeat count.","");
! 	*error = True;
! 	return str;
      }
  
      if (*str == '+') {
! 	*plus = TRUE;
  	str++;
      }
      if (*str == ')')
***************
*** 1465,1475 ****
  	str++;
      else {
  	Syntax("Missing ')'.","");
! 	return right_paren;
      }
  
-     if (reps > 1 || plus) RepeatEvent(eventP, reps, plus, actionsP);
- 
      return str;
  }
  
--- 1469,1477 ----
  	str++;
      else {
  	Syntax("Missing ')'.","");
! 	*error = True;
      }
  
      return str;
  }
  
***************
*** 1525,1530 ****
--- 1527,1535 ----
               }
               else str++;
  	} else {
+ 	    int reps = 0;
+ 	    Boolean plus = False;
+ 
              event = XtNew(EventRec);
              event->event = nullEvent;
              event->state = /* (StatePtr) -1 */ NULL;
***************
*** 1531,1541 ****
              event->next = NULL;
              event->actions = NULL;
  
! 	    str = ParseEvent(str, event,error);
              if (*error) return str;
  	    *nextEvent = event;
  	    *actionsP = &event->actions;
! 	    str = ParseRepeat(str, &event, actionsP);
  	    nextEvent = &event->next;
  	}
  	ScanWhitespace(str);
--- 1536,1547 ----
              event->next = NULL;
              event->actions = NULL;
  
! 	    str = ParseEvent(str, event, &reps, &plus, error);
              if (*error) return str;
  	    *nextEvent = event;
  	    *actionsP = &event->actions;
! 	    if (reps > 1 || plus)
! 		RepeatEvent(&event, reps, plus, actionsP);
  	    nextEvent = &event->next;
  	}
  	ScanWhitespace(str);
*** /tmp/,RCSt1000130	Tue Mar 17 11:48:45 1992
--- mit/lib/Xt/TMstate.c	Thu Feb 27 17:06:01 1992
***************
*** 1,4 ****
! /* $XConsortium: TMstate.c,v 1.159 91/12/03 16:33:34 converse Exp $ */
  /*LINTLIBRARY*/
  
  /***********************************************************
--- 1,4 ----
! /* $XConsortium: TMstate.c,v 1.161 92/02/27 17:04:04 converse Exp $ */
  /*LINTLIBRARY*/
  
  /***********************************************************
***************
*** 299,305 ****
  		 * late modifiers. If there isn't a match we use the
  		 * parser's copy
  		 */
! 		if (event->lateModifiers) {
  		    XtFree((char *)event->lateModifiers);
  		    event->lateModifiers = NULL;
  		}
--- 299,306 ----
  		 * late modifiers. If there isn't a match we use the
  		 * parser's copy
  		 */
! 		if (event->lateModifiers &&
! 		    --event->lateModifiers->ref_count == 0) {
  		    XtFree((char *)event->lateModifiers);
  		    event->lateModifiers = NULL;
  		}
***************
*** 396,409 ****
      TMModifierMatch	modMatch;
      TMEventPtr 		eventSeq;
  {
!     if (typeMatch->eventCodeMask) {	/* first time? */
! 	typeMatch->eventCode = XInternAtom( eventSeq->xev->xany.display,
! 				        XrmQuarkToString(typeMatch->eventCode),
! 				        False
! 				      );
! 	typeMatch->eventCodeMask = 0L;
!     }
!     return (typeMatch->eventCode == eventSeq->event.eventCode);
  }
  
  #define IsOn(vec,idx) ((vec)[(idx)>>3] & (1 << ((idx) & 7)))
--- 397,408 ----
      TMModifierMatch	modMatch;
      TMEventPtr 		eventSeq;
  {
!     Atom	atom;
! 
!     atom = XInternAtom(eventSeq->xev->xany.display, 
! 		       XrmQuarkToString(typeMatch->eventCode),
! 		       False);
!     return (atom == eventSeq->event.eventCode);
  }
  
  #define IsOn(vec,idx) ((vec)[(idx)>>3] & (1 << ((idx) & 7)))
*** /tmp/,RCSt1000448	Tue Mar 17 12:03:39 1992
--- mit/lib/Xaw/Panner.c	Tue Mar  3 13:54:13 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: Panner.c,v 1.43 91/08/26 10:53:17 gildea Exp $
   *
   * Copyright 1989 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: Panner.c,v 1.45 92/03/03 13:52:26 converse Exp $
   *
   * Copyright 1989 Massachusetts Institute of Technology
   *
***************
*** 483,490 ****
   *****************************************************************************/
  
  
! static void Initialize (greq, gnew)
      Widget greq, gnew;
  {
      PannerWidget req = (PannerWidget) greq, new = (PannerWidget) gnew;
      Dimension defwidth, defheight;
--- 483,492 ----
   *****************************************************************************/
  
  
! static void Initialize (greq, gnew, args, num_args)
      Widget greq, gnew;
+     ArgList args;
+     Cardinal *num_args;
  {
      PannerWidget req = (PannerWidget) greq, new = (PannerWidget) gnew;
      Dimension defwidth, defheight;
***************
*** 531,537 ****
  	    gotpm = TRUE;
  	}
      }
!     (*gw->core.widget_class->core_class.superclass->core_class.realize)
        (gw, valuemaskp, attr);
  
      if (gotpm) XFreePixmap (XtDisplay(gw), pm);
--- 533,539 ----
  	    gotpm = TRUE;
  	}
      }
!     (*pannerWidgetClass->core_class.superclass->core_class.realize)
        (gw, valuemaskp, attr);
  
      if (gotpm) XFreePixmap (XtDisplay(gw), pm);
***************
*** 599,606 ****
  
  
  /* ARGSUSED */
! static Boolean SetValues (gcur, greq, gnew)
      Widget gcur, greq, gnew;
  {
      PannerWidget cur = (PannerWidget) gcur;
      PannerWidget new = (PannerWidget) gnew;
--- 601,610 ----
  
  
  /* ARGSUSED */
! static Boolean SetValues (gcur, greq, gnew, args, num_args)
      Widget gcur, greq, gnew;
+     ArgList args;
+     Cardinal *num_args;
  {
      PannerWidget cur = (PannerWidget) gcur;
      PannerWidget new = (PannerWidget) gnew;
*** /tmp/,RCSt1000745	Tue Mar 17 15:21:29 1992
--- mit/clients/xterm/Imakefile	Wed Mar 11 17:36:06 1992
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.55 91/09/22 11:40:47 rws Exp $
  XCOMM
  XCOMM                         Attention xterm porters
  XCOMM
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.56 92/03/11 17:35:22 gildea Exp $
  XCOMM
  XCOMM                         Attention xterm porters
  XCOMM
***************
*** 20,26 ****
           PTYLIB = -lpucc
  #endif
  
!    MAIN_DEFINES = -DUTMP $(TTYGROUPDEF) $(PUCCPTYDDEF)
     MISC_DEFINES = /* -DALLOWLOGFILEEXEC */
  
            SRCS1 = button.c charproc.c cursor.c data.c input.c \
--- 20,31 ----
           PTYLIB = -lpucc
  #endif
  
!  OSMAJORVERSION = OSMajorVersion
!  OSMINORVERSION = OSMinorVersion
! 
!    MAIN_DEFINES = -DUTMP $(TTYGROUPDEF) $(PUCCPTYDDEF) \
! 		  -DOSMAJORVERSION=$(OSMAJORVERSION) \
! 		  -DOSMINORVERSION=$(OSMINORVERSION)
     MISC_DEFINES = /* -DALLOWLOGFILEEXEC */
  
            SRCS1 = button.c charproc.c cursor.c data.c input.c \
*** /tmp/,RCSt1000549	Tue Mar 17 12:09:36 1992
--- mit/clients/xterm/main.c	Wed Mar 11 17:37:01 1992
***************
*** 1,5 ****
  #ifndef lint
! static char *rid="$XConsortium: main.c,v 1.199 91/12/23 17:02:24 gildea Exp $";
  #endif /* lint */
  
  /*
--- 1,5 ----
  #ifndef lint
! static char *rid="$XConsortium: main.c,v 1.200 92/03/11 17:36:12 gildea Exp $";
  #endif /* lint */
  
  /*
***************
*** 1208,1214 ****
  	strcpy(ttydev, ttyname(*pty));
  	return 0;
  #endif
! #ifdef sgi
  	{
  	    char    *tty_name;
  
--- 1208,1214 ----
  	strcpy(ttydev, ttyname(*pty));
  	return 0;
  #endif
! #if defined(sgi) && OSMAJORVERSION >= 4
  	{
  	    char    *tty_name;
  
***************
*** 1237,1243 ****
  #ifdef USE_GET_PSEUDOTTY
  	return ((*pty = getpseudotty (&ttydev, &ptydev)) >= 0 ? 0 : 1);
  #else
! #if (defined(umips) && defined (SYSTYPE_SYSV))
  	struct stat fstat_buf;
  
  	*pty = open ("/dev/ptc", O_RDWR);
--- 1237,1243 ----
  #ifdef USE_GET_PSEUDOTTY
  	return ((*pty = getpseudotty (&ttydev, &ptydev)) >= 0 ? 0 : 1);
  #else
! #if (defined(sgi) && OSMAJORVERSION < 4) || (defined(umips) && defined (SYSTYPE_SYSV))
  	struct stat fstat_buf;
  
  	*pty = open ("/dev/ptc", O_RDWR);
*** /tmp/,RCSt1000569	Tue Mar 17 12:10:45 1992
--- mit/clients/xterm/misc.c	Fri Mar 13 17:04:37 1992
***************
*** 1,5 ****
  /*
!  *	$XConsortium: misc.c,v 1.90 91/07/25 17:59:05 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  *	$XConsortium: misc.c,v 1.92 92/03/13 17:02:08 gildea Exp $
   */
  
  /*
***************
*** 254,262 ****
  			       (event->detail == NotifyPointer) ? INWINDOW :
  								  FOCUS);
  		if (screen->grabbedKbd && (event->mode == NotifyUngrab)) {
- 		    screen->grabbedKbd = FALSE;
- 		    ReverseVideo(term);
  		    XBell(screen->display, 100);
  		}
  	}
  }
--- 254,263 ----
  			       (event->detail == NotifyPointer) ? INWINDOW :
  								  FOCUS);
  		if (screen->grabbedKbd && (event->mode == NotifyUngrab)) {
  		    XBell(screen->display, 100);
+ 		    ReverseVideo(term);
+ 		    screen->grabbedKbd = FALSE;
+ 		    update_securekbd();
  		}
  	}
  }
***************
*** 570,576 ****
  
  	cp = screen->TekEmu ? Tbptr : bptr;
  	if((i = cp - screen->logstart) > 0)
! 		write(screen->logfd, screen->logstart, i);
  	screen->logstart = screen->TekEmu ? Tbuffer : buffer;
  }
  
--- 571,577 ----
  
  	cp = screen->TekEmu ? Tbptr : bptr;
  	if((i = cp - screen->logstart) > 0)
! 		write(screen->logfd, (char *)screen->logstart, i);
  	screen->logstart = screen->TekEmu ? Tbuffer : buffer;
  }
  
*** /tmp/,RCSt1000589	Tue Mar 17 12:12:00 1992
--- mit/clients/xterm/charproc.c	Fri Mar 13 18:01:33 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: charproc.c,v 1.173 91/07/22 11:32:49 gildea Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: charproc.c,v 1.176 92/03/13 18:00:30 gildea Exp $
   */
  
  /*
***************
*** 1253,1259 ****
  	if (select_mask & pty_mask && eventMode == NORMAL) {
  	    if (screen->logging)
  		FlushLog(screen);
! 	    bcnt = read(screen->respond, bptr = buffer, BUF_SIZE);
  	    if (bcnt < 0) {
  		if (errno == EIO)
  		    Cleanup (0);
--- 1253,1259 ----
  	if (select_mask & pty_mask && eventMode == NORMAL) {
  	    if (screen->logging)
  		FlushLog(screen);
! 	    bcnt = read(screen->respond, (char *)(bptr = buffer), BUF_SIZE);
  	    if (bcnt < 0) {
  		if (errno == EIO)
  		    Cleanup (0);
***************
*** 1508,1513 ****
--- 1508,1514 ----
  		switch (param[i]) {
  		case 1:			/* DECCKM			*/
  			(*func)(&termw->keyboard.flags, CURSOR_APL);
+ 			update_appcursor();
  			break;
  		case 2:			/* ANSI/VT52 mode		*/
  			if (func == bitset) {
***************
*** 1587,1593 ****
  				screen->send_mouse_pos = 0;
  			break;
  		case 38:		/* DECTEK			*/
! 			if(func == bitset & !(screen->inhibit & I_TEK)) {
  				if(screen->logging) {
  					FlushLog(screen);
  					screen->logstart = Tbuffer;
--- 1588,1594 ----
  				screen->send_mouse_pos = 0;
  			break;
  		case 38:		/* DECTEK			*/
! 			if(func == bitset && !(screen->inhibit & I_TEK)) {
  				if(screen->logging) {
  					FlushLog(screen);
  					screen->logstart = Tbuffer;
***************
*** 1812,1818 ****
  		case 44:		/* margin bell			*/
  			if(!(screen->marginbell = screen->save_modes[12]))
  				screen->bellarmed = -1;
! 			update_visualbell();
  			break;
  		case 45:		/* reverse wraparound	*/
  			termw->flags &= ~REVERSEWRAP;
--- 1813,1819 ----
  		case 44:		/* margin bell			*/
  			if(!(screen->marginbell = screen->save_modes[12]))
  				screen->bellarmed = -1;
! 			update_marginbell();
  			break;
  		case 45:		/* reverse wraparound	*/
  			termw->flags &= ~REVERSEWRAP;
***************
*** 2149,2158 ****
  }
  
  
! static void VTInitialize (request, new)
!    XtermWidget request, new;
  {
     int i;
     /* Zero out the entire "screen" component of "new" widget,
        then do field-by-field assigment of "screen" fields
        that are named in the resource list. */
--- 2150,2165 ----
  }
  
  
! /* ARGSUSED */
! static void VTInitialize (wrequest, wnew, args, num_args)
!    Widget wrequest, wnew;
!    ArgList args;
!    Cardinal *num_args;
  {
+    XtermWidget request = (XtermWidget) wrequest;
+    XtermWidget new     = (XtermWidget) wnew;
     int i;
+ 
     /* Zero out the entire "screen" component of "new" widget,
        then do field-by-field assigment of "screen" fields
        that are named in the resource list. */
***************
*** 2402,2408 ****
  	screen->bot_marg = screen->max_row = Height(screen) /
  				screen->fullVwin.f_height - 1;
  
! 	screen->sc.row = screen->sc.col = screen->sc.flags = NULL;
  
  	/* Mark screen buffer as unallocated.  We wait until the run loop so
  	   that the child process does not fork and exec with all the dynamic
--- 2409,2415 ----
  	screen->bot_marg = screen->max_row = Height(screen) /
  				screen->fullVwin.f_height - 1;
  
! 	screen->sc.row = screen->sc.col = screen->sc.flags = 0;
  
  	/* Mark screen buffer as unallocated.  We wait until the run loop so
  	   that the child process does not fork and exec with all the dynamic
***************
*** 2411,2417 ****
  	if (!tekWidget)			/* if not called after fork */
  	  screen->buf = screen->allbuf = NULL;
  
! 	screen->do_wrap = NULL;
  	screen->scrolls = screen->incopy = 0;
  	set_vt_box (screen);
  
--- 2418,2424 ----
  	if (!tekWidget)			/* if not called after fork */
  	  screen->buf = screen->allbuf = NULL;
  
! 	screen->do_wrap = 0;
  	screen->scrolls = screen->incopy = 0;
  	set_vt_box (screen);
  
***************
*** 2641,2647 ****
  	term->flags &= ~ORIGIN;
  	if(full) {
  		TabReset (term->tabs);
! 		term->keyboard.flags = NULL;
  		update_appcursor();
  		update_appkeypad();
  		screen->gsets[0] = 'B';
--- 2648,2654 ----
  	term->flags &= ~ORIGIN;
  	if(full) {
  		TabReset (term->tabs);
! 		term->keyboard.flags = 0;
  		update_appcursor();
  		update_appkeypad();
  		screen->gsets[0] = 'B';
*** /tmp/,RCSt1029848	Tue Mar 17 11:36:12 1992
--- mit/clients/editres/widgets.c	Tue Feb 11 11:49:17 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: widgets.c,v 1.19 91/12/06 17:20:00 dave Exp $
   *
   * Copyright 1989 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: widgets.c,v 1.20 92/02/11 11:44:24 dave Exp $
   *
   * Copyright 1989 Massachusetts Institute of Technology
   *
***************
*** 835,840 ****
--- 835,842 ----
      WNode * node = (WNode *) ptr;
      NameInfo *old_name, *name = node->resources->res_box->name_info;
      
+     global_resource_box_up = FALSE;
+ 
      XtFree((XtPointer) node->resources->res_box);
      node->resources->res_box = NULL;
  
*** /tmp/,RCSt1029866	Tue Mar 17 11:37:36 1992
--- mit/clients/editres/handler.c	Tue Feb 11 11:49:22 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: handler.c,v 1.25 91/10/09 17:36:13 dave Exp $
   *
   * Copyright 1989 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: handler.c,v 1.26 92/02/11 11:45:31 dave Exp $
   *
   * Copyright 1989 Massachusetts Institute of Technology
   *
***************
*** 561,569 ****
  XtPointer shell_ptr, junk;
  {
      Widget shell = (Widget) shell_ptr;
- 
-     if (streq(XtName(shell), RESOURCE_BOX))
- 	global_resource_box_up = FALSE;
  
      XtPopdown(shell);
      XtDestroyWidget(shell);
--- 561,566 ----
*** /tmp/,RCSt1029944	Tue Mar 17 11:42:43 1992
--- mit/clients/xauth/process.c	Tue Feb 18 18:05:08 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: process.c,v 1.41 92/01/22 23:39:12 gildea Exp $
   *
   * Copyright 1989 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: process.c,v 1.42 92/02/18 18:05:00 gildea Exp $
   *
   * Copyright 1989 Massachusetts Institute of Technology
   *
***************
*** 330,348 ****
  {
      char *s;
      register char *cp;
!     char buf[2];
  
      cp = s = malloc (n);
      if (!cp) return 0;
  
      while (n > 0) {
! 	if ((buf[0] = getinput (fp)) == EOF || buf[0] == '\n' ||
! 	    (buf[1] = getinput (fp)) == EOF || buf[1] == '\n') {
  	    free (s);
  	    return 0;
  	}
! 	*cp = (char) ((hexvalues[(unsigned int)buf[0]] * 16) + 
! 		      hexvalues[(unsigned int)buf[1]]);
  	cp++;
  	n--;
      }
--- 330,347 ----
  {
      char *s;
      register char *cp;
!     int c1, c2;
  
      cp = s = malloc (n);
      if (!cp) return 0;
  
      while (n > 0) {
! 	if ((c1 = getinput (fp)) == EOF || c1 == '\n' ||
! 	    (c2 = getinput (fp)) == EOF || c2 == '\n') {
  	    free (s);
  	    return 0;
  	}
! 	*cp = (char) ((hexvalues[c1] * 16) + hexvalues[c2]);
  	cp++;
  	n--;
      }

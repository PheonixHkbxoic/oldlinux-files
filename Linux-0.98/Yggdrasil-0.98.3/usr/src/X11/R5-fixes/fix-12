		      Release 5 Public Patch #12
			   MIT X Consortium

To apply this patch:

cd to the top of the source tree (to the directory containing the "mit"
and "contrib" subdirectories) and do:
	patch -p -s < ThisFile
Patch will work silently unless an error occurs.
If you want to watch patch do its thing, leave out the "-s" argument to patch.

Finally, to rebuild after applying this patch, cd to the "mit" subdirectory
and do:
	make -k >& make.log

Brief notes on what this patch fixes:

Xlib: lots of internationalization bugs

Prereq: public-patch-11

*** /tmp/,RCSt1a09635	Sun May 17 13:35:02 1992
--- mit/bug-report	Sun May 17 13:33:01 1992
***************
*** 2,8 ****
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-11
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:
--- 2,8 ----
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-12
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:
*** /tmp/d14042	Sun May  3 18:19:16 1992
--- mit/lib/X/XSetLocale.c	Sun May  3 18:19:13 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XSetLocale.c,v 1.32 91/05/13 08:45:00 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XSetLocale.c,v 1.33 92/04/22 11:48:46 rws Exp $
   */
  
  /*
***************
*** 118,125 ****
      int   len;
  
      start = index(osname, ':');
!     if (!start)
  	return osname;
      start++;
      end = index(start, ';');
      if (!end)
--- 118,127 ----
      int   len;
  
      start = index(osname, ':');
!     if (!start) {
! 	strcpy(siname, osname);
  	return osname;
+     }
      start++;
      end = index(start, ';');
      if (!end)
*** /tmp/d15668	Sun May  3 18:33:39 1992
--- mit/lib/X/Xlcint.h	Sun May  3 18:33:36 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: Xlcint.h,v 11.13 91/06/05 09:09:43 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: Xlcint.h,v 11.14 92/04/14 15:42:59 rws Exp $
   */
  
  /*
***************
*** 89,94 ****
--- 89,96 ----
  #define	ICFontSet		12
  #define	ICLineSpace		13
  #define	ICCursor		14
+ #define	ICResourceClass		26
+ #define	ICResourceName		27
  
  #define	IMQueryInputStyle	0
  
*** /tmp/d15753	Sun May  3 18:34:25 1992
--- mit/lib/X/XlcWrap.c	Sun May  3 18:34:22 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XlcWrap.c,v 11.8 91/05/02 16:26:52 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XlcWrap.c,v 11.9 92/04/24 16:07:40 rws Exp $
   */
  
  /*
***************
*** 124,134 ****
  	i += strlen(user_mods);
      mods = Xmalloc(i);
      if (mods) {
! 	if (user_mods) {
! 	    strcpy(mods, user_mods);
! 	    strcat(mods, prog_mods);
! 	} else
! 	    strcpy(mods, prog_mods);
      }
      return mods;
  }
--- 124,132 ----
  	i += strlen(user_mods);
      mods = Xmalloc(i);
      if (mods) {
! 	strcpy(mods, prog_mods);
! 	if (user_mods)
! 	    strcat(mods, user_mods);
      }
      return mods;
  }
*** /tmp/d15866	Sun May  3 18:35:25 1992
--- mit/lib/X/Xsi/ProtoFlt.c	Sun May  3 18:35:22 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: ProtoFlt.c,v 1.26 92/03/03 10:01:17 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: ProtoFlt.c,v 1.27 92/04/24 16:13:58 rws Exp $
   */
  
  /*
***************
*** 360,369 ****
  
      if (!im || (im->fd < 0)) return(False);
      /*
!      * If key_code is larger than max_keycode, this key event be regarded
       * as the event pushed back by this filter.
       */
!     if (ev->xkey.keycode == (display->max_keycode + 1)) {
  	if (_XipTypeOfNextICQueue(ic) == XIM_KEYSYM &&
  	    (keysym = _XipKeySymOfNextICQueue(ic)) > XK_BackSpace){
  	    if ((keycode = XKeysymToKeycode(display, keysym)) != 0) {
--- 360,369 ----
  
      if (!im || (im->fd < 0)) return(False);
      /*
!      * If key_code is 0, this key event be regarded
       * as the event pushed back by this filter.
       */
!     if (ev->xkey.keycode == 0) {
  	if (_XipTypeOfNextICQueue(ic) == XIM_KEYSYM &&
  	    (keysym = _XipKeySymOfNextICQueue(ic)) > XK_BackSpace){
  	    if ((keycode = XKeysymToKeycode(display, keysym)) != 0) {
***************
*** 431,437 ****
  	    bcopy((char *)ev, (char *)&dummy_ev, sizeof(XEvent));
  	    dummy_ev.type = KeyPress;
  	    dummy_ev.xkey.state = 0;
! 	    dummy_ev.xkey.keycode = display->max_keycode + 1;
  	    if (first == 0) count--;
  	    for (i = 0; i < count; i++) {
  		XPutBackEvent(display, &dummy_ev);
--- 431,437 ----
  	    bcopy((char *)ev, (char *)&dummy_ev, sizeof(XEvent));
  	    dummy_ev.type = KeyPress;
  	    dummy_ev.xkey.state = 0;
! 	    dummy_ev.xkey.keycode = 0;
  	    if (first == 0) count--;
  	    for (i = 0; i < count; i++) {
  		XPutBackEvent(display, &dummy_ev);
***************
*** 440,446 ****
  	    if (first > 0) continue;
  	    first++;
  	    ev->xkey.state = 0;
! 	    ev->xkey.keycode = display->max_keycode + 1;
  	    if (_XipTypeOfNextICQueue(ic) == XIM_KEYSYM &&
  		(keysym = _XipKeySymOfNextICQueue(ic)) > XK_BackSpace){
  		if ((keycode = XKeysymToKeycode(display, keysym)) != 0) {
--- 440,446 ----
  	    if (first > 0) continue;
  	    first++;
  	    ev->xkey.state = 0;
! 	    ev->xkey.keycode = 0;
  	    if (_XipTypeOfNextICQueue(ic) == XIM_KEYSYM &&
  		(keysym = _XipKeySymOfNextICQueue(ic)) > XK_BackSpace){
  		if ((keycode = XKeysymToKeycode(display, keysym)) != 0) {
*** /tmp/d15993	Sun May  3 18:36:33 1992
--- mit/lib/X/Xsi/XCnvMBToCT.c	Sun May  3 18:36:31 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XCnvMBToCT.c,v 1.20 91/11/17 16:18:34 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XCnvMBToCT.c,v 1.21 92/04/14 15:54:22 rws Exp $
   */
  
  /*
***************
*** 270,276 ****
              continue;
            case SPACE:
  	    /* force designate ISO8859.1 to GL (Codeset 0) */
! 	    ctSetid(xlocale, CODESET0);
  	    goto _Normal_char;
            case CSI:
              /* not supported yet */
--- 270,276 ----
              continue;
            case SPACE:
  	    /* force designate ISO8859.1 to GL (Codeset 0) */
! 	    ctSetGLid(xlocale, CODESET0);
  	    goto _Normal_char;
            case CSI:
              /* not supported yet */
*** /tmp/d16015	Sun May  3 18:36:46 1992
--- mit/lib/X/Xsi/XCnvWCToMB.c	Sun May  3 18:36:43 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XCnvWCToMB.c,v 1.22 91/11/17 16:22:31 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XCnvWCToMB.c,v 1.23 92/04/14 15:54:49 rws Exp $
   */
  
  /*
***************
*** 296,302 ****
              wc_str++, wccnt++, wc_len--;
              continue;
          }
! 	ctid = _XcwGetWoffset(*wc_str, &newwoffset);
  	if (ctid == ND || (newcsid = _Xmbctidtocsid(xlocale, ctid)) == ND) {
  	    /* XXX BUG: if stateful encoding, need to check/add
  			designate sequence of default string.
--- 296,302 ----
              wc_str++, wccnt++, wc_len--;
              continue;
          }
! 	ctid = _XcwGetWoffsetFromLocale(xlocale, *wc_str, &newwoffset);
  	if (ctid == ND || (newcsid = _Xmbctidtocsid(xlocale, ctid)) == ND) {
  	    /* XXX BUG: if stateful encoding, need to check/add
  			designate sequence of default string.
*** /tmp/d16079	Sun May  3 18:37:19 1992
--- mit/lib/X/Xsi/XCrFntSet.c	Sun May  3 18:37:16 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XCrFntSet.c,v 1.44 92/03/03 10:00:34 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XCrFntSet.c,v 1.46 92/04/24 16:10:50 rws Exp $
   */
  
  /*
***************
*** 75,82 ****
      Display        *dpy;
      XFontSet        font_set;
  {
!     _XlcFreeLocale(((XsiFontSet)font_set)->xlc);
!     Xfree((char *) ((XsiFontSet)font_set)->ctid);
  }
  
  static RConst XFontSetMethodsRec fs_methods = {
--- 75,84 ----
      Display        *dpy;
      XFontSet        font_set;
  {
!     if (((XsiFontSet)font_set)->xlc)
! 	_XlcFreeLocale(((XsiFontSet)font_set)->xlc);
!     if (font_set->core.num_of_fonts > 0)
! 	Xfree((char *) ((XsiFontSet)font_set)->ctid);
  }
  
  static RConst XFontSetMethodsRec fs_methods = {
***************
*** 385,401 ****
          }
          start++;
      }
!     /* treat jisx0208.1983-0 same as jisx0208.1990-0 */
!     if ((i = strlen(cset)) == 15 && strlen(start) == i &&
  	*(cset+14) == *(start+14) &&
! 	!strncmp(cset, "jisx0208", 8)) {
!          return ((compareNLowercase(start, cset, 8) == 0) ? True : False);
      }
!     /* treat ISO8859.* for GL same as ISO8859.1 */
      if (GLorGR == GL && !strncmp(cset, "iso8859-", 8)) {
           return ((compareNLowercase(start, cset, 8) == 0) ? True : False);
      }
!     return ((compareLowercase(start, cset) == 0) ? True : False);
  }
  
  static int
--- 387,406 ----
          }
          start++;
      }
!     if (compareLowercase(start, cset) == 0)
! 	return (True);
! 
!     /* jisx0208.1990-0 is super set of jisx0208.1983-0 */
!     if (strlen(cset) == 15 && strlen(start) == 15 &&
  	*(cset+14) == *(start+14) &&
! 	!strncmp(cset, "jisx0208.1983", 13)) {
!          return ((compareNLowercase(start, "jisx0208.1990", 13) == 0) ? True : False);
      }
!     /* GL of ISO8859.* is same as GL of ISO8859.1 */
      if (GLorGR == GL && !strncmp(cset, "iso8859-", 8)) {
           return ((compareNLowercase(start, cset, 8) == 0) ? True : False);
      }
!     return (False);
  }
  
  static int
***************
*** 552,562 ****
  
  #ifdef XML
  static int
! TryLoad(s_tmp, id_tmp, found, info, charset, GLorGR)
! XFontStruct	*s_tmp[];
  int		id_tmp[];
  int		found;
- XFontStruct     *info;
  char		*charset;
  _CSID		GLorGR;
  {
--- 557,565 ----
  
  #ifdef XML
  static int
! AlreadyLoad(id_tmp, found, charset, GLorGR)
  int		id_tmp[];
  int		found;
  char		*charset;
  _CSID		GLorGR;
  {
***************
*** 567,573 ****
--- 570,587 ----
  	if (id_tmp[i] == id_tmp[found])
  	    return 0;
      }
+     return 1;
+ }
  
+ static int
+ TryLoad(s_tmp, id_tmp, found, info, charset, GLorGR)
+ XFontStruct	*s_tmp[];
+ int		id_tmp[];
+ int		found;
+ XFontStruct     *info;
+ char		*charset;
+ _CSID		GLorGR;
+ {
      if (! (s_tmp[found] = (XFontStruct *)Xmalloc(sizeof(XFontStruct))))
  	return 0;
  #ifndef MUSTCOPY
***************
*** 652,672 ****
  			loadASCIIFONT = 1;
  		    }
  		} else {
  		    if (!info)
  			info_list = XListFontsWithInfo(dpy, list[j], 1, &count_list, &info);
  		    if (count_list != 1)
  			/* never go to here. */
  			continue;
! 
! 		    f_tmp[found+1] = f_tmp[found];
! 		    found += TryLoad(s_tmp, id_tmp, found, info, charset, GL);
  		}
- 		if (!info)
- 		    info_list = XListFontsWithInfo(dpy, list[j], 1, &count_list, &info);
- 		if (count_list != 1)
- 		    /* never go to here. */
- 		    continue;
- 		found += TryLoad(s_tmp, id_tmp, found, info, charset, GR);
  		notfound = 0;
  		if (info)
  		    XFreeFontInfo(info_list, info, count_list);
--- 666,691 ----
  			loadASCIIFONT = 1;
  		    }
  		} else {
+ 		    if (AlreadyLoad(id_tmp, found, charset, GL)) {
+ 
+ 			if (!info)
+ 			    info_list = XListFontsWithInfo(dpy, list[j], 1, &count_list, &info);
+ 			if (count_list != 1)
+ 			    /* never go to here. */
+ 			    continue;
+ 
+ 			f_tmp[found+1] = f_tmp[found];
+ 			found += TryLoad(s_tmp, id_tmp, found, info, charset, GL);
+ 		    }
+ 		}
+ 		if (AlreadyLoad(id_tmp, found, charset, GR)) {
  		    if (!info)
  			info_list = XListFontsWithInfo(dpy, list[j], 1, &count_list, &info);
  		    if (count_list != 1)
  			/* never go to here. */
  			continue;
! 		    found += TryLoad(s_tmp, id_tmp, found, info, charset, GR);
  		}
  		notfound = 0;
  		if (info)
  		    XFreeFontInfo(info_list, info, count_list);
***************
*** 880,886 ****
  		      &font_set->ascent, &font_set->descent);
      font_set->core.default_string = NULL;
      for (i = 0; (int)i < found; i++) {
! 	Xfree((char *)f_tmp[i]);
      }
  
      /*
--- 899,905 ----
  		      &font_set->ascent, &font_set->descent);
      font_set->core.default_string = NULL;
      for (i = 0; (int)i < found; i++) {
! 	if (f_tmp[i]) Xfree((char *)f_tmp[i]);
      }
  
      /*
*** /tmp/d16101	Sun May  3 18:37:32 1992
--- mit/lib/X/Xsi/XCrIC.c	Sun May  3 18:37:30 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XCrIC.c,v 1.30 91/06/05 09:23:58 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XCrIC.c,v 1.31 92/04/14 15:44:17 rws Exp $
   */
  
  /*
***************
*** 114,133 ****
  };
  
  static Status
! _StringToPixel(display, w, name, pixel)
      Display *display;
!     Window w;
      char *name;
      unsigned long *pixel;
  {
      XColor c, e_c;
-     Colormap colormap;
-     XWindowAttributes win_info;
      Status status;
  
-     XGetWindowAttributes(display, w, &win_info);
-     colormap = win_info.colormap;
- 
      if (name[0] == '#') {
  	status = XParseColor(display, colormap, name, &c);
  	if (status != 0) {
--- 114,128 ----
  };
  
  static Status
! _StringToPixel(display, colormap, name, pixel)
      Display *display;
!     Colormap colormap;
      char *name;
      unsigned long *pixel;
  {
      XColor c, e_c;
      Status status;
  
      if (name[0] == '#') {
  	status = XParseColor(display, colormap, name, &c);
  	if (status != 0) {
***************
*** 155,161 ****
  {
      XipIM im = ipIMofIC(ic);
      unsigned long ret_mask = 0;
-     int screen;
      char name_prefix[256], class_prefix[256];
      char res_name_buf[256], res_class_buf[256];
      /*
--- 150,155 ----
***************
*** 166,182 ****
  #endif	/* XML */
      char def_fg_name[256], def_bg_name[256];
      unsigned long def_fg, def_bg;
-     Window window;
      char *str_type[20];
      XrmValue value;
      XIMArg args[8], pre_args[4], st_args[4];
      int count = 0, pre_count = 0, st_count = 0;
  
      if (rdb == NULL) {
  	return(0);
      }
!     screen = DefaultScreen(display);
!     window = RootWindow(display, screen);
      if (res_name == NULL || *res_name == '\0'
  	|| res_class == NULL || *res_class == '\0') {
  	strcpy(name_prefix, "*.");
--- 160,183 ----
  #endif	/* XML */
      char def_fg_name[256], def_bg_name[256];
      unsigned long def_fg, def_bg;
      char *str_type[20];
      XrmValue value;
      XIMArg args[8], pre_args[4], st_args[4];
      int count = 0, pre_count = 0, st_count = 0;
+     Colormap colormap, def_colormap;
+     XWindowAttributes win_info;
  
      if (rdb == NULL) {
  	return(0);
      }
!     if (ic->core.client_window) {
! 	XGetWindowAttributes(display, ic->core.client_window, &win_info);
!     } else {
! 	XGetWindowAttributes(display,
! 			     RootWindow(display, DefaultScreen(display)),
! 			     &win_info);
!     }
!     def_colormap = win_info.colormap;
      if (res_name == NULL || *res_name == '\0'
  	|| res_class == NULL || *res_class == '\0') {
  	strcpy(name_prefix, "*.");
***************
*** 195,201 ****
  	if (XrmGetResource(rdb, res_name_buf, res_class_buf,
  			   str_type, &value) == True) {
  	    strncpy(def_fg_name, value.addr, (int)value.size);
! 	    if (_StringToPixel(display, window, def_fg_name, &def_fg) == 0) {
  		if (!(mask & (1 << ICForeground))) {
  		    pre_args[pre_count].name = (char *)XNForeground;
  		    pre_args[pre_count].value = (XPointer)def_fg;
--- 196,207 ----
  	if (XrmGetResource(rdb, res_name_buf, res_class_buf,
  			   str_type, &value) == True) {
  	    strncpy(def_fg_name, value.addr, (int)value.size);
! 	    if (ic->core.preedit_attr.colormap) {
! 		colormap = ic->core.preedit_attr.colormap;
! 	    } else {
! 		colormap = def_colormap;
! 	    }
! 	    if (_StringToPixel(display, colormap, def_fg_name, &def_fg) == 0) {
  		if (!(mask & (1 << ICForeground))) {
  		    pre_args[pre_count].name = (char *)XNForeground;
  		    pre_args[pre_count].value = (XPointer)def_fg;
***************
*** 220,226 ****
  	if (XrmGetResource(rdb, res_name_buf, res_class_buf,
  			   str_type, &value) == True) {	
  	    strncpy(def_bg_name, value.addr, (int)value.size);	
! 	    if (_StringToPixel(display, window, def_bg_name, &def_bg) == 0) {
  		if (!(mask & (1 << ICBackground))) {
  		    pre_args[pre_count].name = (char *)XNBackground;
  		    pre_args[pre_count].value = (XPointer)def_bg;
--- 226,237 ----
  	if (XrmGetResource(rdb, res_name_buf, res_class_buf,
  			   str_type, &value) == True) {	
  	    strncpy(def_bg_name, value.addr, (int)value.size);	
! 	    if (ic->core.preedit_attr.colormap) {
! 		colormap = ic->core.preedit_attr.colormap;
! 	    } else {
! 		colormap = def_colormap;
! 	    }
! 	    if (_StringToPixel(display, colormap, def_bg_name, &def_bg) == 0) {
  		if (!(mask & (1 << ICBackground))) {
  		    pre_args[pre_count].name = (char *)XNBackground;
  		    pre_args[pre_count].value = (XPointer)def_bg;
*** /tmp/d16186	Sun May  3 18:38:19 1992
--- mit/lib/X/Xsi/XICSetVal.c	Sun May  3 18:38:16 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XICSetVal.c,v 1.27 91/09/11 11:40:57 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XICSetVal.c,v 1.28 92/04/24 16:14:45 rws Exp $
   */
  
  /*
***************
*** 266,272 ****
      req.input_style = ic->core.input_style;
      req.focus_window = ic->core.focus_window;
      req.filter_events = ic->core.filter_events;
!     req.max_keycode = im->core.display->max_keycode;
  #ifdef	XML
      if (mask & (1 << ICUsingLanguage)) {
  	if (ic->xlc_num == 0) {
--- 266,272 ----
      req.input_style = ic->core.input_style;
      req.focus_window = ic->core.focus_window;
      req.filter_events = ic->core.filter_events;
!     req.max_keycode = 0;	/* noused */
  #ifdef	XML
      if (mask & (1 << ICUsingLanguage)) {
  	if (ic->xlc_num == 0) {
*** /tmp/d16208	Sun May  3 18:38:31 1992
--- mit/lib/X/Xsi/XIMKeyBind.c	Sun May  3 18:38:29 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XIMKeyBind.c,v 1.22 92/03/03 10:01:53 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XIMKeyBind.c,v 1.23 92/04/24 16:14:56 rws Exp $
   */
  
  /*
***************
*** 55,61 ****
      char		*mbuf;
  #endif
  
!     if (ev->keycode > ev->display->max_keycode) {
  	(void)_XipGetNextICQueue(ic, &type, &length, keysym, (char **)&ptr);
  	if (type == XIM_STRING || (type == XIM_KEYSYM && length > 0)) {
  #ifdef X_WCHAR
--- 55,61 ----
      char		*mbuf;
  #endif
  
!     if (ev->keycode == 0) {
  	(void)_XipGetNextICQueue(ic, &type, &length, keysym, (char **)&ptr);
  	if (type == XIM_STRING || (type == XIM_KEYSYM && length > 0)) {
  #ifdef X_WCHAR
***************
*** 148,154 ****
      int			ret_len, scanned_bytes;
      int			ret;
  
!     if (ev->keycode > ev->display->max_keycode) {
  	_XipGetNextICQueue(ic, &type, &length, keysym, (char **)&ptr);
  	if (type == XIM_STRING) {
  	    ret_len = nbytes;
--- 148,154 ----
      int			ret_len, scanned_bytes;
      int			ret;
  
!     if (ev->keycode == 0) {
  	_XipGetNextICQueue(ic, &type, &length, keysym, (char **)&ptr);
  	if (type == XIM_STRING) {
  	    ret_len = nbytes;
***************
*** 213,219 ****
      char		*ptr;
      int			ret_len;
  
!     if (ev->keycode > ev->display->max_keycode) {
  	_XipGetNextICQueue(ic, &type, &length, keysym, &ptr);
  	if (type == XIM_STRING) {
  	    if (length > nbytes) {
--- 213,219 ----
      char		*ptr;
      int			ret_len;
  
!     if (ev->keycode == 0) {
  	_XipGetNextICQueue(ic, &type, &length, keysym, &ptr);
  	if (type == XIM_STRING) {
  	    if (length > nbytes) {
*** /tmp/d16272	Sun May  3 18:39:06 1992
--- mit/lib/X/Xsi/XInitCT.c	Sun May  3 18:39:03 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XInitCT.c,v 1.17 92/03/03 10:02:52 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XInitCT.c,v 1.18 92/04/14 15:55:19 rws Exp $
   */
  
  /*
***************
*** 378,386 ****
      ctSetid(xlocale, id);
      return(True);
  }
- #endif
  
- #ifdef not_use
  int
  _XcwNameGetLength(state_name, GLorGR)
      char       *state_name;
--- 378,384 ----
***************
*** 446,451 ****
--- 444,475 ----
      return(ND);
  }
  
+ static _CSID
+ _XcwEscGetIdFromLocale(xlocale, state_encoding)
+     XLocale	 xlocale;
+     char	*state_encoding;
+ {
+     Fontset			*fontset;
+     _CSID                       id;
+     char			esc[128];
+ 
+     if(!xlocale && !xlocale->xlc_db && !xlocale->xlc_db->lc_fontset) {
+ 	return (_XcwEscGetId(state_encoding));
+     }
+     fontset = xlocale->xlc_db->lc_fontset;
+ 
+     if(state_encoding[1] == 0x25) {
+ 	strcpy(esc, state_encoding);
+ 	esc[4] = '0'; esc[5] = '0';	/* mask length */
+ 	state_encoding = esc;
+     }
+     for (id = 0; id < fontset->fs_num; id++) {
+         if (!strcmp(state_encoding, fontset->fs_cset[id]->cs_des))
+ 	    return(fontset->fs_cset[id]->cs_id);
+         }
+     return (_XcwEscGetId(state_encoding));
+ }
+ 
  Bool
  _XcwEscSetStatus(xlocale, state_encoding)
      XLocale	 xlocale;
***************
*** 452,458 ****
      char	*state_encoding;
  {
      _CSID	id;
!     if((id = _XcwEscGetId(state_encoding)) == ND)
  	return(False);
      ctSetGLorGR(xlocale, ISOStateTable[id].GLorGR);
      ctSetid(xlocale, id);
--- 476,482 ----
      char	*state_encoding;
  {
      _CSID	id;
!     if((id = _XcwEscGetIdFromLocale(xlocale, state_encoding)) == ND)
  	return(False);
      ctSetGLorGR(xlocale, ISOStateTable[id].GLorGR);
      ctSetid(xlocale, id);
***************
*** 467,473 ****
      wchar	*woffset;
  {
      _CSID	id;
!     if((id = _XcwEscGetId(state_encoding)) == ND)
  	return(False);
      ctSetGLorGR(xlocale, ISOStateTable[id].GLorGR);
      ctSetid(xlocale, id);
--- 491,497 ----
      wchar	*woffset;
  {
      _CSID	id;
!     if((id = _XcwEscGetIdFromLocale(xlocale, state_encoding)) == ND)
  	return(False);
      ctSetGLorGR(xlocale, ISOStateTable[id].GLorGR);
      ctSetid(xlocale, id);
***************
*** 572,577 ****
--- 596,631 ----
          }
      }
      return(ind);
+ }
+ 
+ _CSID
+ _XcwGetWoffsetFromLocale(xlocale, wc, woffset)
+     XLocale	        xlocale;
+     wchar		wc;
+     wchar	       *woffset;
+ {
+     register wchar              disp_min;
+     _CSID                       id;
+     Fontset			*fontset;
+ 
+     if(!xlocale && !xlocale->xlc_db && !xlocale->xlc_db->lc_fontset) {
+ 	*woffset = 0;
+ 	return (_XcwGetWoffset(wc, woffset));
+     }
+ 
+     fontset = xlocale->xlc_db->lc_fontset;
+     wc &= ~0x7f;
+     for (id = 0; id < fontset->fs_num; id++) {
+ 	if (fontset->fs_cset[id]->cs_len == 2)
+ 	    disp_min = PosSub(wc & ~0x7f00, fontset->fs_cset[id]->cs_woff);
+ 	else
+ 	    disp_min = PosSub(wc, fontset->fs_cset[id]->cs_woff);
+ 	if (disp_min < 0x80) {
+ 	    *woffset = fontset->fs_cset[id]->cs_woff;
+ 	    return(fontset->fs_cset[id]->cs_id);
+ 	}
+     }
+     return (_XcwGetWoffset(wc, woffset));
  #undef PosSub
  }
  
***************
*** 611,618 ****
  {
      _CSID		id;
  
!     id = _XcwGetWoffset(wc, woffset);
!     if(id == ND)
  	return;
  
      ctSetGLorGR(xlocale, ISOStateTable[id].GLorGR);
--- 665,671 ----
  {
      _CSID		id;
  
!     if ((id = _XcwGetWoffsetFromLocale(xlocale, wc, woffset)) == ND)
  	return;
  
      ctSetGLorGR(xlocale, ISOStateTable[id].GLorGR);
***************
*** 645,652 ****
      wchar	woffset;
      _CSID	id;
  
!     id = _XcwGetWoffset(wc, &woffset);
!     if(id == ND)
  	return;
      
      if (ISOStateTable[id].GLorGR == GL)
--- 698,704 ----
      wchar	woffset;
      _CSID	id;
  
!     if ((id = _XcwGetWoffsetFromLocale(xlocale, wc, woffset)) == ND)
  	return;
      
      if (ISOStateTable[id].GLorGR == GL)
*** /tmp/d16358	Sun May  3 18:39:53 1992
--- mit/lib/X/Xsi/XlcLoad.c	Sun May  3 18:39:50 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XlcLoad.c,v 1.40 91/12/23 11:37:03 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XlcLoad.c,v 1.41 92/04/14 15:53:03 rws Exp $
   */
  
  /*
***************
*** 873,879 ****
  		fprintf(stderr, "Xlib: bad format locale file: %s\n", fn);
  	    if (lastBadLCName)
  		Xfree(lastBadLCName);
! 	    if (lastBadLCName = Xmalloc(strlen(lc_name)))
  		strcpy(lastBadLCName, lc_name);
  	}
      }
--- 873,879 ----
  		fprintf(stderr, "Xlib: bad format locale file: %s\n", fn);
  	    if (lastBadLCName)
  		Xfree(lastBadLCName);
! 	    if (lastBadLCName = Xmalloc(strlen(lc_name) + 1))
  		strcpy(lastBadLCName, lc_name);
  	}
      }
*** /tmp/d16464	Sun May  3 18:40:49 1992
--- mit/lib/X/Xsi/XwcDeGlyph.c	Sun May  3 18:40:46 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XwcDeGlyph.c,v 1.15 91/11/17 16:29:59 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XwcDeGlyph.c,v 1.16 92/04/14 15:55:31 rws Exp $
   */
  
  /*
***************
*** 111,117 ****
  		*ctid = ctGetid(xlocale);
  	    newwoffset = woffset;
  	} else {
!             if(_XcwGetWoffset(wc, &newwoffset) == ND) { /* MUST not change Status */
  		/* XXX BUG: need to check designate sequence of default string.
  		   But current default string is NULL, so OK. :-) */
  		for (i = 0; *(defstr + i) != 0; i++) {
--- 111,117 ----
  		*ctid = ctGetid(xlocale);
  	    newwoffset = woffset;
  	} else {
!             if(_XcwGetWoffsetFromLocale(xlocale, wc, &newwoffset) == ND) { /* MUST not change Status */
  		/* XXX BUG: need to check designate sequence of default string.
  		   But current default string is NULL, so OK. :-) */
  		for (i = 0; *(defstr + i) != 0; i++) {
*** /tmp/d16592	Sun May  3 18:41:53 1992
--- mit/lib/X/Xsi/Xi18nint.h	Sun May  3 18:41:51 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: Xi18nint.h,v 1.18 91/11/17 15:59:13 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: Xi18nint.h,v 1.19 92/04/14 15:45:50 rws Exp $
   */
  
  /*
***************
*** 154,163 ****
  #endif	/* !NO_LOCAL_IM */
  
  #ifdef	XML
! #define ICUsingLanguage		26
! #define ICCurrentLanguage	27
! #define ICChangeLocaleCB	28
! #define ICAllMask		0x1fffffff
  #else	/* XML */
  #define	ICAllMask		0x03ffffff
  #endif	/* XML */
--- 154,163 ----
  #endif	/* !NO_LOCAL_IM */
  
  #ifdef	XML
! #define ICUsingLanguage		28
! #define ICCurrentLanguage	29
! #define ICChangeLocaleCB	30
! #define ICAllMask		0x73ffffff
  #else	/* XML */
  #define	ICAllMask		0x03ffffff
  #endif	/* XML */
***************
*** 393,398 ****
--- 393,404 ----
  extern int _XipwcLookupString(
  #if NeedFunctionPrototypes
  	XIC, XKeyEvent*, wchar_t*, int, KeySym*, Status*
+ #endif
+ );
+ 
+ extern unsigned long _XipReadRdb(
+ #if NeedFunctionPrototypes
+ 	Display*, XipIC, unsigned long, XrmDatabase, char*, char*
  #endif
  );
  
*** /tmp/d16614	Sun May  3 18:42:06 1992
--- mit/lib/X/Xsi/Xlocaleint.h	Sun May  3 18:42:03 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: Xlocaleint.h,v 1.34 91/11/17 16:11:44 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: Xlocaleint.h,v 1.35 92/04/14 15:55:37 rws Exp $
   */
  
  /*
***************
*** 294,300 ****
  extern _CSID		_XcwNameGetGLorGRId();
  extern void             _XcwGetAll();
  extern void		_XcwGetDefaultEncoding();
! extern _CSID		_XcwGetWoffset();
  extern Bool             _XcwCheckDefaultState();
  extern Bool		_XmbCheck();
  extern Bool		_XcwIdCheck();
--- 294,300 ----
  extern _CSID		_XcwNameGetGLorGRId();
  extern void             _XcwGetAll();
  extern void		_XcwGetDefaultEncoding();
! extern _CSID		_XcwGetWoffsetFromLocale();
  extern Bool             _XcwCheckDefaultState();
  extern Bool		_XmbCheck();
  extern Bool		_XcwIdCheck();
*** /tmp/d16678	Sun May  3 18:42:39 1992
--- mit/lib/X/Xsi/XLocalIM.c	Sun May  3 18:42:36 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XLocalIM.c,v 1.8 91/12/27 15:12:20 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XLocalIM.c,v 1.9 92/04/24 16:15:02 rws Exp $
   */
  
  /*
***************
*** 890,896 ****
      if (xcvt->cnt == 0)
  	return(False);
  
!     if (ev->xkey.keycode == (display->max_keycode + 1)) {
  	if (_XipTypeOfNextICQueue((XipIC)ic) == XIM_KEYSYM){
  	    if ((keycode = XKeysymToKeycode(display,
  			    _XipKeySymOfNextICQueue((XipIC)ic))) != 0
--- 890,896 ----
      if (xcvt->cnt == 0)
  	return(False);
  
!     if (ev->xkey.keycode == 0) {
  	if (_XipTypeOfNextICQueue((XipIC)ic) == XIM_KEYSYM){
  	    if ((keycode = XKeysymToKeycode(display,
  			    _XipKeySymOfNextICQueue((XipIC)ic))) != 0
***************
*** 932,938 ****
      bcopy((char *)ev, (char *)&dummy_ev, sizeof(XEvent));
      dummy_ev.type = KeyPress;
      dummy_ev.xkey.state = 0;
!     dummy_ev.xkey.keycode = display->max_keycode + 1;
  
      if (xcvt->off == True) {
  	if ((c = off_key_check(xcvt)) == 0) {
--- 932,938 ----
      bcopy((char *)ev, (char *)&dummy_ev, sizeof(XEvent));
      dummy_ev.type = KeyPress;
      dummy_ev.xkey.state = 0;
!     dummy_ev.xkey.keycode = 0;
  
      if (xcvt->off == True) {
  	if ((c = off_key_check(xcvt)) == 0) {
***************
*** 954,960 ****
  	       return(False);
  	}
  	ev->xkey.state = 0;
! 	ev->xkey.keycode = display->max_keycode + 1;
  	if ((keycode = XKeysymToKeycode(display,
  				_XipKeySymOfNextICQueue((XipIC)ic))) != 0
  	    && _XipStringOfNextICQueue((XipIC)ic) == NULL) {
--- 954,960 ----
  	       return(False);
  	}
  	ev->xkey.state = 0;
! 	ev->xkey.keycode = 0;
  	if ((keycode = XKeysymToKeycode(display,
  				_XipKeySymOfNextICQueue((XipIC)ic))) != 0
  	    && _XipStringOfNextICQueue((XipIC)ic) == NULL) {
***************
*** 984,990 ****
  	       return(False);
  	}
  	ev->xkey.state = 0;
! 	ev->xkey.keycode = display->max_keycode + 1;
  	if ((keycode = XKeysymToKeycode(display,
  				_XipKeySymOfNextICQueue((XipIC)ic))) != 0
  	    && _XipStringOfNextICQueue((XipIC)ic) == NULL) {
--- 984,990 ----
  	       return(False);
  	}
  	ev->xkey.state = 0;
! 	ev->xkey.keycode = 0;
  	if ((keycode = XKeysymToKeycode(display,
  				_XipKeySymOfNextICQueue((XipIC)ic))) != 0
  	    && _XipStringOfNextICQueue((XipIC)ic) == NULL) {
*** /tmp/d16789	Sun May  3 18:43:40 1992
--- mit/lib/X/Ximp/XimpLCUtil.c	Sun May  3 18:43:38 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpLCUtil.c,v 1.6 91/10/07 17:48:57 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpLCUtil.c,v 1.7 92/04/14 13:29:21 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 28,34 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 28,34 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 84,90 ****
      GR_ENCODING,
      LENGTH,
      NAME,
!     STRING,
  } keyword_value;
  
  typedef struct KeywordRec {
--- 84,90 ----
      GR_ENCODING,
      LENGTH,
      NAME,
!     STRING
  } keyword_value;
  
  typedef struct KeywordRec {
*** /tmp/d16811	Sun May  3 18:43:52 1992
--- mit/lib/X/Ximp/XIMProto.h	Sun May  3 18:43:49 1992
***************
*** 1,7 ****
! /* $XConsortium: XIMProto.h,v 1.4 91/10/10 20:41:32 rws Exp $ */
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,7 ----
! /* $XConsortium: XIMProto.h,v 1.5 92/04/14 13:28:34 rws Exp $ */
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 28,34 ****
  ******************************************************************/
  
  /* Ximp implementation revision */
! #define XIMP_REVISION "Ximp Revision 3.1"
  
  /* Ximp Protocol Version */
  #define XIMP_PROTOCOL_VERSION "XIMP.3.5"
--- 28,34 ----
  ******************************************************************/
  
  /* Ximp implementation revision */
! #define XIMP_REVISION "Ximp Revision 3.2"
  
  /* Ximp Protocol Version */
  #define XIMP_PROTOCOL_VERSION "XIMP.3.5"
*** /tmp/d16833	Sun May  3 18:44:04 1992
--- mit/lib/X/Ximp/XimpCallbk.c	Sun May  3 18:44:01 1992
***************
*** 1,9 ****
! /* $XConsortium: XimpCallbk.c,v 1.4 91/10/07 17:47:37 rws Exp $ */
  /******************************************************************
  
!               Copyright 1991, by Fuji Xerox Co.,Ltd.
!               Copyright 1991, by FUJITSU LIMITED
!               Copyright 1991, by Sun Microsystems, Inc.
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,9 ----
! /* $XConsortium: XimpCallbk.c,v 1.5 92/04/14 13:28:40 rws Exp $ */
  /******************************************************************
  
!               Copyright 1991, 1992 by Fuji Xerox Co.,Ltd.
!               Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sun Microsystems, Inc.
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 29,36 ****
                                 kaz@ssdev.ksp.fujixerox.co.jp
            Takashi Fujiwara     FUJITSU LIMITED
                                 fujiwara@a80.tech.yk.fujitsu.co.jp
! 	  Hideki Hiura         hhiura@Sun.COM
! 	  		       Sun Microsystems, Inc.
  ******************************************************************/
  
  #define NEED_EVENTS
--- 29,36 ----
                                 kaz@ssdev.ksp.fujixerox.co.jp
            Takashi Fujiwara     FUJITSU LIMITED
                                 fujiwara@a80.tech.yk.fujitsu.co.jp
!           Hideki Hiura         Sun Microsystems, Inc.
!                                hhiura@Sun.COM
  ******************************************************************/
  
  #define NEED_EVENTS
***************
*** 42,47 ****
--- 42,48 ----
  
  #define XIMP_MAXBUF	256
  
+ extern void	_Ximp_IM_SendMessage();
  
  void
  _Ximp_CallGeometryCallback(xic, event)
***************
*** 62,87 ****
      XClientMessageEvent *event;
  {
      register XIMCallback *cb;
!     static XClientMessageEvent clmsg;
  
-     clmsg.type = ClientMessage;
-     clmsg.display = xic->core.im->core.display;
-     clmsg.window = ((Ximp_XIM) xic->core.im)->ximp_impart->fe_window;
-     clmsg.message_type = ((Ximp_XIM) xic->core.im)->ximp_impart->improtocol_id;
-     clmsg.format = 32;
-     clmsg.data.l[0] = XIMP_PREEDITSTART_RETURN;
-     clmsg.data.l[1] = xic->ximp_icpart->icid;
      cb = &xic->core.preedit_attr.callbacks.start;
      if (cb->callback) {
! 	clmsg.data.l[2] = (*(int (*) ()) cb->callback) (xic, cb->client_data, NULL);
  
      } else {
! 	clmsg.data.l[2] = -1;
      }
!     XSendEvent(xic->core.im->core.display,
! 	       ((Ximp_XIM) xic->core.im)->ximp_impart->fe_window,
! 	       False, NoEventMask, (XEvent *) & clmsg);
!     XFlush(xic->core.im->core.display);
  }
  
  void
--- 63,78 ----
      XClientMessageEvent *event;
  {
      register XIMCallback *cb;
!              int          data;
  
      cb = &xic->core.preedit_attr.callbacks.start;
      if (cb->callback) {
! 	data = (*(int (*) ()) cb->callback) (xic, cb->client_data, NULL);
  
      } else {
! 	data = -1;
      }
!     _Ximp_IM_SendMessage(xic, XIMP_PREEDITSTART_RETURN, data, NULL, NULL);
  }
  
  void
***************
*** 513,536 ****
  
      cb = &xic->core.preedit_attr.callbacks.caret;
      if (cb->callback) {
- 	static XClientMessageEvent clmsg;
  	CallData.position = event->data.l[2];
  	CallData.direction = ToXIMCaretDirection(event->data.l[3]);
  	CallData.style = ToXIMCaretStyle(event->data.l[4]);
  	(*cb->callback) (xic, cb->client_data, &CallData);
- 	clmsg.type = ClientMessage;
- 	clmsg.display = xic->core.im->core.display;
- 	clmsg.window = ((Ximp_XIM) xic->core.im)->ximp_impart->fe_window;
- 	clmsg.message_type = ((Ximp_XIM) xic->core.im)->ximp_impart->improtocol_id;
- 	clmsg.format = 32;
- 	clmsg.data.l[0] = XIMP_PREEDITCARET_RETURN;
- 	clmsg.data.l[1] = xic->ximp_icpart->icid;
- 	clmsg.data.l[2] = CallData.position;;
  
! 	XSendEvent(xic->core.im->core.display,
! 		   ((Ximp_XIM) xic->core.im)->ximp_impart->fe_window,
! 		   False, NoEventMask, &clmsg);
! 	XFlush(xic->core.im->core.display);
      }
  }
  
--- 504,516 ----
  
      cb = &xic->core.preedit_attr.callbacks.caret;
      if (cb->callback) {
  	CallData.position = event->data.l[2];
  	CallData.direction = ToXIMCaretDirection(event->data.l[3]);
  	CallData.style = ToXIMCaretStyle(event->data.l[4]);
  	(*cb->callback) (xic, cb->client_data, &CallData);
  
!         _Ximp_IM_SendMessage(xic, XIMP_PREEDITCARET_RETURN,
! 				CallData.position, NULL, NULL);
      }
  }
  
*** /tmp/d16855	Sun May  3 18:44:17 1992
--- mit/lib/X/Ximp/XimpConv.c	Sun May  3 18:44:14 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpConv.c,v 1.5 91/10/07 17:47:44 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpConv.c,v 1.6 92/04/14 13:28:45 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 28,34 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 28,34 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d16877	Sun May  3 18:44:29 1992
--- mit/lib/X/Ximp/XimpCrFS.c	Sun May  3 18:44:26 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpCrFS.c,v 1.5 91/10/07 17:47:50 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpCrFS.c,v 1.6 92/04/14 13:28:48 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 29,35 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 29,35 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d16899	Sun May  3 18:44:41 1992
--- mit/lib/X/Ximp/XimpIC.c	Sun May  3 18:44:39 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpIC.c,v 1.5 92/03/03 11:03:14 rws Exp $ */
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,8 ----
! /* $XConsortium: XimpIC.c,v 1.6 92/04/14 13:29:06 rws Exp $ */
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 8,29 ****
  provided that the above copyright notice appear in all copies and
  that both that copyright notice and this permission notice appear
  in supporting documentation, and that the name of FUJITSU LIMITED
! not be used in advertising or publicity pertaining to distribution
! of the software without specific, written prior permission.
! FUJITSU LIMITED makes no representations about the suitability of
! this software for any purpose.  It is provided "as is" without
! express or implied warranty.
  
! FUJITSU LIMITED DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
! INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
! IN NO EVENT SHALL FUJITSU LIMITED BE LIABLE FOR ANY SPECIAL, INDIRECT
! OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
! OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
! OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
! OR PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
!                                fujiwara@a80.tech.yk.fujitsu.co.jp
  
  ******************************************************************/
  
--- 9,32 ----
  provided that the above copyright notice appear in all copies and
  that both that copyright notice and this permission notice appear
  in supporting documentation, and that the name of FUJITSU LIMITED
! and Sony Corporation not be used in advertising or publicity
! pertaining to distribution of the software without specific,
! written prior permission.
! FUJITSU LIMITED and Sony Corporation make no representations about
! the suitability of this software for any purpose.  It is provided
! "as is" without express or implied warranty.
  
! FUJITSU LIMITED AND SONY CORPORATION DISCLAIM ALL WARRANTIES WITH
! REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU LIMITED AND
! SONY CORPORATION BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
! DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
! OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
! TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
! PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
!           Makoto Wakamatsu     Sony Corporation
  
  ******************************************************************/
  
***************
*** 53,71 ****
  extern void		_Ximp_SetPreeditFont();
  extern void		_Ximp_SetStatusAtr();
  extern void		_Ximp_SetStatusFont();
  extern Bool		_Ximp_XimFilter_Client();
  
  static void 		_Ximp_AttributesSetL();
  extern void 		_Ximp_IM_SendMessage();
  
- #if NeedFunctionPrototypes
- extern Bool _Ximp_XimFilter_Keypress (
- 	Display *d, 
- 	Window w, 
- 	XEvent *ev, 
- 	XPointer client_data);
- #endif
- 
  static XICMethodsRec Ximp_ic_methods = {
  				_Ximp_DestroyIC, 	/* destroy */
  				_Ximp_SetFocus,  	/* set_focus */
--- 56,67 ----
  extern void		_Ximp_SetPreeditFont();
  extern void		_Ximp_SetStatusAtr();
  extern void		_Ximp_SetStatusFont();
+ extern Bool		_Ximp_XimFilter_Keypress();
  extern Bool		_Ximp_XimFilter_Client();
  
  static void 		_Ximp_AttributesSetL();
  extern void 		_Ximp_IM_SendMessage();
  
  static XICMethodsRec Ximp_ic_methods = {
  				_Ximp_DestroyIC, 	/* destroy */
  				_Ximp_SetFocus,  	/* set_focus */
***************
*** 78,97 ****
  				_Ximp_WcLookupString,	/* wc_lookup_string */
  				};
  
- Bool
- _Ximp_XimFilter_Keypress (d, w, ev, client_data)
- 	Display		*d;
- 	Window		w;
- 	XEvent		*ev;
- 	XPointer	client_data;
- {
- 	extern Bool	_Ximp_Keypress ();
- 
- 	return(_Ximp_Keypress (d, w, ev, client_data));
- }
- 
- static Ximp_XIC		current_xic = 0;
- 
  XIC
  _Ximp_CreateIC(im, values)
  	XIM		 im;
--- 74,79 ----
***************
*** 117,123 ****
  	ic->core.filter_events = KeyPressMask | KeyReleaseMask | StructureNotifyMask;
  
  	ic->ximp_icpart = ximp_icpart;
! 	_Ximp_SetICValueData(ic, values, XIMP_CREATE_IC, &dummy);
  
  	/* The Value must be set */
  	if(!(ximp_icpart->value_mask & XIMP_INPUT_STYLE)) /* Input Style */
--- 99,106 ----
  	ic->core.filter_events = KeyPressMask | KeyReleaseMask | StructureNotifyMask;
  
  	ic->ximp_icpart = ximp_icpart;
! 	if(_Ximp_SetICValueData(ic, values, XIMP_CREATE_IC, &dummy))
! 		goto Set_Error;
  
  	/* The Value must be set */
  	if(!(ximp_icpart->value_mask & XIMP_INPUT_STYLE)) /* Input Style */
***************
*** 132,154 ****
  	if(ic->core.input_style & XIMStatusArea)
  		if(!(ximp_icpart->proto_mask & XIMP_STS_FONT_MASK)) /* FontSet */
  			goto Set_Error;
! 	if(!(ximp_icpart->value_mask & XIMP_CLIENT_WIN)) /* Client Window */
! 		goto Set_Error;
  	
  	_Ximp_SetValue_Resource(ic, &dummy);
  
! 	if(((Ximp_XIM)im)->ximp_impart->inputserver) {
! 		if(_Ximp_SetOpenXIMP(ic) == False)
  			goto Set_Error;
  	}
- 	if (!current_xic) {
- 		_XRegisterFilterByType (ic->core.im->core.display,
- 				ic->core.focus_window,
- 				KeyPress, KeyPress,
- 				_Ximp_XimFilter_Keypress,
- 				(XPointer)ic);
- 		current_xic = ic;
- 	}
  	return((XIC)ic);
  
     Set_Error :
--- 115,143 ----
  	if(ic->core.input_style & XIMStatusArea)
  		if(!(ximp_icpart->proto_mask & XIMP_STS_FONT_MASK)) /* FontSet */
  			goto Set_Error;
! 	if(ic->core.input_style & XIMPreeditCallbacks)
! 		if(!(ximp_icpart->value_mask & XIMP_PRE_CALLBAK)) /* Preedit Callback */
! 			goto Set_Error;
! 	if(ic->core.input_style & XIMStatusCallbacks)
! 		if(!(ximp_icpart->value_mask & XIMP_STS_CALLBAK)) /* Status Callback */
! 			goto Set_Error;
  	
  	_Ximp_SetValue_Resource(ic, &dummy);
  
! 	if(((Ximp_XIM)im)->ximp_impart->inputserver ||
! 	   ((Ximp_XIM)im)->ximp_impart->connectserver) {
! 		if(_Ximp_SetOpenXIMP(ic, XIMP_CREATE_IC) == False)
  			goto Set_Error;
+ 	} else {
+ 		if(ic->ximp_icpart->proto_mask & XIMP_FOCUS_WIN_MASK) {
+ 			_XRegisterFilterByType (ic->core.im->core.display,
+ 						ic->core.focus_window,
+ 						KeyPress, KeyPress,
+ 						_Ximp_XimFilter_Keypress,
+ 						(XPointer)ic);
+ 			ic->ximp_icpart->filter_mode |= 0x1;
+ 		}
  	}
  	return((XIC)ic);
  
     Set_Error :
***************
*** 161,176 ****
  _Ximp_DestroyIC(ic)
  	Ximp_XIC	 ic;
  {
! 	if(ic->ximp_icpart->icid) {
!  		_Ximp_IM_SendMessage(ic, XIMP_DESTROY, NULL, NULL, NULL);
! 		if (current_xic) {
! 			_XUnregisterFilter (ic->core.im->core.display,
! 					ic->core.focus_window,
! 					_Ximp_XimFilter_Keypress,
! 					(XPointer)current_xic);
! 			current_xic = 0;
! 		}
  	}
  	Xfree(ic->ximp_icpart);
  	return;
  }
--- 150,167 ----
  _Ximp_DestroyIC(ic)
  	Ximp_XIC	 ic;
  {
! 	if(ic->ximp_icpart->filter_mode & 0x1) {
! 		_XUnregisterFilter (ic->core.im->core.display,
! 				ic->core.focus_window,
! 				_Ximp_XimFilter_Keypress,
! 				(XPointer)ic);
  	}
+ 	if(ic->ximp_icpart->filter_mode & 0x2) {
+ 		_XUnregisterFilter(ic->core.im->core.display,
+ 				   ic->ximp_icpart->back_focus_win,
+ 				   _Ximp_XimFilter_Client, (XPointer)NULL);
+ 	}
+  	_Ximp_IM_SendMessage(ic, XIMP_DESTROY, NULL, NULL, NULL);
  	Xfree(ic->ximp_icpart);
  	return;
  }
***************
*** 179,197 ****
  _Ximp_SetFocus(ic)
  	Ximp_XIC	ic;
  {
! 	if (ic->ximp_icpart->icid) {
!  		_Ximp_IM_SendMessage(ic, XIMP_SETFOCUS, NULL, NULL, NULL);
! 		if (current_xic)
! 			_XUnregisterFilter (ic->core.im->core.display,
! 						ic->core.focus_window,
! 						_Ximp_XimFilter_Keypress,
! 						(XPointer)current_xic);
  		_XRegisterFilterByType (ic->core.im->core.display,
  					ic->core.focus_window,
  					KeyPress, KeyPress,
  					_Ximp_XimFilter_Keypress,
  					(XPointer)ic);
! 		current_xic = ic;
  	}
  	return;
  }
--- 170,183 ----
  _Ximp_SetFocus(ic)
  	Ximp_XIC	ic;
  {
!  	_Ximp_IM_SendMessage(ic, XIMP_SETFOCUS, NULL, NULL, NULL);
! 	if(!(ic->ximp_icpart->filter_mode & 0x1)) {
  		_XRegisterFilterByType (ic->core.im->core.display,
  					ic->core.focus_window,
  					KeyPress, KeyPress,
  					_Ximp_XimFilter_Keypress,
  					(XPointer)ic);
! 		ic->ximp_icpart->filter_mode |= 0x1;
  	}
  	return;
  }
***************
*** 200,214 ****
  _Ximp_UnSetFocus(ic)
  	Ximp_XIC	ic;
  {
! 	if(ic->ximp_icpart->icid) {
! 		_Ximp_IM_SendMessage(ic, XIMP_UNSETFOCUS, NULL, NULL, NULL);
! 		if (current_xic) {
! 			_XUnregisterFilter (ic->core.im->core.display,
! 					ic->core.focus_window,
! 					_Ximp_XimFilter_Keypress,
! 					(XPointer)current_xic);
! 			current_xic = 0;
! 		}
  	}
  	return;
  }
--- 186,198 ----
  _Ximp_UnSetFocus(ic)
  	Ximp_XIC	ic;
  {
! 	_Ximp_IM_SendMessage(ic, XIMP_UNSETFOCUS, NULL, NULL, NULL);
! 	if(ic->ximp_icpart->filter_mode & 0x1) {
! 		_XUnregisterFilter (ic->core.im->core.display,
! 				ic->core.focus_window,
! 				_Ximp_XimFilter_Keypress,
! 				(XPointer)ic);
! 		ic->ximp_icpart->filter_mode &= ~(0x1);
  	}
  	return;
  }
***************
*** 237,249 ****
  			((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id,
  			XA_WINDOW, 32, PropModeReplace,
  			(unsigned char *)&ic->core.focus_window, 1);
! 	_XUnregisterFilter(ic->core.im->core.display,
! 			   ic->core.focus_window,
! 			   _Ximp_XimFilter_Client, (XPointer)NULL);
  	_XRegisterFilterByType(ic->core.im->core.display,
  			       ic->core.focus_window,
  			       ClientMessage, ClientMessage,
  			       _Ximp_XimFilter_Client, NULL);
  	return;
  }
  
--- 221,250 ----
  			((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id,
  			XA_WINDOW, 32, PropModeReplace,
  			(unsigned char *)&ic->core.focus_window, 1);
! 
! 	if(ic->ximp_icpart->filter_mode & 0x2) {
! 		_XUnregisterFilter(ic->core.im->core.display,
! 				   ic->ximp_icpart->back_focus_win,
! 				   _Ximp_XimFilter_Client, (XPointer)NULL);
! 	}
  	_XRegisterFilterByType(ic->core.im->core.display,
  			       ic->core.focus_window,
  			       ClientMessage, ClientMessage,
  			       _Ximp_XimFilter_Client, NULL);
+ 	ic->ximp_icpart->filter_mode |= 0x2;
+ 
+ 	if(ic->ximp_icpart->filter_mode & 0x1) {
+ 		_XUnregisterFilter (ic->core.im->core.display,
+ 				ic->ximp_icpart->back_focus_win,
+ 				_Ximp_XimFilter_Keypress,
+ 				(XPointer)ic);
+ 	}
+ 	_XRegisterFilterByType (ic->core.im->core.display,
+ 				ic->core.focus_window,
+ 				KeyPress, KeyPress,
+ 				_Ximp_XimFilter_Keypress,
+ 				(XPointer)ic);
+ 	ic->ximp_icpart->filter_mode |= 0x1;
  	return;
  }
  
***************
*** 297,303 ****
  _Ximp_SetPreeditFont(ic)
  	Ximp_XIC		 ic;
  {
- 	Ximp_PreeditPropRec	*preedit_atr;
  	Atom			actual_type;
  	int			actual_format;
  	unsigned long		nitems, bytes_after;
--- 298,303 ----
***************
*** 320,326 ****
  			XA_STRING, 8, PropModeReplace,
  			(unsigned char *)(ic->ximp_icpart->preedit_font),
  			strlen(ic->ximp_icpart->preedit_font));
- 	    XFree(ic->ximp_icpart->preedit_font);
  	    }
  	return;
  }
--- 320,325 ----
***************
*** 396,402 ****
  			XA_STRING, 8, PropModeReplace,
  			(unsigned char *)(ic->ximp_icpart->status_font),
  			strlen(ic->ximp_icpart->status_font));
- 	    XFree(ic->ximp_icpart->status_font);
  	    }
  	return;
  }
--- 395,400 ----
***************
*** 422,427 ****
--- 420,428 ----
  {
  	XEvent		Message;
  	
+ 	if((request != XIMP_CREATE) && !(ic->ximp_icpart->icid))
+ 		return;
+ 
  	/* ClientMessage Send */
  	Message.xclient.type         = ClientMessage;
  	Message.xclient.display      = ic->core.im->core.display;
*** /tmp/d16921	Sun May  3 18:44:53 1992
--- mit/lib/X/Ximp/XimpIM.c	Sun May  3 18:44:51 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpIM.c,v 1.5 91/11/17 15:36:42 rws Exp $ */
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,8 ----
! /* $XConsortium: XimpIM.c,v 1.6 92/04/14 13:29:18 rws Exp $ */
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporaion
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 8,29 ****
  provided that the above copyright notice appear in all copies and
  that both that copyright notice and this permission notice appear
  in supporting documentation, and that the name of FUJITSU LIMITED
! not be used in advertising or publicity pertaining to distribution
! of the software without specific, written prior permission.
! FUJITSU LIMITED makes no representations about the suitability of
! this software for any purpose.  It is provided "as is" without
! express or implied warranty.
  
! FUJITSU LIMITED DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
! INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
! IN NO EVENT SHALL FUJITSU LIMITED BE LIABLE FOR ANY SPECIAL, INDIRECT
! OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
! OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
! OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
! OR PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
!                                fujiwara@a80.tech.yk.fujitsu.co.jp
  
  ******************************************************************/
  
--- 9,32 ----
  provided that the above copyright notice appear in all copies and
  that both that copyright notice and this permission notice appear
  in supporting documentation, and that the name of FUJITSU LIMITED
! and Sony Corporation not be used in advertising or publicity
! pertaining to distribution of the software without specific,
! written prior permission.
! FUJITSU LIMITED and Sony Corporation make no representations about
! the suitability of this software for any purpose.  It is provided
! "as is" without express or implied warranty.
  
! FUJITSU LIMITED AND SONY CORPORATION DISCLAIM ALL WARRANTIES WITH
! REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU LIMITED AND
! SONY CORPORATION BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
! DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
! OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
! TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
! PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
! 	  Makoto Wakamatsu     Sony Corporaion
  
  ******************************************************************/
  
***************
*** 47,52 ****
--- 50,57 ----
  extern Bool		 _Ximp_GetIMExtension();
  static Bool 		 _Ximp_GetStyle();
  
+ extern Bool		 _Ximp_XimFilter_Destroy();
+ 
  Ximp_XIM 		*Ximp_Xim_List = (Ximp_XIM *)NULL;
  int			 Ximp_Xim_count = 0;
  static	Atom	 	 Protocol_ID;
***************
*** 56,62 ****
  				_Ximp_CreateIC, 	/* create_ic */
  				};
  
! static char	*Strstr( src, dest )
  register char	*src, *dest;
  {
      register	len;
--- 61,67 ----
  				_Ximp_CreateIC, 	/* create_ic */
  				};
  
! char	*_Ximp_Strstr( src, dest )
  register char	*src, *dest;
  {
      register	len;
***************
*** 103,108 ****
--- 108,114 ----
  	ximp_impart->connectserver  = 0;
  	ximp_impart->inputserver    = 1;
  	ximp_impart->use_wchar      = False;
+ 	ximp_impart->process_start_keys = NULL;
  	im->ximp_impart = ximp_impart;
  
          if(_Ximp_OpenIM_Resource(im) == True)
***************
*** 146,151 ****
--- 152,161 ----
  	for(ic = im->core.ic_chain; ic; ic = ic->core.next)
  		XDestroyIC(ic);
  	ximp_impart = (XIMXimpRec *)im->ximp_impart;
+ 	if( ximp_impart->process_start_keys ) {
+ 		XFree( ximp_impart->process_start_keys->keys_list );
+ 		XFree( ximp_impart->process_start_keys );
+ 	}
  	if(ximp_impart->connectserver) {
  		for(i=0; i < Ximp_Xim_count; i++) {
  			if(Ximp_Xim_List[i] == im) {
***************
*** 218,224 ****
   
   		(void)strcpy(IMname, _XIMP_BASE);
   		(void)strcat(IMname, LCname);
!  		mod = Strstr(lcd->core.modifiers, MODIFIER);
   		if (mod) {
   			(void)strcat(IMname, "@");
   			mod += strlen(MODIFIER);
--- 228,234 ----
   
   		(void)strcpy(IMname, _XIMP_BASE);
   		(void)strcat(IMname, LCname);
!  		mod = _Ximp_Strstr(lcd->core.modifiers, MODIFIER);
   		if (mod) {
   			(void)strcat(IMname, "@");
   			mod += strlen(MODIFIER);
***************
*** 357,363 ****
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
  		return(False);
  	}
! 	if((ext_list = (Atom *)Xmalloc((sizeof(Atom) * nitems + 1))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
  		return(False);
  	}
--- 367,373 ----
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
  		return(False);
  	}
! 	if((ext_list = (Atom *)Xmalloc((sizeof(Atom) * (nitems + 1)))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
  		return(False);
  	}
***************
*** 413,418 ****
--- 423,434 ----
  	}
  
  	_Ximp_SetupExtension(im);
+ 
+ 	_XRegisterFilterByType(im->core.display, fe_window_id,
+ 			       DestroyNotify, DestroyNotify,
+ 			       _Ximp_XimFilter_Destroy, NULL);
+ 	XSelectInput(im->core.display, fe_window_id, StructureNotifyMask);
+ 
  	im->ximp_impart->connectserver  = 1;
  	return(True);
  }
***************
*** 475,488 ****
  	int		i;
  
  	if(!(im->ximp_impart->connectserver)) {
! 		(*((long *)(p_style))) = (long)NULL;
  		return(False);
  	}
  	p = im->ximp_impart->im_styles;
! 	*p_style = (XIMStyles *)Xmalloc(sizeof(XIMStyles));
  	(*p_style)->count_styles = p->count_styles;
! 	(*p_style)->supported_styles = (XIMStyle *)
! 		Xmalloc(p->count_styles * sizeof(XIMStyle));
  	for(i=0; i < (int)p->count_styles; i++) {
  		(*p_style)->supported_styles[i] = p->supported_styles[i];
  	}
--- 491,505 ----
  	int		i;
  
  	if(!(im->ximp_impart->connectserver)) {
! 		*p_style = (XIMStyles *)NULL;
  		return(False);
  	}
  	p = im->ximp_impart->im_styles;
! 	if((*p_style = (XIMStyles *)Xmalloc(sizeof(XIMStyles)
! 			    + p->count_styles * sizeof(XIMStyle))) == NULL)
! 		return(False);
  	(*p_style)->count_styles = p->count_styles;
! 	(*p_style)->supported_styles = (XIMStyle *)(*p_style + sizeof(XIMStyles));
  	for(i=0; i < (int)p->count_styles; i++) {
  		(*p_style)->supported_styles[i] = p->supported_styles[i];
  	}
*** /tmp/d16943	Sun May  3 18:45:06 1992
--- mit/lib/X/Ximp/XimpLCd.c	Sun May  3 18:45:03 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpLCd.c,v 1.3 91/07/09 17:36:35 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpLCd.c,v 1.5 92/04/22 11:53:17 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 28,34 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 28,34 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 222,230 ****
--- 222,238 ----
  	char		*name;
  	{
  	XLCd	 xlcd;
+ #if !defined(X_NOT_STDC_ENV) && !defined(X_LOCALE)
+ 	char siname[256];
+ 	char *_XlcMapOSLocaleName();
  
+ 	_XlcMapOSLocaleName(name, siname);
+ 	if(!(xlcd = (XLCd) _Ximp_init_locale(siname)))
+ 		return((XLCd)NULL);
+ #else
  	if(!(xlcd = (XLCd) _Ximp_init_locale(name)))
  		return((XLCd)NULL);
+ #endif
  
  	xlcd->methods       = &lcd_methods;
  	xlcd->core.name     = Xmalloc(strlen(name) + 1);
*** /tmp/d16965	Sun May  3 18:45:18 1992
--- mit/lib/X/Ximp/XimpLkup.c	Sun May  3 18:45:15 1992
***************
*** 1,9 ****
! /* $XConsortium: XimpLkup.c,v 1.6 92/03/03 11:03:23 rws Exp $ */
  /******************************************************************
  
!               Copyright 1991, by Sony Corporation
!               Copyright 1991, by FUJITSU LIMITED
!               Copyright 1991, by Fuji Xerox Co.,Ltd.
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,9 ----
! /* $XConsortium: XimpLkup.c,v 1.7 92/04/14 13:29:28 rws Exp $ */
  /******************************************************************
  
!               Copyright 1991, 1992 by Sony Corporation
!               Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Fuji Xerox Co.,Ltd.
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 26,34 ****
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
  OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  
!   Author: Masaki Takeuchi,     Sony Corporation
!           Takashi Fujiwara,    FUJITSU LIMITED 
!           Kazunori Nishihara,  Fuji Xerox Co.,Ltd.
  
  ******************************************************************/
  
--- 26,35 ----
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
  OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  
!   Author: Masaki Takeuchi      Sony Corporation
!           Takashi Fujiwara     FUJITSU LIMITED 
!           Kazunori Nishihara   Fuji Xerox Co.,Ltd.
!           Makoto Wakamatsu     Sony Corporation
  
  ******************************************************************/
  
***************
*** 69,84 ****
  extern void		_Ximp_ProcExtension();
  
  static void		_Ximp_CallCallback();
! static void		_Ximp_ProcError();
  
- #if NeedFunctionPrototypes
- static Bool
- _Ximp_ResetPredicate(
- 	Display *d,
- 	XEvent *ev,
- 	XPointer parg);
- #endif
- 
  typedef struct {
  	Atom type;
  	ICID icid;
--- 70,77 ----
  extern void		_Ximp_ProcExtension();
  
  static void		_Ximp_CallCallback();
! extern void		_Ximp_ProcError();
  
  typedef struct {
  	Atom type;
  	ICID icid;
***************
*** 86,97 ****
  } XimpResetPredArgRec, *XimpResetPredArg;
  
  static Bool
! _Ximp_ResetPredicate(d, ev, parg)
  Display *d;
  XEvent *ev;
! XPointer parg;
  {
! 	XimpResetPredArg arg = (XimpResetPredArg)parg;
  	if (ev->type == ClientMessage) {
  		if (ev->xclient.message_type == arg->type) {
  			if ((ev->xclient.format == 32) &&
--- 79,98 ----
  } XimpResetPredArgRec, *XimpResetPredArg;
  
  static Bool
! #if NeedFunctionPrototypes
! _Ximp_ResetPredicate(
!     Display *d,
!     XEvent *ev,
!     XPointer arg0)
! #else
! _Ximp_ResetPredicate(d, ev, arg0)
  Display *d;
  XEvent *ev;
! XPointer arg0;
! #endif
  {
!     XimpResetPredArg arg = (XimpResetPredArg) arg0 ;
! 
  	if (ev->type == ClientMessage) {
  		if (ev->xclient.message_type == arg->type) {
  			if ((ev->xclient.format == 32) &&
***************
*** 232,240 ****
  #define LookupMessage	3
  
  static int		_xim_lookup_sign;
! static unsigned int	_xim_backup_keycode;
! static unsigned int	_xim_backup_state;
! static unsigned char	*_xim_prop_return;
  static unsigned long	_xim_string_length;
  static int		_xim_message_len;
  static unsigned char	_xim_message_buf[24];
--- 233,239 ----
  #define LookupMessage	3
  
  static int		_xim_lookup_sign;
! static unsigned char	*_xim_prop_return = (unsigned char *) NULL;
  static unsigned long	_xim_string_length;
  static int		_xim_message_len;
  static unsigned char	_xim_message_buf[24];
***************
*** 250,342 ****
  {
  	XComposeStatus	 comp_status;
  	int		 ret = 0, len;
  
  	if(ev->type == KeyPress && ev->keycode == 0) { /* Filter function */
! 		if (_xim_lookup_sign == LookupKeypress) {
! 			ev->state   = _xim_backup_state;
! 			ev->keycode = _xim_backup_keycode;
! 			ret = _Ximp_LookupMBText(ic, ev, buffer, bytes, keysym, &comp_status);
! 			ev->send_event = False ;
! 			if(ret > 0) {
! 				if(keysym && *keysym != NoSymbol) {
! 					if(status) *status = XLookupBoth;
! 					 }
! 				else {
! 					if(status) *status = XLookupChars;
! 					}
! 				}
! 			else {
! 				if(keysym && *keysym != NoSymbol) {
! 					if(status) *status = XLookupKeySym;
! 					}
! 				else {
! 					if(status) *status = XLookupNone;
! 					}
! 				}
! 			return(ret);
  			}
! 		else if(_xim_lookup_sign == LookupProperty) {
! 			if (_Ximp_cttombs(ic->core.im->core.lcd,
! 					  _xim_prop_return,
! 					  _xim_string_length,
! 					  buffer, &bytes, NULL) < 0) 
! 			    ret = 0;
! 			else
! 			    ret = bytes;
! 			XFree((XPointer)_xim_prop_return);
  			}
! 		else if (_xim_lookup_sign == LookupMessage) {
! 			if (_Ximp_cttombs(ic->core.im->core.lcd,
! 					  _xim_message_buf,
! 					  _xim_message_len,
! 					  buffer, &bytes, NULL) < 0) 
! 			    ret = 0;
! 			else
! 			    ret = bytes;
! 			}
! 		if(status)*status = (ret > 0) ? XLookupChars : XLookupNone;
! 		return(ret);
  		}
  	else if(ev->type == KeyPress) {
! 		if(ic->core.client_window == (Window)NULL) {
  			if(status) *status = XLookupNone;
  			return(0);
! 			}
! 		if (ic->ximp_icpart->input_mode) {/* ON : input_mode */
! 			_Ximp_IM_SendMessage(ic, XIMP_KEYPRESS,
! 						 (long)ev->keycode,
! 						 (long)ev->state, NULL);
! 			if(status) *status = XLookupNone;
! 			return(0);
! 			}
  		ret = _Ximp_LookupMBText(ic, ev, buffer, bytes, keysym, &comp_status);
- 		if(ret >= 0) {
- 			if(_Ximp_StartXIMP(ic, ev, keysym ? *keysym : 0)) {
- 				if(status) *status = XLookupNone;
- 					return(0);
- 				}
- 			}
  		if(ret > 0) {
  			if(keysym && *keysym != NoSymbol) {
  				if(status) *status = XLookupBoth;
! 				}
! 			 else {
  				if(status) *status = XLookupChars;
- 				}
  			}
  		else {
  			if(keysym && *keysym != NoSymbol) {
  				if(status) *status = XLookupKeySym;
! 				}
! 			 else {
  				if(status) *status = XLookupNone;
- 				}
  			}
!  		}
  	else {
! 		if (status)
! 			*status = XLookupNone;
!     		}
  	return(ret);
  }
  
--- 249,314 ----
  {
  	XComposeStatus	 comp_status;
  	int		 ret = 0, len;
+ 	Ximp_XLCd	 lcd;
+ 	unsigned char    *s;
+ 	int		 str_len;
  
  	if(ev->type == KeyPress && ev->keycode == 0) { /* Filter function */
! 		if ((_xim_lookup_sign == LookupProperty) ||
! 		    (_xim_lookup_sign == LookupMessage)) {
! 			if (_xim_lookup_sign == LookupMessage) {
! 				s = _xim_message_buf;
! 				str_len = _xim_message_len;
! 			} else {
! 				s = _xim_prop_return;
! 				str_len = _xim_string_length;
  			}
! 			lcd = (Ximp_XLCd)ic->core.im->core.lcd;
! 			len = _Ximp_ct_mbslen(lcd, s, str_len, NULL);
! 			if (len > bytes) {
! 				ret = len;
! 				if(status) *status = XBufferOverflow;
! 			} else if (_Ximp_cttombs(lcd, s, str_len,
! 					  	 buffer, &bytes, NULL) <=  0) {
! 				ret = 0;
! 				if(status) *status = XLookupNone;
! 			} else {
! 				ret = bytes;
! 				if(status) *status = XLookupChars;
  			}
! 			return(ret);
! 		} else {
! 			if(status) *status = XLookupNone;
! 			return(0);
  		}
+ 	}
  	else if(ev->type == KeyPress) {
! 		if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
  			if(status) *status = XLookupNone;
  			return(0);
! 		}
! 		ic->ximp_icpart->putback_key_event = False;
  		ret = _Ximp_LookupMBText(ic, ev, buffer, bytes, keysym, &comp_status);
  		if(ret > 0) {
  			if(keysym && *keysym != NoSymbol) {
  				if(status) *status = XLookupBoth;
! 			}
! 			else {
  				if(status) *status = XLookupChars;
  			}
+ 		}
  		else {
  			if(keysym && *keysym != NoSymbol) {
  				if(status) *status = XLookupKeySym;
! 			}
! 			else {
  				if(status) *status = XLookupNone;
  			}
! 		}
!  	}
  	else {
! 		if (status) *status = XLookupNone;
!     	}
  	return(ret);
  }
  
***************
*** 352,440 ****
  	XComposeStatus	 comp_status;
  	int		 ret, len;
  	char		 look[128];
  
  	if(ev->type == KeyPress && ev->keycode == 0) { /* Filter function */
! 		if (_xim_lookup_sign == LookupKeypress) {
! 			ev->state   = _xim_backup_state;
! 			ev->keycode = _xim_backup_keycode;
! 			ret = _Ximp_LookupWCText(ic, ev, buffer, wlen, keysym, &comp_status);
! 			ev->send_event = False ;
! 			if(ret > 0) {
! 				if(keysym && *keysym != NoSymbol) {
! 					if(status) *status = XLookupBoth;
! 					 }
! 				else {
! 					if(status) *status = XLookupChars;
! 					}
! 				}
! 			else {
! 				if(keysym && *keysym != NoSymbol) {
! 					if(status) *status = XLookupKeySym;
! 					}
! 				else {
! 					if(status) *status = XLookupNone;
! 					}
! 				}
! 			return(ret);
  			}
! 		else if(_xim_lookup_sign == LookupProperty) {
! 			len = wlen;
! 			if (_Ximp_cttowcs(ic->core.im->core.lcd,
! 							  _xim_prop_return,
! 							  _xim_string_length,
! 							  buffer, &len, NULL) < 0)
! 				ret = 0;
! 			else
  				ret = len;
! 			XFree((XPointer)_xim_prop_return);
! 			}
! 		else if (_xim_lookup_sign == LookupMessage) {
! 			len = wlen;
! 			if (_Ximp_cttowcs(ic->core.im->core.lcd,
! 							  _xim_message_buf,
! 							  _xim_message_len,
! 							  buffer, &len, NULL) < 0)
  				ret = 0;
! 			else
! 				ret = len;
  			}
! 		if(status)*status = (ret > 0) ? XLookupChars : XLookupNone;
! 		return(ret);
! 		}
! 	else {
! 		if(ic->core.client_window == (Window)NULL) {
  			if(status) *status = XLookupNone;
  			return(0);
! 			}
! 		if (ic->ximp_icpart->input_mode) {/* ON : input_mode */
! 			_Ximp_IM_SendMessage(ic, XIMP_KEYPRESS,
! 						 (long)ev->keycode,
! 						 (long)ev->state, NULL);
  			if(status) *status = XLookupNone;
  			return(0);
  			}
  		ret = _Ximp_LookupWCText(ic, ev, buffer, wlen, keysym, &comp_status);
! 		if(ret >= 0) {
! 			if(_Ximp_StartXIMP(ic, ev, keysym ? *keysym : 0)) {
! 				if(status) *status = XLookupNone;
! 					return(0);
! 				}
  			if(keysym && *keysym != NoSymbol) {
  				if(status) *status = XLookupBoth;
! 				}
  			 else {
  				if(status) *status = XLookupChars;
- 				}
  			}
  		else {
  			if(keysym && *keysym != NoSymbol) {
  				if(status) *status = XLookupKeySym;
! 				}
  			 else {
  				if(status) *status = XLookupNone;
- 				}
  			}
!  		}
  	return(ret);
  }
  
--- 324,389 ----
  	XComposeStatus	 comp_status;
  	int		 ret, len;
  	char		 look[128];
+ 	Ximp_XLCd	 lcd;
+ 	unsigned char    *s;
+ 	int		 str_len;
  
  	if(ev->type == KeyPress && ev->keycode == 0) { /* Filter function */
! 		if ((_xim_lookup_sign == LookupProperty) ||
! 		    (_xim_lookup_sign == LookupMessage)) {
! 			if (_xim_lookup_sign == LookupMessage) {
! 				s = _xim_message_buf;
! 				str_len = _xim_message_len;
! 			} else {
! 				s = _xim_prop_return;
! 				str_len = _xim_string_length;
  			}
! 			lcd = (Ximp_XLCd)ic->core.im->core.lcd;
! 			len = _Ximp_ct_wcslen(lcd, s, str_len, NULL);
! 			if (len > wlen) {
  				ret = len;
! 				if(status) *status = XBufferOverflow;
! 			} else if (_Ximp_cttowcs(lcd, s, str_len,
! 						 buffer, &wlen, NULL) <=  0) {
  				ret = 0;
! 				if(status) *status = XLookupNone;
! 			} else {
! 				ret = wlen;
! 				if(status) *status = XLookupChars;
  			}
! 			return(ret);
! 		} else {
  			if(status) *status = XLookupNone;
  			return(0);
! 		}
! 	}
! 	else if(ev->type == KeyPress) {
! 		if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
  			if(status) *status = XLookupNone;
  			return(0);
  			}
+ 		ic->ximp_icpart->putback_key_event = False;
  		ret = _Ximp_LookupWCText(ic, ev, buffer, wlen, keysym, &comp_status);
! 		if(ret > 0) {
  			if(keysym && *keysym != NoSymbol) {
  				if(status) *status = XLookupBoth;
! 			}
  			 else {
  				if(status) *status = XLookupChars;
  			}
+ 		}
  		else {
  			if(keysym && *keysym != NoSymbol) {
  				if(status) *status = XLookupKeySym;
! 			}
  			 else {
  				if(status) *status = XLookupNone;
  			}
! 		}
!  	}
! 	else {
! 		if (status) *status = XLookupNone;
!     	}
  	return(ret);
  }
  
***************
*** 476,499 ****
  	XEvent			 Message;
  	extern Bool		_Ximp_Setup ();
  
! 	if(ic->ximp_icpart->input_mode) /* ON : input_mode */
! 		return(False);
  
  	if(!(((Ximp_XIM)ic->core.im)->ximp_impart->connectserver)) {
! 		if(keysym && keysym ==
! 		  (((Ximp_XIM)ic->core.im)->ximp_impart->def_startkeysym)) {
! 			if(_Ximp_Setup (ic->core.im) == False)
! 				isEventPassedToIMS = 1;
! 			else
! 				isEventPassedToIMS = 0;
  		}
! 		else
! 			isEventPassedToIMS = 1;
! 	}
! 	else {	
  		list = ((Ximp_XIM)ic->core.im)->ximp_impart->im_keyslist;
  		for(i = 0, isEventPassedToIMS = 1; i < (int)list->count_keys; i++) {
! 			if(   (keysym && keysym == list->keys_list[i].keysym)
  			   && ((ev->state & list->keys_list[i].modifier_mask)
  			       == list->keys_list[i].modifier ) ) {
  				isEventPassedToIMS = 0;
--- 425,456 ----
  	XEvent			 Message;
  	extern Bool		_Ximp_Setup ();
  
! 	if (ic->ximp_icpart->input_mode) { /* ON : input_mode */
! 		if (!ic->ximp_icpart->putback_key_event && ev->keycode != 0) {
! 			_Ximp_IM_SendMessage( ic, XIMP_KEYPRESS,
! 					     (long)ev->keycode,
! 					     (long)ev->state, NULL );
! 			return (True);
! 		}
! 		return (False);
! 	}
  
  	if(!(((Ximp_XIM)ic->core.im)->ximp_impart->connectserver)) {
! 		if( (list = ((Ximp_XIM)ic->core.im)->ximp_impart->process_start_keys) == NULL )
! 			return(False);
! 		for(i = 0, isEventPassedToIMS = 1; i < (int)list->count_keys; i++) {
! 			if( (keysym && keysym == list->keys_list[i].keysym)
! 			   && ((ev->state & list->keys_list[i].modifier_mask)
! 			       == list->keys_list[i].modifier ) ) {
! 				isEventPassedToIMS = (_Ximp_Setup( ic->core.im ) == False);
! 				break;
! 				}
! 			}
  		}
! 	else {
  		list = ((Ximp_XIM)ic->core.im)->ximp_impart->im_keyslist;
  		for(i = 0, isEventPassedToIMS = 1; i < (int)list->count_keys; i++) {
! 			if( (keysym && keysym == list->keys_list[i].keysym)
  			   && ((ev->state & list->keys_list[i].modifier_mask)
  			       == list->keys_list[i].modifier ) ) {
  				isEventPassedToIMS = 0;
***************
*** 500,521 ****
  				break;
  				}
  			}
! 	}
  	if(isEventPassedToIMS) return(False);
  
  	if(ic->ximp_icpart->icid == NULL)
! 		if(!(_Ximp_SetOpenXIMP(ic))) return(False);
! 	_XRegisterFilterByType(ic->core.im->core.display,
! 			       ic->core.client_window,
! 			       ClientMessage, ClientMessage,
! 			       _Ximp_XimFilter_Client, NULL);
! 	_XRegisterFilterByType(ic->core.im->core.display,
! 			       ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window,
! 			       DestroyNotify, DestroyNotify,
! 			       _Ximp_XimFilter_Destroy, NULL);
! 	XSelectInput (ic->core.im->core.display,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->fe_window,
! 			StructureNotifyMask);
  
  	if (_Ximp_FocusInput (ic->core.focus_window, &dummy_mask))
  		ic->ximp_icpart->back_mask = dummy_mask;
--- 457,467 ----
  				break;
  				}
  			}
! 		}
  	if(isEventPassedToIMS) return(False);
  
  	if(ic->ximp_icpart->icid == NULL)
! 		if(!(_Ximp_SetOpenXIMP(ic, XIMP_START_IC))) return(False);
  
  	if (_Ximp_FocusInput (ic->core.focus_window, &dummy_mask))
  		ic->ximp_icpart->back_mask = dummy_mask;
***************
*** 532,556 ****
  		XSelectInput(d, ic->core.focus_window, dummy_mask);
  	}
  	ic->ximp_icpart->input_mode = 1;
  	_Ximp_IM_SendMessage(ic, XIMP_BEGIN, NULL, NULL, NULL);
  	XFlush(ic->core.im->core.display);
  	return(True);
  }
  
  Bool
! _Ximp_SetOpenXIMP(ic)
  	Ximp_XIC	ic;
  {
  	unsigned long	 mask;
  	XEvent		 event;
  
! 	if(ic->core.client_window == (Window)NULL)
! 		return(False);
  
  	if(!(ic->ximp_icpart->proto_mask & XIMP_FOCUS_WIN_MASK)) {
- 		ic->ximp_icpart->proto_mask |= XIMP_FOCUS_WIN_MASK;
  		ic->core.focus_window = ic->core.client_window;
! 		}
  	
  	/* Property Data Set */
  	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
--- 478,545 ----
  		XSelectInput(d, ic->core.focus_window, dummy_mask);
  	}
  	ic->ximp_icpart->input_mode = 1;
+ 	_Ximp_IM_SendMessage(ic, XIMP_MOVE,
+ 		ic->ximp_icpart->preedit_attr.SpotLocation.x,
+ 		ic->ximp_icpart->preedit_attr.SpotLocation.y,
+ 		NULL);
  	_Ximp_IM_SendMessage(ic, XIMP_BEGIN, NULL, NULL, NULL);
  	XFlush(ic->core.im->core.display);
  	return(True);
  }
  
+ 
+ typedef struct {
+ 	Atom type;
+ 	Window owner;
+ } XimpCreatePredArgRec, *XimpCreatePredArg;
+ 
+ static Bool
+ _Ximp_CreatePredicate(d, ev, arg0)
+ Display *d;
+ XEvent *ev;
+ XPointer arg0;
+ {
+     XimpCreatePredArg arg = (XimpCreatePredArg) arg0;
+ 
+ 	if (ev->type == ClientMessage) {
+ 		if (ev->xclient.message_type == arg->type) {
+ 			if (ev->xclient.format == 32) {
+ 				switch (ev->xclient.data.l[0]) {
+ 				case XIMP_CREATE_RETURN:
+ 				case XIMP_ERROR:
+ 					return(True);
+ 				}
+ 			}
+ 		}
+ 	} else if (ev->type == DestroyNotify) {
+ 		if (ev->xdestroywindow.window == arg->owner) {
+ 			return(True);
+ 		}
+ 	}
+ 	return(False);
+ }
+ 
  Bool
! _Ximp_SetOpenXIMP(ic, mode)
  	Ximp_XIC	ic;
+ 	int		mode;
  {
  	unsigned long	 mask;
  	XEvent		 event;
+ 	XimpCreatePredArgRec Arg;
  
! 	if(mode == XIMP_CREATE_IC) {  /* XCretaeIC() */
! 		if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
! 			ic->core.client_window = XCreateSimpleWindow(
! 				ic->core.im->core.display,
! 				DefaultRootWindow(ic->core.im->core.display),
! 				0, 0, 1, 1, 1, 0, 0);
! 		}
! 	}
  
  	if(!(ic->ximp_icpart->proto_mask & XIMP_FOCUS_WIN_MASK)) {
  		ic->core.focus_window = ic->core.client_window;
! 	}
  	
  	/* Property Data Set */
  	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
***************
*** 560,567 ****
  	XFlush(ic->core.im->core.display);
  
  	mask = ic->ximp_icpart->proto_mask;
! 	if(mask & XIMP_PROP_FOCUS)
! 		_Ximp_SetFocusWindow(ic);
  	if(!(   (ic->core.input_style & XIMPreeditCallbacks)
  	     || (ic->core.input_style & XIMPreeditNone) ) ) { 
  		if(mask & XIMP_PROP_PREEDIT)
--- 549,556 ----
  	XFlush(ic->core.im->core.display);
  
  	mask = ic->ximp_icpart->proto_mask;
! 	_Ximp_SetFocusWindow(ic);
! 	mask |= XIMP_FOCUS_WIN_MASK;
  	if(!(   (ic->core.input_style & XIMPreeditCallbacks)
  	     || (ic->core.input_style & XIMPreeditNone) ) ) { 
  		if(mask & XIMP_PROP_PREEDIT)
***************
*** 590,623 ****
  	signal(SIGALRM, _time_out);
  	alarm(XIMP_TIME_OUT);
  #endif /* XIMP_SIGNAL */
  	while(_time_flag != 1) {
! 		if( (XCheckTypedEvent(ic->core.im->core.display, ClientMessage, &event)) == False) {
  #ifdef XIMP_SIGNAL
  			sleep(1);
  #endif /* XIMP_SIGNAL */
  			continue;
  			}
! 		if(event.xclient.message_type != ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id) {
! 			XPutBackEvent(ic->core.im->core.display, &event);
! 			continue;
! 			}
! 		else if(event.xclient.data.l[0] != XIMP_CREATE_RETURN) {
  #ifdef XIMP_SIGNAL
  			alarm(0);
  #endif /* XIMP_SIGNAL */
! 			_Ximp_ProcError (ic->core.im->core.display, NULL, &event);
  			_time_flag = 0;
! 			/* return(False); */
! 			continue;
  			}
! 		else { /* XIMP_CRETAE_RETURN   Event */
  #ifdef XIMP_SIGNAL
  			alarm(0);
  #endif /* XIMP_SIGNAL */
! 			ic->ximp_icpart->icid = (ICID)event.xclient.data.l[1];
! 			_Ximp_A_CreateExtension(ic);
  			_time_flag = 0;
! 			return(True);
  			}
  		}
  	_time_flag = 0;
--- 579,611 ----
  	signal(SIGALRM, _time_out);
  	alarm(XIMP_TIME_OUT);
  #endif /* XIMP_SIGNAL */
+ 	Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
+ 	Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
  	while(_time_flag != 1) {
! 		if( (XCheckIfEvent(ic->core.im->core.display, &event, _Ximp_CreatePredicate, (XPointer)&Arg)) == False) {
  #ifdef XIMP_SIGNAL
  			sleep(1);
  #endif /* XIMP_SIGNAL */
  			continue;
  			}
! 		if(event.type == ClientMessage &&
! 		   event.xclient.data.l[0] == XIMP_CREATE_RETURN) {
  #ifdef XIMP_SIGNAL
  			alarm(0);
  #endif /* XIMP_SIGNAL */
! 			ic->ximp_icpart->icid = (ICID)event.xclient.data.l[1];
! 			_Ximp_A_CreateExtension(ic);
  			_time_flag = 0;
! 			return(True);
  			}
! 		else {
  #ifdef XIMP_SIGNAL
  			alarm(0);
  #endif /* XIMP_SIGNAL */
! 			_Ximp_ProcError (ic->core.im->core.display, NULL, &event);
  			_time_flag = 0;
! 			/* return(False); */
! 			continue;
  			}
  		}
  	_time_flag = 0;
***************
*** 635,651 ****
  }
  
  void
! _Ximp_ProcKeypress (d, w, ev)
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
  {
! 	ICID	icid;
  
  	icid = ev->data.l[1];
! 	_xim_backup_keycode = ev->data.l[2];
! 	_xim_backup_state = ev->data.l[3];
! 	_xim_lookup_sign = LookupKeypress;
  }
  
  static void
--- 623,657 ----
  }
  
  void
! _Ximp_ProcKeypress (d, w, ev, kev)
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
+ 	XKeyEvent		*kev;
  {
! 	ICID			icid;
! 	Ximp_XIC 		ic;
  
  	icid = ev->data.l[1];
! 	kev->type = KeyPress;
! 	kev->serial = ev->serial;
! 	kev->send_event = False;
! 	kev->display = ev->display;
! 	kev->window = ev->window;
! 	kev->root = DefaultRootWindow(ev->display);
! 	kev->subwindow = (Window)NULL;
! 	kev->time = 0L;
! 	kev->x = 0;
! 	kev->y = 0;
! 	kev->x_root = 0;
! 	kev->y_root = 0;
! 	kev->keycode = ev->data.l[2];
! 	kev->state = ev->data.l[3];
! 	kev->same_screen = True;
! 	ic = _Ximp_LookupXIC(icid);
! 	if(ic->ximp_icpart->input_mode) { /* ON : input_mode */
! 		ic->ximp_icpart->putback_key_event = True;
! 	}
  }
  
  static void
***************
*** 724,729 ****
--- 730,738 ----
  	int			actual_format_return;
  	unsigned long		nitems_return;
  
+ 	if (_xim_prop_return) {
+ 		XFree((XPointer)(_xim_prop_return));
+ 	}
  	icid      = ev->data.l[1];
  	read_prop = ev->data.l[2];
  	ic   = _Ximp_LookupXIC(icid);
***************
*** 741,747 ****
  	_xim_lookup_sign = LookupProperty;
  }
  
! static void
  _Ximp_ProcError (d, w, ev)
  	Display			*d;
  	Window			w;
--- 750,756 ----
  	_xim_lookup_sign = LookupProperty;
  }
  
! void
  _Ximp_ProcError (d, w, ev)
  	Display			*d;
  	Window			w;
***************
*** 850,864 ****
  	XClientMessageEvent	*ev;
  	XPointer		*client_data;
  {
  	if (ev->message_type != _Ximp_Protocol_id ())
  		return (False);
  	if (ev->format == 32) {
  		switch (ev->data.l[0]) {
  		case XIMP_KEYPRESS:
! 			_Ximp_ProcKeypress (d, w, ev);
! 			_Ximp_MakeKeypress (d, w, ev);
! 			ev->send_event = False ;
! 			XPutBackEvent(d, (XEvent *)ev);
  			break ;
  		case XIMP_CREATE_RETURN:
  			_Ximp_ProcCreateReturn (d, w, ev);
--- 859,873 ----
  	XClientMessageEvent	*ev;
  	XPointer		*client_data;
  {
+ 	XKeyEvent kev;
+ 
  	if (ev->message_type != _Ximp_Protocol_id ())
  		return (False);
  	if (ev->format == 32) {
  		switch (ev->data.l[0]) {
  		case XIMP_KEYPRESS:
! 			_Ximp_ProcKeypress (d, w, ev, &kev);
! 			XPutBackEvent(d, (XEvent *)&kev);
  			break ;
  		case XIMP_CREATE_RETURN:
  			_Ximp_ProcCreateReturn (d, w, ev);
***************
*** 920,929 ****
  	long			dummy_mask;
  
  	for(i=0; i < Ximp_Xim_count; i++) {
! 		if(Ximp_Xim_List[i]->ximp_impart->fe_window == w)
  			ximp_impart = Ximp_Xim_List[i]->ximp_impart;
  		else
  			continue;
  		_Ximp_SetupFreeExtension(Ximp_Xim_List[i]);
  		_Ximp_SetupFree(ximp_impart->im_proto_vl,
  			ximp_impart->im_styles,
--- 929,940 ----
  	long			dummy_mask;
  
  	for(i=0; i < Ximp_Xim_count; i++) {
! 		if(Ximp_Xim_List[i] != NULL  &&
! 		   Ximp_Xim_List[i]->ximp_impart->fe_window == w)
  			ximp_impart = Ximp_Xim_List[i]->ximp_impart;
  		else
  			continue;
+ 		_XUnregisterFilter(d, w, _Ximp_XimFilter_Destroy, (XPointer)NULL);
  		_Ximp_SetupFreeExtension(Ximp_Xim_List[i]);
  		_Ximp_SetupFree(ximp_impart->im_proto_vl,
  			ximp_impart->im_styles,
***************
*** 933,940 ****
--- 944,956 ----
  			ximp_impart->im_vendor_name,
  			ximp_impart->im_ext_list);
  		ximp_impart->connectserver = 0;
+ 		ximp_impart->fe_window = (Window)NULL;
  		for(ic = Ximp_Xim_List[i]->core.ic_chain; ic; ic = ic->core.next) {
  			((Ximp_XIC)ic)->ximp_icpart->icid = NULL;
+ 			_XUnregisterFilter(d,
+ 					   ic->core.focus_window,
+ 					   _Ximp_XimFilter_Client,
+ 					   NULL);
  			if(((Ximp_XIC)ic)->ximp_icpart->input_mode) {/* ON : input_mode */
  				dummy_mask = ((Ximp_XIC)ic)->ximp_icpart->back_mask;
  				XSelectInput(ic->core.im->core.display,
***************
*** 948,965 ****
  }
  
  Bool
! _Ximp_Keypress (d, w, ev, ic)
! 	Display			*d;
! 	Window			w;
! 	XKeyEvent		*ev;
! 	Ximp_XIC		ic;
  {
! #define BUFFLIM		32
! 	KeySym		ks;
! 	char		buff[BUFFLIM];
  
! 	XLookupString (ev, buff, BUFFLIM, &ks, NULL);
! 	return _Ximp_StartXIMP (ic, ev, ks);
  }
  
  /*
--- 964,981 ----
  }
  
  Bool
! _Ximp_XimFilter_Keypress (d, w, ev, client_data)
! 	Display		*d;
! 	Window		w;
! 	XEvent		*ev;
! 	XPointer	client_data;
  {
! #define	BUFFLIM		32
!     KeySym		ks;
!     char		buff[BUFFLIM];
  
!     XLookupString( (XKeyEvent *)ev, buff, BUFFLIM, &ks, NULL );
!     return( _Ximp_StartXIMP( (Ximp_XIC)client_data, ev, ks ) );
  }
  
  /*
*** /tmp/d16987	Sun May  3 18:45:31 1992
--- mit/lib/X/Ximp/XimpMCT.c	Sun May  3 18:45:28 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpMCT.c,v 1.4 91/10/07 17:50:08 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpMCT.c,v 1.5 92/04/14 13:29:33 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 28,34 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 28,34 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 227,232 ****
--- 227,306 ----
      if (mbstr_len)
  	*mbstr_len = bufptr - mbstr;
      ret = ctptr - ctext;
+ error:
+     (*lcd->ximp_lcpart->methods->cnv_end)(lcd);
+ 
+     return ret;
+ }
+ 
+ int
+ _Ximp_ct_mbslen(lcd, ctext, ctext_len, unconv_num)
+     Ximp_XLCd lcd;
+     unsigned char *ctext;
+     int ctext_len;
+     int *unconv_num;
+ {
+     unsigned char ch, *ctptr = ctext;
+     unsigned char *tmpptr;
+     unsigned char msb_mask;
+     unsigned char buf[BUFSIZE];
+     int GL_codeset, GR_codeset, codeset_number;
+     int tmp_len, skip_size;
+     int ret = 0;
+     int (*cstombs)();
+ 
+     if (unconv_num)
+ 	*unconv_num = 0;
+     
+     cstombs = lcd->ximp_lcpart->methods->cstombs;
+     GL_codeset = _get_codeset_number(lcd, ISO8859_1, GL);
+     GR_codeset = _get_codeset_number(lcd, ISO8859_1, GR);
+ 
+     (*lcd->ximp_lcpart->methods->cnv_start)(lcd);
+ 
+     while (ctext_len > 0) {
+ 	ch = *ctptr;
+ 	if (ch == 0x1b) {
+ 	    tmp_len = _check_ESC_sequence(lcd, ctptr, ctext_len, 
+ 					  &GL_codeset, &GR_codeset);
+ 	} else if (ch == 0x9b) {
+ 	    tmp_len =_check_CSI_sequence(lcd, ctptr, ctext_len);
+ 	} else {
+ 	    tmpptr = ctptr;
+ 	    msb_mask = ch & 0x80;
+ 	    for ( ; ctext_len; tmpptr++, ctext_len--) {
+ 		ch = *tmpptr;
+ 		if (msb_mask != (ch & 0x80) || ch == '\033' || ch == 0x9b)
+ 		    break;
+ 	        if ((ch < 0x20 && ch != '\n' && ch != '\t') ||
+ 			(ch >= 0x80 && ch < 0xa0)) {
+ 		    ret = -1;
+ 		    goto error;
+ 		}
+ 	    }
+ 
+ 	    codeset_number = msb_mask ? GR_codeset : GL_codeset;
+ 	    if (codeset_number > -1) {
+ 		tmp_len = BUFSIZE;
+ 		skip_size = (*cstombs)(lcd, ctptr, tmpptr - ctptr,
+ 				       buf, &tmp_len, codeset_number);
+ 		if (skip_size < 0) {
+ 		    ret - -1;
+ 		    goto error;
+ 		}
+ 		ret += tmp_len;
+ 	    } else if (unconv_num)
+ 		*unconv_num += tmpptr - ctptr;
+ 	    ctptr = tmpptr;
+ 	    continue;
+ 	}
+ 	if (tmp_len < 0) {
+ 	    ret = -1;
+ 	    goto error;
+ 	}
+ 	ctptr += tmp_len;
+ 	ctext_len -= tmp_len;
+     }
  error:
      (*lcd->ximp_lcpart->methods->cnv_end)(lcd);
  
*** /tmp/d17009	Sun May  3 18:45:43 1992
--- mit/lib/X/Ximp/XimpMDrS.c	Sun May  3 18:45:40 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpMDrS.c,v 1.2 91/07/09 17:22:03 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpMDrS.c,v 1.3 92/04/14 13:29:36 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 29,35 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 29,35 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17031	Sun May  3 18:45:55 1992
--- mit/lib/X/Ximp/XimpMEsc.c	Sun May  3 18:45:52 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpMEsc.c,v 1.2 91/07/09 17:22:05 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpMEsc.c,v 1.3 92/04/14 13:29:38 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 29,35 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 29,35 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17053	Sun May  3 18:46:06 1992
--- mit/lib/X/Ximp/XimpMExt.c	Sun May  3 18:46:04 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpMExt.c,v 1.2 91/07/09 17:22:07 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpMExt.c,v 1.3 92/04/14 13:29:40 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 29,35 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 29,35 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17075	Sun May  3 18:46:18 1992
--- mit/lib/X/Ximp/XimpWCT.c	Sun May  3 18:46:15 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpWCT.c,v 1.4 91/10/07 17:50:48 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpWCT.c,v 1.5 92/04/14 13:30:14 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 28,34 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 28,34 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 227,232 ****
--- 227,306 ----
      if (wcstr_len)
  	*wcstr_len = bufptr - wcstr;
      ret = ctptr - ctext;
+ error:
+     (*lcd->ximp_lcpart->methods->cnv_end)(lcd);
+ 
+     return ret;
+ }
+ 
+ int
+ _Ximp_ct_wcslen(lcd, ctext, ctext_len, unconv_num)
+     Ximp_XLCd lcd;
+     unsigned char *ctext;
+     int ctext_len;
+     int *unconv_num;
+ {
+     unsigned char ch, *ctptr = ctext;
+     unsigned char *tmpptr;
+     unsigned char msb_mask;
+     wchar_t buf[BUFSIZE];
+     int GL_codeset, GR_codeset, codeset_number;
+     int tmp_len, skip_size;
+     int ret = 0;
+     int (*cstowcs)();
+ 
+     if (unconv_num)
+ 	*unconv_num = 0;
+     
+     cstowcs = lcd->ximp_lcpart->methods->cstowcs;
+     GL_codeset = _get_codeset_number(lcd, ISO8859_1, GL);
+     GR_codeset = _get_codeset_number(lcd, ISO8859_1, GR);
+ 
+     (*lcd->ximp_lcpart->methods->cnv_start)(lcd);
+ 
+     while (ctext_len > 0) {
+ 	ch = *ctptr;
+ 	if (ch == 0x1b) {
+ 	    tmp_len = _check_ESC_sequence(lcd, ctptr, ctext_len, 
+ 					  &GL_codeset, &GR_codeset);
+ 	} else if (ch == 0x9b) {
+ 	    tmp_len =_check_CSI_sequence(lcd, ctptr, ctext_len);
+ 	} else {
+ 	    tmpptr = ctptr;
+ 	    msb_mask = ch & 0x80;
+ 	    for ( ; ctext_len; tmpptr++, ctext_len--) {
+ 		ch = *tmpptr;
+ 		if (msb_mask != (ch & 0x80) || ch == '\033' || ch == 0x9b)
+ 		    break;
+ 	        if ((ch < 0x20 && ch != '\n' && ch != '\t') ||
+ 			(ch >= 0x80 && ch < 0xa0)) {
+ 		    ret = -1;
+ 		    goto error;
+ 		}
+ 	    }
+ 
+ 	    codeset_number = msb_mask ? GR_codeset : GL_codeset;
+ 	    if (codeset_number > -1) {
+ 		tmp_len = BUFSIZE;
+ 		skip_size = (*cstowcs)(lcd, ctptr, tmpptr - ctptr,
+ 				       buf, &tmp_len, codeset_number);
+ 		if (skip_size < 0) {
+ 		    ret = -1;
+ 		    goto error;
+ 		}
+ 		ret += tmp_len;
+ 	    } else if (unconv_num)
+ 		*unconv_num += tmpptr - ctptr;
+ 	    ctptr = tmpptr;
+ 	    continue;
+ 	}
+ 	if (tmp_len < 0) {
+ 	    ret = -1;
+ 	    goto error;
+ 	}
+ 	ctptr += tmp_len;
+ 	ctext_len -= tmp_len;
+     }
  error:
      (*lcd->ximp_lcpart->methods->cnv_end)(lcd);
  
*** /tmp/d17097	Sun May  3 18:46:30 1992
--- mit/lib/X/Ximp/XimpWDrS.c	Sun May  3 18:46:27 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpWDrS.c,v 1.2 91/07/09 17:22:11 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpWDrS.c,v 1.3 92/04/14 13:30:18 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 29,35 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 29,35 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17119	Sun May  3 18:46:42 1992
--- mit/lib/X/Ximp/XimpWEsc.c	Sun May  3 18:46:39 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpWEsc.c,v 1.2 91/07/09 17:22:12 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpWEsc.c,v 1.3 92/04/14 13:30:22 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 29,35 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 29,35 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17141	Sun May  3 18:46:53 1992
--- mit/lib/X/Ximp/XimpWExt.c	Sun May  3 18:46:50 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpWExt.c,v 1.2 91/07/09 17:22:14 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpWExt.c,v 1.3 92/04/14 13:30:24 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 29,35 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 29,35 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17163	Sun May  3 18:47:05 1992
--- mit/lib/X/Ximp/Ximplc.h	Sun May  3 18:47:02 1992
***************
*** 1,7 ****
! /* $XConsortium: Ximplc.h,v 1.4 91/10/07 17:51:06 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: Ximplc.h,v 1.5 92/04/14 13:30:42 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 28,34 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 28,35 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 35,55 ****
  provided that the above copyright notice appear in all copies and
  that both that copyright notice and this permission notice appear
  in supporting documentation, and that the name of FUJITSU LIMITED
! not be used in advertising or publicity pertaining to distribution
! of the software without specific, written prior permission.
! FUJITSU LIMITED makes no representations about the suitability of
! this software for any purpose.  It is provided "as is" without
! express or implied warranty.
  
! FUJITSU LIMITED DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
! INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
! IN NO EVENT SHALL FUJITSU LIMITED BE LIABLE FOR ANY SPECIAL, INDIRECT
! OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
! OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
! OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
! OR PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
  
  ******************************************************************/
  /*
--- 36,60 ----
  provided that the above copyright notice appear in all copies and
  that both that copyright notice and this permission notice appear
  in supporting documentation, and that the name of FUJITSU LIMITED
! and Sony Corporation not be used in advertising or publicity
! pertaining to distribution of the software without specific, written
! prior permission.
! FUJITSU LIMITED and Sony Corporation make no representations about
! the suitability of this software for any purpose.  It is provided
! "as is" without express or implied warranty.
  
! FUJITSU LIMITED AND SONY CORPORATION DISCLAIM ALL WARRANTIES WITH
! REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU LIMITED AND
! SONY CORPORATION BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
! DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
! OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
! TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
! PERFORMANCE
! OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
+           Makoto Wakamatsu     Sony Corporation
  
  ******************************************************************/
  /*
***************
*** 200,205 ****
--- 205,211 ----
  
  #define XIMP_CREATE_IC	0
  #define	XIMP_SET_IC	1
+ #define	XIMP_START_IC	2
  
  #define XIMP_INPUT_STYLE	0x0001
  #define XIMP_CLIENT_WIN		0x0002
***************
*** 207,212 ****
--- 213,220 ----
  #define XIMP_RES_CLASS		0x0008
  #define XIMP_GEOMETRY_CB        0x0010
  #define XIMP_FILTER_EV          0x0020
+ #define XIMP_PRE_CALLBAK        0x0040
+ #define XIMP_STS_CALLBAK        0x0080
  
  #define XIMP_PROP_FOCUS		( XIMP_FOCUS_WIN_MASK )
  #define XIMP_PROP_PREEDIT	( XIMP_PRE_AREA_MASK \
***************
*** 259,265 ****
  	int		 connectserver;
  	int		 inputserver;
  	Bool		 use_wchar;
! 	KeySym		 def_startkeysym;
  	char		*locale_server;
  	Window		 fe_window;
  	Window		 owner;
--- 267,273 ----
  	int		 connectserver;
  	int		 inputserver;
  	Bool		 use_wchar;
! 	Ximp_KeyList	*process_start_keys;
  	char		*locale_server;
  	Window		 fe_window;
  	Window		 owner;
***************
*** 331,338 ****
--- 339,349 ----
  	long			 icid;
  	int			 input_mode;
  	int			 is_bep_mode;
+ 	int			 filter_mode;
  	unsigned long		 back_mask;
  	long			 value_mask;
+ 	Bool			 putback_key_event;
+ 	Window			 back_focus_win;
  
  	long			 proto_mask;
  	Ximp_PreeditPropRec	 preedit_attr;
*** /tmp/d17206	Sun May  3 18:47:26 1992
--- mit/lib/X/Ximp/XimpCT.c	Sun May  3 18:47:24 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpCT.c,v 1.3 92/03/03 11:02:11 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpCT.c,v 1.4 92/04/14 13:28:38 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 28,34 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 28,34 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 124,130 ****
  	while (encoding_ptr = *table_ptr++)
  	    if (encoding_ptr->GR_encoding) {
  	    	if (encoding_ptr->char_length == char_length &&
! 		    !strcmp(encoding_ptr->GR_encoding, encoding) &&
  		    encoding_ptr->GR_gc_size == gc_size)
  
  		    return encoding_ptr->lindex;
--- 124,130 ----
  	while (encoding_ptr = *table_ptr++)
  	    if (encoding_ptr->GR_encoding) {
  	    	if (encoding_ptr->char_length == char_length &&
! 		    !strcmp(encoding_ptr->GR_encoding, (char *)encoding) &&
  		    encoding_ptr->GR_gc_size == gc_size)
  
  		    return encoding_ptr->lindex;
***************
*** 133,139 ****
  	while (encoding_ptr = *table_ptr++)
  	    if (encoding_ptr->GL_encoding) {
  	    	if (encoding_ptr->char_length == char_length &&
! 		    !strcmp(encoding_ptr->GL_encoding, encoding) &&
  		    encoding_ptr->GL_gc_size == gc_size)
  
  		    return encoding_ptr->lindex;
--- 133,139 ----
  	while (encoding_ptr = *table_ptr++)
  	    if (encoding_ptr->GL_encoding) {
  	    	if (encoding_ptr->char_length == char_length &&
! 		    !strcmp(encoding_ptr->GL_encoding, (char *)encoding) &&
  		    encoding_ptr->GL_gc_size == gc_size)
  
  		    return encoding_ptr->lindex;
***************
*** 239,245 ****
      if (encoding_len < 0)
  	return -1;
  
!     strncpy(encoding, ctptr, encoding_len);
      encoding[encoding_len] = 0;
      ctptr += encoding_len;
  
--- 239,245 ----
      if (encoding_len < 0)
  	return -1;
  
!     strncpy((char *)encoding, (char *)ctptr, encoding_len);
      encoding[encoding_len] = 0;
      ctptr += encoding_len;
  
***************
*** 395,406 ****
  	if (msb_mask == GR)
  	    *encoding_ptr++ = '-';
      }
!     strcpy(encoding_ptr, (msb_mask == GR) ? 
  		encoding_rec->GR_encoding : encoding_rec->GL_encoding);
!     tmp_len = strlen(encoding);
      if ((ct_len -= tmp_len) < 0)
  	return -1;
!     strcpy(ctptr, encoding);
      ctptr += tmp_len;
  
      min_ch = 0x20;
--- 395,406 ----
  	if (msb_mask == GR)
  	    *encoding_ptr++ = '-';
      }
!     strcpy((char *)encoding_ptr, (msb_mask == GR) ? 
  		encoding_rec->GR_encoding : encoding_rec->GL_encoding);
!     tmp_len = strlen((char *)encoding);
      if ((ct_len -= tmp_len) < 0)
  	return -1;
!     strcpy((char *)ctptr, (char *)encoding);
      ctptr += tmp_len;
  
      min_ch = 0x20;
*** /tmp/d17228	Sun May  3 18:47:39 1992
--- mit/lib/X/Ximp/XimpDefCnv.c	Sun May  3 18:47:36 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpDefCnv.c,v 1.2 91/10/07 17:47:57 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpDefCnv.c,v 1.3 92/04/14 13:28:51 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 28,34 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 28,34 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17250	Sun May  3 18:47:50 1992
--- mit/lib/X/Ximp/XimpDrStr.c	Sun May  3 18:47:48 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpDrStr.c,v 1.1 91/07/09 17:36:53 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpDrStr.c,v 1.2 92/04/14 13:28:54 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 29,35 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 29,35 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 112,119 ****
  
              XSetFont(dpy, gc, font->fid);
  	    if (char_length < 2) {
! 	        XDrawString(dpy, d, gc, x, y, xchar_buf, tmp_len);
! 		x += XTextWidth(font, xchar_buf, tmp_len);
              } else {
  	        XDrawString16(dpy, d, gc, x, y, xchar2b_buf, tmp_len);
  		x += XTextWidth16(font, xchar2b_buf, tmp_len);
--- 112,119 ----
  
              XSetFont(dpy, gc, font->fid);
  	    if (char_length < 2) {
! 	        XDrawString(dpy, d, gc, x, y, (char *)xchar_buf, tmp_len);
! 		x += XTextWidth(font, (char *)xchar_buf, tmp_len);
              } else {
  	        XDrawString16(dpy, d, gc, x, y, xchar2b_buf, tmp_len);
  		x += XTextWidth16(font, xchar2b_buf, tmp_len);
*** /tmp/d17272	Sun May  3 18:48:02 1992
--- mit/lib/X/Ximp/XimpEUC.c	Sun May  3 18:47:59 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpEUC.c,v 1.3 91/10/07 17:48:17 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpEUC.c,v 1.4 92/04/14 13:28:56 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 28,34 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 28,34 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17294	Sun May  3 18:48:15 1992
--- mit/lib/X/Ximp/XimpExten.c	Sun May  3 18:48:12 1992
***************
*** 1,8 ****
! /* $XConsortium: XimpExten.c,v 1.4 91/10/10 20:41:37 rws Exp $ */
  /******************************************************************
  
!     Copyright 1991, by FUJITSU LIMITED.
!     Copyright 1991, by Sun Microsystems, Inc.
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,8 ----
! /* $XConsortium: XimpExten.c,v 1.5 92/04/14 13:29:00 rws Exp $ */
  /******************************************************************
  
!     Copyright 1991, 1992 by FUJITSU LIMITED.
!     Copyright 1991, 1992 by Sun Microsystems, Inc.
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 26,33 ****
  
  Author: Takashi Fujiwara     FUJITSU LIMITED
  		       fujiwara@a80.tech.yk.fujitsu.co.jp
!   Hideki Hiura (hhiura@Sun.COM)
! 				     Sun Microsystems, Inc.
  ******************************************************************/
  
  #define NEED_EVENTS
--- 26,33 ----
  
  Author: Takashi Fujiwara     FUJITSU LIMITED
  		       fujiwara@a80.tech.yk.fujitsu.co.jp
!         Hideki Hiura         Sun Microsystems, Inc.
! 	               hhiura@Sun.COM
  ******************************************************************/
  
  #define NEED_EVENTS
***************
*** 37,42 ****
--- 37,54 ----
  #include "Xlcint.h"
  #include "Ximplc.h"
  
+ #ifdef XIMP_SIGNAL
+ #include <sys/signal.h>
+ #endif /* XIMP_SIGNAL */
+ static int	_time_flag = 0;
+ #ifdef XIMP_SIGNAL
+ static int
+ _time_out()
+ 	{
+ 	_time_flag = 1;
+ 	}
+ #endif /* XIMP_SIGNAL */
+ 
  #define		XIM_UNKNOWN_KEYSYM	0x77777777
  #define		XIM_UNDETERMINED	0x77777776
  
***************
*** 48,65 ****
  
  typedef enum {
      XIMCB_Success,
!     XIMCB_FatalError,
  }               XIMCBResult;
  
  
  typedef enum {
      DrawUpHorizontally = 0,
!     DrawUpVertically = 1,
  }               DrawUpDirection;
  
  typedef enum {
      XIMOwnsLabel = 0,
!     CBOwnsLabel = 1,
  }               WhoOwnsLabel;
  
  typedef struct {
--- 60,77 ----
  
  typedef enum {
      XIMCB_Success,
!     XIMCB_FatalError
  }               XIMCBResult;
  
  
  typedef enum {
      DrawUpHorizontally = 0,
!     DrawUpVertically = 1
  }               DrawUpDirection;
  
  typedef enum {
      XIMOwnsLabel = 0,
!     CBOwnsLabel = 1
  }               WhoOwnsLabel;
  
  typedef struct {
***************
*** 111,116 ****
--- 123,129 ----
  
  extern Ximp_XIC _Ximp_LookupXIC();
  extern void     _Ximp_IM_SendMessage();
+ extern void 	_Ximp_ProcError();
  
  #define Private static
  /*
***************
*** 170,176 ****
  typedef enum {
      XICOpCreate = 1,
      XICOpSet = 2,
!     XICOpGet = 3,
  }               XICOp_t;
  
  /*
--- 183,189 ----
  typedef enum {
      XICOpCreate = 1,
      XICOpSet = 2,
!     XICOpGet = 3
  }               XICOp_t;
  
  /*
***************
*** 235,247 ****
      XICOp_t         op;
      long            value;
  {
!     XIMXimpRec     *im_impart = ((Ximp_XIM)ic->core.im)->ximp_impart;
!     Ximp_ExtXIMRec *ext_im;
!     long           *p_long;
  
-     if(!(im_impart->inputserver))
- 	return (False);
-     ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
      if (!(ext_im->extension_back_front_exist))
  	return (False);
  
--- 248,255 ----
      XICOp_t         op;
      long            value;
  {
!     Ximp_ExtXIMRec *ext_im = (Ximp_ExtXIMRec *)(((Ximp_XIM)ic->core.im)->ximp_impart)->imtype;
  
      if (!(ext_im->extension_back_front_exist))
  	return (False);
  
***************
*** 252,263 ****
  	return (True);
  	break;
      case XICOpGet:
! 	if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 		*((long *) value) = (long)NULL;
! 		break;
! 	}
! 	*p_long = (long)(ic->ximp_icpart->is_bep_mode);
! 	*((long *) value) = (long)p_long;
  	return (True);
  	break;
      }
--- 260,266 ----
  	return (True);
  	break;
      case XICOpGet:
! 	*((long *) value) = (long)(ic->ximp_icpart->is_bep_mode);
  	return (True);
  	break;
      }
***************
*** 297,302 ****
--- 300,346 ----
   *	  +-----------------------------------------+
   **/
  
+ 
+ typedef struct {
+ 	Atom message_type;
+ 	Atom ext_type;
+ 	Window owner;
+ } XimpConversionPredArgRec, *XimpConversionPredArg;
+ 
+ Private Bool
+ #if NeedFunctionPrototypes
+ ximp_ext_conversionPredicate(
+     Display *d,
+     XEvent *ev,
+     XPointer arg0
+     )
+ #else
+ ximp_ext_conversionPredicate(d, ev, arg0)
+ Display *d;
+ XEvent *ev;
+ XPointer arg0;
+ #endif
+ {
+     XimpConversionPredArg arg = (XimpConversionPredArg) arg0;
+ 
+ 	if (ev->type == ClientMessage) {
+ 		if (ev->xclient.message_type == arg->message_type) {
+ 			if (ev->xclient.format == 32) {
+ 				if(ev->xclient.data.l[0] == XIMP_ERROR)
+ 					return(True);
+ 				else if(ev->xclient.data.l[0] == XIMP_EXTENSION
+ 				     && ev->xclient.data.l[3] == arg->ext_type)
+ 					return(True);
+ 			}
+ 		}
+ 	} else if (ev->type == DestroyNotify) {
+ 		if (ev->xdestroywindow.window == arg->owner) {
+ 			return(True);
+ 		}
+ 	}
+ 	return(False);
+ }
+ 
  Private int
  ximp_ext_conversion(ic, op, value)
      Ximp_XIC        ic;
***************
*** 303,315 ****
      XICOp_t         op;
      long            value;
  {
!     XIMXimpRec     *im_impart = ((Ximp_XIM)ic->core.im)->ximp_impart;
!     Ximp_ExtXIMRec *ext_im;
!     int            *p_long;
  
-     if(!(im_impart->inputserver))
- 	return (False);
-     ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
      if (!(ext_im->extension_conversion_exist))
  	return (False);
  
--- 347,356 ----
      XICOp_t         op;
      long            value;
  {
!     Ximp_ExtXIMRec *ext_im = (Ximp_ExtXIMRec *)(((Ximp_XIM)ic->core.im)->ximp_impart)->imtype;
!     XEvent	    event;
!     XimpConversionPredArgRec Arg;
  
      if (!(ext_im->extension_conversion_exist))
  	return (False);
  
***************
*** 316,321 ****
--- 357,367 ----
      switch (op) {
      case XICOpCreate:
      case XICOpSet:
+ 	if(ic->ximp_icpart->icid == NULL) {
+ 		if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver)
+ 			return (False);
+ 		return (True);
+ 		}
  	/*
  	 * Set Conversion mode on/off
  	 */
***************
*** 330,349 ****
  	return True;
  	break;
      case XICOpGet:
  	_Ximp_IM_SendMessage(ic, XIMP_EXTENSION,
  		     ext_im->extension_conversion_id,
  		     False,	/* GetICVelues */
  		     value);
! 	/*
! 	 * KNOWN issue: above call would never affect following.
! 	 */
! 	if((p_long = (long *)Xmalloc(sizeof(long))) == NULL) {
! 		*((long *) value) = (long)NULL;
! 		break;
!         }
! 	*p_long = (long)(ext_im->extension_conversion);
! 	*((long *) value) = (long)p_long;
! 	return (True);
  	break;
      }
      return (False);
--- 376,427 ----
  	return True;
  	break;
      case XICOpGet:
+ 	if(ic->ximp_icpart->icid == NULL) {
+ 		if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver)
+ 			return (False);
+ 		*((long *) value) = (long)(ext_im->extension_conversion);
+ 		return (True);
+ 		}
  	_Ximp_IM_SendMessage(ic, XIMP_EXTENSION,
  		     ext_im->extension_conversion_id,
  		     False,	/* GetICVelues */
  		     value);
! #ifdef XIMP_SIGNAL
! 	signal(SIGALRM, _time_out);
! 	alarm(XIMP_TIME_OUT);
! #endif /* XIMP_SIGNAL */
! 	Arg.message_type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 	Arg.ext_type     = ext_im->extension_conversion_id;
! 	Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 	while(_time_flag != 1) {
! 		if( (XCheckIfEvent(ic->core.im->core.display, &event, ximp_ext_conversionPredicate, (XPointer)&Arg)) == False) {
! #ifdef XIMP_SIGNAL
! 			sleep(1);
! #endif /* XIMP_SIGNAL */
! 			continue;
! 			}
! 		if(event.type == ClientMessage &&
! 		   event.xclient.data.l[0] == XIMP_EXTENSION) {
! #ifdef XIMP_SIGNAL
! 			alarm(0);
! #endif /* XIMP_SIGNAL */
! 			ext_im->extension_conversion = (Bool)event.xclient.data.l[4];
! 			*((long *) value) = (long)(ext_im->extension_conversion);
! 			_time_flag = 0;
! 			return(True);
! 			}
! 		else {
! #ifdef XIMP_SIGNAL
! 			alarm(0);
! #endif /* XIMP_SIGNAL */
! 			_Ximp_ProcError (ic->core.im->core.display, NULL, &event);
! 			_time_flag = 0;
! 			/* return(False); */
! 			continue;
! 			}
! 		}
! 	_time_flag = 0;
! 	return(False);
  	break;
      }
      return (False);
***************
*** 360,369 ****
      XICOp_t         op;
      long            value;
  {
!     XIMXimpRec     *im_impart = ((Ximp_XIM)ic->core.im)->ximp_impart;
!     Ximp_ExtXIMRec *ext_im;
  
-     ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
      if (!(ext_im->extension_statuswindow_exist))
  	return (False);
  
--- 438,445 ----
      XICOp_t         op;
      long            value;
  {
!     Ximp_ExtXIMRec *ext_im = (Ximp_ExtXIMRec *)(((Ximp_XIM)ic->core.im)->ximp_impart)->imtype;
  
      if (!(ext_im->extension_statuswindow_exist))
  	return (False);
  
***************
*** 608,615 ****
      XIMXimpRec     *im_impart = ((Ximp_XIM)ic->core.im)->ximp_impart;
      Ximp_ExtXIMRec *ext_im;
  
-     if(!(im_impart->inputserver))
- 	return (False);
      ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
      if (!(ext_im->extension_lookup_exist))
  	return (False);
--- 684,689 ----
***************
*** 619,624 ****
--- 693,703 ----
  	ic->ximp_icpart->use_lookup_choices = True ;
  	break ;
      case XICOpSet:
+ 	if(ic->ximp_icpart->icid == NULL) {
+ 		if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver)
+ 			return (False);
+ 		return (True);
+ 		}
  	ic->ximp_icpart->use_lookup_choices = True ;
  	_Ximp_IM_SendMessage(ic, XIMP_EXTENSION,
  			     ext_im->extension_lookup_id,
***************
*** 748,754 ****
  			    ext_im->extension_lookup_start_rep,
  			    32,
  			    PropModeReplace,
! 			    prop,
  			    6);
  
  	    XFlush(ic->core.im->core.display);
--- 827,833 ----
  			    ext_im->extension_lookup_start_rep,
  			    32,
  			    PropModeReplace,
! 			    (unsigned char *)prop,
  			    6);
  
  	    XFlush(ic->core.im->core.display);
***************
*** 867,873 ****
  			   ((Ximp_XIM) ic->core.im)->ximp_impart->fe_window,
  			   *(prop + 4), 0, 4096, True, AnyPropertyType,
  			   &type, &format, &nitems, &after,
! 			   (unsigned char *) &feedback) == Success)&&feedback){
  
  	for (i = l = 0; i < luc_draw->n_choices; i++, l += 2) {
  	    if (luc_draw->choices[i].value){
--- 946,952 ----
  			   ((Ximp_XIM) ic->core.im)->ximp_impart->fe_window,
  			   *(prop + 4), 0, 4096, True, AnyPropertyType,
  			   &type, &format, &nitems, &after,
! 			   (unsigned char **) &feedback) == Success)&&feedback){
  
  	for (i = l = 0; i < luc_draw->n_choices; i++, l += 2) {
  	    if (luc_draw->choices[i].value){
***************
*** 1200,1218 ****
      ext_id = ev->data.l[2];
      ic = _Ximp_LookupXIC(icid);
  
-     if(!((Ximp_XIM)ic->core.im)->ximp_impart->inputserver)
- 	return;
      im_impart = ((Ximp_XIM)ic->core.im)->ximp_impart;
      ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
  
!     if (ext_id == ext_im->extension_conversion_id) {
! 	if (!(ext_im->extension_conversion_exist))
! 	    return;
! 	ext_im->extension_conversion = (Bool) ev->data.l[4];
!     } else if (ext_id == ext_im->extension_back_front_id) {
! 	if (!(ext_im->extension_back_front_exist))
! 	    return;
!     } else if (ext_id == ext_im->extension_lookup_id) {
  	if (ext_im->extension_lookup_exist)
  	    _Ximp_ExtLookup(d, w, ev, ic);
  	return;
--- 1279,1288 ----
      ext_id = ev->data.l[2];
      ic = _Ximp_LookupXIC(icid);
  
      im_impart = ((Ximp_XIM)ic->core.im)->ximp_impart;
      ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
  
!     if (ext_id == ext_im->extension_lookup_id) {
  	if (ext_im->extension_lookup_exist)
  	    _Ximp_ExtLookup(d, w, ev, ic);
  	return;
*** /tmp/d17316	Sun May  3 18:48:29 1992
--- mit/lib/X/Ximp/XimpICG.c	Sun May  3 18:48:26 1992
***************
*** 1,33 ****
! /* $XConsortium: XimpICG.c,v 1.6 92/03/03 11:01:06 rws Exp $ */
  /******************************************************************
  
!     Copyright 1991, by FUJITSU LIMITED.
!     Copyright 1991, by Sun Microsystems, Inc.
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
  provided that the above copyright notice appear in all copies and that
  both that copyright notice and this permission notice appear in
! supporting documentation, and that the name of FUJITSU LIMITED or Sun
! Microsystems, Inc.  not be used in advertising or publicity pertaining
! to distribution of the software without specific, written prior
! permission.  FUJITSU LIMITED and Sun Microsystems, Inc. make no
  representations about the suitability of this software for any
  purpose.  It is provided "as is" without express or implied warranty.
  
! FUJITSU LIMITED AND SUN MICROSYSTEMS, INC. DISCLAIMS ALL WARRANTIES
! WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU LIMITED AND SUN
! MICROSYSTEMS, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
! CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
! USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
! OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
! PERFORMANCE OF THIS SOFTWARE.
  
  Author: Takashi Fujiwara     FUJITSU LIMITED
! 		       fujiwara@a80.tech.yk.fujitsu.co.jp
!         Hideki Hiura (hhiura@Sun.COM)
! 				     Sun Microsystems, Inc.
  
  ******************************************************************/
  
--- 1,34 ----
! /* $XConsortium: XimpICG.c,v 1.8 92/04/22 15:46:03 rws Exp $ */
  /******************************************************************
  
!     Copyright 1991, 1992 by FUJITSU LIMITED.
!     Copyright 1991, 1992 by Sun Microsystems, Inc.
!     Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
  provided that the above copyright notice appear in all copies and that
  both that copyright notice and this permission notice appear in
! supporting documentation, and that the name of FUJITSU LIMITED, Sun
! Microsystems, Inc. and Sony Corporation  not be used in advertising
! or publicity pertaining to distribution of the software without
! specific, written prior permission.
! FUJITSU LIMITED , Sun Microsystems, Inc. and Sony Corporation make no
  representations about the suitability of this software for any
  purpose.  It is provided "as is" without express or implied warranty.
  
! FUJITSU LIMITED, SUN MICROSYSTEMS, INC. AND SONY CORPORATION DISCLAIM
! ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
! WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU
! LIMITED, SUN MICROSYSTEMS, INC. AND SONY CORPORATION BE LIABLE FOR ANY
! SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
! RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
! CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
! CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  
  Author: Takashi Fujiwara     FUJITSU LIMITED
!         Hideki Hiura         Sun Microsystems, Inc.
!         Makoto Wakamatsu     Sony Corporaion
  
  ******************************************************************/
  
***************
*** 57,64 ****
  {
  	XIMArg		*p;
  	char		*p_char;
- 	long		*p_long;
- 	XIMCallback 	*p_callback;
  	char		*return_name = NULL;
  	int		 len;
  
--- 58,63 ----
***************
*** 65,71 ****
  	for(p = values; p->name != NULL; p++) {
  		if(strcmp(p->name, XNInputStyle) == 0) {
  			if(ic->ximp_icpart->value_mask & XIMP_INPUT_STYLE) {
! 			    (*((long *)(p->value))) = (long)ic->core.input_style;
  			} else {			    
  			    return_name = p->name;
  			    break;
--- 64,70 ----
  	for(p = values; p->name != NULL; p++) {
  		if(strcmp(p->name, XNInputStyle) == 0) {
  			if(ic->ximp_icpart->value_mask & XIMP_INPUT_STYLE) {
! 			    *((XIMStyle *)(p->value)) = ic->core.input_style;
  			} else {			    
  			    return_name = p->name;
  			    break;
***************
*** 72,78 ****
  			}
  		} else if(strcmp(p->name, XNClientWindow)==0) {
  			if(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN) {
! 			    (*((long *)(p->value))) = (long)ic->core.client_window;
  			} else {
  			    return_name = p->name;
  			    break;
--- 71,77 ----
  			}
  		} else if(strcmp(p->name, XNClientWindow)==0) {
  			if(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN) {
! 			    *((Window *)(p->value)) = ic->core.client_window;
  			} else {
  			    return_name = p->name;
  			    break;
***************
*** 79,85 ****
  			}
  		} else if(strcmp(p->name, XNFocusWindow)==0) {
  			if(ic->ximp_icpart->proto_mask & XIMP_FOCUS_WIN_MASK) {
! 			    (*((long *)(p->value))) = (long)ic->core.focus_window;
  			} else if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver){
  			    return_name = p->name;
  			    break;
--- 78,84 ----
  			}
  		} else if(strcmp(p->name, XNFocusWindow)==0) {
  			if(ic->ximp_icpart->proto_mask & XIMP_FOCUS_WIN_MASK) {
! 			    *((Window *)(p->value)) = ic->core.focus_window;
  			} else if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver){
  			    return_name = p->name;
  			    break;
***************
*** 88,105 ****
  						 XIMP_FOCUS_WIN_MASK,
  						((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id,
  						XA_WINDOW);
! 			    (*((long *)(p->value))) = *(long*)tmp ;
  			    free(tmp) ;
  			}
  		} else if(strcmp(p->name, XNResourceName)==0) {
  			if(ic->core.im->core.res_name != (char *)NULL) {
  			    len = strlen(ic->core.im->core.res_name);
! 			    if((p_char = Xmalloc(sizeof(len+1))) == NULL) {
  				return_name = p->name;
  				break;
  			    }
  			    strcpy(p_char, ic->core.im->core.res_name);
! 			    (*((long *)(p->value))) = (long)p_char;
  			} else {
  			    return_name = p->name;
  			    break;
--- 87,104 ----
  						 XIMP_FOCUS_WIN_MASK,
  						((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id,
  						XA_WINDOW);
! 			    *((Window *)(p->value)) = *(Window *)tmp ;
  			    free(tmp) ;
  			}
  		} else if(strcmp(p->name, XNResourceName)==0) {
  			if(ic->core.im->core.res_name != (char *)NULL) {
  			    len = strlen(ic->core.im->core.res_name);
! 			    if((p_char = Xmalloc(len+1)) == NULL) {
  				return_name = p->name;
  				break;
  			    }
  			    strcpy(p_char, ic->core.im->core.res_name);
! 			    *((char **)(p->value)) = p_char;
  			} else {
  			    return_name = p->name;
  			    break;
***************
*** 106,112 ****
  			}
  		} else if(strcmp(p->name, XNResourceClass)==0) {
  			if(ic->core.im->core.res_class != (char *)NULL) {
! 			    (*((long *)(p->value))) = (long)ic->core.im->core.res_class;
  			} else {
  			    return_name = p->name;
  			    break;
--- 105,117 ----
  			}
  		} else if(strcmp(p->name, XNResourceClass)==0) {
  			if(ic->core.im->core.res_class != (char *)NULL) {
! 			    len = strlen(ic->core.im->core.res_class);
! 			    if((p_char = Xmalloc(len+1)) == NULL) {
! 				return_name = p->name;
! 				break;
! 			    }
! 			    strcpy(p_char, ic->core.im->core.res_name);
! 			    *((char **)(p->value)) = p_char;
  			} else {
  			    return_name = p->name;
  			    break;
***************
*** 113,132 ****
  			}
  		} else if(strcmp(p->name, XNGeometryCallback)==0) {
  			if(ic->ximp_icpart->value_mask & XIMP_GEOMETRY_CB) {
! 			    (*((long *)(p->value))) = (long)ic->core.geometry_callback.callback;
  			} else {
  			    return_name = p->name;
  			    break;
  			}
  		} else if(strcmp(p->name, XNFilterEvents)==0) {
! 		    (*((long *)(p->value))) = (long)ic->core.filter_events;
  		} else if(strcmp(p->name, XNPreeditAttributes)==0) {
  			if( _Ximp_PreGetAttributes(ic, p->value,
! 						   return_name) == False)
  				break;
  		} else if(strcmp(p->name, XNStatusAttributes)==0) {
  			if( _Ximp_StatusGetAttributes(ic, p->value,
! 						   return_name) == False)
  				break;
  		} else {
  			if( _Ximp_GetICExtension(ic, p->name, p->value) == False) {
--- 118,137 ----
  			}
  		} else if(strcmp(p->name, XNGeometryCallback)==0) {
  			if(ic->ximp_icpart->value_mask & XIMP_GEOMETRY_CB) {
! 			    *((XIMCallback *)(p->value)) = ic->core.geometry_callback;
  			} else {
  			    return_name = p->name;
  			    break;
  			}
  		} else if(strcmp(p->name, XNFilterEvents)==0) {
! 		    *((unsigned long *)(p->value)) = ic->core.filter_events;
  		} else if(strcmp(p->name, XNPreeditAttributes)==0) {
  			if( _Ximp_PreGetAttributes(ic, p->value,
! 						   &return_name) == False)
  				break;
  		} else if(strcmp(p->name, XNStatusAttributes)==0) {
  			if( _Ximp_StatusGetAttributes(ic, p->value,
! 						   &return_name) == False)
  				break;
  		} else {
  			if( _Ximp_GetICExtension(ic, p->name, p->value) == False) {
***************
*** 142,168 ****
  _Ximp_PreGetAttributes(ic, vl, return_name)
  	Ximp_XIC	 ic;
  	XIMArg		*vl;
! 	char		*return_name;
  {
  	XIMArg		*p;
  	XRectangle	*p_rect;
  	XPoint		*p_point;
- 	long		*p_long;
  	unsigned long	 mask;
  	int		 im_preedit_flag = 0;
! 	int		 im_font_flag    = 0;
! 	Ximp_PreeditPropRec	*preedit_data;
  	XIMCallback 	*p_callback;
- 	XPointer	*xptr;
  
! 	if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver) {
  		for(mask = 0, p = vl; p->name != NULL; p++) {
  			if(strcmp(p->name, XNArea)==0)
  				mask |= XIMP_PRE_AREA_MASK;
  			else if(strcmp(p->name, XNAreaNeeded)==0)
  				mask |= XIMP_PRE_AREANEED_MASK;
! 			else if(strcmp(p->name, XNSpotLocation)==0)
  				mask |= XIMP_PRE_SPOTL_MASK;
  			else if(strcmp(p->name, XNColormap)==0)
  				mask |= XIMP_PRE_COLORMAP_MASK;
  			else if(strcmp(p->name, XNStdColormap)==0)
--- 147,176 ----
  _Ximp_PreGetAttributes(ic, vl, return_name)
  	Ximp_XIC	 ic;
  	XIMArg		*vl;
! 	char		**return_name;
  {
  	XIMArg		*p;
  	XRectangle	*p_rect;
  	XPoint		*p_point;
  	unsigned long	 mask;
  	int		 im_preedit_flag = 0;
! 	Ximp_PreeditPropRec	*preedit_data = NULL;
  	XIMCallback 	*p_callback;
  
! 	if(((Ximp_XIM)ic->core.im)->ximp_impart->connectserver) {
  		for(mask = 0, p = vl; p->name != NULL; p++) {
  			if(strcmp(p->name, XNArea)==0)
  				mask |= XIMP_PRE_AREA_MASK;
  			else if(strcmp(p->name, XNAreaNeeded)==0)
  				mask |= XIMP_PRE_AREANEED_MASK;
! 			else if(strcmp(p->name, XNSpotLocation)==0) {
! 				if(!ic->ximp_icpart->input_mode)
! 				    _Ximp_IM_SendMessage(ic, XIMP_MOVE,
! 					ic->ximp_icpart->preedit_attr.SpotLocation.x,
! 					ic->ximp_icpart->preedit_attr.SpotLocation.y,
! 					NULL);
  				mask |= XIMP_PRE_SPOTL_MASK;
+ 			}
  			else if(strcmp(p->name, XNColormap)==0)
  				mask |= XIMP_PRE_COLORMAP_MASK;
  			else if(strcmp(p->name, XNStdColormap)==0)
***************
*** 177,184 ****
  				mask |= XIMP_PRE_LINESP_MASK;
  			else if(strcmp(p->name, XNCursor)==0)
  				mask |= XIMP_PRE_CURSOR_MASK;
- 			else if(strcmp(p->name, XNFontSet)==0)
- 				im_font_flag = 1;
  		}
  		if(mask) {
  			preedit_data = (Ximp_PreeditPropRec *)_Ximp_GetRequestIM(ic, mask,
--- 185,190 ----
***************
*** 191,197 ****
  	for(p = vl; p->name != NULL; p++) {
  		if(strcmp(p->name, XNArea)==0) {
  			if(im_preedit_flag) {
! 				p_rect = (XRectangle *)(p->value) ;
  				p_rect->x       = preedit_data->Area.x;
  				p_rect->y       = preedit_data->Area.y;
  				p_rect->width   = preedit_data->Area.width;
--- 197,206 ----
  	for(p = vl; p->name != NULL; p++) {
  		if(strcmp(p->name, XNArea)==0) {
  			if(im_preedit_flag) {
! 				if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
  				p_rect->x       = preedit_data->Area.x;
  				p_rect->y       = preedit_data->Area.y;
  				p_rect->width   = preedit_data->Area.width;
***************
*** 198,387 ****
  				p_rect->height  = preedit_data->Area.height;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_AREA_MASK) {
! 				        p_rect = (XRectangle *)(p->value) ;
  					p_rect->x       = ic->core.preedit_attr.area.x;
  					p_rect->y       = ic->core.preedit_attr.area.y;
  					p_rect->width   = ic->core.preedit_attr.area.width;
  					p_rect->height  = ic->core.preedit_attr.area.height;
  				} else {
! 				        return_name = p->name;
  				        return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNAreaNeeded)==0) {
  			if(im_preedit_flag) {
! 				p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle));
! 				xptr = (XPointer *)p->value;
! 				*xptr = (XPointer)p_rect;
  				p_rect->x  = p_rect->y  = 0;
  				p_rect->width   = preedit_data->AreaNeeded.width;
  				p_rect->height  = preedit_data->AreaNeeded.height;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_AREANEED_MASK) {
! 					p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle));
! 					xptr = (XPointer *)p->value;
! 					*xptr = (XPointer)p_rect;
  					p_rect->x  = p_rect->y  = 0;
  					p_rect->width   = ic->core.preedit_attr.area_needed.width;
  					p_rect->height  = ic->core.preedit_attr.area_needed.height;
  				} else {
! 				        return_name = p->name;
  				        return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNSpotLocation)==0) {
  			if(im_preedit_flag) {
! 				p_point = (XPoint *)Xmalloc(sizeof(XPoint));
! 				xptr = (XPointer *)p->value;
! 				*xptr = (XPointer)p_point;
  				p_point->x = preedit_data->SpotLocation.x;
  				p_point->y = preedit_data->SpotLocation.y;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_SPOTL_MASK) {
! 					p_point = (XPoint *)Xmalloc(sizeof(XPoint));
! 					xptr = (XPointer *)p->value;
! 					*xptr = (XPointer)p_point;
  					p_point->x = ic->core.preedit_attr.spot_location.x;
  					p_point->y = ic->core.preedit_attr.spot_location.y;
  				} else {
! 				        return_name = p->name;
  				        return(False);
  				}
  			}
  		} else if(  strcmp(p->name, XNColormap)==0
  		        || strcmp(p->name, XNStdColormap)==0) {
  			if(im_preedit_flag) {
! 			         p_long = (long *)(p->value);
! 				*p_long = preedit_data->Colormap;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_COLORMAP_MASK) {
! 				         p_long = (long *)(p->value);
! 					*p_long = ic->core.preedit_attr.colormap;
  				} else {
! 					return_name = p->name;
  					return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNBackground)==0) {
  			if(im_preedit_flag) {
! 			         p_long = (long *)(p->value);
! 				*p_long = preedit_data->Background;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_BG_MASK) {
! 				         p_long = (long *)(p->value);
! 					*p_long = ic->core.preedit_attr.background;
  				} else {
! 					return_name = p->name;
  					return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNForeground)==0) {
  			if(im_preedit_flag) {
! 			         p_long = (long *)(p->value);
! 				*p_long = preedit_data->Foreground;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_FG_MASK) {
! 				         p_long = (long *)(p->value);
! 					*p_long = ic->core.preedit_attr.foreground;
  				} else {
! 					return_name = p->name;
  					return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNBackgroundPixmap)==0) {
  			if(im_preedit_flag) {
! 			         p_long = (long *)(p->value);
! 				*p_long = preedit_data->Bg_Pixmap;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_BGPIXMAP_MASK) {
! 				         p_long = (long *)(p->value);
! 					*p_long = ic->core.preedit_attr.background_pixmap;
  				} else {
! 					return_name = p->name;
  					return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNFontSet)==0) {
  			if(ic->ximp_icpart->proto_mask & XIMP_PRE_FONT_MASK) {
! 			         p_long = (long *)(p->value);
! 				*p_long = (long)ic->core.preedit_attr.fontset;
  			} else {
! 				return_name = p->name;
  				return(False);
  			}
  		} else if(strcmp(p->name, XNLineSpace)==0) {
  			if(im_preedit_flag) {
! 			         p_long = (long *)(p->value);
! 				*p_long = preedit_data->LineSpacing;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_LINESP_MASK) {
! 				         p_long = (long *)(p->value);
! 					*p_long = ic->core.preedit_attr.line_space;
  				} else {
! 					return_name = p->name;
  					return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNCursor)==0) {
  			if(im_preedit_flag) {
! 			         p_long = (long *)(p->value);
! 				*p_long = preedit_data->Cursor;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_CURSOR_MASK) {
! 				         p_long = (long *)(p->value);
! 					*p_long = ic->core.preedit_attr.cursor;
  				} else {
! 					return_name = p->name;
  					return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNPreeditStartCallback)==0) {
  			if((int)ic->core.preedit_attr.callbacks.start.callback) {
! 			        p_callback = (XIMCallback *)(p->value) ;
  				p_callback->client_data =
  					ic->core.preedit_attr.callbacks.start.client_data;
  				p_callback->callback =
  					ic->core.preedit_attr.callbacks.start.callback;
  			} else {
! 				return_name = p->name;
  				return(False);
  			}
  		} else if(strcmp(p->name, XNPreeditDrawCallback)==0) {
  			if((int)ic->core.preedit_attr.callbacks.draw.callback) {
! 			        p_callback = (XIMCallback *)(p->value) ;
  				p_callback->client_data =
  					ic->core.preedit_attr.callbacks.draw.client_data;
  				p_callback->callback =
  					ic->core.preedit_attr.callbacks.draw.callback;
  			} else {
! 				return_name = p->name;
  				return(False);
  			}
  		} else if(strcmp(p->name, XNPreeditDoneCallback)==0) {
  			if((int)ic->core.preedit_attr.callbacks.done.callback) {
! 			        p_callback = (XIMCallback *)(p->value) ;
  				p_callback->client_data =
  					ic->core.preedit_attr.callbacks.done.client_data;
  				p_callback->callback =
  					ic->core.preedit_attr.callbacks.done.callback;
  			} else {
! 				return_name = p->name;
  				return(False);
  			}
  		} else if(strcmp(p->name, XNPreeditCaretCallback)==0) {
  			if((int)ic->core.preedit_attr.callbacks.caret.callback) {
! 			        p_callback = (XIMCallback *)(p->value) ;
  				p_callback->client_data =
  					ic->core.preedit_attr.callbacks.caret.client_data;
  				p_callback->callback =
  					ic->core.preedit_attr.callbacks.caret.callback;
  			} else {
! 				return_name = p->name;
  				return(False);
  			}
  		}
  	}
! 	XFree(preedit_data);
  	return(True);
  }
  
--- 207,411 ----
  				p_rect->height  = preedit_data->Area.height;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_AREA_MASK) {
! 					if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 						*return_name = p->name;
! 						return(False);
! 					}
  					p_rect->x       = ic->core.preedit_attr.area.x;
  					p_rect->y       = ic->core.preedit_attr.area.y;
  					p_rect->width   = ic->core.preedit_attr.area.width;
  					p_rect->height  = ic->core.preedit_attr.area.height;
  				} else {
! 				        *return_name = p->name;
  				        return(False);
  				}
  			}
+ 			*((XRectangle **)(p->value)) = p_rect;
  		} else if(strcmp(p->name, XNAreaNeeded)==0) {
  			if(im_preedit_flag) {
! 				if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
  				p_rect->x  = p_rect->y  = 0;
  				p_rect->width   = preedit_data->AreaNeeded.width;
  				p_rect->height  = preedit_data->AreaNeeded.height;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_AREANEED_MASK) {
! 					if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 						*return_name = p->name;
! 						return(False);
! 					}
  					p_rect->x  = p_rect->y  = 0;
  					p_rect->width   = ic->core.preedit_attr.area_needed.width;
  					p_rect->height  = ic->core.preedit_attr.area_needed.height;
  				} else {
! 				        *return_name = p->name;
  				        return(False);
  				}
  			}
+ 			*((XRectangle **)(p->value)) = p_rect;
  		} else if(strcmp(p->name, XNSpotLocation)==0) {
  			if(im_preedit_flag) {
! 				if((p_point = (XPoint *)Xmalloc(sizeof(XPoint))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
  				p_point->x = preedit_data->SpotLocation.x;
  				p_point->y = preedit_data->SpotLocation.y;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_SPOTL_MASK) {
! 					if((p_point = (XPoint *)Xmalloc(sizeof(XPoint))) == NULL) {
! 						*return_name = p->name;
! 						return(False);
! 					}
  					p_point->x = ic->core.preedit_attr.spot_location.x;
  					p_point->y = ic->core.preedit_attr.spot_location.y;
  				} else {
! 				        *return_name = p->name;
  				        return(False);
  				}
  			}
+ 			*((XPoint **)(p->value)) = p_point;
  		} else if(  strcmp(p->name, XNColormap)==0
  		        || strcmp(p->name, XNStdColormap)==0) {
  			if(im_preedit_flag) {
! 			         *((Colormap *)(p->value)) = preedit_data->Colormap;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_COLORMAP_MASK) {
! 				         *((Colormap *)(p->value)) = ic->core.preedit_attr.colormap;
  				} else {
! 					*return_name = p->name;
  					return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNBackground)==0) {
  			if(im_preedit_flag) {
! 			         *((unsigned long *)(p->value)) = preedit_data->Background;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_BG_MASK) {
! 				         *((unsigned long *)(p->value)) = ic->core.preedit_attr.background;
  				} else {
! 					*return_name = p->name;
  					return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNForeground)==0) {
  			if(im_preedit_flag) {
! 			         *((unsigned long *)(p->value)) = preedit_data->Foreground;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_FG_MASK) {
! 				         *((unsigned long *)(p->value)) = ic->core.preedit_attr.foreground;
  				} else {
! 					*return_name = p->name;
  					return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNBackgroundPixmap)==0) {
  			if(im_preedit_flag) {
! 			         *((Pixmap *)(p->value)) = preedit_data->Bg_Pixmap;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_BGPIXMAP_MASK) {
! 				         *((Pixmap *)(p->value)) = ic->core.preedit_attr.background_pixmap;
  				} else {
! 					*return_name = p->name;
  					return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNFontSet)==0) {
  			if(ic->ximp_icpart->proto_mask & XIMP_PRE_FONT_MASK) {
! 			         *((XFontSet *)(p->value)) = ic->core.preedit_attr.fontset;
  			} else {
! 				*return_name = p->name;
  				return(False);
  			}
  		} else if(strcmp(p->name, XNLineSpace)==0) {
  			if(im_preedit_flag) {
! 			         *((int *)(p->value)) = preedit_data->LineSpacing;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_LINESP_MASK) {
! 				         *((int *)(p->value)) = ic->core.preedit_attr.line_space;
  				} else {
! 					*return_name = p->name;
  					return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNCursor)==0) {
  			if(im_preedit_flag) {
! 			         *((Cursor *)(p->value)) = preedit_data->Cursor;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_CURSOR_MASK) {
! 				         *((Cursor *)(p->value)) = ic->core.preedit_attr.cursor;
  				} else {
! 					*return_name = p->name;
  					return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNPreeditStartCallback)==0) {
  			if((int)ic->core.preedit_attr.callbacks.start.callback) {
! 
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
  				p_callback->client_data =
  					ic->core.preedit_attr.callbacks.start.client_data;
  				p_callback->callback =
  					ic->core.preedit_attr.callbacks.start.callback;
+ 				*((XIMCallback **)(p->value)) = p_callback;
  			} else {
! 				*return_name = p->name;
  				return(False);
  			}
  		} else if(strcmp(p->name, XNPreeditDrawCallback)==0) {
  			if((int)ic->core.preedit_attr.callbacks.draw.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
  				p_callback->client_data =
  					ic->core.preedit_attr.callbacks.draw.client_data;
  				p_callback->callback =
  					ic->core.preedit_attr.callbacks.draw.callback;
+ 				*((XIMCallback **)(p->value)) = p_callback;
  			} else {
! 				*return_name = p->name;
  				return(False);
  			}
  		} else if(strcmp(p->name, XNPreeditDoneCallback)==0) {
  			if((int)ic->core.preedit_attr.callbacks.done.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
  				p_callback->client_data =
  					ic->core.preedit_attr.callbacks.done.client_data;
  				p_callback->callback =
  					ic->core.preedit_attr.callbacks.done.callback;
+ 				*((XIMCallback **)(p->value)) = p_callback;
  			} else {
! 				*return_name = p->name;
  				return(False);
  			}
  		} else if(strcmp(p->name, XNPreeditCaretCallback)==0) {
  			if((int)ic->core.preedit_attr.callbacks.caret.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
  				p_callback->client_data =
  					ic->core.preedit_attr.callbacks.caret.client_data;
  				p_callback->callback =
  					ic->core.preedit_attr.callbacks.caret.callback;
+ 				*((XIMCallback **)(p->value)) = p_callback;
  			} else {
! 				*return_name = p->name;
  				return(False);
  			}
  		}
  	}
! 	if( preedit_data )
! 		XFree(preedit_data);
  	return(True);
  }
  
***************
*** 389,408 ****
  _Ximp_StatusGetAttributes(ic, vl, return_name)
  	Ximp_XIC	 ic;
  	XIMArg	 	*vl;
! 	char		*return_name;
  {
  	XIMArg		*p;
  	XRectangle	*p_rect;
- 	XPoint		*p_point;
- 	long		*p_long;
  	unsigned long	 mask;
  	int		 im_status_flag = 0;
! 	int		 im_font_flag    = 0;
! 	Ximp_StatusPropRec	*status_data;
  	XIMCallback 	*p_callback;
- 	XPointer	*xptr;
  
! 	if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver) {
  		for(mask = 0, p = vl; p->name != NULL; p++) {
  			if(strcmp(p->name, XNArea)==0)
  				mask |= XIMP_STS_AREA_MASK;
--- 413,428 ----
  _Ximp_StatusGetAttributes(ic, vl, return_name)
  	Ximp_XIC	 ic;
  	XIMArg	 	*vl;
! 	char		**return_name;
  {
  	XIMArg		*p;
  	XRectangle	*p_rect;
  	unsigned long	 mask;
  	int		 im_status_flag = 0;
! 	Ximp_StatusPropRec	*status_data = NULL;
  	XIMCallback 	*p_callback;
  
! 	if(((Ximp_XIM)ic->core.im)->ximp_impart->connectserver) {
  		for(mask = 0, p = vl; p->name != NULL; p++) {
  			if(strcmp(p->name, XNArea)==0)
  				mask |= XIMP_STS_AREA_MASK;
***************
*** 422,429 ****
  				mask |= XIMP_STS_LINESP_MASK;
  			else if(strcmp(p->name, XNCursor)==0)
  				mask |= XIMP_STS_CURSOR_MASK;
- 			else if(strcmp(p->name, XNFontSet)==0)
- 				im_font_flag = 1;
  		}
  		if(mask) {
  			status_data = (Ximp_StatusPropRec *)_Ximp_GetRequestIM(ic, mask,
--- 442,447 ----
***************
*** 437,443 ****
  	for(p = vl; p->name != NULL; p++) {
  		if(strcmp(p->name, XNArea)==0) {
  			if(im_status_flag) {
! 				p_rect = (XRectangle *)(p->value) ;
  				p_rect->x       = status_data->Area.x;
  				p_rect->y       = status_data->Area.y;
  				p_rect->width   = status_data->Area.width;
--- 455,464 ----
  	for(p = vl; p->name != NULL; p++) {
  		if(strcmp(p->name, XNArea)==0) {
  			if(im_status_flag) {
! 				if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
  				p_rect->x       = status_data->Area.x;
  				p_rect->y       = status_data->Area.y;
  				p_rect->width   = status_data->Area.width;
***************
*** 444,604 ****
  				p_rect->height  = status_data->Area.height;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_AREA_MASK) {
! 					p_rect = (XRectangle *)(p->value) ;
  					p_rect->x       = ic->core.status_attr.area.x;
  					p_rect->y       = ic->core.status_attr.area.y;
  					p_rect->width   = ic->core.status_attr.area.width;
  					p_rect->height  = ic->core.status_attr.area.height;
  				} else {
! 				        return_name = p->name;
  				        return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNAreaNeeded)==0) {
  			if(im_status_flag) {
! 				p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle));
! 				xptr = (XPointer *)p->value;
! 				*xptr = (XPointer)p_rect;
  				p_rect->x  = p_rect->y  = 0;
  				p_rect->width   = status_data->AreaNeeded.width;
  				p_rect->height  = status_data->AreaNeeded.height;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_AREANEED_MASK) {
! 					p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle));
! 					xptr = (XPointer *)p->value;
! 					*xptr = (XPointer)p_rect;
  					p_rect->x  = p_rect->y  = 0;
  					p_rect->width   = ic->core.status_attr.area_needed.width;
  					p_rect->height  = ic->core.status_attr.area_needed.height;
  				} else {
! 					return_name = p->name;
  					return(False);
  				}
  			}
  		} else if(  strcmp(p->name, XNColormap)==0
  		        || strcmp(p->name, XNStdColormap)==0) {
  			if(im_status_flag) {
! 			         p_long = (long *)(p->value);
! 				*p_long = status_data->Colormap;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_COLORMAP_MASK) {
! 				         p_long = (long *)(p->value);
! 					*p_long = ic->core.status_attr.colormap;
  				} else {
! 					return_name = p->name;
  					return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNBackground)==0) {
  			if(im_status_flag) {
! 			         p_long = (long *)(p->value);
! 				*p_long = status_data->Background;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_BG_MASK) {
! 				         p_long = (long *)(p->value);
! 					*p_long = ic->core.status_attr.background;
  				} else {
! 					return_name = p->name;
  					return(False);
  			        }
  			}
  		} else if(strcmp(p->name, XNForeground)==0) {
  			if(im_status_flag) {
! 			         p_long = (long *)(p->value);
! 				*p_long = status_data->Foreground;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_FG_MASK) {
! 				         p_long = (long *)(p->value);
! 					*p_long = ic->core.status_attr.foreground;
  				} else {
! 					return_name = p->name;
  					return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNBackgroundPixmap)==0) {
  			if(im_status_flag) {
! 			         p_long = (long *)(p->value);
! 				*p_long = status_data->Bg_Pixmap;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_BGPIXMAP_MASK) {
! 				         p_long = (long *)(p->value);
! 					*p_long = ic->core.status_attr.background_pixmap;
  				} else {
! 					return_name = p->name;
  					return(False);
  			        }
  			}
  		} else if(strcmp(p->name, XNFontSet)==0) {
  			if(ic->ximp_icpart->proto_mask & XIMP_STS_FONT_MASK) {
! 			         p_long = (long *)(p->value);
! 				*p_long = (long)ic->core.status_attr.fontset;
  			} else {
! 				return_name = p->name;
  				return(False);
  			}
  		} else if(strcmp(p->name, XNLineSpace)==0) {
  			if(im_status_flag) {
! 			         p_long = (long *)(p->value);
! 				*p_long = status_data->LineSpacing;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_LINESP_MASK) {
! 				         p_long = (long *)(p->value);
! 					*p_long = ic->core.status_attr.line_space;
  				} else {
! 					return_name = p->name;
  					return(False);
  				}
- 
  			}
  		} else if(strcmp(p->name, XNCursor)==0) {
  			if(im_status_flag) {
! 			         p_long = (long *)(p->value);
! 				*p_long = status_data->Cursor;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_CURSOR_MASK) {
! 				         p_long = (long *)(p->value);
! 					*p_long = ic->core.status_attr.cursor;
  				} else { 
! 					return_name = p->name;
  					return(False);
  			        }
  			}
  		} else if(strcmp(p->name, XNStatusStartCallback)==0) {
  			if((int)ic->core.status_attr.callbacks.start.callback) {
! 			        p_callback = (XIMCallback *)(p->value) ;
  				p_callback->client_data =
  					ic->core.status_attr.callbacks.start.client_data;
  				p_callback->callback =
  					ic->core.status_attr.callbacks.start.callback;
  			} else {
! 				return_name = p->name;
! 				break;
  			}
  		} else if(strcmp(p->name, XNStatusDrawCallback)==0) {
  			if((int)ic->core.status_attr.callbacks.draw.callback) {
! 			        p_callback = (XIMCallback *)(p->value) ;
  				p_callback->client_data =
  					ic->core.status_attr.callbacks.draw.client_data;
  				p_callback->callback =
  					ic->core.status_attr.callbacks.draw.callback;
  			} else {
! 				return_name = p->name;
! 				break;
  			}
  		} else if(strcmp(p->name, XNStatusDoneCallback)==0) {
  			if((int)ic->core.status_attr.callbacks.done.callback) {
! 			        p_callback = (XIMCallback *)(p->value) ;
  				p_callback->client_data =
  					ic->core.status_attr.callbacks.done.client_data;
  				p_callback->callback =
  					ic->core.status_attr.callbacks.done.callback;
  			} else {
! 				return_name = p->name;
! 				break;
  			}
  		}
  	}
! 	XFree(status_data);
  	return(True);
  }
  
--- 465,631 ----
  				p_rect->height  = status_data->Area.height;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_AREA_MASK) {
! 					if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 						*return_name = p->name;
! 						return(False);
! 					}
  					p_rect->x       = ic->core.status_attr.area.x;
  					p_rect->y       = ic->core.status_attr.area.y;
  					p_rect->width   = ic->core.status_attr.area.width;
  					p_rect->height  = ic->core.status_attr.area.height;
  				} else {
! 				        *return_name = p->name;
  				        return(False);
  				}
  			}
+ 			*((XRectangle **)(p->value)) = p_rect;
  		} else if(strcmp(p->name, XNAreaNeeded)==0) {
  			if(im_status_flag) {
! 				if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
  				p_rect->x  = p_rect->y  = 0;
  				p_rect->width   = status_data->AreaNeeded.width;
  				p_rect->height  = status_data->AreaNeeded.height;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_AREANEED_MASK) {
! 					if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 						*return_name = p->name;
! 						return(False);
! 					}
  					p_rect->x  = p_rect->y  = 0;
  					p_rect->width   = ic->core.status_attr.area_needed.width;
  					p_rect->height  = ic->core.status_attr.area_needed.height;
  				} else {
! 					*return_name = p->name;
  					return(False);
  				}
  			}
+ 			*((XRectangle **)(p->value)) = p_rect;
  		} else if(  strcmp(p->name, XNColormap)==0
  		        || strcmp(p->name, XNStdColormap)==0) {
  			if(im_status_flag) {
! 			         *((Colormap *)(p->value)) = status_data->Colormap;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_COLORMAP_MASK) {
! 				         *((Colormap *)(p->value)) = ic->core.status_attr.colormap;
  				} else {
! 					*return_name = p->name;
  					return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNBackground)==0) {
  			if(im_status_flag) {
! 			         *((unsigned long *)(p->value)) = status_data->Background;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_BG_MASK) {
! 				         *((unsigned long *)(p->value)) = ic->core.status_attr.background;
  				} else {
! 					*return_name = p->name;
  					return(False);
  			        }
  			}
  		} else if(strcmp(p->name, XNForeground)==0) {
  			if(im_status_flag) {
! 			         *((unsigned long *)(p->value)) = status_data->Foreground;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_FG_MASK) {
! 				         *((unsigned long *)(p->value)) = ic->core.status_attr.foreground;
  				} else {
! 					*return_name = p->name;
  					return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNBackgroundPixmap)==0) {
  			if(im_status_flag) {
! 			         *((Pixmap *)(p->value)) = status_data->Bg_Pixmap;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_BGPIXMAP_MASK) {
! 				         *((Pixmap *)(p->value)) = ic->core.status_attr.background_pixmap;
  				} else {
! 					*return_name = p->name;
  					return(False);
  			        }
  			}
  		} else if(strcmp(p->name, XNFontSet)==0) {
  			if(ic->ximp_icpart->proto_mask & XIMP_STS_FONT_MASK) {
! 			         *((XFontSet *)(p->value)) = ic->core.status_attr.fontset;
  			} else {
! 				*return_name = p->name;
  				return(False);
  			}
  		} else if(strcmp(p->name, XNLineSpace)==0) {
  			if(im_status_flag) {
! 			         *((int *)(p->value)) = status_data->LineSpacing;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_LINESP_MASK) {
! 				         *((int *)(p->value)) = ic->core.status_attr.line_space;
  				} else {
! 					*return_name = p->name;
  					return(False);
  				}
  			}
  		} else if(strcmp(p->name, XNCursor)==0) {
  			if(im_status_flag) {
! 			         *((Cursor *)(p->value)) = status_data->Cursor;
  			} else {
  				if(ic->ximp_icpart->proto_mask & XIMP_STS_CURSOR_MASK) {
! 				         *((Cursor *)(p->value)) = ic->core.status_attr.cursor;
  				} else { 
! 					*return_name = p->name;
  					return(False);
  			        }
  			}
  		} else if(strcmp(p->name, XNStatusStartCallback)==0) {
  			if((int)ic->core.status_attr.callbacks.start.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
  				p_callback->client_data =
  					ic->core.status_attr.callbacks.start.client_data;
  				p_callback->callback =
  					ic->core.status_attr.callbacks.start.callback;
+ 				*((XIMCallback **)(p->value)) = p_callback;
  			} else {
! 				*return_name = p->name;
! 				return(False);
  			}
  		} else if(strcmp(p->name, XNStatusDrawCallback)==0) {
  			if((int)ic->core.status_attr.callbacks.draw.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
  				p_callback->client_data =
  					ic->core.status_attr.callbacks.draw.client_data;
  				p_callback->callback =
  					ic->core.status_attr.callbacks.draw.callback;
+ 				*((XIMCallback **)(p->value)) = p_callback;
  			} else {
! 				*return_name = p->name;
! 				return(False);
  			}
  		} else if(strcmp(p->name, XNStatusDoneCallback)==0) {
  			if((int)ic->core.status_attr.callbacks.done.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
  				p_callback->client_data =
  					ic->core.status_attr.callbacks.done.client_data;
  				p_callback->callback =
  					ic->core.status_attr.callbacks.done.callback;
+ 				*((XIMCallback **)(p->value)) = p_callback;
  			} else {
! 				*return_name = p->name;
! 				return(False);
  			}
  		}
  	}
! 	if( status_data )
! 		XFree(status_data);
  	return(True);
  }
  
***************
*** 612,617 ****
--- 639,658 ----
  }
  #endif /* XIMP_SIGNAL */
  
+ static Bool Check_Message(display, event, arg)
+     Display *display;
+     XEvent  *event;
+     XPointer arg;
+ {
+     if ( event->type == ClientMessage && 
+ 	 event->xclient.message_type == 
+ 	 ((Ximp_XIM)arg)->ximp_impart->improtocol_id )
+ 	return True;
+     else
+ 	return False;
+ }
+ 
+ 
  static XPointer
  _Ximp_GetRequestIM(ic, mask, get_atom_id, atom_id)
  	Ximp_XIC	 ic;
***************
*** 637,655 ****
  #endif /* XIMP_SIGNAL */
  
  	while(_time_flag != 1) {
! 		if( (XCheckTypedEvent(ic->core.im->core.display, ClientMessage, &event)) == False) {
  #ifdef XIMP_SIGNAL
- 			sleep(1);
- #endif /* XIMP_SIGNAL */
- 			continue;
- 		}
- 		if(event.xclient.message_type == ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id) {
- #ifdef XIMP_SIGNAL
  			alarm(0);
  #endif /* XIMP_SIGNAL */
  			break;
  		} else {
! 			XPutBackEvent(ic->core.im->core.display, &event);
  			continue;
  		}
  	}
--- 678,693 ----
  #endif /* XIMP_SIGNAL */
  
  	while(_time_flag != 1) {
! 		if (XCheckIfEvent(ic->core.im->core.display, &event, 
! 			Check_Message, (XPointer)ic->core.im) ) {
  #ifdef XIMP_SIGNAL
  			alarm(0);
  #endif /* XIMP_SIGNAL */
  			break;
  		} else {
! #ifdef XIMP_SIGNAL
! 			sleep(1);
! #endif /* XIMP_SIGNAL */
  			continue;
  		}
  	}
*** /tmp/d17338	Sun May  3 18:48:42 1992
--- mit/lib/X/Ximp/XimpICS.c	Sun May  3 18:48:40 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpICS.c,v 1.2 91/10/07 17:48:43 rws Exp $ */
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,8 ----
! /* $XConsortium: XimpICS.c,v 1.3 92/04/14 13:29:14 rws Exp $ */
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporaion
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 8,29 ****
  provided that the above copyright notice appear in all copies and
  that both that copyright notice and this permission notice appear
  in supporting documentation, and that the name of FUJITSU LIMITED
! not be used in advertising or publicity pertaining to distribution
! of the software without specific, written prior permission.
! FUJITSU LIMITED makes no representations about the suitability of
! this software for any purpose.  It is provided "as is" without
! express or implied warranty.
  
! FUJITSU LIMITED DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
! INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
! IN NO EVENT SHALL FUJITSU LIMITED BE LIABLE FOR ANY SPECIAL, INDIRECT
! OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
! OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
! OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
  OR PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
!                                fujiwara@a80.tech.yk.fujitsu.co.jp
  
  ******************************************************************/
  
--- 9,32 ----
  provided that the above copyright notice appear in all copies and
  that both that copyright notice and this permission notice appear
  in supporting documentation, and that the name of FUJITSU LIMITED
! and Sony Corporaion not be used in advertising or publicity
! pertaining to distribution of the software without specific,
! written prior permission.
! FUJITSU LIMITED and Sony Corporaion make no representations about
! the suitability of this software for any purpose.  It is provided
! "as is" without express or implied warranty.
  
! FUJITSU LIMITED AND SONY CORPORATION DISCLAIM ALL WARRANTIES WITH
! REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU LIMITED AND
! SONY CORPORATION BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
! DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
! OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
! TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
  OR PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
!           Makoto Wakamatsu     Sony Corporaion
  
  ******************************************************************/
  
***************
*** 43,48 ****
--- 46,52 ----
  extern void		_Ximp_SetStatusAtr();
  extern void		_Ximp_SetStatusFont();
  extern void		_Ximp_IM_SendMessage();
+ extern Bool		_Ximp_XimFilter_Keypress();
  
  static Bool		_Ximp_PreSetAttributes();
  static Bool		_Ximp_StatusSetAttributes();
***************
*** 56,77 ****
  	char		*ret;
  	int		 change_mask = 0;
  
! 	ret = _Ximp_SetICValueData(ic, values, XIMP_SET_IC, &change_mask);
  
  	if(   (ic->ximp_icpart->value_mask & XIMP_RES_NAME)
  	   || (ic->ximp_icpart->value_mask & XIMP_RES_CLASS) )
  		_Ximp_SetValue_Resource(ic, &change_mask);
  
! 	if(ic->ximp_icpart->icid == NULL)
  		return(ret);
  
! 	if(change_mask == XIMP_PRE_SPOTL_MASK) {
!  		_Ximp_IM_SendMessage(ic, XIMP_MOVE,
  				ic->ximp_icpart->preedit_attr.SpotLocation.x,
  				ic->ximp_icpart->preedit_attr.SpotLocation.y,
  				NULL);
! 		return(ret);
  		}
  	if(change_mask & XIMP_PROP_FOCUS)
  		_Ximp_SetFocusWindow(ic);
  	if(!(   (ic->core.input_style & XIMPreeditCallbacks)
--- 60,100 ----
  	char		*ret;
  	int		 change_mask = 0;
  
! 	if((ret = _Ximp_SetICValueData(ic, values, XIMP_SET_IC, &change_mask)))
! 		return(ret);
  
  	if(   (ic->ximp_icpart->value_mask & XIMP_RES_NAME)
  	   || (ic->ximp_icpart->value_mask & XIMP_RES_CLASS) )
  		_Ximp_SetValue_Resource(ic, &change_mask);
  
! 	if(ic->ximp_icpart->icid == NULL) {
! 		if(change_mask & XIMP_PROP_FOCUS) {
! 			if(ic->ximp_icpart->filter_mode & 0x1) {
! 				_XUnregisterFilter (ic->core.im->core.display,
! 						ic->ximp_icpart->back_focus_win,
! 						_Ximp_XimFilter_Keypress,
! 						(XPointer)ic);
! 				}
! 			_XRegisterFilterByType (ic->core.im->core.display,
! 						ic->core.focus_window,
! 						KeyPress, KeyPress,
! 						_Ximp_XimFilter_Keypress,
! 						(XPointer)ic);
! 			ic->ximp_icpart->filter_mode |= 0x1;
! 			}
  		return(ret);
+ 		}
  
! 	if(ic->core.input_style & XIMPreeditPosition) {
! 		if(change_mask == XIMP_PRE_SPOTL_MASK) {
! 			if(ic->ximp_icpart->input_mode)
! 			    _Ximp_IM_SendMessage(ic, XIMP_MOVE,
  				ic->ximp_icpart->preedit_attr.SpotLocation.x,
  				ic->ximp_icpart->preedit_attr.SpotLocation.y,
  				NULL);
! 			return(ret);
  		}
+ 	}
  	if(change_mask & XIMP_PROP_FOCUS)
  		_Ximp_SetFocusWindow(ic);
  	if(!(   (ic->core.input_style & XIMPreeditCallbacks)
***************
*** 94,100 ****
  	else {
  		change_mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
  		}
!  	_Ximp_IM_SendMessage(ic, XIMP_SETVALUE, change_mask, NULL, NULL);
  	return(ret);
  	}
  
--- 117,124 ----
  	else {
  		change_mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
  		}
! 	if(change_mask)
!  		_Ximp_IM_SendMessage(ic, XIMP_SETVALUE, change_mask, NULL, NULL);
  	return(ret);
  	}
  
***************
*** 119,126 ****
  			}
  		else if(strcmp(p->name, XNClientWindow)==0) {
  			if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
! 				ic->core.client_window = (Window)p->value;
! 				ic->ximp_icpart->value_mask |= XIMP_CLIENT_WIN;
  				}
  			else {
  				return_name = p->name;
--- 143,168 ----
  			}
  		else if(strcmp(p->name, XNClientWindow)==0) {
  			if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
! 				if(mode == XIMP_SET_IC && (ic->ximp_icpart->icid)) {
! 					_Ximp_IM_SendMessage(ic, XIMP_DESTROY, NULL, NULL, NULL);
! 					XDestroyWindow(ic->core.im->core.display,
! 						       ic->core.client_window);
! 					ic->core.client_window = (Window)p->value;
! 					ic->ximp_icpart->value_mask |= XIMP_CLIENT_WIN;
! 					if(_Ximp_SetOpenXIMP(ic, mode) == False) {
! 						return_name = p->name;
! 						break;
! 						}
! 					*change_mask = NULL;
! 					}
! 				else { /* XIMP_CREATE_IC | (XIMP_SET_IC && XIMP_START_IC) */
! 					ic->core.client_window = (Window)p->value;
! 					ic->ximp_icpart->value_mask |= XIMP_CLIENT_WIN;
! 					if(!(ic->ximp_icpart->proto_mask & XIMP_FOCUS_WIN_MASK)) {
! 						ic->core.focus_window = ic->core.client_window;
! 						ic->ximp_icpart->proto_mask |= XIMP_FOCUS_WIN_MASK;
! 						}
! 					}
  				}
  			else {
  				return_name = p->name;
***************
*** 151,156 ****
--- 193,199 ----
  					     new_focus_window,
  					     dummy_mask);
  				}
+ 			ic->ximp_icpart->back_focus_win = ic->core.focus_window;
  			ic->core.focus_window = (Window)p->value;
  			ic->ximp_icpart->proto_mask |= XIMP_FOCUS_WIN_MASK;
  			*change_mask                |= XIMP_FOCUS_WIN_MASK;
***************
*** 282,287 ****
--- 325,332 ----
  		else if(strcmp(p->name, XNFontSet)==0) {
  			ic->core.preedit_attr.fontset = (XFontSet)p->value;
  			if(p->value != NULL) {
+ 				if(ic->ximp_icpart->preedit_font)
+ 	    				Xfree(ic->ximp_icpart->preedit_font);
  				list_ret = XFontsOfFontSet(
  					ic->core.preedit_attr.fontset,
  					&struct_list, &name_list);
***************
*** 288,294 ****
  				for(i = 0, len = 0; i < list_ret; i++) {
  					len += strlen(name_list[i]);
  					}
! 				tmp = Xmalloc(len + i);
  				tmp[0] = NULL;
  				for(i = 0; i < list_ret; i++) {
  					strcat(tmp, name_list[i]);
--- 333,339 ----
  				for(i = 0, len = 0; i < list_ret; i++) {
  					len += strlen(name_list[i]);
  					}
! 				tmp = Xmalloc(len + i + 1);
  				tmp[0] = NULL;
  				for(i = 0; i < list_ret; i++) {
  					strcat(tmp, name_list[i]);
***************
*** 321,326 ****
--- 366,372 ----
  				((XIMCallback *)p->value)->client_data;
  			ic->core.preedit_attr.callbacks.start.callback =
  				((XIMCallback *)p->value)->callback;
+ 			ic->ximp_icpart->value_mask |= XIMP_PRE_CALLBAK;
  			}
  		else if(strcmp(p->name, XNPreeditDoneCallback)==0) {
  			ic->core.preedit_attr.callbacks.done.client_data =
***************
*** 327,332 ****
--- 373,379 ----
  				((XIMCallback *)p->value)->client_data;
  			ic->core.preedit_attr.callbacks.done.callback =
  				((XIMCallback *)p->value)->callback;
+ 			ic->ximp_icpart->value_mask |= XIMP_PRE_CALLBAK;
  			}
  		else if(strcmp(p->name, XNPreeditDrawCallback)==0) {
  			ic->core.preedit_attr.callbacks.draw.client_data =
***************
*** 333,338 ****
--- 380,386 ----
  				((XIMCallback *)p->value)->client_data;
  			ic->core.preedit_attr.callbacks.draw.callback =
  				((XIMCallback *)p->value)->callback;
+ 			ic->ximp_icpart->value_mask |= XIMP_PRE_CALLBAK;
  			}
  		else if(strcmp(p->name, XNPreeditCaretCallback)==0) {
  			ic->core.preedit_attr.callbacks.caret.client_data =
***************
*** 339,344 ****
--- 387,393 ----
  				((XIMCallback *)p->value)->client_data;
  			ic->core.preedit_attr.callbacks.caret.callback =
  				((XIMCallback *)p->value)->callback;
+ 			ic->ximp_icpart->value_mask |= XIMP_PRE_CALLBAK;
  			}
  		}
  	return(True);
***************
*** 423,428 ****
--- 472,479 ----
  		else if(strcmp(p->name, XNFontSet)==0) {
  			ic->core.status_attr.fontset = (XFontSet)p->value;
  			if (p->value != NULL) {
+ 				if(ic->ximp_icpart->status_font)
+ 	    				Xfree(ic->ximp_icpart->status_font);
  				list_ret = XFontsOfFontSet(
  					ic->core.status_attr.fontset,
  					&struct_list, &name_list);
***************
*** 429,435 ****
  				for(i = 0, len = 0; i < list_ret; i++) {
  					len += strlen(name_list[i]);
  					}
! 				tmp = Xmalloc(len + i);
  				tmp[0] = NULL;
  				for(i = 0; i < list_ret; i++) {
  					strcat(tmp, name_list[i]);
--- 480,486 ----
  				for(i = 0, len = 0; i < list_ret; i++) {
  					len += strlen(name_list[i]);
  					}
! 				tmp = Xmalloc(len + i + 1);
  				tmp[0] = NULL;
  				for(i = 0; i < list_ret; i++) {
  					strcat(tmp, name_list[i]);
***************
*** 454,461 ****
  		else if(strcmp(p->name, XNCursor)==0) {
  			ic->core.status_attr.cursor = (Cursor)p->value;
  			attr->Cursor = ic->core.status_attr.cursor;
! 			ic->ximp_icpart->proto_mask |= XIMP_PRE_CURSOR_MASK;
! 			*change_mask                |= XIMP_PRE_CURSOR_MASK;
  			}
  		else if(strcmp(p->name, XNStatusStartCallback)==0) {
  			ic->core.status_attr.callbacks.start.client_data =
--- 505,512 ----
  		else if(strcmp(p->name, XNCursor)==0) {
  			ic->core.status_attr.cursor = (Cursor)p->value;
  			attr->Cursor = ic->core.status_attr.cursor;
! 			ic->ximp_icpart->proto_mask |= XIMP_STS_CURSOR_MASK;
! 			*change_mask                |= XIMP_STS_CURSOR_MASK;
  			}
  		else if(strcmp(p->name, XNStatusStartCallback)==0) {
  			ic->core.status_attr.callbacks.start.client_data =
***************
*** 462,467 ****
--- 513,519 ----
  				((XIMCallback *)p->value)->client_data;
  			ic->core.status_attr.callbacks.start.callback =
  				((XIMCallback *)p->value)->callback;
+ 			ic->ximp_icpart->value_mask |= XIMP_STS_CALLBAK;
  			}
  		else if(strcmp(p->name, XNStatusDoneCallback)==0) {
  			ic->core.status_attr.callbacks.done.client_data =
***************
*** 468,473 ****
--- 520,526 ----
  				((XIMCallback *)p->value)->client_data;
  			ic->core.status_attr.callbacks.done.callback =
  				((XIMCallback *)p->value)->callback;
+ 			ic->ximp_icpart->value_mask |= XIMP_STS_CALLBAK;
  			}
  		else if(strcmp(p->name, XNStatusDrawCallback)==0) {
  			ic->core.status_attr.callbacks.draw.client_data =
***************
*** 474,479 ****
--- 527,533 ----
  				((XIMCallback *)p->value)->client_data;
  			ic->core.status_attr.callbacks.draw.callback =
  				((XIMCallback *)p->value)->callback;
+ 			ic->ximp_icpart->value_mask |= XIMP_STS_CALLBAK;
  			}
  		}
  	return(True);
*** /tmp/d17360	Sun May  3 18:48:55 1992
--- mit/lib/X/Ximp/XimpMPer.c	Sun May  3 18:48:53 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpMPer.c,v 1.1 91/07/09 17:37:12 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpMPer.c,v 1.2 92/04/14 13:29:43 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 29,35 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 29,35 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17382	Sun May  3 18:49:06 1992
--- mit/lib/X/Ximp/XimpMPrTxt.c	Sun May  3 18:49:04 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpMPrTxt.c,v 1.2 91/10/07 17:50:17 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpMPrTxt.c,v 1.3 92/04/14 13:29:46 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 28,34 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 28,34 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 109,116 ****
      buf_ptr = buf;
      for (i = 0; i < count; i++) {
  	list[i] = str_ptr;
! 	strcpy(str_ptr, buf_ptr);
! 	tmp_len = strlen(str_ptr) + 1;
  	str_ptr += tmp_len;
  	buf_ptr += tmp_len;
      }
--- 109,116 ----
      buf_ptr = buf;
      for (i = 0; i < count; i++) {
  	list[i] = str_ptr;
! 	strcpy((char *)str_ptr, (char *)buf_ptr);
! 	tmp_len = strlen((char *)str_ptr) + 1;
  	str_ptr += tmp_len;
  	buf_ptr += tmp_len;
      }
*** /tmp/d17404	Sun May  3 18:49:19 1992
--- mit/lib/X/Ximp/XimpMTxtPr.c	Sun May  3 18:49:16 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpMTxtPr.c,v 1.2 91/10/07 17:50:20 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpMTxtPr.c,v 1.3 92/04/14 13:29:49 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 28,34 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 28,34 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17426	Sun May  3 18:49:30 1992
--- mit/lib/X/Ximp/XimpPrTxt.c	Sun May  3 18:49:27 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpPrTxt.c,v 1.2 91/10/07 17:50:23 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpPrTxt.c,v 1.3 92/04/14 13:29:53 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 28,34 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 28,34 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17448	Sun May  3 18:49:43 1992
--- mit/lib/X/Ximp/XimpRm.c	Sun May  3 18:49:39 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpRm.c,v 1.3 92/03/03 11:03:30 rws Exp $ */
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,8 ----
! /* $XConsortium: XimpRm.c,v 1.4 92/04/14 13:29:56 rws Exp $ */
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporaion
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 8,29 ****
  provided that the above copyright notice appear in all copies and
  that both that copyright notice and this permission notice appear
  in supporting documentation, and that the name of FUJITSU LIMITED
! not be used in advertising or publicity pertaining to distribution
! of the software without specific, written prior permission.
! FUJITSU LIMITED makes no representations about the suitability of
! this software for any purpose.  It is provided "as is" without
! express or implied warranty.
  
! FUJITSU LIMITED DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
! INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
! IN NO EVENT SHALL FUJITSU LIMITED BE LIABLE FOR ANY SPECIAL, INDIRECT
! OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
! OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
! OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
  OR PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
!                                fujiwara@a80.tech.yk.fujitsu.co.jp
  
  ******************************************************************/
  
--- 9,32 ----
  provided that the above copyright notice appear in all copies and
  that both that copyright notice and this permission notice appear
  in supporting documentation, and that the name of FUJITSU LIMITED
! and Sony Corporaion not be used in advertising or publicity
! pertaining to distribution of the software without specific,
! written prior permission.
! FUJITSU LIMITED and Sony Corporation make no representations about
! the suitability of this software for any purpose.  It is provided
! "as is" without express or implied warranty.
  
! FUJITSU LIMITED AND SONY CORPORATION DISCLAIM ALL WARRANTIES WITH
! REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU LIMITED AND
! SONY CORPORATION BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
! DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
! OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
! TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
  OR PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
!           Makoto Wakamatsu     Sony Corporaion
  
  ******************************************************************/
  
***************
*** 52,63 ****
  		strcpy(res_class, "*");
  	else	{
  		strcpy(res_class, im->core.res_class);
! 		strcat(res_name, ".");
  		}
  	strcat(res_name, "ximp.");
  	strcat(res_class, "Ximp.");
  	}
  
  Bool
  _Ximp_OpenIM_Resource(im)
  	Ximp_XIM	 im;
--- 55,174 ----
  		strcpy(res_class, "*");
  	else	{
  		strcpy(res_class, im->core.res_class);
! 		strcat(res_class, ".");
  		}
  	strcat(res_name, "ximp.");
  	strcat(res_class, "Ximp.");
  	}
  
+ 
+ #ifndef	isalnum
+ #define	isalnum(c)	\
+     (('0' <= (c) && (c) <= '9')  || \
+      ('A' <= (c) && (c) <= 'Z')  || \
+      ('a' <= (c) && (c) <= 'z'))
+ #endif
+ 
+ static void	_Ximp_parse( im, event )
+ Ximp_XIM	 im;
+ char		*event;
+ {
+     static Ximp_Key	key;
+     char		*modifier, *detail;
+     char		*ss;
+     int			ii;
+     Bool		exclamation, tilde;
+     Ximp_KeyList	*keylist;
+     static struct {
+ 	char	*name;
+ 	int	len;
+ 	long	mask;
+     } mod[] = {
+ 	{ "Ctrl",	4,	ControlMask	},
+ 	{ "Lock",	4,	LockMask	},
+ 	{ "Caps",	4,	LockMask	},
+ 	{ "Shift",	5,	ShiftMask	},
+ 	{ "Alt",	3,	Mod1Mask	},
+ 	{ "Meta",	4,	Mod1Mask	},
+ 	{ NULL,		0,	0		}};
+     extern char		*_Ximp_Strstr();
+ #define	AllMask	(ControlMask | LockMask | ShiftMask | Mod1Mask)
+ 
+     if( (ss = _Ximp_Strstr( event, "<Key>" )) == NULL )
+ 	return;
+     detail = ss + 5;
+     *ss = NULL;
+ 
+     modifier = event;
+     key.modifier = 0;
+     key.modifier_mask = 0;
+     key.keysym = XK_VoidSymbol;
+     exclamation = False;
+     do {
+ 	while( *modifier == ' '  ||  *modifier == '\t' )
+ 	    modifier++;
+ 	if( *modifier == NULL )
+ 	    break;
+ 	if( strncmp( modifier, "None", 4 ) == 0 ) {
+ 	    if( key.modifier_mask != 0  ||  exclamation )
+ 		return;
+ 	    key.modifier_mask = AllMask;
+ 	    modifier += 4;
+ 	}
+ 	else {
+ 	    if( *modifier == '!' ) {
+ 		if( key.modifier_mask != 0  ||  exclamation )
+ 		    return;
+ 		key.modifier_mask = AllMask;
+ 		exclamation = True;
+ 		modifier++;
+ 		continue;
+ 	    }
+ 	    if( (tilde = (*modifier == '~')) ) {
+ 		modifier++;
+ 		while( *modifier == ' '  ||  *modifier == '\t' )
+ 		    modifier++;
+ 	    }
+ 	    for( ii = 0; mod[ii].name != NULL; ii++ ) {
+ 		if( strncmp( modifier, mod[ii].name, mod[ii].len ) == 0 ) {
+ 		    key.modifier_mask |= mod[ii].mask;
+ 		    if( !tilde )
+ 			key.modifier |= mod[ii].mask;
+ 		    modifier += mod[ii].len;
+ 		    break;
+ 		}
+ 	    }
+ 	}
+ 	if( mod[ii].name == NULL )
+ 	    return;
+     } while( *modifier != NULL );
+ 
+     while( *detail == ' '  ||  *detail == '\t' )
+ 	detail++;
+     for( ss = detail; isalnum(*ss)  ||  *ss == '_'; ss++ );
+     *ss = NULL;
+     if( (key.keysym = XStringToKeysym( detail )) != NoSymbol ) {
+ 	if( !(keylist = im->ximp_impart->process_start_keys) ) {
+ 	    if( (keylist = (Ximp_KeyList *)Xcalloc(1, sizeof(Ximp_KeyList))) == NULL )
+ 		return;
+ 	    if((keylist->keys_list = (Ximp_Key *)Xmalloc(sizeof(Ximp_Key))) == NULL) {
+ 		Xfree( keylist );
+ 		return;
+ 	    }
+ 	}
+ 	else {
+ 	    Ximp_Key	*keys_list;
+ 	    if( (keys_list = (Ximp_Key *)Xrealloc(keylist->keys_list, sizeof(Ximp_Key) * (keylist->count_keys + 1))) == NULL )
+ 		return;
+ 	    keylist->keys_list = keys_list;
+ 	}
+ 	keylist->keys_list[keylist->count_keys] = key;
+ 	keylist->count_keys++;
+ 	im->ximp_impart->process_start_keys = keylist;
+     }
+ }
+ 
+ 
  Bool
  _Ximp_OpenIM_Resource(im)
  	Ximp_XIM	 im;
***************
*** 68,73 ****
--- 179,185 ----
  	XrmValue	 value;
  	Bool		 ret = False;
  	KeySym		 keysym = NoSymbol;
+ 	Ximp_KeyList	*keylist;
  
  	if(im->core.rdb == NULL)
  		return(ret);
***************
*** 87,97 ****
  				str_type, &value) == True) { 
  				keysym = XStringToKeysym(value.addr);
  				}
! 			if(keysym == NoSymbol)
! 				ret = False;
! 			else {
! 				im->ximp_impart->def_startkeysym = keysym;
! 				ret = True;
  				}
  			}
  		}
--- 199,246 ----
  				str_type, &value) == True) { 
  				keysym = XStringToKeysym(value.addr);
  				}
! 			ret = False;
! 			if(keysym != NoSymbol) {
! 				if((keylist = (Ximp_KeyList *)Xmalloc(sizeof(Ximp_KeyList))) != NULL ) {
! 					if((keylist->keys_list = (Ximp_Key *)Xmalloc(sizeof(Ximp_Key)))!= NULL) {
! 						keylist->count_keys = 1;
! 						keylist->keys_list[0].modifier = 0;
! 						keylist->keys_list[0].modifier_mask = 0;
! 						keylist->keys_list[0].keysym = keysym;
! 						im->ximp_impart->process_start_keys = keylist;
! 						ret = True;
! 						}
! 					else
! 						Xfree(keylist);
! 					}
! 				}
! 
! 			/* ProcessStartKeys */
! 			_Ximp_Get_resource_name(im, res_name, res_class);
! 			strcat(res_name, "processStartKeys");
! 			strcat(res_class, "ProcessStartKeys");
! 			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 						str_type, &value)  == True) {
! 				char	*string, *ss, c;
! 				char	*line;
! 
! 				if( (line = Xmalloc(value.size)) != NULL ) {
! 					string = value.addr;
! 					do {
! 						ss = line;
! 						while( (c = *string) != NULL ) {
! 							string++;
! 							if( c == '\n' )
! 								break;
! 							*ss++ = c;
! 							}
! 						*ss = NULL;
! 						_Ximp_parse( im, line );
! 					} while( *string != NULL );
! 					Xfree( line );
! 					if( im->ximp_impart->process_start_keys )
! 						ret = True;
! 					}
  				}
  			}
  		}
*** /tmp/d17470	Sun May  3 18:49:55 1992
--- mit/lib/X/Ximp/XimpSJIS.c	Sun May  3 18:49:53 1992
***************
*** 1,26 ****
! /* $XConsortium: XimpSJIS.c,v 1.3 91/10/07 17:50:33 rws Exp $ */
! /*
!  * Copyright 1991 Sony Corporation
!  *
!  * Permission to use, copy, modify, distribute, and sell this software and its
!  * documentation for any purpose is hereby granted without fee, provided that
!  * the above copyright notice appear in all copies and that both that
!  * copyright notice and this permission notice appear in supporting
!  * documentation, and that the name of Sony not be used in advertising or
!  * publicity pertaining to distribution of the software without specific,
!  * written prior permission.  Sony makes no representations about the
!  * suitability of this software for any purpose.  It is provided "as is"
!  * without express or implied warranty.
!  *
!  * SONY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
!  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SONY
!  * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
!  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
!  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  *
!  * Author: Masaki Takeuchi, Sony Corporation
!  */
  
  #include "Xlibint.h"
  #include "Xlcint.h"
--- 1,30 ----
! /* $XConsortium: XimpSJIS.c,v 1.4 92/04/14 13:29:59 rws Exp $ */
! /******************************************************************
! 
!               Copyright 1991, 1992 Sony Corporation
! 
! Permission to use, copy, modify, distribute, and sell this software
! and its documentation for any purpose is hereby granted without fee,
! provided that the above copyright notice appear in all copies and
! that both that copyright notice and this permission notice appear
! in supporting documentation, and that the name of Sony not be used
! in advertising or publicity pertaining to distribution of the
! software without specific, written prior permission.
! Sony makes no representations about the suitability of this software
! for any purpose.  It is provided "as is" without express or implied
! warranty.
!  
! SONY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
! ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
! SHALL SONY BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
! DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
! OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
! TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
! PERFORMANCE OF THIS SOFTWARE.
! 
!   Author: Masaki Takeuchi       Sony Corporation
! 
! ******************************************************************/
  
  #include "Xlibint.h"
  #include "Xlcint.h"
*** /tmp/d17492	Sun May  3 18:50:08 1992
--- mit/lib/X/Ximp/XimpTxtEsc.c	Sun May  3 18:50:05 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpTxtEsc.c,v 1.1 91/07/09 17:37:28 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpTxtEsc.c,v 1.2 92/04/14 13:30:02 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 29,35 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 29,35 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 112,118 ****
  		break;
  
  	    if (char_length < 2)
! 		width += XTextWidth(font, xchar_buf, tmp_len);
              else
  		width += XTextWidth16(font, xchar2b_buf, tmp_len);
  
--- 112,118 ----
  		break;
  
  	    if (char_length < 2)
! 		width += XTextWidth(font, (char *)xchar_buf, tmp_len);
              else
  		width += XTextWidth16(font, xchar2b_buf, tmp_len);
  
*** /tmp/d17514	Sun May  3 18:50:19 1992
--- mit/lib/X/Ximp/XimpTxtExt.c	Sun May  3 18:50:16 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpTxtExt.c,v 1.3 91/10/10 20:41:43 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpTxtExt.c,v 1.4 92/04/14 13:30:06 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 29,35 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 29,35 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 117,123 ****
  		break;
  
  	    if (char_length < 2)
! 		XTextExtents(font, xchar_buf, tmp_len, &direction,
  			     &tmp_ascent, &tmp_descent, &tmp_overall);
              else
  		XTextExtents16(font, xchar2b_buf, tmp_len, &direction,
--- 117,123 ----
  		break;
  
  	    if (char_length < 2)
! 		XTextExtents(font, (char *)xchar_buf, tmp_len, &direction,
  			     &tmp_ascent, &tmp_descent, &tmp_overall);
              else
  		XTextExtents16(font, xchar2b_buf, tmp_len, &direction,
*** /tmp/d17536	Sun May  3 18:50:30 1992
--- mit/lib/X/Ximp/XimpTxtPer.c	Sun May  3 18:50:28 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpTxtPer.c,v 1.3 91/10/10 20:41:46 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpTxtPer.c,v 1.4 92/04/14 13:30:08 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 29,35 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 29,35 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17558	Sun May  3 18:50:42 1992
--- mit/lib/X/Ximp/XimpTxtPr.c	Sun May  3 18:50:39 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpTxtPr.c,v 1.2 91/10/07 17:50:45 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpTxtPr.c,v 1.3 92/04/14 13:30:11 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 28,34 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 28,34 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17580	Sun May  3 18:50:54 1992
--- mit/lib/X/Ximp/XimpWPer.c	Sun May  3 18:50:52 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpWPer.c,v 1.1 91/07/09 17:37:39 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpWPer.c,v 1.2 92/04/14 13:30:27 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 29,35 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 29,35 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17602	Sun May  3 18:51:06 1992
--- mit/lib/X/Ximp/XimpWPrTxt.c	Sun May  3 18:51:03 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpWPrTxt.c,v 1.2 91/10/07 17:50:54 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpWPrTxt.c,v 1.3 92/04/14 13:30:30 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 28,34 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 28,34 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17624	Sun May  3 18:51:17 1992
--- mit/lib/X/Ximp/XimpWTxtPr.c	Sun May  3 18:51:14 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpWTxtPr.c,v 1.2 91/10/07 17:50:57 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpWTxtPr.c,v 1.3 92/04/14 13:30:33 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 28,34 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 28,34 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17646	Sun May  3 18:51:29 1992
--- mit/lib/X/Ximp/XimpXConv.c	Sun May  3 18:51:26 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpXConv.c,v 1.2 91/07/30 14:27:58 rws Exp $ */
  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpXConv.c,v 1.3 92/04/14 13:30:36 rws Exp $ */
  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
   *
   * Permission to use, copy, modify, distribute, and sell this software and its
   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 29,35 ****
  
  /******************************************************************
  
!               Copyright 1991, by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 29,35 ----
  
  /******************************************************************
  
!               Copyright 1991, 1992 by FUJITSU LIMITED
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17668	Sun May  3 18:51:41 1992
--- mit/lib/X/Ximp/Ximpint.c	Sun May  3 18:51:38 1992
***************
*** 1,7 ****
! /* $XConsortium: Ximpint.c,v 1.3 91/10/10 20:41:48 rws Exp $ */
  /******************************************************************
  
!               Copyright 1991, by Fuji Xerox Co.,Ltd.
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,7 ----
! /* $XConsortium: Ximpint.c,v 1.4 92/04/14 13:30:39 rws Exp $ */
  /******************************************************************
  
!               Copyright 1991, 1992 by Fuji Xerox Co.,Ltd.
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 178,184 ****
      int i;
      unsigned char c;
  
!     count = XLookupString(event, buffer, nbytes, &symbol, status);
      if (keysym) *keysym = symbol;
      if ((nbytes == 0) || (symbol == NoSymbol)) {
  	return(count);
--- 178,184 ----
      int i;
      unsigned char c;
  
!     count = XLookupString(event, (char *)buffer, nbytes, &symbol, status);
      if (keysym) *keysym = symbol;
      if ((nbytes == 0) || (symbol == NoSymbol)) {
  	return(count);
***************
*** 223,229 ****
      int i;
      unsigned char c;
  
!     count = XLookupString(event, look, nbytes, &symbol, status);
      if (keysym) *keysym = symbol;
      if ((nbytes == 0) || (symbol == NoSymbol)) {
  	return(count);
--- 223,229 ----
      int i;
      unsigned char c;
  
!     count = XLookupString(event, (char *)look, nbytes, &symbol, status);
      if (keysym) *keysym = symbol;
      if ((nbytes == 0) || (symbol == NoSymbol)) {
  	return(count);

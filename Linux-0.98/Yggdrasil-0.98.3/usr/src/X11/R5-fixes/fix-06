		      Release 5 Public Patch #6
			   MIT X Consortium

To apply this patch:

cd to the top of the source tree (to the directory containing the "mit"
and "contrib" subdirectories) and do:
	rm -f mit/doc/I18N/Xsi/README
	rm -f mit/doc/I18N/Xsi/title.an
	rm -f mit/doc/I18N/Xsi/Xlc/*
	rm -fr mit/doc/I18N/Xsi/nls
	patch -p -s < ThisFile
Patch will work silently unless an error occurs.  You will likely get
the following warning messages (multiple times), which can be ignored:
	mkdir: mit: File exists
	mkdir: mit/doc: File exists
	mkdir: mit/doc/I18N: File exists
	mkdir: mit/doc/I18N/Xsi: File exists
	mkdir: mit/doc/I18N/Xsi/Xlc: File exists
If you want to watch patch do its thing, leave out the "-s" argument to patch.

Brief notes on what this patch fixes:

doc: I18N (Xsi and Ximp) doc updates

Prereq: public-patch-5

*** /tmp/,RCSt1002057	Mon Oct 28 16:32:16 1991
--- mit/bug-report	Mon Oct 28 16:32:17 1991
***************
*** 2,8 ****
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-5
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:
--- 2,8 ----
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-6
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:

*** /dev/null	Tue Oct  8 15:18:15 1991
--- mit/doc/I18N/Xsi/Xlc/Imakefile	Tue Oct  8 15:11:07 1991
***************
*** 0 ****
--- 1,34 ----
+ XCOMM $XConsortium: Imakefile,v 1.1 91/10/08 15:11:07 rws Exp $
+ 
+             TBL = tbl
+           TROFF = troff
+           PRINT = lpr
+       MANMACROS = -man
+        MSMACROS = -ms
+       PROPTIONS = -n
+ 
+ HEAD = intro.ms
+ 
+ SRCS = \
+        CTWC.man \
+        nls.man \
+        Locale.man \
+        ParseCT.man \
+        CTToMB.man \
+        CTToWC.man \
+        MBToCT.man \
+        MBToWC.man \
+        WCToCT.man \
+        WCToMB.man
+ 
+ all: Xlc.lpt
+ 
+ Xlc.lpt:
+ 	$(TROFF) $(MSMACROS) $(HEAD) > head.lpt
+ 	$(TBL) $(SRCS) | $(TROFF) $(MANMACROS) - > Xlc.lpt
+ 
+ print: Xlc.lpt
+ 	$(PRINT) $(PROPTIONS) head.lpt Xlc.lpt
+ 
+ clean::
+ 	$(RM) head.lpt Xlc.lpt

*** /dev/null	Tue Oct  8 15:18:15 1991
--- mit/doc/I18N/Xsi/Xlc/intro.ms	Tue Oct  8 15:12:16 1991
***************
*** 0 ****
--- 1,31 ----
+ .\" $XConsortium: intro.ms,v 1.1 91/10/08 15:12:16 rws Exp $
+ .EH ''''
+ .OH ''''
+ .EF ''''
+ .OF ''''
+ .ps 11
+ .nr PS 11
+ \&
+ .sp 10
+ .ce 6
+ \s+6\fBX Locale - C Language Interface\fP\s-6
+ .bp
+ \&
+ .sp 5
+ .ce 6
+ \s+2\fBIntroduction\fP\s-2
+ .sp 6
+ .PP
+ This section describes the X locale model and the locale source definition
+ file -- NLS profile.  Also it contains the specifications for internal
+ functions that access locale and control the mechanizm of locale.
+ .PP
+ The reference for the section is:
+ .IP
+ X/Open Portability Guide, Volume 3, XSI Internationalization.
+ .IP
+ Compound Text Encoding, Version 1.1, X11R5
+ .IP
+ ISO DIS 10646(UCS), 4 November 1990
+ .IP
+ ISO 639 & ISO 3166

*** /dev/null	Tue Oct  8 15:18:15 1991
--- mit/doc/I18N/Xsi/Xlc/CTToMB.man	Tue Oct  8 15:24:11 1991
***************
*** 0 ****
--- 1,158 ----
+ .\" $XConsortium: CTToMB.man,v 1.2 91/10/08 15:24:06 rws Exp $
+ .\" Copyright 1990 by OMRON Corp.  All Rights Reserved.
+ .TH _XConvertCTToMB 3X11 "Release 5" "X Version 11" "XSI FUNCTIONS"
+ .SH NAME
+ _XConvertCTToMB \- conversion from CT string to multibyte string
+ .SH SYNOPSIS
+ .B int _XConvertCTToMB\f2(xlocale, ct_str, ct_bytes, mb_str, mb_bytes,
+ .br
+ .B                                    \f2scanned_bytes, state)
+ .br
+ .B XLocale \f2xlocale\f3;
+ .br
+ .B unsigned char \f2*ct_str\f3;
+ .br
+ .B int \f2ct_bytes\f3;
+ .br
+ .B unsigned char \f2*mb_str\f3;
+ .br
+ .B int \f2*mb_bytes\f3;
+ .br
+ .B int \f2*scanned_bytes\f3;
+ .br
+ .B _State \f2*state\f3;
+ .br
+ .SH ARGUMENTS
+ .IP \fIxlocale\fP 1i 
+ In: specifies locale, the default NULL is the current locale.
+ .IP \fIct_str\fP 1i 
+ In: multibyte string.
+ .b
+ .IP \fImb_bytes\fP 1i 
+ In: length of mb strings, counted in bytes.
+ .br
+ .IP \fIct_str\fP 1i
+ Out: conversion buffer of result CT string.
+ .br
+ .IP \fIct_bytes\fP 1i 
+ In/Out: as "In" it is length of buffer ct_str passed by caller; 
+ as "Out" it is the returned number of converted CT string, counted in bytes. 
+ .br
+ .IP \fIscanned_bytes\fP 1i 
+ Number of mb bytes converted when the function returns.
+ .br
+ .IP \fIstate\fP 1i
+ In/Out: as "In" it is the state at the beginning of
+ the CT string;
+ as "Out" it is the current state stopped at last converted CT
+ encoding.  The state is defined internally by Xlib.
+ If this pointer is null, the function will assume
+ the state to be the default CT state. Of course,
+ nothing will be put in the null pointer. Do not modify or free this data
+ which is owned by the Xlib.
+ .br
+ .SH DESCRIPTION
+ The
+ .B _XConvertCTToMB
+ converts the string encoded in CT to string encoded in the specified
+ \fIxlocale\fP.
+ After a successful conversion, the null character '\\0' will be
+ appended to mb_str if there is more room for it in the buffer.
+ The null character 
+ of mb string is not counted in length of output buffer mb_bytes.
+ .PP
+ The returned state will point to a state of 
+ the encoding in the internal table, so do not modify or free this 
+ pointer.
+ .PP
+ When function returns at any time, scanned_bytes always remembers
+ where stopped, and state always remembers the current CT state
+ if it is not null pointer.
+ .PP
+ The caller of this funcion has to provide the output buffer mb_str,
+ and store the buffer length into mb_bytes as input. 
+ By using scanned_bytes and state, the caller can break a large
+ CT string into pieces, and convert one piece at a time.
+ .PP
+ In other hand caller can pass any broken CT
+ string to this function for doing conversion.
+ For example, caller can still be trying of conversion when 
+ the error BadBuffer is occurred(output buffer was exhausted).
+ Usually, the application passes the NULL to state for first 
+ conversion as following:
+ .IP "" "   "
+ char *state = NULL;
+ .br
+ \f3_XConvertCTToMB(NULL, ct_str, ct_len, mb_str,
+             &mb_len, &scanned, &state)\f2
+ .PP
+ If the value of state is invalid or null-pointer, the function
+ will suppose the default state of CT as initial.
+ The default state of CT is defined in 3 cases of encoding:
+ .IP "" 2
+ 1\. no control sequence, GL and GR of Latin-1 is supposed.
+ .IP 
+ 2\. control sequence of Latin-1 GL only, GR of Latin-1 is supposed too.
+ .IP
+ 3\. control sequence of Latin-1 GR only, GL of Latin-1 is supposed too.
+ .PP
+ The function returns the BadBuffer meaning that
+ the output buffer mb_str was exhausted.
+ The function returns the BadTerminate meaning that
+ the CT string ct_str is terminated uncompletely, 
+ e.g., uncompleted ESC sequence or
+ uncompleted code point ended at tail of ct_str.
+ .PP
+ Only in both the case of BadBuffer and BadTerminate the
+ caller can
+ move pointer ct_str to (ct_str + *scanned_bytes), then continue
+ to do conversion.
+ And function ensure that the mb_str stores the already converted
+ mb string; mb_bytes counts
+ the number of them in bytes; the state stores
+ the last state of encoding.
+ .PP
+ The function returns a number greate than zero meaning a number of
+ wrong codepoints recovered by the funcition.
+ The wrong codepoint
+ will be recovered with the first codepoint of the charset at which
+ the wrong codepoint occurs.
+ After replaced, the function will continue to do conversion untill
+ one of the results Success, BadTerminate, BadBuffer or BadEncoding
+ is met.
+ .PP
+ The funcition returns BadEncoding meaning for unrecoverable wrong code 
+ which is wrong escape sequence, or not registered by
+ system yet.
+ .PP
+ Both the null character and ct_bytes will terminate the conversion.
+ .PP
+ All error status are defined to be less than zero, i.e.:
+ .IP "" 2
+ #define Success          0
+ .IP
+ #define BadBuffer       -1
+ .IP
+ #define BadTerminate    -2
+ .IP
+ #define BadEncoding     -3
+ .SH RETURNED VALUE
+ The
+ .B _XConvertCTToMB will return the following values:
+ .TP
+ .B Success
+ successful conversion.
+ .TP
+ .B BadBuffer
+ output buffer(mb_str) was exhausted.
+ .TP
+ .B BadTerminate
+ CT string was terminated uncompletely.
+ .TP
+ .B BadEncoding
+ wrong codepoints can not be recovered.
+ .TP
+ .B "> 0"
+ number of wrong codepoints, but recovered.
+ .SH SEE ALSO
+ Refer to "CT and WC" for their definitions.

*** /dev/null	Tue Oct  8 15:18:15 1991
--- mit/doc/I18N/Xsi/Xlc/CTToWC.man	Tue Oct  8 15:24:13 1991
***************
*** 0 ****
--- 1,159 ----
+ .\" $XConsortium: CTToWC.man,v 1.2 91/10/08 15:24:12 rws Exp $
+ .\" Copyright 1990 by OMRON Corp.  All Rights Reserved.
+ .TH _XConvertCTToWC 3X11 "Release 5" "X Version 11" "XSI FUNCTIONS"
+ .SH NAME
+ _XConvertCTToWC \- conversion from  CT string to  WC string
+ .SH SYNOPSIS
+ .B int _XConvertCTToWC\f2(xlocale, ct_str, ct_bytes, wc_str, wc_len,
+ .br
+ .B                                    \f2scanned_bytes, state)
+ .br
+ .B XLocale \f2xlocale\f3;
+ .br
+ .B char \f2*ct_str\f3;
+ .br
+ .B int \f2ct_bytes\f3;
+ .br
+ .B wchar \f2*wc_str\f3;
+ .br
+ .B int \f2*wc_len\f3;
+ .br
+ .B int \f2*scanned_bytes\f3;
+ .br
+ .B _State \f2*state\f3;
+ .br
+ .SH ARGUMENTS
+ .IP \fIxlocale\fP 1i
+ In: specifies locale, the default NULL is the current locale.
+ .IP \fIct_str\fP 1i 
+ In: CT string.
+ .br
+ .IP \fIct_bytes\fP 1i 
+ In: length of CT strings, counted in bytes.
+ .br
+ .IP \fIwc_str\fP 1i
+ Out: conversion buffer of result wchar string.
+ .br
+ .IP \fIwc_len\fP 1i 
+ In/Out: as "In" it is length of buffer wc_str passed by caller; 
+ as "Out" it is the returned number of converted wchars. 
+ .br
+ .IP \fIscanned_bytes\fP 1i 
+ Number of CT bytes converted when the function returns.
+ .br
+ .IP \fIstate\fP 1i
+ In/Out: as "In" it is the state at the beginning of
+ the CT string;
+ as "Out" it is the current state stopped at last converted CT
+ encoding.  The state is defined internally by Xlib.
+ If this pointer is null, the function will assume
+ the state to be the default CT state. Of course,
+ nothing will be put in the null pointer. Do not modify or free this data
+ .br
+ .SH DESCRIPTION
+ The
+ .B _XConvertCTToWC
+ converts the string encoded in CT to string encoded in wchar.
+ After a successful conversion, the null character WNULL will be
+ appended to wc_str if there is room for it in the buffer.
+ The terminator WNULL
+ of wchar string is not counted in length of output buffer wc_len.
+ .PP
+ The returned state will point to a state of 
+ the encoding in the internal table, so do not modify or free this 
+ pointer.
+ .PP
+ When function returns at any time, scanned_bytes always remembers
+ where stopped, and state always remembers the current CT state
+ if it is not null pointer.
+ .PP
+ The caller of this funcion has to provide the output buffer wc_str,
+ and store the buffer length(in wchars) into wc_len as input. 
+ By using scanned_bytes and state, the caller can break a large
+ CT string into pieces, and convert one piece at a time.
+ .PP
+ In other hand caller can pass any broken CT
+ string to this function for doing conversion.
+ For example, caller can still be trying of conversion when 
+ the error BadBuffer is occurred(output buffer was exhausted).
+ Usually, the application passes the NULL to state for first 
+ conversion as the following:
+ .IP "" "   "
+ char *state = NULL;
+ .br
+ \f3_XConvertCTToWC(NULL, ct_str, ct_len, mb_str,
+             &mb_len, &scanned, &state)\f2
+ .PP
+ The conversion function returns the value of variable state
+ to use for the conversion of the next unconverted piece of the
+ same string.  And so on.
+ .PP
+ If the value of state is invalid or null-pointer, the function
+ will suppose the default state of CT as initial.
+ The default state of CT is defined in 3 cases of encoding:
+ .IP "" 2
+ 1\. no control sequence, GL and GR of Latin-1 is supposed.
+ .IP 
+ 2\. control sequence of Latin-1 GL only, GR of Latin-1 is supposed too.
+ .IP
+ 3\. control sequence of Latin-1 GR only, GL of Latin-1 is supposed too.
+ .PP
+ The function returns the BadBuffer meaning that
+ the output buffer wc_str was exhausted.
+ The function returns the BadTerminate meaning that
+ the CT string ct_str is terminated uncompletely, 
+ e.g., uncompleted ESC sequence or
+ uncompleted code point ended at tail of ct_str.
+ .PP
+ Only in both the case of BadBuffer and BadTerminate the
+ caller can
+ move pointer ct_str to (ct_str + *scanned_bytes), then continue
+ to do conversion.
+ And function ensure that the wc_str stores the already converted
+ wchar string; wc_len counts
+ the number of them in wchars(not bytes); the state stores
+ the last state of encoding.
+ .PP
+ The function returns a number greate than zero meaning a number of
+ wrong codepoints recovered by the funcition.
+ The wrong codepoint
+ will be recovered with the first codepoint of the charset at which
+ the wrong codepoint occurs.
+ After replaced, the function will continue to do conversion untill
+ one of the results Success, BadTerminate, BadBuffer or BadEncoding
+ is met.
+ .PP
+ The funcition returns BadEncoding meaning for unrecoverable wrong code 
+ which is actually wrong escape sequence, or not registered by
+ system yet.
+ .PP
+ Both the null character and ct_bytes will terminate the conversion.
+ .PP
+ All error status are defined to be less than zero, i.e.:
+ .IP "" 2
+ #define Success          0
+ .IP
+ #define BadBuffer       -1
+ .IP
+ #define BadTerminate    -2
+ .IP
+ #define BadEncoding     -3
+ .SH RETURNED VALUE
+ The
+ .B _XConvertCTToWC will return the following values:
+ .TP
+ .B Success
+ successful conversion.
+ .TP
+ .B BadBuffer
+ output buffer(wc_str) was exhausted.
+ .TP
+ .B BadTerminate
+ .TP
+ .B BadEncoding 
+ wrong codepoints can not be recovered.
+ .TP
+ .B "> 0"
+ number of wrong codepoints, but recovered.
+ .SH SEE ALSO
+ Refer to "CT and WC" for their definitions.

*** /dev/null	Tue Oct  8 15:18:15 1991
--- mit/doc/I18N/Xsi/Xlc/CTWC.man	Tue Oct  8 15:11:22 1991
***************
*** 0 ****
--- 1,89 ----
+ '\" t
+ .\" $XConsortium: CTWC.man,v 1.1 91/10/08 15:11:21 rws Exp $
+ .\" Copyright 1990 by OMRON Corp.  All Rights Reserved.
+ .TH CTandWC 3X11 "Release 5" "X Version 11" "XSI FUNCTIONS"
+ .SH NAME
+ CT and WC \- compound text and wide character encoding
+ .SH DESCRIPTION
+ .PP
+ In this implementation the communication codeset is Compound Text
+ encoding, abbreviated to
+ .B CT,
+ the internal processing codeset is wide
+ character encoding, abbreviated to
+ .B WC.
+ The CT and WC occuring wherever
+ in this implementation is defined as following:
+ .IP [1]
+ The CT encoding conforms with X standard document "Compound Text
+ Encoding, Version 1.1" except:
+ .sp
+   Section 7.  Directionality
+   Section 10. Extensions
+ .IP
+ The CT string is terminated with null character.
+ .IP [2]
+ The WC is restricted to the following part of ISO DIS 10646(UCS):
+ .sp
+ .TS
+ l1 l.
+ *	canonical form, 4 octets(4-byte: group/plane/row/cell).
+ *	in the next sentences all number is decimal, and default group
+ 	is 032, plane is 032.
+ *	row 032 for ISO 8859-1(L.2,p18) 
+ *	right-hand half of row 033 for right half of ISO8859-2(L4,p18) 
+ *	right-hand half of row 040 for right half of ISO8859-5(S25.2,p19)
+ *	right-hand half of row 042 for right half of ISO8859-7(S26.2,p19)
+ *	right-hand half of row 044 for right half of ISO8859-6(S27.1,p19)
+ *	left-hand half of row 059 for JIS X 0201(Private Use zone)
+ *	I-11, plane 048 of group 032 for Chinese GB 2312(S9,p9)
+ *	I-11, plane 064 of group 032 for Japanese JIS X 0208(S10,p9)
+ *	I-10, plane 064 of group 032 for Japanese JIS X 0212(S10,p9)
+ *	plane 080 of group 032 for Korean KS C5601(S10,p9)
+ .TE
+ .IP
+ where the numbers in paranthesis are line#(L), section#(S) and page#(p)
+ in document of ISO DIS 10646(UCS), 4 November 1990.
+ .IP
+ The other registered charset in CT are put on the following place of 
+ DIS 10646.
+ .sp
+ .TS
+ l1 l.
+ *	right-hand half of row 034 for right half of ISO8859-3
+ *	right-hand half of row 035 for right half of ISO8859-4
+ *	right-hand half of row 036 for right half of ISO8859-9
+ .TE
+ .IP
+ The following Private Use planes and zones are used for User
+ Defined Character(UDC):
+ .sp
+ .TS
+ l1 l.
+ *	planes 224 of group 032 to 255(32 planes)
+ *	left-hand half of row 052 of plane 032 of group 032 to 059(8 rows)
+ .TE
+ .IP
+ The WC string is terminated with WNULL character.  The WNULL is 
+ implementation-defined. 
+ .IP [3]
+ Conversion between WC and CT.
+ .IP
+ The conversion between WC and CT will be done accoding to the above
+ correspondency.  In CT a charset can be designated both to graphic
+ left(GL) and to graphic right(GR); in WC there is no such GL and GR.
+ So the conversion function translates GL and GR of CT to same place
+ of WC.  In the reverse, the conversion function always translates
+ the WC to the GL of CT as following:
+ .sp
+ .TS
+ l1 l.
+ *	plane 048 of Chinese to "ESC$(A", not "ESC$)A"
+ *	plane 064 of Japanese to "ESC$(B", not "ESC$)B"
+ *	plane 080 of Korean to "ESC$(C", not "ESC$)C"
+ *	others one to one, no ambigious.
+ .TE
+ .SH SEE ALSO
+ ISO DIS 10646(UCS), 4 November 1990.
+ .br
+ Compound Text Encoding, Version 1.1, X11R5.

*** /dev/null	Tue Oct  8 15:18:15 1991
--- mit/doc/I18N/Xsi/Xlc/Locale.man	Tue Oct  8 15:24:16 1991
***************
*** 0 ****
--- 1,226 ----
+ .\" $XConsortium: Locale.man,v 1.2 91/10/08 15:24:15 rws Exp $
+ .\" Copyright 1990 by OMRON Corp.  All Rights Reserved.
+ .TH XLocale 3X11 "Release 5" "X Version 11" "XSI FUNCTIONS"
+ .SH NAME
+ XLocale \- all functions to access locale database
+ .SH SYNOPSIS
+ .B #include \f2"Xlocaleint.h"
+ .PP
+ .B int
+ .br
+ .B _Xmbtype\f2(xlocale)
+ .br
+ .B XLocale \f2xlocale\f3;
+ .PP
+ The _Xmbtype() returns the codeset type of the locale. Two
+ types will be returned:
+ .IP "" "    "
+ CDS_STATELESS -- state-independent codeset
+ .br
+ CDS_STATEFUL  -- state-dependent codeset
+ .PP
+ If application never calls the setting locale, the function returns -1,
+ no locale has been set.  With the _Xmbtype you can check if there is
+ locale.
+ .PP
+ .B int
+ .br
+ .B _Xmbcsnum\f2(xlocale)
+ .br
+ .B XLocale \f2xlocale\f3;
+ .PP
+ The _Xmbcsnum returns the number of charsets of the locale.
+ .PP
+ .B _CSID
+ .br
+ .B _Xmbcsid\f2(xlocale, mbstr)
+ .br
+ .B Xlocale \f2xlocale\f3;
+ .br
+ .B unsigned char *\f2mbstr\f3;
+ .PP
+ The function returns the charset id "CSi" of the multibyte character
+ encoded in the current locale.  The multibyte character is stored in
+ the null-terminated string "mbstr".  The charset id is ordered from
+ positive number 0.  The CSi is defined to a constant "i", e.g, CS1
+ is constant 1.
+ .PP
+ The _Xmbcsid returns constant ND for any error of the multibyte character
+ which maybe wrong code, or maybe terminated unexpectly.
+ .PP
+ For state-dependent codeset, _Xmbcsid keeps the track of the current
+ locking shift-state. In other word only this function _Xmbcsid would 
+ change the current state.   When the mbstr is passed as a NULL pointer,
+ the _Xmbcsid sets the initial state.
+ .IP "" "    "
+ _Xmbcsid(xlocale, NULL)
+ .PP
+ .B int
+ .br
+ .B _Xmblen\f2(xlocale)
+ .br 
+ .B XLocale \f2xlocale\f3;
+ .PP
+ The _Xmblen returns the number of bytes of the current charset in the xlocale.
+ The returned value is zero for wrong charset id.
+ .PP
+ .B char *
+ .br
+ .B _Xmbdsg\f2(xlocale)
+ .br
+ .B XLocale \f2xlocale\f3;
+ .PP
+ This function is for state-dependent codeset only.
+ The _Xmbdsg returns the designation of this charset. The NULL
+ returned is for wrong csid. The returned string is owned by
+ the locale, do not change or free it.
+ .PP
+ .B int 
+ .br
+ .B _Xmbdlen\f2(xlocale, mbstr)
+ .br
+ .B Xlocale \f2xlocale\f3;
+ .br
+ unsigned char *\f2mbstr\f3;
+ .PP
+ This function is for state-dependent codeset only.  If the mbstr
+ contains a complete designation sequence, the _Xmbdsg returns
+ the length of the sequence; otherwise returns zero.  The mbstr
+ is null-terminated string.
+ .PP
+ .B int
+ .br
+ .B _Xmbfsnum\f2(xlocale)
+ .br
+ .B XLocale \f2xlocale\f3;
+ .PP
+ The _Xmbfsnum returns the number of font charsets of the current locale.
+ This number is different from _Xmbcsnum().
+ .PP
+ .B char *
+ .br
+ .B _Xmbfsname\f2(xlocale)
+ .br
+ .B XLocale \f2xlocale\f3;
+ .PP
+ The _Xmbfsname returns the charset name with the current charset. 
+ The name is form of CharsetRegistry-CharsetEncoding registered by X
+ in the definition of XLFD.  The NULL returned is for the wrong charset.
+ The returned string is owned by the current locale, so do not
+ change and free this data.
+ .PP
+ .B int
+ .br
+ .B _Xmbfslen\f2(xlocale)
+ .br
+ .B XLocale \f2xlocale\f3;
+ .PP
+ The _Xmbfslen returns the number of bytes of the current charset of
+ font encoding. The zero returned is for wrong charset.
+ .PP
+ .B wchar 
+ .br
+ .B _Xmbfswf\f2(xlocale, csid)
+ .B XLocale \f2xlocale\f3;
+ .br
+ .B int  \f2csid\f3;
+ .PP
+ The _Xmbfswf returns the woffset of the font charset id.
+ This woffset is for the 4-byte wchar encoding. Refer to CTAndWC(3)
+ for WC definition.  The negative value -1 returned is for wrong csid.
+ .PP
+ .B char *
+ .br
+ .B _Xmbfsdsg\f2(xlocale)
+ .br
+ .B XLocale \f2xlocale\f3;
+ .PP
+ The _Xmbfsdsg returns the designation sequence, i.e., escape sequence
+ of font charset which is registered by X in the "Compound Text Encoding,
+ Version 1.1".  The returned value is owned by the locale, do not free
+ or change it.  The NULL returned is for wrong charset.
+ .PP
+ .B int
+ .br
+ .B _Xmbctocsc\f2(xlocale, mbstr, cscode)
+ .br
+ .B XLocale \f2xlocale\f3;
+ .br
+ .B unsigned char *\f2mbstr\f3;
+ .br
+ .B unsigned int  *\f2cscode\f3;
+ .PP
+ The _Xmbctocsc converts codepoint of multibyte character
+ to codepoing of charset. 
+ The csid is it's charset id.  The converted code
+ is stored in the cscode.
+ If wrong codepoint, use the first codepoint of csid as default,
+ and return negative value. if correct, return 0 meaning Success.
+ The _Xmbctocsc always supposes that the mbstr points to a codepoint,
+ not shift-state sequence if codeset is state-dependent. The caller
+ should note this, otherwise the _Xmbctocsc treats it as wrong codepoint.
+ .PP
+ .B int
+ .br
+ .B _Xcsctombc\f2(xlocale, cscode, code)
+ .br
+ .B XLocale \f2xlocale\f3;
+ .br
+ .B unsigned int  \f2cscode\f3;
+ .br
+ .B unsigned int *\f2code\f3;
+ .PP
+ The _Xcsctombc does the reverse conversion of _Xmbctocsc.
+ .PP
+ .B char *
+ .br
+ .B _Xsetlocale\f2(locale_category, locale_name)
+ .br
+ .B int   \f2locale_category\f3;
+ .br
+ .B char *\f2locale_name\f3;
+ .PP
+ .PP
+ The _Xsetlocale sets the current locale for the specified category.
+ If the operation was successful, _Xsetlocale returns a
+ pointer to the current locale name for the category
+ If the category is invalid or the locale is not
+ supported in the system, _Xsetlocale returns a NULL
+ pointer.
+ The returned locale name is owned by the system locale, do not change
+ or free it.
+ .PP
+ The category is defined to one of the following:
+ .IP "" "        "
+ LC_CTYPE
+ .br
+ LC_ALL
+ .PP
+ The locale name is allowed to the form:
+ .IP "" "        "
+ NULL
+ .br
+ ""
+ .br
+ string
+ .PP
+ The value NULL means to query the current locale name, and _Xsetlocale
+ returns the locale name string.
+ .PP
+ The empty string sets the implementation-depedent locale. It
+ examines the enviroment $LANG.  If ${LANG} is set and con-
+ tains the name of a valid locale, that value is used to set
+ category. If the value is still not  obtained, _Xsetlocale 
+ sets the category to C-language "C" and return the locale
+ name. The C locale is ASCII codeset.
+ .PP
+ The locale name is accepted to the following form:
+ .IP "" "   "
+ language[_territory[.codeset]]
+ .PP
+ The language and territory are country codes defined in ISO 639 and
+ ISO 3166.
+ .SH SEE ALSO
+ X/Open Portability Guide, Volume 3, XSI Internationalization.
+ .br
+ IS0 639, ISO 3166.

*** /dev/null	Tue Oct  8 15:18:15 1991
--- mit/doc/I18N/Xsi/Xlc/MBToCT.man	Tue Oct  8 15:24:19 1991
***************
*** 0 ****
--- 1,127 ----
+ .\" $XConsortium: MBToCT.man,v 1.2 91/10/08 15:24:17 rws Exp $
+ .\" Copyright 1990 by OMRON Corp.  All Rights Reserved.
+ .TH _XConvertMBToCT 3X11 "Release 5" "X Version 11" "XSI FUNCTIONS"
+ .SH NAME
+ _XConvertMBToCT \- conversion from mb string to CT
+ .SH SYNOPSIS
+ .B int _XConvertMBToCT\f2(xlocale, mb_str, mb_bytes, ct_str, ct_bytes,
+ .br
+ .B                                    \f2scanned_bytes, state)
+ .br
+ .B XLocale \f2xlocale\f3;
+ .br
+ .B char \f2*mb_str\f3;
+ .br
+ .B int \f2mb_bytes\f3;
+ .br
+ .B char \f2*ct_str\f3;
+ .br
+ .B int \f2*ct_bytes\f3;
+ .br
+ .B int \f2*scanned_bytes\f3;
+ .br
+ .B _State \f2*state\f3;
+ .SH ARGUMENTS
+ .IP \fIxlocale\fP 1i
+ In: specifies locale, the default NULL is the current locale.
+ .IP \fImb_str\fP 1i
+ In: multibyte string.
+ .br
+ .IP \fImb_bytes\fP 1i 
+ In: length of mb string, counted in bytes.
+ .br
+ .IP \fIct_str\fP 1i 
+ Out: conversion buffer of result CT string.
+ .br
+ .IP \fIct_bytes\fP 1i 
+ In/Out: as "In" it is length of buffer ct_str
+ passed by caller; as "Out" it is the returned
+ length of converted CT string, both counted in bytes.
+ .br
+ .IP \fIscanned_bytes\fP 1i 
+ Out: scanned number of bytes of mb_str,
+ .br
+ .IP \fIstate\fP 1i 
+ In/Out: as "In" it is the state at the beginning of mb string;
+ as "Out" it is the current state stopped at the last converted mb string.
+ .br
+ .SH DESCRIPTION
+ The
+ .B _XConvertMBToCT
+ converts the multibyte string encoded in the specfied \fIxlocale\fP
+ to CT string.
+ After a successful conversion the default state designation of CT (usually
+ it's Latin-1 GL) will
+ be appended at ct_str if the last state is not default state.
+ And function will automatically
+ append a null character to ct_str if more room in output buffer ct_str.
+ This null character is not counted in length of CT string.
+ .PP
+ When fucntion returns at any time, scanned_bytes always remembers
+ where stopped, and \fIstate\fP always remembers the curren state
+ of \fIxlocale\fP if it is state-dependent codeset.
+ .PP
+ The caller of this funcion has to provide the output buffer ct_str.
+ By using \fIscanned_bytes\fP and \fIstate\fP, the caller can break a large
+ mb string into pieces, and convert one piece at a time.
+ The result of CT string is concatenatable. However concatenation
+ may produce reduntant designation sequence.
+ .PP
+ If the codeset of the \fIxlocale\fP is state-dependent and
+ the mb_str is passed as NULL pointer, the function will set
+ initial state in the specfied \fIxlocale\fP.
+ Usually, the application should calls it with NULL mb_str for first
+ conversion as the following:
+ .IP "" "   "
+ \f3_XConvertMBToCT(NULL, mb_bytes, wc_str,
+             &mb_bytes, &scanned)\f2
+ .PP
+ The function returns BadBuffer meaning that
+ the output buffer ct_str was exhausted. In this case function
+ ensure that the ct_str
+ stores already converted CT string; ct_bytes stores 
+ number of bytes of ct_str; the scanned_bytes stores
+ the number of already proccessed mb string. 
+ Caller can move mb_str to (mb_str + *scanned_bytes) for next conversion.
+ .PP
+ The function returns a number greate than zero meaning a BadEncoding,
+ the unconvertable codes in mb string were met.
+ In this case the function will automatically recover the wrong code
+ with the following algorithm:
+ .IP "" 2
+ If a byte of mb codepoint is wrong, replace it with the mininum byte
+ of the character encoded in the current charset.
+ .PP
+ Then function continues to do conversion.
+ .PP
+ Both the null character and mb_bytes will terminate the conversion.
+ .PP
+ All errors are defined less than zero, i.e.:
+ .IP "" 2
+ #define Success         0
+ .IP 
+ #define BadBuffer      -1
+ .IP
+ #define BadTerminate   -2
+ .IP
+ #define BadEncoding    -3
+ .SH RETURNED VALUE
+ The
+ .B _XConvertMBToCT returns the following value:
+ .TP
+ .B Success
+ successful conversion.
+ .TP
+ .B BadBuffer
+ buffer was exhausted.
+ .TP
+ .B BadTerminate
+ mb_str terminated at uncomplete codepoint.
+ .TP
+ .B BadEncoding
+ wrong codepoints can not be recovered.
+ .TP
+ .B "> 0"
+ number of wrong codepoints, but recovered.
+ .SH "SEE ALSO"
+ Refer to "CT and WC" for their definitions.

*** /dev/null	Tue Oct  8 15:18:15 1991
--- mit/doc/I18N/Xsi/Xlc/MBToWC.man	Tue Oct  8 15:24:22 1991
***************
*** 0 ****
--- 1,134 ----
+ .\" $XConsortium: MBToWC.man,v 1.2 91/10/08 15:24:21 rws Exp $
+ .\" Copyright 1990 by OMRON Corp.  All Rights Reserved.
+ .TH _XConvertMBToWC 3X11 "Release 5" "X Version 11" "XSI FUNCTIONS"
+ .SH NAME
+ _XConvertMBToWC \- conversion from  CT string to mb string.
+ .SH SYNOPSIS
+ .B int _XConvertMBToWC\f2(xlocale, mb_str, mb_bytes, wc_str, wc_len,
+ .br
+ .B                                    \f2scanned_bytes, state)
+ .br
+ .B XLocale \f2xlocale\f3;
+ .br
+ .B unsigned char \f2*mb_str\f3;
+ .br
+ .B int \f2mb_bytes\f3;
+ .br
+ .B wchar \f2*wc_str\f3;
+ .br
+ .B int \f2*wc_len\f3;
+ .br
+ .B int \f2*scanned_bytes\f3;
+ .br
+ .B _State \f2*state\f3;
+ .br
+ .SH ARGUMENTS
+ .IP \fIxlocale\fP 1i
+ In: specifies locale, the default NULL is the current locale.
+ .IP \fImb_str\fP 1i 
+ In: multibyte string.
+ .br
+ .IP \fImb_bytes\fP 1i 
+ In: length of mb strings, counted in bytes.
+ .br
+ .IP \fIwc_str\fP 1i
+ Out: conversion buffer of result wchar string.
+ .br
+ .IP \fIwc_len\fP 1i 
+ In/Out: as "In" it is length of buffer wc_str passed by caller; 
+ as "Out" it is the returned number of converted wchars. 
+ .br
+ .IP \fIscanned_bytes\fP 1i 
+ Number of mb bytes converted when the function returns.
+ .br
+ .IP \fIstate\fP 1i
+ In/Out: as "In" it is the state at the beginning of mb string;
+ as "Out" it is the current state stopped at the last converted mb string.
+ .br
+ .SH DESCRIPTION
+ The
+ .B _XConvertMBToWC
+ converts the multibyte string encoded in the specfied \fIxlocale\fP
+ to wchar string.
+ After a successful conversion, the null character WNULL will be
+ appended to wc_str if there is room for it in the buffer.
+ The terminator WNULL
+ of wchar string is not counted in length of output buffer wc_len.
+ .PP
+ When function returns at any time, scanned_bytes always remembers
+ where stopped, and \fIstate\fP always remembers the curren state
+ of \fIxlocale\fP if it is state-dependent codeset.
+ .PP
+ The caller of this funcion has to provide the output buffer wc_str,
+ and store the buffer length(in wchars) into wc_len as input. 
+ By using \fIscanned_bytes\fP and \fIstate\fP, the caller can break a large
+ mb string into pieces, and convert one piece at a time.
+ .PP
+ In other hand caller can pass any broken mb 
+ string to this function for doing conversion.
+ For example, caller can still be trying of conversion when 
+ the error BadBuffer is occurred(output buffer was exhausted).
+ If the codeset of the \fIxlocale\fP is state-dependent and
+ the mb_str is passed as NULL pointer, the function will set
+ initial state in the \fIxlocale\fP.
+ Usually, the application should calls it with NULL mb_str for first 
+ conversion as the following:
+ .IP "" "   "
+ \f3_XConvertMBToWC(NULL, mb_bytes, wc_str,
+             &mb_len, &scanned)\f2
+ .PP
+ The function returns the BadBuffer meaning that
+ the output buffer wc_str was exhausted.
+ The function returns the BadTerminate meaning that
+ the mb string is terminated uncompletely, 
+ e.g., uncompleted ESC sequence or
+ uncompleted code point ended at tail of mb_str.
+ .PP
+ Only in both the case of BadBuffer and BadTerminate the
+ caller can
+ move pointer mb_str to (mb_str + *scanned_bytes), then continue
+ to do conversion.
+ And function ensure that the wc_str stores the already converted
+ wchar string; wc_len counts
+ the number of them in wchars(not bytes); 
+ .PP
+ The function returns a number greate than zero meaning a number of
+ wrong codepoints recovered by the funcition.
+ The wrong codepoint
+ will be recovered with the first codepoint of the charset at which
+ the wrong codepoint occurs.
+ After replaced, the function will continue to do conversion untill
+ one of the results Success, BadTerminate, BadBuffer or BadEncoding
+ is met.
+ .PP
+ Both the null character and mb_bytes will terminate the conversion.
+ .PP
+ All error status are defined to be less than zero, i.e.:
+ .IP "" 2
+ #define Success          0
+ .IP
+ #define BadBuffer       -1
+ .IP
+ #define BadTerminate    -2
+ .IP
+ #define BadEncoding     -3
+ .SH RETURNED VALUE
+ The
+ .B _XConvertMBToWC will return the following values:
+ .TP
+ .B Success
+ successful conversion.
+ .TP
+ .B BadBuffer
+ output buffer(wc_str) was exhausted.
+ .TP
+ .B BadTerminate
+ mb_str terminated at uncomplete codepoint.
+ .TP
+ .B BadEncoding 
+ wrong codepoints can not be recovered.
+ .TP
+ .B "> 0"
+ number of wrong codepoints, but recovered.
+ .SH SEE ALSO
+ Refer to "CT and WC" for their definitions.

*** /dev/null	Tue Oct  8 15:18:15 1991
--- mit/doc/I18N/Xsi/Xlc/ParseCT.man	Tue Oct  8 15:11:30 1991
***************
*** 0 ****
--- 1,75 ----
+ .\" $XConsortium: ParseCT.man,v 1.1 91/10/08 15:11:29 rws Exp $
+ .\" Copyright 1990 by OMRON Corp.  All Rights Reserved.
+ .TH _XParseISOEncoding 3X11 "Release 5" "X Version 11" "XSI FUNCTIONS"
+ .SH NAME
+ _XParseISOEncoding \- parse compound text encoding(ISO 2022)
+ .SH SYNOPSIS
+ .B Status _XParseISOEncoding\f2(ct_str, ct_bytes, scanned_bytes, isoinfo)
+ .br
+ .B char \f2*ct_str\f3;
+ .br
+ .B int \f2ct_bytes\f3;
+ .br
+ .B int \f2*scanned_bytes\f3;
+ .br
+ .B ISOStateInfo \f2*isoinfo\f3;
+ .br
+ .SH ARGUMENTS
+ .IP \fIct_str\fP 1i 
+ In: CT string.
+ .br
+ .IP \fIct_bytes\fP 1i 
+ In: length of CT strings, counted in bytes.
+ .br
+ .IP \fIscanned_bytes\fP 1i 
+ Out: Number of CT bytes has scanned.
+ .br
+ .IP \fIisoinfo\fP 1i
+ Out: the information about CT encoding.
+ .br
+ .SH DESCRIPTION
+ The
+ .B _XParseISOEncoding 
+ parses escape control sequence of compound text(ISO 2022), then
+ return the following information about it to isoinfo:
+ .IP "" 2
+ a. number of code bytes.
+ .IP
+ b. mininum & maximun of encoding. (0x21, 0x7E) for 94-GL; (0xA0, 0xFF)
+ for 96-GR; (0xA1, 0xFE) for 94-GR.
+ .PP
+ The data type of isoinfo is defined:
+  typedef struct {
+      int              code_bytes;
+      unsigned char    code_min, code_max;
+  } ISOStateInfo;
+ .PP
+ All error status are defined to be less than zero, i.e.:
+ .IP "" 2
+ #define Success          0
+ .IP
+ #define BadBuffer       -1
+ .IP
+ #define BadTerminate    -2
+ .IP
+ #define BadEncoding     -3
+ .PP
+ The ct_str points to the escape sequence of string, the ct_bytes
+ is the length of ct_str in bytes.  The function will also return
+ the scanned number of bytes of ct_str to the variable scanned_bytes.
+ .PP
+ The CT encoding non-registered by X is treated as BadEncoding.
+ .SH RETURNED VALUE
+ The
+ .B _XParseISOEncoding will return the following values:
+ .TP
+ .B Success
+ successful parsing.
+ .TP
+ .B BadTerminate
+ CT string was terminated uncompletely.
+ .TP
+ .B BadEncoding
+ wrong escape sequence of the CT encoding.
+ .SH SEE ALSO
+ Refer to "CT and WC" for CT definition.

*** /dev/null	Tue Oct  8 15:18:15 1991
--- mit/doc/I18N/Xsi/Xlc/WCToCT.man	Tue Oct  8 15:24:24 1991
***************
*** 0 ****
--- 1,105 ----
+ .\" $XConsortium: WCToCT.man,v 1.2 91/10/08 15:24:23 rws Exp $
+ .\" Copyright 1990 by OMRON Corp.  All Rights Reserved.
+ .TH _XConvertWCToCT 3X11 "Release 5" "X Version 11" "XSI FUNCTIONS"
+ .SH NAME
+ _XConvertWCToCT \- conversion from  WC string to CT
+ .SH SYNOPSIS
+ .B int _XConvertWCToCT\f2(xlocale, wc_str, wc_len, ct_str, ct_bytes, scanned_len)
+ .br
+ .B XLocale \f2xlocale\f3;
+ .br
+ .B wchar \f2*wc_str\f3;
+ .br
+ .B int \f2wc_len\f3;
+ .br
+ .B char \f2*ct_str\f3;
+ .br
+ .B int \f2*ct_bytes\f3;
+ .br
+ .B int \f2*scanned_len\f3;
+ .SH ARGUMENTS
+ .IP \fIxlocale\fP 1i
+ In: specifies locale, the default NULL is the current locale.
+ .IP \fIwc_str\fP 1i
+ In: wchar string.
+ .br
+ .IP \fIwc_len\fP 1i 
+ In: length of wchar string, counted in wchars.
+ .br
+ .IP \fIct_str\fP 1i 
+ Out: conversion buffer of result CT string.
+ .br
+ .IP \fIct_bytes\fP 1i 
+ In/Out: as "In" it is length of buffer ct_str
+ passed by caller; as "Out" it is the returned
+ length of converted CT string, both counted in bytes
+ .br
+ .IP \fIscanned_len\fP 1i 
+ Out: scanned number of wchars,
+ counted in wchars
+ .br
+ .SH DESCRIPTION
+ The
+ .B _XConvertWCToCT
+ converts the string encoded in wchar to string encoded in CT.
+ After a successful conversion the default state designation of CT will
+ be appended at ct_str if the last state is not same as default state.
+ And function will automatically
+ append a null character to ct_str if more room in output buffer ct_str.
+ This null character is not counted in length of CT string.
+ .PP
+ When fucntion returns at any time, scanned_len always remembers
+ where stopped.
+ .PP
+ The caller of this funcion has to provide the output buffer ct_str.
+ By using scanned_len, the caller can break a large
+ wchar string into pieces, and convert one piece at a time.
+ The result of CT string is concatenatable. However concatenation
+ may produce reduntant designation sequence.
+ .PP
+ The function returns BadBuffer meaning that
+ the output buffer ct_str was exhausted. In this case function
+ ensure that the ct_str
+ stores already converted CT string; ct_bytes stores 
+ number of bytes of ct_str; the scanned_len stores
+ the number of already proccessed wchars. 
+ Caller can move wc_str to (wc_str + *scanned_len) for next conversion.
+ .PP
+ The function returns a number greate than zero meaning a BadEncoding,
+ the unconvertable codes in wchar string were met.
+ In this case the function will automatically recover the wrong code
+ with the following algorithm:
+ .IP "" 2
+ If a byte of wchar code is wrong, replace it with the mininum character 
+ of the current encoding.
+ .PP
+ Then function continues to do conversion.
+ .PP
+ Both the WNULL character and wc_len will terminate the conversion.
+ .PP
+ All errors are defined less than zero, i.e.:
+ .IP "" 2
+ #define Success         0
+ .IP 
+ #define BadBuffer      -1
+ .IP
+ #define BadTerminate   -2
+ .IP
+ #define BadEncoding    -3
+ .SH RETURNED VALUE
+ The
+ .B _XConvertWCToCT returns the following value:
+ .TP
+ .B Success
+ successful conversion.
+ .TP
+ .B BadBuffer
+ buffer was exhausted.
+ .TP
+ .B BadEncoding
+ wrong codepoints can not be recovered.
+ .TP
+ .B "> 0"
+ number of wrong codepoints, but recovered.
+ .SH "SEE ALSO"
+ Refer to "CT and WC" for their definitions.

*** /dev/null	Tue Oct  8 15:18:15 1991
--- mit/doc/I18N/Xsi/Xlc/WCToMB.man	Tue Oct  8 15:24:27 1991
***************
*** 0 ****
--- 1,105 ----
+ .\" $XConsortium: WCToMB.man,v 1.2 91/10/08 15:24:26 rws Exp $
+ .\" Copyright 1990 by OMRON Corp.  All Rights Reserved.
+ .TH _XConvertWCToMB 3X11 "Release 5" "X Version 11" "XSI FUNCTIONS"
+ .SH NAME
+ _XConvertWCToMB \- conversion from  WC string to mb string
+ .SH SYNOPSIS
+ .B int _XConvertWCToMB\f2(xlocale, wc_str, wc_len, mb_str, mb_bytes,
+ .br
+ .B                                    \f2scanned_len)
+ .br
+ .B XLocale \f2xlocale\f3;
+ .br
+ .B wchar \f2*wc_str\f3;
+ .br
+ .B int \f2wc_len\f3;
+ .br
+ .B unsigned char \f2*mb_str\f3;
+ .br
+ .B int \f2*mb_bytes\f3;
+ .br
+ .B int \f2*scanned_len\f3;
+ .SH ARGUMENTS
+ .IP \fIxlocale\fP 1i
+ In: specifies locale, the default NULL is the current locale.
+ .IP \fIwc_str\fP 1i
+ In: wchar string.
+ .br
+ .IP \fIwc_len\fP 1i 
+ In: length of wchar string, counted in wchars.
+ .br
+ .IP \fImb_str\fP 1i 
+ Out: conversion buffer of result mb string.
+ .br
+ .IP \fImb_bytes\fP 1i 
+ In/Out: as "In" it is length of buffer mb_str
+ passed by caller; as "Out" it is the returned
+ length of converted mb string, both counted in bytes
+ .br
+ .IP \fIscanned_len\fP 1i 
+ Out: scanned number of wchars,
+ counted in wchars
+ .br
+ .SH DESCRIPTION
+ The
+ .B _XConvertWCToMB
+ converts the wc string to multibyte string encoded in the current locale.
+ After successful conversion function will automatically
+ append a null to mb_str if more room in output buffer mb_str.
+ This null character is not counted in length of mb string.
+ .PP
+ When fucntion returns at any time, scanned_len always remembers
+ where stopped.
+ .PP
+ The caller of this funcion has to provide the output buffer mb_str.
+ By using scanned_len, the caller can break a large
+ wchar string into pieces, and convert one piece at a time.
+ The result of mb string is concatenatable. However concatenation
+ may produce reduntant designation sequence if the codeset is state-dependent.
+ .PP
+ The function returns BadBuffer meaning that
+ the output buffer mb_str was exhausted. In this case function
+ ensure that the mb_str
+ stores already converted mb string; mb_bytes stores 
+ number of bytes of mb_str; the scanned_len stores
+ the number of already proccessed wchars. 
+ Caller can move wc_str to (wc_str + *scanned_len) for next conversion.
+ .PP
+ The function returns a number greate than zero meaning a BadEncoding,
+ the unconvertable codes in wchar string were met.
+ In this case the function will automatically recover the wrong code
+ with the following algorithm:
+ .IP "" 2
+ If a byte of wchar code is wrong, replace it with the mininum character 
+ of the current encoding.
+ .PP
+ Then function continues to do conversion.
+ .PP
+ Both the WNULL character and wc_len will terminate the conversion.
+ .PP
+ All errors are defined less than zero, i.e.:
+ .IP "" 2
+ #define Success         0
+ .IP 
+ #define BadBuffer      -1
+ .IP
+ #define BadTerminate   -2
+ .IP
+ #define BadEncoding    -3
+ .SH RETURNED VALUE
+ The
+ .B _XConvertWCToMB returns the following value:
+ .TP
+ .B Success
+ successful conversion.
+ .TP
+ .B BadBuffer
+ buffer was exhausted.
+ .TP
+ .B BadEncoding
+ wrong codepoints can not be recovered.
+ .TP
+ .B "> 0"
+ number of wrong codepoints, but recovered.
+ .SH "SEE ALSO"
+ Refer to "CT and WC" for their definitions.

*** /dev/null	Tue Oct  8 15:18:15 1991
--- mit/doc/I18N/Xsi/Xlc/nls.man	Tue Oct  8 15:24:29 1991
***************
*** 0 ****
--- 1,227 ----
+ '\" t
+ .\" $XConsortium: nls.man,v 1.2 91/10/08 15:24:28 rws Exp $
+ .\" Copyright 1990 by OMRON Corp.  All Rights Reserved.
+ .TH NLS 3X11 "Release 5" "X Version 11" "XSI FUNCTIONS"
+ .SH NAME
+ NLS \- Native Language Support
+ .SH DESCRIPTION
+ .PP
+ An X locale definition file consists of four category sources:
+ .sp
+ .RS
+ .TS
+ l.
+ XLC_ALL
+ XLC_ENCODING
+ XLC_CODESET
+ XLC_FONTSET
+ .TE
+ .RE
+ .LP
+ which specify the name, encoding and font charsets of this locale respectively.
+ .PP
+ Each category source definition starts with a category identifier line
+ and ends with a category trailer line.  A category identifier consists of
+ the character string XLC_, immediately followed by the name of the category. 
+ The category trailer consists of the string END, followed by the category 
+ identifier string. Within each category the definition consists of keywords 
+ and operands. A line may be continued by placing a backslash as the last
+ character on the line.  Keywords and operands shall be seperated by one or 
+ more blanks.  Any blanks preceding a keyword or preceding the first nonblank
+ character on a continuation line shall be ignored.  Lines containing a #
+ character in the first column shall be treated as comments.
+ .PP
+ The following definition is a rough Backus-Naur form(BNF), just a
+ description. 
+ .sp
+ .RS
+ .TS
+ l.
+ *** start of file ***
+ XLC_ALL
+ <name>
+ END XLC_ALL
+ 
+ XLC_ENCODING
+ <encoding_name>
+ END XLC_ENCODING
+ 
+ XLC_CODESET
+ <type>:<mblen_list>
+ <map_table>
+ <conversion_list>
+ END XLC_CODESET
+ 
+ XLC_FONTSET
+ <font_charset_list>
+ END XLC_FONTSET
+ *** end of file ****
+ .sp
+ .TE
+ .RE
+ .TS
+ l l1 l.
+ <name>	::=	lang_terr.codeset
+ 
+ <encoding_name>	::=	<string>
+ 
+ <type>	::=	L|l|F|f
+ 
+ <mblen_list>	::=	<number> |
+ 		<number> <colon> <mblen_list>
+ 
+ <map_talbe>	::=	<stateless_map> | <stateful_map>
+ <stateless_map>	::=	<LB> <one_map> <RB>|
+ 		<LB> <one_map> <RB>
+ 		<map_table>
+ <one_map>	::=	<csid> |
+ 		<csid> <separator> <one_map>
+ <stateful_map>	::=	<esc_sequence> |
+ 		<esc_sequence>
+ 		<stateful_map>
+ 
+ <conversion_list>	::=	<LP> <rang_list> <RP> |
+ 		<LP> <range_list> <RP>
+ 		<conversion_list> 
+ <range_list>	::=	<range> |
+ 		<range> <separator> <range_list>
+ <range>	::=	<number> <equal> <number> <colon> <number>
+ <font_charset_list>	::=	<font_charset> |
+ 		<font_charset>
+ 		<font_charset_list>
+ <font_charset>	::=	<font_encoding> <colon> <gflag>
+ 		[<colon> <woffset> <colon> <esc_sequence>]
+ <esc_sequence>	::=	<escape> <string>
+ 
+ <csid>	::=	CS0 | CS1 | CS2 | CS3 |
+ 		CS4 | CS5 | CS6 | CS7 |
+ 		CS8 | CS9 | CSA | CSB |
+ 		CSC | CSD | CSE | CSF |
+ 		C0 | C1 | ND | 
+ 		<minus> <number>
+ <number>	::=	positive integer
+ <LB>	::=	left bracket symbol "{"
+ <RB>	::=	right bracket symbol "}"
+ <LP>	::=	left paranthesis symbol "(" 
+ <RP>	::=	right paranthesis symbol ")" 
+ <colon>	::=	colon symbol ":"
+ <minus>	::=	minus symbol "-"
+ <gflag>	::=	GL | GR
+ <separator>	::=	space | tab | newline | comma symbol ","
+ <woffset>	::=	4-byte hexdecimal number
+ <escape>	::=	\\\\033
+ .\" first double \\ given to tbl, second double \\ given to roff,
+ .\" so that the result of print is \033.
+ <string>	::=	string without quotation.
+ <font_encoding>	::=	CharsetRegistry-CharsetEncoding of XLFD name
+ .TE
+ .PP
+ The name is the whole format lang_terr.codeset except the basic locale
+ name C which is used for the default locale.  The lang is 2-lowcase-letter
+ code for the name of language defined in ISO 639, the terr is 2-upcase-letter
+ code for the name of country defined in ISO 3166, the codeset is a name of
+ coded character set, such ujis, mscode, etc.
+ .PP
+ The encoding_name defines the name of this encoding which is commonly 
+ used between the inter-client communications, such encoding names are
+ STRING, COMPOUND_TEXT, JAPANESE_EUC16 and so on.
+ .PP
+ The type specifies the type of codeset.  There are 2 types: L for
+ state-independent codeset(stateless type) and F for state-dependent codeset
+ (stateful type).  
+ .PP
+ The mblen_list specifies the length of codepoints of each charset in
+ the bytes.  It should be noted that the length of designation sequence is not
+ included in the mblen while the type of codeset is state-dependent. 
+ .PP
+ The map_table describes the mapping from codepoint to charset, i.e., 
+ classifying codepoints to each charset.  Corresponding to 2 types of codesets,
+ there are 2 forms of map_table exclusively:
+ .IP "state-independent codset"
+ The map_table is 256 elements for the composition of 1 byte.  The
+ charsets are numbered to CS0, CS1, CS2, CS3 and so on;  The control
+ code set is numbered to C0 and C1; the ND stands for not-defined charset
+ in this codeset.  Any codepoint will be mapped to a charset with
+ this table from the first byte usually.
+ .IP "state-dependent codeset"
+ The map_table consists of series of designation sequences for each
+ charset.
+ .PP
+ The conversition_list specifies the conversin of codepoints between
+ codeset and font charset.  A conversion_list consists of several range_list's
+ for each charset.  A range_list consists of the following list:
+ .sp
+ .RS
+ .TS
+ l1 l1 l.
+ L-starting1 = R-starting1:R-ending1
+ L-starting2 = R-starting2:R-ending2
+ 	...
+ L-startingN = R-startingN:R-endingN
+ .TE
+ .RE	
+ .PP
+ The left is a starting codepoint of codeset, the right is a starting
+ and ending codepoint of charset.  Every expresstion specifies the conversion 
+ range of codepoints from
+ .sp
+ .RS
+ [L-startingN, L-endingN]
+ .RE
+ to
+ .RS
+ [R-startingN, R-endingN] 
+ .RE
+ .PP
+ where the L-endingN is equal to (L-startingN + R-endingN - R-startingN) 
+ since each range is contiguous codepoints.  
+ .PP
+ The font_charset_list consists of a series of font encoding of a charset.
+ Each font encoding is specified either by the form:
+ .sp
+   CharsetRegistry-CharsetEncoding:<gflag>
+ .sp
+ for the standard font charset registered in X or by the form:
+ .sp
+ .(l
+   CharsetRegistry-CharsetEncoding:<gflag>:woffset:
+   esc_sequence
+ .)l
+ .PP
+ for the self-defined font charset whose woffset is an offset in the 
+ encoding ISO DIS 10646, the esc_sequence should comform with Compound
+ Text Encoding of X standard.   The <gflag> will be set to GL for the font
+ charset siting on the graphic left encoding, or GR for the font charset
+ siting on the graphic right encoding.
+ .br
+ .PP
+ The resource of all locales are stored on NLS database. A native profile
+ contains source definitions for locale categories. The file name of the native
+ profile is the locale name, e.g., ja_JP.ujis, ja_JP.mscode, ...(see the native
+ profiles under the default directory /usr/lib/X11/nls/).
+ .PP
+ At initialization time, system will load all the locale names from a
+ table file "nls.dir" onto the NLS database.  The table file specifies
+ which native profiles will be loaded at run time as application requires.  The table file contains the
+ native profile names, i.e., the locale names. The table file is in the same
+ default directory /usr/lib/X11/nls/.
+ .PP
+ If the table file doesn't exist.  system will load all native profiles
+ under the /usr/lib/X11/nls/.  If the table file exists, but contains the emtpy,
+ so nothing will be loaded onto NLS database except the default locale C.
+ On this case, system will look for the C locale in the native profile named "C",
+ if not found, system will automatically create the default C locale on NLS
+ database.
+ .PP
+ The default directorey /usr/lib/X11/nls can be changed by the environment
+ variable $XNLSPATH.
+ .PP
+ On NLS database, the locale name is the index to the resource, the locale
+ value are corresponding to each category.
+ .SH SEE ALSO
+ .PP
+ X/Open Portability Guide, Volume 3, XSI Internationalization.
+ .br
+ Compound Text Encoding, Version 1.1, X11R5.
+ .br
+ ISO 639. ISO 3166

*** /tmp/,RCSt1a04136	Wed Oct  9 10:14:15 1991
--- mit/doc/I18N/Ximp/Ximp3_3.doc	Wed Oct  9 10:14:06 1991
***************
*** 48,54 ****
  
  
  
! 		Revision 3.4		 1 August, 1991
  
  
  
--- 48,54 ----
  
  
  
! 		Revision 3.5		 20 September, 1991
  
  
  
***************
*** 451,460 ****
  	Property Type	:  XA_STRING
  	Format		:  8
  	data		:  String described protocol version
! 	nelements	:  1
  
  	  +---------------------------------//----------+
! 	  | XIMP.3.4					|
  	  +---------------------------------//----------+
  
  3.3.2. _XIMP_STYLE
--- 451,460 ----
  	Property Type	:  XA_STRING
  	Format		:  8
  	data		:  String described protocol version
! 	nelements	:  String Length of data
  
  	  +---------------------------------//----------+
! 	  | XIMP.3.5					|
  	  +---------------------------------//----------+
  
  3.3.2. _XIMP_STYLE
***************
*** 461,467 ****
  
  	Property Name	:  _XIMP_STYLE
  	Property Type	:  _XIMP_STYLE
! 	Format		:  16
  	data		:  List of XIMStyle specified in XIM specification
  	nelements	:  The number of styles, IM server supported
  
--- 461,467 ----
  
  	Property Name	:  _XIMP_STYLE
  	Property Type	:  _XIMP_STYLE
! 	Format		:  32
  	data		:  List of XIMStyle specified in XIM specification
  	nelements	:  The number of styles, IM server supported
  
***************
*** 498,504 ****
  	Property Type	:  XA_STRING
  	Format		:  8
  	data		:  String described server name
! 	nelements	:  1
  
  	  +---------------------------------//----------+
  	  |						|
--- 498,504 ----
  	Property Type	:  XA_STRING
  	Format		:  8
  	data		:  String described server name
! 	nelements	:  String length of data
  
  	  +---------------------------------//----------+
  	  |						|
***************
*** 510,516 ****
  	Property Type	:  XA_STRING
  	Format		:  8
  	data		:  String described server version
! 	nelements	:  1
  
  	  +---------------------------------//----------+
  	  |						|
--- 510,516 ----
  	Property Type	:  XA_STRING
  	Format		:  8
  	data		:  String described server version
! 	nelements	:  String length of data
  
  	  +---------------------------------//----------+
  	  |						|
***************
*** 522,528 ****
  	Property Type	:  XA_STRING
  	Format		:  8
  	data		:  String described vendor name
! 	nelements	:  1
  
  	  +---------------------------------//----------+
  	  |						|
--- 522,528 ----
  	Property Type	:  XA_STRING
  	Format		:  8
  	data		:  String described vendor name
! 	nelements	:  String length of data
  
  	  +---------------------------------//----------+
  	  |						|
***************
*** 641,650 ****
  	Property Type	:  XA_STRING
  	Format		:  8
  	data		:  String specifies Protocol Version
! 	nelements	:  1
  
  	  +---------------------------------//----------+
! 	  | XIMP.3.4					|
  	  +---------------------------------//----------+
  
      - _XIMP_FOCUS Property
--- 641,650 ----
  	Property Type	:  XA_STRING
  	Format		:  8
  	data		:  String specifies Protocol Version
! 	nelements	:  String length of data
  
  	  +---------------------------------//----------+
! 	  | XIMP.3.5					|
  	  +---------------------------------//----------+
  
      - _XIMP_FOCUS Property
***************
*** 653,659 ****
  	Property Type	:  XA_WINDOW
  	Format		:  32
  	data		:  Focus Window ID
! 	nelements	:  1
  
  	  +-------------------------------------+
  	  | Window ID				|
--- 653,659 ----
  	Property Type	:  XA_WINDOW
  	Format		:  32
  	data		:  Focus Window ID
! 	nelements	:  String length of data
  
  	  +-------------------------------------+
  	  | Window ID				|
***************
*** 670,676 ****
  	Format		:  32
  	data		:  Values corresponding the XIM specification
  			   with the following format.
! 	nelements	:  1
  
  	  +-------------------------------------+
  	 0| Area.x				|
--- 670,676 ----
  	Format		:  32
  	data		:  Values corresponding the XIM specification
  			   with the following format.
! 	nelements	:  13
  
  	  +-------------------------------------+
  	 0| Area.x				|
***************
*** 1102,1108 ****
  network byte order.
  
      If a compound text is longer to be sent in one client message,
! compound text may be devide into pieces and sent by several client message.
  The following is the format in this case.
  
  	  +------+------+---------------------------------------------+
--- 1102,1108 ----
  network byte order.
  
      If a compound text is longer to be sent in one client message,
! compound text may be divide into pieces and sent by several client message.
  The following is the format in this case.
  
  	  +------+------+---------------------------------------------+
***************
*** 1233,1241 ****
  
  4.11. Querying Attributes of IM Server
  
!     The client can query the attributes of IM server with XIMP_GETVALUE.
! Also the client can query the default attributes which are not specified
! by the client.
  
      o Processing Contents
  
--- 1233,1241 ----
  
  4.11. Querying Attributes of IM Server
  
!     The client can query the IC informations from the IM server with
! XIMP_GETVALUE.  Also the client can query the default attributes which
! are not specified by the client.
  
      o Processing Contents
  
***************
*** 1419,1424 ****
--- 1419,1425 ----
     XIMP_PREEDITDONE         |  PreeditDontCallback      | 5.3.
     XIMP_PREEDITDRAW         |  PreeditDrawCallback      | 5.4.
     XIMP_PREEDITDRAW_CM      |  PreeditDrawCallback      | 5.4.
+    XIMP_PREEDITDRAW_TINY    |  PreeditDrawCallback      | 5.4.
     XIMP_PREEDITCARET        |  PreeditCaretCallback     | 5.5.
     XIMP_STATUSSTART         |  StatusStartCallback      | 5.6.
     XIMP_STATUSDONE          |  StatusDoneCallback       | 5.7.
***************
*** 1509,1515 ****
  	Format		:  32
  	data		:  Values corresponding the XIM specification
  			   with the following format.
! 	nelements	:  1
  
  	  +---------------------------------+
  	0 | caret                           |
--- 1510,1516 ----
  	Format		:  32
  	data		:  Values corresponding the XIM specification
  			   with the following format.
! 	nelements	:  3
  
  	  +---------------------------------+
  	0 | caret                           |
***************
*** 1526,1532 ****
  	Property Type	:  COMPOUND_TEXT
  	Format		:  8
  	data		:  Contents of pre-edit
! 	nelements	:  1
  
  	  +--------------------------------//-----------+
  	0 | string                                      |
--- 1527,1533 ----
  	Property Type	:  COMPOUND_TEXT
  	Format		:  8
  	data		:  Contents of pre-edit
! 	nelements	:  elements of data
  
  	  +--------------------------------//-----------+
  	0 | string                                      |
***************
*** 1540,1554 ****
  	Format		:  32
  	data		:  attributes of each characters
  				in the contents of pre-edit
! 	nelements	:  1
  
  	  +---------------------------------//----------+
  	0 | feedback                                    |
  	  +---------------------------------//----------+
  
! 2) Protocol format for using ClientMessages
  
!     This protocol was provided for use two ClientMessages
  The IM server does not intrude into this two ClientMessages.
  
      o Format for First ClientMessage
--- 1541,1555 ----
  	Format		:  32
  	data		:  attributes of each characters
  				in the contents of pre-edit
! 	nelements	:  elements of data
  
  	  +---------------------------------//----------+
  	0 | feedback                                    |
  	  +---------------------------------//----------+
  
! 2) Protocol format for using ClientMessages (part 1.)
  
!     This protocol was realized by two ClientMessages.
  The IM server does not intrude into this two ClientMessages.
  
      o Format for First ClientMessage
***************
*** 1559,1581 ****
           0| XIMP_PREEDITDRAW_CM                 |
            +-------------------------------------+
           4| ICID                                |
!           +-------------------------------------+
!          8| caret                               |
!           +-----------------+-------------------+
!         12| chg_first       | chg_length        |
!           +-----------------+-------------------+
          16| feedback                            |
            +-------------------------------------+
  
      Note 1.
! 	format == 32, and chg_first, chg_length was into 12-15 byte
! 	field, it's using 16 bit Network Order.
      Note 2.
! 	The feedback field has one XIMFeedback value for all of
! 	the characters which are contained in the following ClientMessage.
! 	This means the XIMFeedback value of all characters are same.
  	If the string has more than two XIMFeedback values,
! 	it must be devided. Therefore, one protocol includes
  	one XIMFeedback value.
  
      o Format for Second ClientMessage
--- 1560,1593 ----
           0| XIMP_PREEDITDRAW_CM                 |
            +-------------------------------------+
           4| ICID                                |
!           +-------------------+-----------------+
!          8|PreeditDrawCBStatus|       caret     |
!           +-------------------+-----------------+
!         12| chg_first         |  chg_length     |
!           +-------------------+-----------------+
          16| feedback                            |
            +-------------------------------------+
  
      Note 1.
! 	format == 32, and chg_first, chg_length are into 12-15 byte
! 	field, they are using 16 bits and they are Network Order.
      Note 2.
! 	The PreeditDrawCBStatus is a BIT array of follows.
! 	0x0001 no_text:	if set, string == NULL and no following client message,
! 			else string exists.
! 	0x0002 no_feedback:
! 			if set, feedback == NULL,
! 			else feedback exists.
! 	0x0004 feedbacks_via_property:
! 			if set, feedback field has atom# that indicates the
! 			property that has XIMFeedback values of string field,
! 			else feedback field has one XIMFeedback value
! 			for all of the characters in string field. 
!     Note 3.
! 	The feedbacks_via_property bit == 0  means the XIMFeedback value of
! 	all characters are same.
  	If the string has more than two XIMFeedback values,
! 	it must be divided. Therefore, one protocol includes
  	one XIMFeedback value.
  
      o Format for Second ClientMessage
***************
*** 1592,1597 ****
--- 1604,1643 ----
               
      format == 8, ICID is set in the 0-3 byte field using Network Order.
   
+ 3) Protocol format for using ClientMessages (part 2.)
+ 
+     This protocol is realized by only one ClientMessage. This is used when
+     a tiny change is made in a preedit draw data.
+ 
+           Data Field in the XClientMessage Structure
+ 
+           +-------------------------------------+
+          0| XIMP_PREEDITDRAW_TINY               |
+           +-------------------------------------+
+          4| ICID                                |
+           +---------------+------------+--------+
+          8| chg_first     | chg_length | length |
+           +---------------+------------+--------+
+         12| string (COMPOUND TEXT)              |
+           +-------------------+-----------------+
+         16| string (continued.)                 |
+           +-------------------------------------+
+ 
+     Note 1.
+ 	format == 32, and chg_first, chg_length, length are stored into 
+ 	8-11 byte field, and chg_first is represented by 16bits,
+ 	chg_length, length are represented by 8 bits, 
+ 	and they are Network Order.
+     Note 2.
+ 	New caret position is the end of changed area of preedit string.
+ 	And caret value is omitted because it can be calculated by
+ 	information in this protocol.
+     Note 3.
+ 	This protocol implies the feedback field == NULL.
+     Note 4.
+ 	String is stored into 12-15 and 16-19 byte field, and using 8 bits 
+ 	format, it is Network Order.
+ 
  5.5. Preedit Caret Callback
  
  	  Data Field in the XClientMessage Structure
***************
*** 1705,1711 ****
  	Property Type	:  COMPOUND_TEXT
  	Format		:  8
  	data		:  string to display in status area
! 	nelements	:  1
  
  	  +----------------------------//---------+
  	0 | string                                |
--- 1751,1757 ----
  	Property Type	:  COMPOUND_TEXT
  	Format		:  8
  	data		:  string to display in status area
! 	nelements	:  elements of data
  
  	  +----------------------------//---------+
  	0 | string                                |
***************
*** 1718,1724 ****
  	Property Type	:  _XIMP_FEEDBACKS
  	Format		:  32
  	data		:  attributes of each characters
! 	nelements	:  1
  
  	  +----------------------------//---------+
  	0 | feedback                              |
--- 1764,1770 ----
  	Property Type	:  _XIMP_FEEDBACKS
  	Format		:  32
  	data		:  attributes of each characters
! 	nelements	:  elements of data
  
  	  +----------------------------//---------+
  	0 | feedback                              |
***************
*** 1750,1756 ****
  	the characters which are contained in the following ClientMessage.
  	This means the XIMFeedback value of all characters are same.
  	If the string has more than two XIMFeedback values,
! 	it must be devided. Therefore, one protocol includes
  	one XIMFeedback value.
  
      o Format for second ClientMessage
--- 1796,1802 ----
  	the characters which are contained in the following ClientMessage.
  	This means the XIMFeedback value of all characters are same.
  	If the string has more than two XIMFeedback values,
! 	it must be divided. Therefore, one protocol includes
  	one XIMFeedback value.
  
      o Format for second ClientMessage


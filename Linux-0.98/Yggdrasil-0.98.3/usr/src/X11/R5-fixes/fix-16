		      Release 5 Public Patch #16
			   MIT X Consortium

To apply this patch:

cd to the top of the source tree (to the directory containing the "mit"
and "contrib" subdirectories) and do:
	patch -p -s < ThisFile
Patch will work silently unless an error occurs.
If you want to watch patch do its thing, leave out the "-s" argument to patch.

Finally, to rebuild after applying this patch, cd to the "mit" subdirectory
and do:
        make -k >& make.log

Brief notes on what this patch fixes:

Xlib: fix-14 was generated against the wrong version of one file, introducing
	a free of static memory
Xlib: (Xsi) XSetICValues does not permit changing XNResource{Name,Class}
Xlib: (Xsi) _XConvertMBToWC() returns unkindly error code
Xlib: (Xsi) XmbTextPerCharExtents returns wrong ink dimensions
Xlib: (Xsi) X{wc/mb}LookupString don't work at XBufferOverflow
Xlib: (Xsi) close some memory leaks
Xlib: (Ximp) memory destroyed when XGetIMValues is called
Xlib: (Ximp) error processing is incorrect

Prereq: public-patch-15

*** /tmp/,RCSt1022087	Sat Aug  1 12:44:11 1992
--- mit/bug-report	Sat Aug  1 12:42:11 1992
***************
*** 2,8 ****
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-15
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:
--- 2,8 ----
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-16
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:
*** /tmp/,RCSt1016014	Sat Aug  1 11:32:02 1992
--- mit/lib/X/XcmsInt.c	Sat Aug  1 11:32:06 1992
***************
*** 1,4 ****
! /* $XConsortium: XcmsInt.c,v 1.8 91/07/25 01:08:44 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: XcmsInt.c,v 1.9 92/01/02 19:27:32 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 268,275 ****
  		(*((XcmsFunctionSet *)ccc->pPerScrnInfo->functionSet)->screenFreeProc)
  			(ccc->pPerScrnInfo->screenData);
  	    }
  	}
- 	Xfree(ccc->pPerScrnInfo);
      }
  
      /*
--- 268,275 ----
  		(*((XcmsFunctionSet *)ccc->pPerScrnInfo->functionSet)->screenFreeProc)
  			(ccc->pPerScrnInfo->screenData);
  	    }
+ 	    Xfree(ccc->pPerScrnInfo);
  	}
      }
  
      /*
*** /tmp/,RCSt1016078	Sat Aug  1 11:32:50 1992
--- mit/lib/X/XcmsLRGB.c	Sat Aug  1 11:32:58 1992
***************
*** 1,4 ****
! /* $XConsortium: XcmsLRGB.c,v 1.20 91/08/20 13:51:23 keith Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: XcmsLRGB.c,v 1.22 92/01/02 19:28:13 rws Exp $" */
  
  /*
   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 637,643 ****
  	  default:
  	    XFree (property_return);
  	    goto FreeSCCData;
- 	    break;
  	}
  
  	/*
--- 637,642 ----
***************
*** 835,842 ****
   *	SYNOPSIS
   */
  static void
! LINEAR_RGB_FreeSCCData(pScreenData)
!     LINEAR_RGB_SCCData *pScreenData;
  /*
   *	DESCRIPTION
   *
--- 834,841 ----
   *	SYNOPSIS
   */
  static void
! LINEAR_RGB_FreeSCCData(pScreenDataTemp)
!     XPointer pScreenDataTemp;
  /*
   *	DESCRIPTION
   *
***************
*** 846,852 ****
   *
   */
  {
!     if (pScreenData) {
  	if (pScreenData->pRedTbl) {
  	    if (pScreenData->pGreenTbl) {
  		if (pScreenData->pRedTbl->pBase != 
--- 845,853 ----
   *
   */
  {
!     LINEAR_RGB_SCCData *pScreenData = (LINEAR_RGB_SCCData *) pScreenDataTemp;
! 
!     if (pScreenData && pScreenData != &Default_RGB_SCCData) {
  	if (pScreenData->pRedTbl) {
  	    if (pScreenData->pGreenTbl) {
  		if (pScreenData->pRedTbl->pBase != 
*** /tmp/d11541	Sat Aug  1 10:38:33 1992
--- mit/lib/X/Xsi/TextPerBd.c	Sat Aug  1 10:38:24 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: TextPerBd.c,v 1.15 91/10/08 14:19:10 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: TextPerBd.c,v 1.16 92/07/29 11:39:57 rws Exp $
   */
  
  /*
***************
*** 114,120 ****
                          byte2 > fnt->max_char_or_byte2)
                          ind = 0;
                      else
!                         ind  = (byte1 - fnt->min_byte1) * d + byte2;
                  }
                  if (fnt->per_char != NULL)
                      onechar = fnt->per_char + ind;
--- 114,121 ----
                          byte2 > fnt->max_char_or_byte2)
                          ind = 0;
                      else
!                         ind  = (byte1 - fnt->min_byte1) * d
! 			     + (byte2 - fnt->min_char_or_byte2);
                  }
                  if (fnt->per_char != NULL)
                      onechar = fnt->per_char + ind;
*** /tmp/d11650	Sat Aug  1 10:39:40 1992
--- mit/lib/X/Xsi/XCnvWCToMB.c	Sat Aug  1 10:39:35 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XCnvWCToMB.c,v 1.23 92/04/14 15:54:49 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XCnvWCToMB.c,v 1.24 92/07/29 11:44:21 rws Exp $
   */
  
  /*
***************
*** 48,54 ****
  /*
    _IsValidEscSequence()
    if str is valid escape sequence returns length of it in bytes.
!   else if str is not valid escape sequence returns -1.
  
    ISO 2022
      6.3.3 Categories of escape sequence
--- 48,55 ----
  /*
    _IsValidEscSequence()
    if str is valid escape sequence returns length of it in bytes.
!   else if str is not valid escape sequence returns BadEncoding.
!   else if str has not enough data returns BadTerminate.
  
    ISO 2022
      6.3.3 Categories of escape sequence
***************
*** 86,92 ****
      int i;
  
      if (len <= 0)
! 	return (-1);
  
      if (*str == ESC) {
  	if (len == 1)	/* Only ESC */
--- 87,93 ----
      int i;
  
      if (len <= 0)
! 	return (BadTerminate);
  
      if (*str == ESC) {
  	if (len == 1)	/* Only ESC */
***************
*** 98,117 ****
  	} else if (*str >= 0x30 && *str <= 0x7e) {
  	    return (2);
  	} else if (*str >= 0x20 && *str <= 0x2f) {
! 	    for (i++; len > 0; str++,i++, len--) {
  		if (*str >= 0x30 && *str <= 0x7e)
  		    return(i);
  		if (*str < 0x20 || *str >= 0x7f)
! 		    return (-1); /* Not valid Escape seqence */
  	    }
! 	    return (-1);
  	} else {
! 	    return (-1);
  	}
      } else if (*str == CSI) {
  	len--; i = 1; str++;
      } else {
! 	return (-1);	/* Not Escape sequence */
      }
  
      if (len == 0)
--- 99,118 ----
  	} else if (*str >= 0x30 && *str <= 0x7e) {
  	    return (2);
  	} else if (*str >= 0x20 && *str <= 0x2f) {
! 	    for (i++, len--, str++; len > 0; str++,i++, len--) {
  		if (*str >= 0x30 && *str <= 0x7e)
  		    return(i);
  		if (*str < 0x20 || *str >= 0x7f)
! 		    return (BadEncoding); /* Not valid Escape seqence */
  	    }
! 	    return (BadTerminate);
  	} else {
! 	    return (BadEncoding);
  	}
      } else if (*str == CSI) {
  	len--; i = 1; str++;
      } else {
! 	return (BadEncoding);	/* Not Escape sequence */
      }
  
      if (len == 0)
***************
*** 121,129 ****
  	if (*str >= 0x40 && *str <= 0x7e)
  	    return(i);
  	if (*str < 0x20 || *str >= 0x7f)
! 	    return (-1); /* Not valid Escape seqence */
      }
!     return (-1);
  }
  
  
--- 122,130 ----
  	if (*str >= 0x40 && *str <= 0x7e)
  	    return(i);
  	if (*str < 0x20 || *str >= 0x7f)
! 	    return (BadEncoding); /* Not valid Escape seqence */
      }
!     return (BadTerminate);
  }
  
  
***************
*** 199,205 ****
  		}
  		continue;
  	    }
! 	    Return(BadEncoding);
  	}
          /*
           * filter control characters.
--- 200,206 ----
  		}
  		continue;
  	    }
! 	    Return(len);
  	}
          /*
           * filter control characters.
*** /tmp/,RCSt1016201	Sat Aug  1 11:34:06 1992
--- mit/lib/X/Xsi/XConnIM.c	Sat Aug  1 11:34:10 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XConnIM.c,v 1.17 92/03/03 10:02:09 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XConnIM.c,v 1.18 92/07/29 13:55:35 rws Exp $
   */
  
  /*
***************
*** 104,109 ****
--- 104,110 ----
      im->major_version = (long)ntohl(i);
      bcopy((char *)(prop + offset_of_minor_version), (char *)&i, version_size);
      im->minor_version = (long)ntohl(i);
+     Xfree((char *)prop);
      if (im->major_version != XIM_MAJOR_VERSION) return(False);
      if (!(im->minor_version >= XIM_MINOR_VERSION)) return(False);
  
*** /tmp/d11780	Sat Aug  1 10:41:01 1992
--- mit/lib/X/Xsi/XCrIC.c	Sat Aug  1 10:40:55 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XCrIC.c,v 1.31 92/04/14 15:44:17 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XCrIC.c,v 1.34 92/07/29 13:54:58 rws Exp $
   */
  
  /*
***************
*** 41,47 ****
  # define Va_start(a,b) va_start(a)
  #endif
  
! #if __STDC__ && !defined(VMS)
  #define RConst const
  #else
  #define RConst /**/
--- 41,47 ----
  # define Va_start(a,b) va_start(a)
  #endif
  
! #if __STDC__ && !defined(NORCONST)
  #define RConst const
  #else
  #define RConst /**/
***************
*** 88,93 ****
--- 88,95 ----
      _XUnregisterFilter(im->core.display, ic->core.focus_window,
  		       ic->prototype_filter, (XPointer)ic);
  
+     if (ic->mb) _XlcFreeLocale(ic->mb);
+     if (ic->wc) _XlcFreeLocale(ic->wc);
  #ifdef	XML
      if (ic->xlc_num > 0) {
  	int i;
***************
*** 97,104 ****
--- 99,112 ----
  	    _XlcFreeLocale(ic->wc_temp[i]);
  	}
      }
+     if (ic->mb_temp) Xfree(ic->mb_temp);
+     if (ic->wc_temp) Xfree(ic->wc_temp);
      if (ic->values.using_language) Xfree(ic->values.using_language);
+     if (ic->values.current_language) Xfree(ic->values.current_language);
  #endif	/* XML */
+     if (ic->ct_buf) Xfree(ic->ct_buf);
+     if (ic->wc_buf) Xfree(ic->wc_buf);
+     (void) _XipFreeAllICQueue(ic);
  }
  
  static RConst XICMethodsRec ic_methods = {
***************
*** 139,146 ****
      }
  }
  
! static unsigned long
! _ReadRdb(display, ic, mask, rdb, res_name, res_class)
      Display *display;
      XipIC ic;
      unsigned long mask;
--- 147,154 ----
      }
  }
  
! unsigned long
! _XipReadRdb(display, ic, mask, rdb, res_name, res_class)
      Display *display;
      XipIC ic;
      unsigned long mask;
***************
*** 312,318 ****
      }
      im->default_ic->core.im = (XIM)im;
  
!     im->default_mask = _ReadRdb(im->core.display, im->default_ic,
  				(unsigned long)0,
  				im->core.rdb, im->core.res_name,
  				im->core.res_class);
--- 320,326 ----
      }
      im->default_ic->core.im = (XIM)im;
  
!     im->default_mask = _XipReadRdb(im->core.display, im->default_ic,
  				(unsigned long)0,
  				im->core.rdb, im->core.res_name,
  				im->core.res_class);
***************
*** 374,380 ****
      }
  
      if (im->core.rdb && ic->values.res_name && ic->values.res_class) {
! 	mask |= _ReadRdb(im->core.display, ic, mask, im->core.rdb,
  			 ic->values.res_name, ic->values.res_class);
      }
  	
--- 382,388 ----
      }
  
      if (im->core.rdb && ic->values.res_name && ic->values.res_class) {
! 	mask |= _XipReadRdb(im->core.display, ic, mask, im->core.rdb,
  			 ic->values.res_name, ic->values.res_class);
      }
  	
***************
*** 438,445 ****
      for (;;) {
  	if ((_XipReadFromIM(im, (char *)&reply1, sz_ximEventReply) < 0) ||
  	    (reply1.state == 0xffff)) {
! 	    Xfree((char *)ic);
! 	    return(NULL);
  	}
  	if (reply1.detail == XIM_CALLBACK) {
  	    /*
--- 446,452 ----
      for (;;) {
  	if ((_XipReadFromIM(im, (char *)&reply1, sz_ximEventReply) < 0) ||
  	    (reply1.state == 0xffff)) {
! 	    goto _err_ret;
  	}
  	if (reply1.detail == XIM_CALLBACK) {
  	    /*
***************
*** 446,462 ****
  	     * Call the callback routines.
  	     */
  	    if (_XipCallCallbacks(ic) < 0) {
! 		Xfree((char *)ic);
! 		return(NULL);
  	    }
  	} else if (reply1.detail == XIM_IC) {
  	    if (_XipReadFromIM(im, (char *)&reply, sz_ximCreateICReply) < 0) {
! 		Xfree((char *)ic);
! 		return(NULL);
  	    }
  	    if (reply.state != 0) {
! 		Xfree((char *)ic);
! 		return(NULL);
  	    }
  	    ic->icid = reply.xic;
  	    break;
--- 453,466 ----
  	     * Call the callback routines.
  	     */
  	    if (_XipCallCallbacks(ic) < 0) {
! 		goto _err_ret;
  	    }
  	} else if (reply1.detail == XIM_IC) {
  	    if (_XipReadFromIM(im, (char *)&reply, sz_ximCreateICReply) < 0) {
! 		goto _err_ret;
  	    }
  	    if (reply.state != 0) {
! 		goto _err_ret;
  	    }
  	    ic->icid = reply.xic;
  	    break;
***************
*** 487,492 ****
--- 491,513 ----
      }
  #endif	/* XML */
      return((XIC)ic);
+ 
+ _err_ret:
+     if (ic->mb) _XlcFreeLocale(ic->mb);
+     if (ic->wc) _XlcFreeLocale(ic->wc);
+ #ifdef  XML
+     if (ic->xlc_num > 0) {
+ 	for (i = 0; i < ic->xlc_num; i++) {
+ 	    _XlcFreeLocale(ic->mb_temp[i]);
+ 	    _XlcFreeLocale(ic->wc_temp[i]);
+ 	}
+     }
+     if (ic->mb_temp) Xfree(ic->mb_temp);
+     if (ic->wc_temp) Xfree(ic->wc_temp);
+     if (ic->values.using_language) Xfree(ic->values.using_language);
+ #endif  /* XML */
+     Xfree((char *)ic);
+     return(NULL);
  }
  
  /*
*** /tmp/d11909	Sat Aug  1 10:42:19 1992
--- mit/lib/X/Xsi/XICSetVal.c	Sat Aug  1 10:42:14 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XICSetVal.c,v 1.28 92/04/24 16:14:45 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XICSetVal.c,v 1.29 92/07/28 17:54:11 rws Exp $
   */
  
  /*
***************
*** 360,365 ****
--- 360,370 ----
      err = _XipICSetValues(ic, args, &mask);
      if (err)
  	return(err);
+     if (im->core.rdb &&
+ 	(mask & (1L << ICResourceClass | 1L << ICResourceName))) {
+ 	mask |= _XipReadRdb(im->core.display, ic, mask, im->core.rdb,
+ 			    ic->values.res_name, ic->values.res_class);
+     }
      
      if (mask & (1L << ICFocusWindow)) {
  	_XUnregisterFilter(im->core.display, old_focus_window,
*** /tmp/d11947	Sat Aug  1 10:42:44 1992
--- mit/lib/X/Xsi/XIMKeyBind.c	Sat Aug  1 10:42:40 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XIMKeyBind.c,v 1.23 92/04/24 16:14:56 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XIMKeyBind.c,v 1.25 92/07/29 12:10:04 rws Exp $
   */
  
  /*
***************
*** 51,62 ****
      int			ret_len, scanned_bytes;
      int			ret;
      unsigned char	buf[32];
  #ifndef X_WCHAR
      char		*mbuf;
  #endif
  
      if (ev->keycode == 0) {
! 	(void)_XipGetNextICQueue(ic, &type, &length, keysym, (char **)&ptr);
  	if (type == XIM_STRING || (type == XIM_KEYSYM && length > 0)) {
  #ifdef X_WCHAR
  	    ret_len = nchars;
--- 51,67 ----
      int			ret_len, scanned_bytes;
      int			ret;
      unsigned char	buf[32];
+     KeySym		tmp_ks;
  #ifndef X_WCHAR
      char		*mbuf;
  #endif
  
      if (ev->keycode == 0) {
! 	if (ev->state > 0) {
! 	    _XipGetOverflowICQueue(ic, &type, &length, &tmp_ks, (char **)&ptr);
! 	} else {
! 	    _XipGetNextICQueue(ic, &type, &length, &tmp_ks, (char **)&ptr);
! 	}
  	if (type == XIM_STRING || (type == XIM_KEYSYM && length > 0)) {
  #ifdef X_WCHAR
  	    ret_len = nchars;
***************
*** 75,103 ****
  		ret_len = mbstowcs(buffer, mbuf, nchars);
  #endif
  		if (ret_len == nchars)
! 		    ret = XBufferOverflow;
  	    }
  #endif
! 	    if (ret < 0) {
  		*status = XBufferOverflow;
  		return(0);
  	    }
! 	    if (type == XIM_STRING)
! 		*status = XLookupChars;
! 	    else
  		*status = XLookupBoth;
  	    return(ret_len);
! 	} else if (type == XIM_KEYSYM) {
  	    *status = XLookupKeySym;
  	    return(0);
  	} else {
! 	    *status = 0;
  	    return(0);
  	}
      } else {
! 	ret_len = XLookupString(ev, (char *)buf, 32, keysym, NULL);
  	if (ret_len > 0) {
! 	    if (*keysym != NoSymbol) {
  		*status = XLookupBoth;
  	    } else {
  		*status = XLookupChars;
--- 80,117 ----
  		ret_len = mbstowcs(buffer, mbuf, nchars);
  #endif
  		if (ret_len == nchars)
! 		    ret = BadBuffer;
  	    }
  #endif
! 	    if (ret == BadBuffer) {
! 		_XipSaveOverflowICQueue(ic, type, length, tmp_ks, ptr);
! 		ev->state = 1;
  		*status = XBufferOverflow;
  		return(0);
+ 	    } else if (ret < 0) {
+ 		*status = XLookupNone;
+ 		return(0);
  	    }
! 	    if (type == XIM_KEYSYM && keysym) {
! 		*keysym = tmp_ks;
  		*status = XLookupBoth;
+ 	    } else {
+ 		*status = XLookupChars;
+ 	    }
  	    return(ret_len);
! 	} else if (type == XIM_KEYSYM && keysym) {
! 	    *keysym = tmp_ks;
  	    *status = XLookupKeySym;
  	    return(0);
  	} else {
! 	    *status = XLookupNone;
  	    return(0);
  	}
      } else {
! 	ret_len = XLookupString(ev, (char *)buf, 32, &tmp_ks, NULL);
  	if (ret_len > 0) {
! 	    if (tmp_ks != NoSymbol && keysym) {
! 		*keysym = tmp_ks;
  		*status = XLookupBoth;
  	    } else {
  		*status = XLookupChars;
***************
*** 107,115 ****
  	    ret = _XConvertMBToWC(ic->wc, (unsigned char *)buf, ret_len,
  			    (wchar *)buffer, &nchars, &scanned_bytes,
  			    (_State *)NULL);
! 	    if (ret < 0) {
  		*status = XBufferOverflow;
  		return(0);
  	    }
  	    ret_len = nchars;
  	    /* XXX BUG Need to restore saved status */
--- 121,132 ----
  	    ret = _XConvertMBToWC(ic->wc, (unsigned char *)buf, ret_len,
  			    (wchar *)buffer, &nchars, &scanned_bytes,
  			    (_State *)NULL);
! 	    if (ret == BadBuffer) {
  		*status = XBufferOverflow;
  		return(0);
+ 	    } else if (ret < 0) {
+ 		*status = XLookupNone;
+ 		return(0);
  	    }
  	    ret_len = nchars;
  	    /* XXX BUG Need to restore saved status */
***************
*** 122,128 ****
  #endif
  #endif
  	} else {
! 	    if (*keysym != NoSymbol) {
  		*status = XLookupKeySym;
  	    } else {
  		*status = XLookupNone;
--- 139,146 ----
  #endif
  #endif
  	} else {
! 	    if (tmp_ks != NoSymbol && keysym) {
! 		*keysym = tmp_ks;
  		*status = XLookupKeySym;
  	    } else {
  		*status = XLookupNone;
***************
*** 147,162 ****
      unsigned char	*ptr;
      int			ret_len, scanned_bytes;
      int			ret;
  
      if (ev->keycode == 0) {
! 	_XipGetNextICQueue(ic, &type, &length, keysym, (char **)&ptr);
  	if (type == XIM_STRING) {
  	    ret_len = nbytes;
  	    ret = _XConvertCTToMB(ic->mb, ptr, length, (unsigned char *)buffer,
  				  &ret_len, &scanned_bytes, (_State *)NULL);
! 	    if (ret < 0) {
  		*status = XBufferOverflow;
  		return(0);
  	    }
  	    *status = XLookupChars;
  	    return(ret_len);
--- 165,190 ----
      unsigned char	*ptr;
      int			ret_len, scanned_bytes;
      int			ret;
+     KeySym		tmp_ks;
  
      if (ev->keycode == 0) {
! 	if (ev->state > 0) {
! 	    _XipGetOverflowICQueue(ic, &type, &length, &tmp_ks, (char **)&ptr);
! 	} else {
! 	    _XipGetNextICQueue(ic, &type, &length, &tmp_ks, (char **)&ptr);
! 	}
  	if (type == XIM_STRING) {
  	    ret_len = nbytes;
  	    ret = _XConvertCTToMB(ic->mb, ptr, length, (unsigned char *)buffer,
  				  &ret_len, &scanned_bytes, (_State *)NULL);
! 	    if (ret == BadBuffer) {
! 		_XipSaveOverflowICQueue(ic, type, length, tmp_ks, ptr);
! 		ev->state = 1;
  		*status = XBufferOverflow;
  		return(0);
+ 	    } else if (ret < 0) {
+ 		*status = XLookupNone;
+ 		return(0);
  	    }
  	    *status = XLookupChars;
  	    return(ret_len);
***************
*** 167,195 ****
  				      (unsigned char *)buffer,
  				      &ret_len, &scanned_bytes,
  				      (_State *)NULL);
! 		if (ret < 0) {
  		    *status = XBufferOverflow;
  		    return(0);
  		}
! 		*status = XLookupBoth;
  		return(length);
  	    }
- 	    *status = XLookupKeySym;
  	    return(0);
  	} else {
! 	    *status = 0;
  	    return(0);
  	}
      } else {
! 	ret_len = XLookupString(ev, buffer, nbytes, keysym, NULL);
  	if (ret_len > 0) {
! 	    if (*keysym != NoSymbol) {
  		*status = XLookupBoth;
  	    } else {
  		*status = XLookupChars;
  	    }
  	} else {
! 	    if (*keysym != NoSymbol) {
  		*status = XLookupKeySym;
  	    } else {
  		*status = XLookupNone;
--- 195,239 ----
  				      (unsigned char *)buffer,
  				      &ret_len, &scanned_bytes,
  				      (_State *)NULL);
! 		if (ret == BadBuffer) {
! 		    _XipSaveOverflowICQueue(ic, type, length, tmp_ks, ptr);
! 		    ev->state = 1;
  		    *status = XBufferOverflow;
  		    return(0);
+ 		} else if (ret < 0) {
+ 		    *status = XLookupNone;
+ 		    return(0);
  		}
! 		if (keysym) {
! 		    *keysym = tmp_ks;
! 		    *status = XLookupBoth;
! 		} else {
! 		    *status = XLookupChars;
! 		}
  		return(length);
+ 	    } else if (keysym) {
+ 		*keysym = tmp_ks;
+ 		*status = XLookupKeySym;
+ 	    } else {
+ 		*status = XLookupNone;
  	    }
  	    return(0);
  	} else {
! 	    *status = XLookupNone;
  	    return(0);
  	}
      } else {
! 	ret_len = XLookupString(ev, buffer, nbytes, &tmp_ks, NULL);
  	if (ret_len > 0) {
! 	    if (tmp_ks != NoSymbol && keysym) {
! 		*keysym = tmp_ks;
  		*status = XLookupBoth;
  	    } else {
  		*status = XLookupChars;
  	    }
  	} else {
! 	    if (tmp_ks != NoSymbol && keysym) {
! 		*keysym = tmp_ks;
  		*status = XLookupKeySym;
  	    } else {
  		*status = XLookupNone;
***************
*** 212,256 ****
      int			length;
      char		*ptr;
      int			ret_len;
  
      if (ev->keycode == 0) {
! 	_XipGetNextICQueue(ic, &type, &length, keysym, &ptr);
  	if (type == XIM_STRING) {
  	    if (length > nbytes) {
  		*status = XBufferOverflow;
  		return(0);
  	    }
  	    (void)strncpy(buffer, ptr, length);
! 	    buffer[length] = 0;
  	    *status = XLookupChars;
  	    return(nbytes);
  	} else if (type == XIM_KEYSYM) {
  	    if (length > 0) {
  		if (length > nbytes) {
  		    *status = XBufferOverflow;
  		    return(0);
  		}
  		(void)strncpy(buffer, ptr, length);
! 		buffer[length] = 0;
! 		*status = XLookupBoth;
  		return(nbytes);
  	    }
- 	    *status = XLookupKeySym;
  	    return(0);
  	} else {
! 	    *status = 0;
  	    return(0);
  	}
      } else {
! 	ret_len = XLookupString(ev, buffer, nbytes, keysym, NULL);
  	if (ret_len > 0) {
! 	    if (*keysym != NoSymbol) {
  		*status = XLookupBoth;
  	    } else {
  		*status = XLookupChars;
  	    }
  	} else {
! 	    if (*keysym != NoSymbol) {
  		*status = XLookupKeySym;
  	    } else {
  		*status = XLookupNone;
--- 256,319 ----
      int			length;
      char		*ptr;
      int			ret_len;
+     KeySym		tmp_ks;
  
      if (ev->keycode == 0) {
! 	if (ev->state > 0) {
! 	    _XipGetOverflowICQueue(ic, &type, &length, &tmp_ks, (char **)&ptr);
! 	} else {
! 	    _XipGetNextICQueue(ic, &type, &length, &tmp_ks, &ptr);
! 	}
  	if (type == XIM_STRING) {
  	    if (length > nbytes) {
+ 		_XipSaveOverflowICQueue(ic, type, length, tmp_ks, ptr);
+ 		ev->state = 1;
  		*status = XBufferOverflow;
  		return(0);
  	    }
  	    (void)strncpy(buffer, ptr, length);
! 	    if (length < nbytes) buffer[length] = 0;
  	    *status = XLookupChars;
  	    return(nbytes);
  	} else if (type == XIM_KEYSYM) {
  	    if (length > 0) {
  		if (length > nbytes) {
+ 		    _XipSaveOverflowICQueue(ic, type, length, tmp_ks, ptr);
+ 		    ev->state = 1;
  		    *status = XBufferOverflow;
  		    return(0);
  		}
  		(void)strncpy(buffer, ptr, length);
! 		if (length < nbytes) buffer[length] = 0;
! 		if (keysym) {
! 		    *keysym = tmp_ks;
! 		    *status = XLookupBoth;
! 		} else {
! 		    *status = XLookupChars;
! 		}
  		return(nbytes);
+ 	    } else if (keysym) {
+ 		*status = XLookupKeySym;
+ 	    } else {
+ 		*status = XLookupNone;
  	    }
  	    return(0);
  	} else {
! 	    *status = XLookupNone;
  	    return(0);
  	}
      } else {
! 	ret_len = XLookupString(ev, buffer, nbytes, &tmp_ks, NULL);
  	if (ret_len > 0) {
! 	    if (tmp_ks != NoSymbol && keysym) {
! 		*keysym = tmp_ks;
  		*status = XLookupBoth;
  	    } else {
  		*status = XLookupChars;
  	    }
  	} else {
! 	    if (tmp_ks != NoSymbol && keysym) {
! 		*keysym = tmp_ks;
  		*status = XLookupKeySym;
  	    } else {
  		*status = XLookupNone;
*** /tmp/d12010	Sat Aug  1 10:43:28 1992
--- mit/lib/X/Xsi/XIMQueue.c	Sat Aug  1 10:43:23 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XIMQueue.c,v 1.9 91/11/17 15:58:54 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XIMQueue.c,v 1.11 92/07/29 13:55:40 rws Exp $
   */
  
  /*
***************
*** 138,144 ****
  		if (_XipReadFromIM(im, ic->in->ptr, ic->in->length) < 0)
  		    return(-1);
  	    } else {
! 		(void) strcpy(ic->in->ptr, (char *)str);
  	    }
  	}
      } else if (type == XIM_STRING) {
--- 138,144 ----
  		if (_XipReadFromIM(im, ic->in->ptr, ic->in->length) < 0)
  		    return(-1);
  	    } else {
! 		(void) strncpy(ic->in->ptr, (char *)str, length);
  	    }
  	}
      } else if (type == XIM_STRING) {
***************
*** 185,188 ****
--- 185,252 ----
      }
  }
  
+ void
+ _XipFreeAllICQueue(ic)
+     XipIC ic;
+ {
+     register XIMQueue *start = ic->in;
+     register XIMQueue *p, *f;
+     for (p = ic->in; p;) {
  
+ 	if (p->buf_max > 0) Xfree((char *)p->ptr);
+ 	f = p;
+ 	p = p->next;
+ 	Xfree((char *)f);
+ 	if (p == start) break;
+     }
+ }
+ 
+ /*
+  * Save to Overflow Queue
+  */
+ void
+ _XipSaveOverflowICQueue(ic, type, length, keysym, ptr)
+     XipIC ic;
+     short type;
+     int length;
+     KeySym keysym;
+     char *ptr;
+ {
+     register XIMQueue *q = &ic->overflow;
+ 
+     q->type = type;
+     q->length = length;
+     q->keysym = keysym;
+     q->state = 0;
+     if (q->length > 0) {
+ 	if (q->buf_max < q->length) {
+ 	    q->ptr = (char *)Xrealloc((char *)q->ptr, (unsigned)q->length);
+ 	    q->buf_max = q->length;
+ 	}
+ 	(void) bcopy(ptr, q->ptr, (unsigned)q->length);
+     }
+ }
+ 
+ /*
+  * Get from Overflow Queue
+  */
+ void
+ _XipGetOverflowICQueue(ic, type, length, keysym, ptr)
+     XipIC ic;
+     short *type;
+     int *length;
+     KeySym *keysym;
+     char **ptr;
+ {
+     register XIMQueue *q = &ic->overflow;
+ 
+     if (q->type == XIM_STRING || q->type == XIM_KEYSYM) {
+ 	*type = q->type;
+ 	*length = q->length;
+ 	if (keysym != NULL) *keysym = q->keysym;
+ 	*ptr = q->ptr;
+ 	q->type = 0;
+     } else {
+ 	*type = 0;
+     }
+ }
*** /tmp/d12081	Sat Aug  1 10:44:15 1992
--- mit/lib/X/Xsi/XOpenIM.c	Sat Aug  1 10:44:11 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XOpenIM.c,v 1.17 91/08/12 17:20:36 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XOpenIM.c,v 1.19 92/07/28 17:52:13 rws Exp $
   */
  
  /*
***************
*** 41,47 ****
  extern int getuid();
  #endif
  
! #if __STDC__ && !defined(VMS)
  #define RConst const
  #else
  #define RConst /**/
--- 41,47 ----
  extern int getuid();
  #endif
  
! #if __STDC__ && !defined(NORCONST)
  #define RConst const
  #else
  #define RConst /**/
***************
*** 72,80 ****
      { XNFocusWindow, sizeof(Window), offset(core.focus_window),
        (unsigned short)IMResourceReadWrite, ICFocusWindow },
      { XNResourceName, sizeof(char *), offset(values.res_name),
!       (unsigned short)IMResourceReadWrite, -1 },
      { XNResourceClass, sizeof(char *), offset(values.res_class),
!       (unsigned short)IMResourceReadWrite, -1 },
      { XNFilterEvents, sizeof(long), offset(core.filter_events),
        (unsigned short)IMResourceRead, ICFilterEvents },
      { XNPreeditAttributes, sizeof(ICAttributes *), offset(core.preedit_attr),
--- 72,80 ----
      { XNFocusWindow, sizeof(Window), offset(core.focus_window),
        (unsigned short)IMResourceReadWrite, ICFocusWindow },
      { XNResourceName, sizeof(char *), offset(values.res_name),
!       (unsigned short)IMResourceReadWrite, ICResourceName },
      { XNResourceClass, sizeof(char *), offset(values.res_class),
!       (unsigned short)IMResourceReadWrite, ICResourceClass },
      { XNFilterEvents, sizeof(long), offset(core.filter_events),
        (unsigned short)IMResourceRead, ICFilterEvents },
      { XNPreeditAttributes, sizeof(ICAttributes *), offset(core.preedit_attr),
*** /tmp/d12485	Sat Aug  1 10:48:37 1992
--- mit/lib/X/Xsi/XIMlibint.h	Sat Aug  1 10:48:32 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: XIMlibint.h,v 1.11 91/11/17 15:59:01 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XIMlibint.h,v 1.13 92/07/29 13:55:45 rws Exp $
   */
  
  /*
***************
*** 60,65 ****
--- 60,68 ----
  extern void	_XipFreeNextICQueue();
  extern int	_XipPutICQueue();
  extern void	_XipGetNextICQueue();
+ extern void	_XipFreeAllICQueue();
+ extern void	_XipSaveOverflowICQueue();
+ extern void	_XipGetOverflowICQueue();
  extern int	_XipWriteToIM();
  extern int	_XipReadFromIM();
  extern int	_XipFlushToIM();
*** /tmp/d12549	Sat Aug  1 10:49:16 1992
--- mit/lib/X/Xsi/Xi18nint.h	Sat Aug  1 10:49:12 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: Xi18nint.h,v 1.19 92/04/14 15:45:50 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: Xi18nint.h,v 1.20 92/07/29 11:58:18 rws Exp $
   */
  
  /*
***************
*** 117,123 ****
  typedef struct {
      XICMethods		methods;		/* method list of this IC */
      XICCoreRec		core;			/* core data of this IC */
!     struct _XIMQueue	*in, *out, *prev;
      Bool		(*prototype_filter)();
      XLocale		mb;
      XLocale		wc;
--- 117,123 ----
  typedef struct {
      XICMethods		methods;		/* method list of this IC */
      XICCoreRec		core;			/* core data of this IC */
!     struct _XIMQueue	*in, *out, *prev, overflow;
      Bool		(*prototype_filter)();
      XLocale		mb;
      XLocale		wc;
*** /tmp/d13599	Sat Aug  1 11:05:16 1992
--- mit/lib/X/Ximp/XIMProto.h	Sat Aug  1 11:05:12 1992
***************
*** 1,4 ****
! /* $XConsortium: XIMProto.h,v 1.5 92/04/14 13:28:34 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: XIMProto.h,v 1.6 92/07/29 10:15:02 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
***************
*** 28,34 ****
  ******************************************************************/
  
  /* Ximp implementation revision */
! #define XIMP_REVISION "Ximp Revision 3.2"
  
  /* Ximp Protocol Version */
  #define XIMP_PROTOCOL_VERSION "XIMP.3.5"
--- 28,34 ----
  ******************************************************************/
  
  /* Ximp implementation revision */
! #define XIMP_REVISION "Ximp Revision 3.3"
  
  /* Ximp Protocol Version */
  #define XIMP_PROTOCOL_VERSION "XIMP.3.5"
*** /tmp/d13631	Sat Aug  1 11:05:35 1992
--- mit/lib/X/Ximp/XimpCallbk.c	Sat Aug  1 11:05:31 1992
***************
*** 1,9 ****
! /* $XConsortium: XimpCallbk.c,v 1.5 92/04/14 13:28:40 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by Fuji Xerox Co.,Ltd.
                Copyright 1991, 1992 by FUJITSU LIMITED
                Copyright 1991, 1992 by Sun Microsystems, Inc.
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,10 ----
! /* $XConsortium: XimpCallbk.c,v 1.6 92/07/29 10:15:36 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by Fuji Xerox Co.,Ltd.
                Copyright 1991, 1992 by FUJITSU LIMITED
                Copyright 1991, 1992 by Sun Microsystems, Inc.
+               Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 10,36 ****
  provided that the above copyright notice appear in all copies and that
  both that copyright notice and this permission notice appear in
  supporting documentation, and that the name of Fuji Xerox Co.,Ltd.,
! FUJITSU LIMITED, Sun Microsystems, Inc. not be used in advertising or
! publicity pertaining to distribution of the software without specific,
! written prior permission.  Fuji Xerox Co.,Ltd., FUJITSU LIMITED makes
  no representations about the suitability of this software for any
  purpose.  It is provided "as is" without express or implied warranty.
  
! FUJI XEROX CO.,LTD., FUJITSU LIMITED, SUN MICROSYSTEMS DISCLAIMS ALL
! WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
! WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJI
! XEROX CO.,LTD., FUJITSU LIMITED, SUN MICROSYSTEMS BE LIABLE FOR ANY
! SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
  RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
  CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  
    Auther: Kazunori Nishihara,  Fuji Xerox Co.,Ltd.
-                                kaz@ssdev.ksp.fujixerox.co.jp
            Takashi Fujiwara     FUJITSU LIMITED
-                                fujiwara@a80.tech.yk.fujitsu.co.jp
            Hideki Hiura         Sun Microsystems, Inc.
!                                hhiura@Sun.COM
  ******************************************************************/
  
  #define NEED_EVENTS
--- 11,37 ----
  provided that the above copyright notice appear in all copies and that
  both that copyright notice and this permission notice appear in
  supporting documentation, and that the name of Fuji Xerox Co.,Ltd.,
! FUJITSU LIMITED, Sun Microsystems, Inc. and Sony Corporation not be
! used in advertising or publicity pertaining to distribution of the
! software without specific, written prior permission.
! Fuji Xerox Co.,Ltd., FUJITSU LIMITED and Sony Corporation make
  no representations about the suitability of this software for any
  purpose.  It is provided "as is" without express or implied warranty.
  
! FUJI XEROX CO.,LTD., FUJITSU LIMITED, SUN MICROSYSTEMS AND
! SONY CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
! INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
! IN NO EVENT SHALL FUJI XEROX CO.,LTD., FUJITSU LIMITED,
! SUN MICROSYSTEMS AND SONY CORPORATION BE LIABLE FOR ANY SPECIAL,
! INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
  RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
  CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  
    Auther: Kazunori Nishihara,  Fuji Xerox Co.,Ltd.
            Takashi Fujiwara     FUJITSU LIMITED
            Hideki Hiura         Sun Microsystems, Inc.
!           Makoto Wakamatsu     Sony Corporation
  ******************************************************************/
  
  #define NEED_EVENTS
***************
*** 266,280 ****
      }
  }
  
! static int      _time_flag = 0;
! #ifdef XIMP_SIGNAL
! static int
! _time_out()
  {
!     _time_flag = 1;
  }
- #endif				/* XIMP_SIGNAL */
  
  void
  _Ximp_CallPreeditDrawCallback2(xic, event)
      Ximp_XIC        xic;
--- 267,307 ----
      }
  }
  
! static Bool
! _Ximp_DCMPredicate( d, ev, arg0 )
! Display		*d;
! XEvent		*ev;
! XPointer	arg0;
  {
!     XimpCMPredicateArg	arg = (XimpCMPredicateArg)arg0;
!     ICID		icid;
!     int			n;
! 
!     if( ev->type == ClientMessage ) {
! 	if( ev->xclient.message_type == arg->type ) {
! 	    if( ev->xclient.format == 8 ) {
! 		for( icid = 0, n = 0; n < 4; n++ ) {
! 		    icid <<= 8;
! 		    icid += ev->xclient.data.b[n];
! 		}
! 		if( icid == arg->icid )
! 		    return( True );
! 	    }
! 	    else if( ev->xclient.format == 32  &&
! 		     ev->xclient.data.l[0] == XIMP_ERROR  &&
! 		     ev->xclient.data.l[1] == arg->icid ) {
! 		return( True );
! 	    }
! 	}
!     }
!     else if( ev->type == DestroyNotify ) {
! 	if( ev->xdestroywindow.window == arg->owner ) {
! 	    return( True );
! 	}
!     }
  }
  
+ 
  void
  _Ximp_CallPreeditDrawCallback2(xic, event)
      Ximp_XIC        xic;
***************
*** 291,296 ****
--- 318,324 ----
      Atom            type;
      int             format;
      unsigned long   nitems, after;
+     XimpCMPredicateArgRec	Arg;
  
      bzero(&CallData, sizeof(XIMPreeditDrawCallbackStruct));
      bzero(&cbtext, sizeof(XIMText));
***************
*** 347,377 ****
  	    /*
  	     * Following Client message must be the preedit string.
  	     */
! #ifdef XIMP_SIGNAL
! 	    signal(SIGALRM, _time_out);
! 	    alarm(XIMP_TIME_OUT);
! #endif				/* XIMP_SIGNAL */
! 	    while (_time_flag != 1) {
! 		if ((XCheckTypedEvent(xic->core.im->core.display, ClientMessage, &ev)) == False) {
! #ifdef XIMP_SIGNAL
! 		    sleep(1);
! #endif				/* XIMP_SIGNAL */
! 		    continue;
! 		}
! 		if (ev.xclient.message_type != ((Ximp_XIM) xic->core.im)->ximp_impart->improtocol_id) {
! 		    XPutBackEvent(xic->core.im->core.display, &ev);
! 		    continue;
! 		} else {
! #ifdef XIMP_SIGNAL
! 		    alarm(0);
! #endif				/* XIMP_SIGNAL */
! 		    break;
! 		}
! 	    }
  
  	    ctlen = ev.xclient.data.b[4];
  	    length = ctlen * XIMP_MB_CUR_MAX(xic->core.im->core.lcd);
- 	    _time_flag = 0;
  	    
  	    if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
  		cbtext.string.wide_char = (wchar_t *) Xmalloc((length + 1) * sizeof(wchar_t));
--- 375,388 ----
  	    /*
  	     * Following Client message must be the preedit string.
  	     */
! 	    Arg.type = ((Ximp_XIM)xic->core.im)->ximp_impart->improtocol_id;
! 	    Arg.owner = ((Ximp_XIM)xic->core.im)->ximp_impart->fe_window;
! 	    Arg.icid = xic->ximp_icpart->icid;
! 	    if( !_XimpIfEvent( xic, &ev, _Ximp_DCMPredicate, (XPointer)&Arg ) )
! 		return;
  
  	    ctlen = ev.xclient.data.b[4];
  	    length = ctlen * XIMP_MB_CUR_MAX(xic->core.im->core.lcd);
  	    
  	    if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
  		cbtext.string.wide_char = (wchar_t *) Xmalloc((length + 1) * sizeof(wchar_t));
***************
*** 648,659 ****
      Ximp_XIC        xic;
      XClientMessageEvent *event;
  {
!     register XIMCallback *cb;
!     char           *text;
!     int             length;
      XIMStatusDrawCallbackStruct CallData;
!     XIMText         cbtext;
!     XEvent          ev;
  
      cb = &xic->core.status_attr.callbacks.draw;
      CallData.type = ToXIMStatusDataType(event->data.l[2]);
--- 659,671 ----
      Ximp_XIC        xic;
      XClientMessageEvent *event;
  {
!     register XIMCallback	*cb;
!     char			*text;
!     int             		length;
      XIMStatusDrawCallbackStruct CallData;
!     XIMText         		cbtext;
!     XEvent          		ev;
!     XimpCMPredicateArgRec	Arg;
  
      cb = &xic->core.status_attr.callbacks.draw;
      CallData.type = ToXIMStatusDataType(event->data.l[2]);
***************
*** 660,687 ****
      if (CallData.type == XIMTextType) {
  	CallData.data.text = &cbtext;
  
! #ifdef XIMP_SIGNAL
! 	signal(SIGALRM, _time_out);
! 	alarm(XIMP_TIME_OUT);
! #endif				/* XIMP_SIGNAL */
! 	while (_time_flag != 1) {
! 	    if ((XCheckTypedEvent(xic->core.im->core.display, ClientMessage, &ev)) == False) {
! #ifdef XIMP_SIGNAL
! 		sleep(1);
! #endif				/* XIMP_SIGNAL */
! 		continue;
! 	    }
! 	    if (ev.xclient.message_type != ((Ximp_XIM) xic->core.im)->ximp_impart->improtocol_id) {
! 		XPutBackEvent(xic->core.im->core.display, &ev);
! 		continue;
! 	    } else {
! #ifdef XIMP_SIGNAL
! 		alarm(0);
! #endif				/* XIMP_SIGNAL */
! 		break;
! 	    }
! 	}
! 	_time_flag = 0;
  	if (cb->callback) {
  	    length = ev.xclient.data.b[4];
  	    if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
--- 672,683 ----
      if (CallData.type == XIMTextType) {
  	CallData.data.text = &cbtext;
  
! 	Arg.type = ((Ximp_XIM)xic->core.im)->ximp_impart->improtocol_id;
! 	Arg.owner = ((Ximp_XIM)xic->core.im)->ximp_impart->fe_window;
! 	Arg.icid = xic->ximp_icpart->icid;
! 	if( !_XimpIfEvent( xic, &ev, _Ximp_DCMPredicate, (XPointer)&Arg ) )
! 	    return;
! 
  	if (cb->callback) {
  	    length = ev.xclient.data.b[4];
  	    if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
*** /tmp/d13727	Sat Aug  1 11:06:32 1992
--- mit/lib/X/Ximp/XimpIC.c	Sat Aug  1 11:06:28 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpIC.c,v 1.6 92/04/14 13:29:06 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: XimpIC.c,v 1.7 92/07/29 10:15:50 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
***************
*** 136,142 ****
  						_Ximp_XimFilter_Keypress,
  						(XPointer)ic);
  			ic->ximp_icpart->filter_mode |= 0x1;
! 		}
  	}
  	return((XIC)ic);
  
--- 136,147 ----
  						_Ximp_XimFilter_Keypress,
  						(XPointer)ic);
  			ic->ximp_icpart->filter_mode |= 0x1;
! 			_XRegisterFilterByType(ic->core.im->core.display,
! 					       ic->core.focus_window,
! 					       ClientMessage, ClientMessage,
! 					       _Ximp_XimFilter_Client, NULL);
! 			ic->ximp_icpart->filter_mode |= 0x2;
! 		    }
  	}
  	return((XIC)ic);
  
***************
*** 162,167 ****
--- 167,176 ----
  				   _Ximp_XimFilter_Client, (XPointer)NULL);
  	}
   	_Ximp_IM_SendMessage(ic, XIMP_DESTROY, NULL, NULL, NULL);
+ 	if( ic->ximp_icpart->preedit_font )
+ 	    Xfree( ic->ximp_icpart->preedit_font );
+ 	if( ic->ximp_icpart->status_font )
+ 	    Xfree( ic->ximp_icpart->status_font );
  	Xfree(ic->ximp_icpart);
  	return;
  }
***************
*** 201,222 ****
  _Ximp_SetFocusWindow(ic)
  	Ximp_XIC	 ic;
  {
- 	Atom		 actual_type;
- 	int		 actual_format;
- 	unsigned long	 nitems, bytes_after;
- 	int		*prop_int;
- 
- 	while(1) {
- 		XGetWindowProperty(ic->core.im->core.display,
- 			ic->core.client_window,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id,
- 			0L, 1000000L, False, XA_WINDOW,
- 			&actual_type, &actual_format, &nitems, &bytes_after,
- 			(unsigned char **)&prop_int);
- 		if(nitems == 0)
- 			break;
- 		XFree((XPointer)prop_int);
- 		}
  	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
  			((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id,
  			XA_WINDOW, 32, PropModeReplace,
--- 210,215 ----
***************
*** 253,262 ****
  	Ximp_XIC		 ic;
  {
  	Ximp_PreeditPropRec	*preedit_atr;
- 	Atom			 actual_type;
- 	int			 actual_format;
- 	unsigned long		 nitems, bytes_after;
- 	int			*prop_int;
  	unsigned char		 prop_data[XIMP_PREEDIT_MAX_CHAR];
  
  	preedit_atr = &(ic->ximp_icpart->preedit_attr);
--- 246,251 ----
***************
*** 275,292 ****
  	_Ximp_AttributesSetL(prop_data, preedit_atr->SpotLocation.x,    48);
  	_Ximp_AttributesSetL(prop_data, preedit_atr->SpotLocation.y,    52);
  
- 	while(1) {
- 		XGetWindowProperty(ic->core.im->core.display,
- 			ic->core.client_window,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
- 			0L, 1000000L, False,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
- 			&actual_type, &actual_format, &nitems, &bytes_after,
- 			(unsigned char **)(&prop_int));
- 		if(nitems == 0)
- 			break;
- 		XFree((XPointer)prop_int);
- 		}
  	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
  			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
  			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
--- 264,269 ----
***************
*** 298,320 ****
  _Ximp_SetPreeditFont(ic)
  	Ximp_XIC		 ic;
  {
- 	Atom			actual_type;
- 	int			actual_format;
- 	unsigned long		nitems, bytes_after;
- 	char			*prop;
- 
  	if (ic->core.preedit_attr.fontset != NULL) {
- 	    while(1) {
- 		XGetWindowProperty(ic->core.im->core.display,
- 			ic->core.client_window,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id,
- 			0L, 1000000L, False, XA_STRING,
- 			&actual_type, &actual_format, &nitems, &bytes_after,
- 			(unsigned char **)&prop);
- 		if(nitems == 0)
- 			break;
- 		XFree((XPointer)prop);
- 	        }
  	    XChangeProperty(ic->core.im->core.display, ic->core.client_window,
  			((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id,
  			XA_STRING, 8, PropModeReplace,
--- 275,281 ----
***************
*** 329,338 ****
  	Ximp_XIC		 ic;
  {
  	Ximp_StatusPropRec	*status_atr;
- 	Atom			 actual_type;
- 	int			 actual_format;
- 	unsigned long		 nitems, bytes_after;
- 	int			*prop_int;
  	unsigned char		 prop_data[XIMP_STATUS_MAX_CHAR];
  
  	status_atr = &(ic->ximp_icpart->status_attr);
--- 290,295 ----
***************
*** 350,367 ****
  	_Ximp_AttributesSetL(prop_data, status_atr->AreaNeeded.height, 44);
  	_Ximp_AttributesSetL(prop_data, status_atr->window,            48);
  
- 	while(1) {
- 		XGetWindowProperty(ic->core.im->core.display,
- 			ic->core.client_window,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
- 			0L, 1000000L, False,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
- 			&actual_type, &actual_format, &nitems, &bytes_after,
- 			(unsigned char **)&prop_int);
- 		if(nitems == 0)
- 			break;
- 		XFree((XPointer)prop_int);
- 		}
  	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
  			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
  			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
--- 307,312 ----
***************
*** 373,395 ****
  _Ximp_SetStatusFont(ic)
  	Ximp_XIC		ic;
  {
- 	Atom			actual_type;
- 	int			actual_format;
- 	unsigned long		nitems, bytes_after;
- 	char			*prop;
- 
  	if (ic->core.status_attr.fontset != NULL) {
- 	    while(1) {
- 		XGetWindowProperty(ic->core.im->core.display,
- 			ic->core.client_window,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id,
- 			0L, 1000000L, False, XA_STRING,
- 			&actual_type, &actual_format, &nitems, &bytes_after,
- 			(unsigned char **)&prop);
- 		if(nitems == 0)
- 			break;
- 		XFree((XPointer)prop);
- 		}
  	    XChangeProperty(ic->core.im->core.display, ic->core.client_window,
  			((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id,
  			XA_STRING, 8, PropModeReplace,
--- 318,324 ----
*** /tmp/d13760	Sat Aug  1 11:06:52 1992
--- mit/lib/X/Ximp/XimpIM.c	Sat Aug  1 11:06:47 1992
***************
*** 1,8 ****
! /* $XConsortium: XimpIM.c,v 1.6 92/04/14 13:29:18 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporaion
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,8 ----
! /* $XConsortium: XimpIM.c,v 1.8 92/07/29 10:16:10 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 26,32 ****
  PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
! 	  Makoto Wakamatsu     Sony Corporaion
  
  ******************************************************************/
  
--- 26,32 ----
  PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
! 	  Makoto Wakamatsu     Sony Corporation
  
  ******************************************************************/
  
***************
*** 156,168 ****
  		XFree( ximp_impart->process_start_keys->keys_list );
  		XFree( ximp_impart->process_start_keys );
  	}
! 	if(ximp_impart->connectserver) {
! 		for(i=0; i < Ximp_Xim_count; i++) {
! 			if(Ximp_Xim_List[i] == im) {
! 				Ximp_Xim_List[i] = NULL;
! 				break;
! 			}
  		}
  		_Ximp_SetupFreeExtension(im);
  		_Ximp_SetupFree(ximp_impart->im_proto_vl,
  				ximp_impart->im_styles,
--- 156,168 ----
  		XFree( ximp_impart->process_start_keys->keys_list );
  		XFree( ximp_impart->process_start_keys );
  	}
! 	for(i=0; i < Ximp_Xim_count; i++) {
! 		if(Ximp_Xim_List[i] == im) {
! 			Ximp_Xim_List[i] = NULL;
! 			break;
  		}
+ 	}
+ 	if(ximp_impart->connectserver) {
  		_Ximp_SetupFreeExtension(im);
  		_Ximp_SetupFree(ximp_impart->im_proto_vl,
  				ximp_impart->im_styles,
***************
*** 255,262 ****
  			XA_STRING, &actual_type, &actual_format, &nitems,
  			&bytes_after, (unsigned char **)(&prop)) != Success)
  		return(False);
! 	if((version = Xmalloc((sizeof(char) * nitems + 1))) == NULL)
  		return(False);
  	strncpy(version, prop, nitems);
  	version[nitems] = '\0';
  	XFree(prop);
--- 255,264 ----
  			XA_STRING, &actual_type, &actual_format, &nitems,
  			&bytes_after, (unsigned char **)(&prop)) != Success)
  		return(False);
! 	if((version = Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
! 		XFree(prop);
  		return(False);
+ 	}
  	strncpy(version, prop, nitems);
  	version[nitems] = '\0';
  	XFree(prop);
***************
*** 271,276 ****
--- 273,279 ----
  	}
  	if((imstyle = (XIMStyles *)Xmalloc(sizeof(XIMStyles))) == NULL) {
  		_Ximp_SetupFree(version, NULL, NULL, NULL, NULL, NULL, NULL);
+ 		XFree((XPointer)prop_long);
  		return(False);
  	}
  	if((imstyle->supported_styles =
***************
*** 277,282 ****
--- 280,286 ----
  		(XIMStyle *)Xmalloc(sizeof(XIMStyle) * nitems)) == NULL) {
  		Xfree(imstyle);
  		_Ximp_SetupFree(version, NULL, NULL, NULL, NULL, NULL, NULL);
+ 		XFree((XPointer)prop_long);
  		return(False);
  	}
  	for(i=0; i < nitems; i++) {
***************
*** 295,300 ****
--- 299,305 ----
  	}
  	if((keylist = (Ximp_KeyList *)Xmalloc(sizeof(Ximp_KeyList))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, NULL, NULL, NULL, NULL, NULL);
+ 		XFree((XPointer)prop_int);
  		return(False);
  	}
  	count = nitems / 3;
***************
*** 301,306 ****
--- 306,312 ----
  	if((keylist->keys_list = (Ximp_Key *)Xmalloc(sizeof(Ximp_Key) * count)) == NULL) {
  		Xfree(keylist);
  		_Ximp_SetupFree(version, imstyle, NULL, NULL, NULL, NULL, NULL);
+ 		XFree((XPointer)prop_int);
  		return(False);
  	}
  	for(i=0,n=0; n < count; n++) {
***************
*** 321,326 ****
--- 327,333 ----
  	}
  	if((server_name = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, NULL, NULL, NULL, NULL);
+ 		XFree(prop);
  		return(False);
  	}
  	strncpy(server_name, prop, nitems);
***************
*** 337,342 ****
--- 344,350 ----
  	}
  	if((server_vl = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, NULL, NULL, NULL);
+ 		XFree(prop);
  		return(False);
  	}
  	strncpy(server_vl, prop, nitems);
***************
*** 353,358 ****
--- 361,367 ----
  	}
  	if((vendor_name = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, NULL, NULL, NULL);
+ 		XFree(prop);
  		return(False);
  	}
  	strncpy(vendor_name, prop, nitems);
***************
*** 369,380 ****
  	}
  	if((ext_list = (Atom *)Xmalloc((sizeof(Atom) * (nitems + 1)))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
  		return(False);
  	}
  	for(i=0; i < nitems; i++)
  		ext_list[i] = prop_int[i];
  	ext_list[nitems] = NULL;
! 	if(prop_int) XFree((XPointer)prop_int);
  
  	im->ximp_impart->fe_window	    = fe_window_id;
  	Protocol_ID                 = XInternAtom(dpy, _XIMP_PROTOCOL, False);
--- 378,392 ----
  	}
  	if((ext_list = (Atom *)Xmalloc((sizeof(Atom) * (nitems + 1)))) == NULL) {
  		_Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
+ 		if( prop_int )
+ 		    XFree((XPointer)prop_int);
  		return(False);
  	}
  	for(i=0; i < nitems; i++)
  		ext_list[i] = prop_int[i];
  	ext_list[nitems] = NULL;
! 	if( prop_int )
! 	    XFree((XPointer)prop_int);
  
  	im->ximp_impart->fe_window	    = fe_window_id;
  	Protocol_ID                 = XInternAtom(dpy, _XIMP_PROTOCOL, False);
***************
*** 403,414 ****
--- 415,436 ----
  
  	if(Ximp_Xim_List == (Ximp_XIM *)NULL){
  		Ximp_Xim_List = (Ximp_XIM *)Xmalloc(sizeof(Ximp_XIM));
+ 		if( Ximp_Xim_List == NULL ) {
+ 		    _Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
+ 		    return( False );
+ 		}
  		Ximp_Xim_List[0] = im;
  		Ximp_Xim_count = 1;
  	}
  	else {
+ 		Ximp_XIM	*ximp_xim;
+ 
  		n = 0;
  		for(i=0; i < Ximp_Xim_count; i++) {
+ 			if( Ximp_Xim_List[i] == im ) {
+ 				n = 1;
+ 				break;
+ 			}
  			if(Ximp_Xim_List[i] == NULL) {
  				Ximp_Xim_List[i] = im;
  				n = 1;
***************
*** 416,424 ****
  			}
  		}
  		if(n == 0) {
! 			Ximp_Xim_List = (Ximp_XIM *)Xrealloc(Ximp_Xim_List, ((i + 1) * sizeof(Ximp_XIM)));
! 			Ximp_Xim_List[i-1] = im;
! 			Ximp_Xim_count = i;
  		}
  	}
  
--- 438,451 ----
  			}
  		}
  		if(n == 0) {
! 			ximp_xim = (Ximp_XIM *)Xrealloc(Ximp_Xim_List, ((i + 1) * sizeof(Ximp_XIM)));
! 			if( ximp_xim == NULL ) {
! 			    _Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
! 			    return( False );
! 			}
! 			Ximp_Xim_List = ximp_xim;
! 			Ximp_Xim_List[Ximp_Xim_count] = im;
! 			Ximp_Xim_count++;
  		}
  	}
  
***************
*** 473,479 ****
  	Ximp_XIC	pic;
  
  	for(i = 0; i < Ximp_Xim_count; i++) {
! 		pim = Ximp_Xim_List[i];
  		for(pic = (Ximp_XIC)pim->core.ic_chain; pic; pic = (Ximp_XIC)pic->core.next) {
  			if(pic->ximp_icpart->icid == icid)
  				return(pic);
--- 500,507 ----
  	Ximp_XIC	pic;
  
  	for(i = 0; i < Ximp_Xim_count; i++) {
! 		if( (pim = Ximp_Xim_List[i]) == NULL )
! 			continue;
  		for(pic = (Ximp_XIC)pim->core.ic_chain; pic; pic = (Ximp_XIC)pic->core.next) {
  			if(pic->ximp_icpart->icid == icid)
  				return(pic);
***************
*** 499,505 ****
  			    + p->count_styles * sizeof(XIMStyle))) == NULL)
  		return(False);
  	(*p_style)->count_styles = p->count_styles;
! 	(*p_style)->supported_styles = (XIMStyle *)(*p_style + sizeof(XIMStyles));
  	for(i=0; i < (int)p->count_styles; i++) {
  		(*p_style)->supported_styles[i] = p->supported_styles[i];
  	}
--- 527,533 ----
  			    + p->count_styles * sizeof(XIMStyle))) == NULL)
  		return(False);
  	(*p_style)->count_styles = p->count_styles;
! 	(*p_style)->supported_styles = (XIMStyle *)((char *)*p_style + sizeof(XIMStyles));
  	for(i=0; i < (int)p->count_styles; i++) {
  		(*p_style)->supported_styles[i] = p->supported_styles[i];
  	}
*** /tmp/d13824	Sat Aug  1 11:07:39 1992
--- mit/lib/X/Ximp/XimpLkup.c	Sat Aug  1 11:07:34 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpLkup.c,v 1.7 92/04/14 13:29:28 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by Sony Corporation
--- 1,4 ----
! /* $XConsortium: XimpLkup.c,v 1.8 92/07/29 10:16:17 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by Sony Corporation
***************
*** 43,61 ****
  
  #include "Ximplc.h"
  
- #ifdef XIMP_SIGNAL
- #include <sys/signal.h>
- #endif /* XIMP_SIGNAL */
- 
- static int	 _time_flag = 0;
- #ifdef XIMP_SIGNAL
- static int
- _time_out()
- 	{
- 	_time_flag = 1;
- 	}
- #endif /* XIMP_SIGNAL */
- 
  extern Ximp_XIC		_Ximp_LookupXIC();
  extern Atom		_Ximp_Protocol_id();
  extern Bool 		_Ximp_XimFilter_Client();
--- 43,48 ----
***************
*** 72,121 ****
  static void		_Ximp_CallCallback();
  extern void		_Ximp_ProcError();
  
! typedef struct {
! 	Atom type;
! 	ICID icid;
! 	Window owner;
! } XimpResetPredArgRec, *XimpResetPredArg;
  
! static Bool
! #if NeedFunctionPrototypes
! _Ximp_ResetPredicate(
!     Display *d,
!     XEvent *ev,
!     XPointer arg0)
! #else
! _Ximp_ResetPredicate(d, ev, arg0)
  Display *d;
  XEvent *ev;
  XPointer arg0;
- #endif
  {
!     XimpResetPredArg arg = (XimpResetPredArg) arg0 ;
  
! 	if (ev->type == ClientMessage) {
! 		if (ev->xclient.message_type == arg->type) {
! 			if ((ev->xclient.format == 32) &&
! 				(ev->xclient.data.l[1] == arg->icid)) {
! 				switch (ev->xclient.data.l[0]) {
! 				case XIMP_RESET_RETURN:
! 				case XIMP_ERROR:
! 				case XIMP_PREEDITDONE:
! 				case XIMP_PREEDITDRAW:
! 				case XIMP_PREEDITDRAW_CM:
! 				case XIMP_STATUSDONE:
! 				case XIMP_STATUSDRAW:
! 				case XIMP_STATUSDRAW_CM:
! 					return(True);
! 				}
! 			}
! 		}
! 	} else if (ev->type == DestroyNotify) {
! 		if (ev->xdestroywindow.window == arg->owner) {
! 			return(True);
! 		}
  	}
! 	return(False);
  }
  
  static unsigned char *
--- 59,113 ----
  static void		_Ximp_CallCallback();
  extern void		_Ximp_ProcError();
  
! Bool
! _XimpIfEvent( ic, event, predicate, arg )
! Ximp_XIC	ic;
! XEvent		*event;
! Bool		(*predicate)(
! #if NeedNestedPrototypes
! 	Display*,
! 	XEvent*,
! 	char*
! #endif
! );
! char		*arg;
! {
!     XIfEvent( ic->core.im->core.display, event, predicate, arg );
!     if( event->type == DestroyNotify ) {
! 	XPutBackEvent( ic->core.im->core.display, event );
! 	return( False );
!     }
!     else if( event->type == ClientMessage  &&  event->xclient.format == 32  &&
! 	     event->xclient.data.l[0] == XIMP_ERROR ) {
! 	_Ximp_ProcError( ic, ic->core.im->core.display, NULL, event );
! 	return( False );
!     }
!     return( True );
! }
  
! 
! Bool
! _Ximp_CMPredicate(d, ev, arg0)
  Display *d;
  XEvent *ev;
  XPointer arg0;
  {
!     XimpCMPredicateArg arg = (XimpCMPredicateArg)arg0;
  
!     if( ev->type == ClientMessage ) {
! 	if( ev->xclient.message_type == arg->type  &&
! 	    ev->xclient.format == 32 ) {
! 	    if( arg->icid == 0  ||  (ev->xclient.data.l[1] == arg->icid) )
! 		if( ev->xclient.data.l[0] == arg->protocol  ||
! 		    ev->xclient.data.l[0] == XIMP_ERROR )
! 		    return(True);
  	}
!     } else if( ev->type == DestroyNotify) {
! 	if( ev->xdestroywindow.window == arg->owner ) {
! 	    return( True );
! 	}
!     }
!     return( False );
  }
  
  static unsigned char *
***************
*** 122,199 ****
  _Ximp_Reset(ic)
  	Ximp_XIC	 ic;
  {
! 	XEvent		 Message;
! 	XEvent		 event;
! 	XimpResetPredArgRec Arg;
  
! 	if(ic->ximp_icpart->icid) {
! 		/* ClientMessage Send */
! 		_Ximp_IM_SendMessage(ic, XIMP_RESET, NULL, NULL, NULL);
  
! #ifdef XIMP_SIGNAL
! 		signal(SIGALRM, _time_out);
! 		alarm(XIMP_TIME_OUT);
! #endif /* XIMP_SIGNAL */
! 		Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 		Arg.icid = ic->ximp_icpart->icid;
! 		Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 		while(_time_flag != 1) {
! 			if( (XCheckIfEvent(ic->core.im->core.display, &event, _Ximp_ResetPredicate, (XPointer)&Arg)) == False) {
! #ifdef XIMP_SIGNAL
! 				sleep(1);
! #endif /* XIMP_SIGNAL */
! 				continue;
! 				}
! 			if (event.type == ClientMessage) {
! 				switch (event.xclient.data.l[0]) {
! 				case XIMP_RESET_RETURN:
! 					{
! 						int rval;
! 						Atom actual_type_return;
! 						int actual_format_return;
! 						unsigned long nitems_return, bytes_after_return;
! 						unsigned char *p = NULL;
! #ifdef XIMP_SIGNAL
! 						alarm(0);
! #endif /* XIMP_SIGNAL */
! 						ic->ximp_icpart->icid = (ICID)event.xclient.data.l[1];
! 						rval = XGetWindowProperty(ic->core.im->core.display,
! 									((Ximp_XIM)ic->core.im)->ximp_impart->fe_window,
! 									(Atom)event.xclient.data.l[2], 0, 1024, True,
! 									AnyPropertyType, &actual_type_return,
! 									&actual_format_return, &nitems_return,
! 									&bytes_after_return, &p);
! 						return(p);
! 						}
! 				case XIMP_ERROR:
! 					_Ximp_ProcError (ic->core.im->core.display,
! 							 NULL, &event);
! 					_time_flag = 0;
! 					return(NULL);
! 				case XIMP_PREEDITDONE:
! 				case XIMP_PREEDITDRAW:
! 				case XIMP_PREEDITDRAW_CM:
! 				case XIMP_PREEDITDRAW_TINY:
! 				case XIMP_STATUSDONE:
! 				case XIMP_STATUSDRAW:
! 				case XIMP_STATUSDRAW_CM:
! 					_Ximp_CallCallback (ic->core.im->core.display, event.xclient.window, &event);
! 					break;
! 					}
! 				}
! 			else {
! #ifdef XIMP_SIGNAL
! 				alarm(0);
! #endif /* XIMP_SIGNAL */
! 				_Ximp_ProcError (ic->core.im->core.display,
! 							 NULL, &event);
! 				_time_flag = 0;
! 				return(NULL);
! 				}
! 			}
! 		_time_flag = 0;
! 		}
! 	return((unsigned char *)NULL);
  }
  
  #define XIMP_MAXBUF 1024
--- 114,149 ----
  _Ximp_Reset(ic)
  	Ximp_XIC	 ic;
  {
!     XEvent			Message;
!     XEvent			event;
!     XimpCMPredicateArgRec	Arg;
!     int				rval;
!     Atom			actual_type_return;
!     int				actual_format_return;
!     unsigned long		nitems_return, bytes_after_return;
!     unsigned char		*p = NULL;
  
!     if(ic->ximp_icpart->icid) {
! 	/* ClientMessage Send */
! 	_Ximp_IM_SendMessage(ic, XIMP_RESET, NULL, NULL, NULL);
  
! 	Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 	Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 	Arg.protocol = XIMP_RESET_RETURN;
! 	Arg.icid = ic->ximp_icpart->icid;
! 	if( !_XimpIfEvent( ic, &event, _Ximp_CMPredicate, (XPointer)&Arg ) )
! 	    return( NULL );
! 
! 	ic->ximp_icpart->icid =(ICID)event.xclient.data.l[1];
! 	rval = XGetWindowProperty( ic->core.im->core.display,
! 		    ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window,
! 		    (Atom)event.xclient.data.l[2], 0, 1024, True,
! 		    AnyPropertyType, &actual_type_return,
! 		    &actual_format_return, &nitems_return,
! 		    &bytes_after_return, &p );
! 	return( p );
!     }
!     return( (unsigned char *)NULL );
  }
  
  #define XIMP_MAXBUF 1024
***************
*** 207,213 ****
  	unsigned char *ct = _Ximp_Reset(ic);
  
  	if (!ct) return(NULL);
! 	mb = Xmalloc(length);
  	_Ximp_cttombs(ic->core.im->core.lcd, ct, strlen((char *)ct), mb, &length, NULL);
  	mb[length] = '\0';
  	return(mb);
--- 157,163 ----
  	unsigned char *ct = _Ximp_Reset(ic);
  
  	if (!ct) return(NULL);
! 	mb = Xmalloc(length+1);
  	_Ximp_cttombs(ic->core.im->core.lcd, ct, strlen((char *)ct), mb, &length, NULL);
  	mb[length] = '\0';
  	return(mb);
***************
*** 222,228 ****
  	unsigned char *ct = _Ximp_Reset(ic);
  
  	if (!ct) return(NULL);
! 	wc = (wchar_t *)Xmalloc(length * sizeof(wchar_t));
  	_Ximp_cttowcs(ic->core.im->core.lcd, ct, strlen((char *)ct), wc, &length, NULL);
  	wc[length] = (wchar_t)0;
  	return(wc);
--- 172,178 ----
  	unsigned char *ct = _Ximp_Reset(ic);
  
  	if (!ct) return(NULL);
! 	wc = (wchar_t *)Xmalloc((length + 1) * sizeof(wchar_t));
  	_Ximp_cttowcs(ic->core.im->core.lcd, ct, strlen((char *)ct), wc, &length, NULL);
  	wc[length] = (wchar_t)0;
  	return(wc);
***************
*** 399,405 ****
  	extern Ximp_XIM	*Ximp_Xim_List;
  
  	for(i = 0; i < Ximp_Xim_count; i++) {
! 		pim = Ximp_Xim_List[i];
  		for (pic = (Ximp_XIC)pim->core.ic_chain;
  			pic; pic = (Ximp_XIC)pic->core.next) {
  			if(pic->core.focus_window == window &&
--- 349,356 ----
  	extern Ximp_XIM	*Ximp_Xim_List;
  
  	for(i = 0; i < Ximp_Xim_count; i++) {
! 		if( (pim = Ximp_Xim_List[i]) == NULL )
! 			continue;
  		for (pic = (Ximp_XIC)pim->core.ic_chain;
  			pic; pic = (Ximp_XIC)pic->core.next) {
  			if(pic->core.focus_window == window &&
***************
*** 484,615 ****
  		NULL);
  	_Ximp_IM_SendMessage(ic, XIMP_BEGIN, NULL, NULL, NULL);
  	XFlush(ic->core.im->core.display);
  	return(True);
  }
  
- 
- typedef struct {
- 	Atom type;
- 	Window owner;
- } XimpCreatePredArgRec, *XimpCreatePredArg;
- 
- static Bool
- _Ximp_CreatePredicate(d, ev, arg0)
- Display *d;
- XEvent *ev;
- XPointer arg0;
- {
-     XimpCreatePredArg arg = (XimpCreatePredArg) arg0;
- 
- 	if (ev->type == ClientMessage) {
- 		if (ev->xclient.message_type == arg->type) {
- 			if (ev->xclient.format == 32) {
- 				switch (ev->xclient.data.l[0]) {
- 				case XIMP_CREATE_RETURN:
- 				case XIMP_ERROR:
- 					return(True);
- 				}
- 			}
- 		}
- 	} else if (ev->type == DestroyNotify) {
- 		if (ev->xdestroywindow.window == arg->owner) {
- 			return(True);
- 		}
- 	}
- 	return(False);
- }
- 
  Bool
  _Ximp_SetOpenXIMP(ic, mode)
  	Ximp_XIC	ic;
  	int		mode;
  {
! 	unsigned long	 mask;
! 	XEvent		 event;
! 	XimpCreatePredArgRec Arg;
  
! 	if(mode == XIMP_CREATE_IC) {  /* XCretaeIC() */
! 		if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
! 			ic->core.client_window = XCreateSimpleWindow(
! 				ic->core.im->core.display,
! 				DefaultRootWindow(ic->core.im->core.display),
! 				0, 0, 1, 1, 1, 0, 0);
! 		}
  	}
  
! 	if(!(ic->ximp_icpart->proto_mask & XIMP_FOCUS_WIN_MASK)) {
! 		ic->core.focus_window = ic->core.client_window;
! 	}
  	
! 	/* Property Data Set */
! 	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->version_id,
! 			XA_STRING, 8, PropModeReplace,
! 			(unsigned char *)XIMP_PROTOCOL_VERSION, strlen(XIMP_PROTOCOL_VERSION));
! 	XFlush(ic->core.im->core.display);
  
! 	mask = ic->ximp_icpart->proto_mask;
! 	_Ximp_SetFocusWindow(ic);
! 	mask |= XIMP_FOCUS_WIN_MASK;
! 	if(!(   (ic->core.input_style & XIMPreeditCallbacks)
! 	     || (ic->core.input_style & XIMPreeditNone) ) ) { 
! 		if(mask & XIMP_PROP_PREEDIT)
! 			_Ximp_SetPreeditAtr(ic);
! 		if(mask & XIMP_PROP_PREFONT)
! 			_Ximp_SetPreeditFont(ic);
! 		}
! 	else {
! 		mask &= ~(XIMP_PROP_PREEDIT | XIMP_PROP_PREFONT);
! 		}
! 	if(!(   (ic->core.input_style & XIMStatusCallbacks)
! 	     || (ic->core.input_style & XIMStatusNone) ) ) { 
! 		if(mask & XIMP_PROP_STATUS)
! 			_Ximp_SetStatusAtr(ic);
! 		if(mask & XIMP_PROP_STSFONT)
! 			_Ximp_SetStatusFont(ic);
! 		}
! 	else {
! 		mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
! 		}
  
! 	/* ClientMessage Send */
! 	_Ximp_IM_SendMessage(ic, XIMP_CREATE, ic->core.input_style, mask, NULL);
  
! #ifdef XIMP_SIGNAL
! 	signal(SIGALRM, _time_out);
! 	alarm(XIMP_TIME_OUT);
! #endif /* XIMP_SIGNAL */
! 	Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 	Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 	while(_time_flag != 1) {
! 		if( (XCheckIfEvent(ic->core.im->core.display, &event, _Ximp_CreatePredicate, (XPointer)&Arg)) == False) {
! #ifdef XIMP_SIGNAL
! 			sleep(1);
! #endif /* XIMP_SIGNAL */
! 			continue;
! 			}
! 		if(event.type == ClientMessage &&
! 		   event.xclient.data.l[0] == XIMP_CREATE_RETURN) {
! #ifdef XIMP_SIGNAL
! 			alarm(0);
! #endif /* XIMP_SIGNAL */
! 			ic->ximp_icpart->icid = (ICID)event.xclient.data.l[1];
! 			_Ximp_A_CreateExtension(ic);
! 			_time_flag = 0;
! 			return(True);
! 			}
! 		else {
! #ifdef XIMP_SIGNAL
! 			alarm(0);
! #endif /* XIMP_SIGNAL */
! 			_Ximp_ProcError (ic->core.im->core.display, NULL, &event);
! 			_time_flag = 0;
! 			/* return(False); */
! 			continue;
! 			}
! 		}
! 	_time_flag = 0;
! 	return(False);
  }
  
  void
--- 435,537 ----
  		NULL);
  	_Ximp_IM_SendMessage(ic, XIMP_BEGIN, NULL, NULL, NULL);
  	XFlush(ic->core.im->core.display);
+ 	_Ximp_CallRestartCallbackExtension( ic );
  	return(True);
  }
  
  Bool
  _Ximp_SetOpenXIMP(ic, mode)
  	Ximp_XIC	ic;
  	int		mode;
  {
!     unsigned long	mask;
!     XEvent		event;
!     XimpCMPredicateArgRec	Arg;
  
!     if(mode == XIMP_CREATE_IC) {  /* XCretaeIC() */
! 	if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
! 	    ic->core.client_window = XCreateSimpleWindow(
! 	    ic->core.im->core.display,
! 	    DefaultRootWindow(ic->core.im->core.display),
! 	    0, 0, 1, 1, 1, 0, 0);
  	}
+     }
  
!     if(!(ic->ximp_icpart->proto_mask & XIMP_FOCUS_WIN_MASK)) {
! 	ic->core.focus_window = ic->core.client_window;
!     }
  	
!     /* Property Data Set */
!     XChangeProperty(ic->core.im->core.display, ic->core.client_window,
! 		    ((Ximp_XIM)ic->core.im)->ximp_impart->version_id,
! 		    XA_STRING, 8, PropModeReplace,
! 		    (unsigned char *)XIMP_PROTOCOL_VERSION, strlen(XIMP_PROTOCOL_VERSION));
!     XFlush(ic->core.im->core.display);
  
!     mask = ic->ximp_icpart->proto_mask;
!     _Ximp_SetFocusWindow(ic);
!     mask |= XIMP_FOCUS_WIN_MASK;
!     if(!(   (ic->core.input_style & XIMPreeditCallbacks)
! 	 || (ic->core.input_style & XIMPreeditNone) ) ) { 
! 	    if(mask & XIMP_PROP_PREEDIT)
! 		    _Ximp_SetPreeditAtr(ic);
! 	    if(mask & XIMP_PROP_PREFONT)
! 		    _Ximp_SetPreeditFont(ic);
!     }
!     else {
! 	mask &= ~(XIMP_PROP_PREEDIT | XIMP_PROP_PREFONT);
!     }
!     if(!(   (ic->core.input_style & XIMStatusCallbacks)
! 	 || (ic->core.input_style & XIMStatusNone) ) ) { 
! 	if(mask & XIMP_PROP_STATUS)
! 	    _Ximp_SetStatusAtr(ic);
! 	if(mask & XIMP_PROP_STSFONT)
! 	    _Ximp_SetStatusFont(ic);
!     }
!     else {
! 	mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
!     }
  
!     /* ClientMessage Send */
!     _Ximp_IM_SendMessage(ic, XIMP_CREATE, ic->core.input_style, mask, NULL);
  
!     Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
!     Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
!     Arg.protocol = XIMP_CREATE_RETURN;
!     Arg.icid = 0;
!     if( _XimpIfEvent( ic, &event, _Ximp_CMPredicate, (XPointer)&Arg ) ) {
! 	ic->ximp_icpart->icid = (ICID)event.xclient.data.l[1];
! 	_Ximp_A_CreateExtension(ic);
! 	return(True);
!     }
!     else {
! 	XDeleteProperty( ic->core.im->core.display,
! 			ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id );
! 	if( !((ic->core.input_style & XIMPreeditCallbacks)  ||
! 	    (ic->core.input_style & XIMPreeditNone)) ) { 
! 	    if( mask & XIMP_PROP_PREEDIT )
! 		XDeleteProperty( ic->core.im->core.display,
! 			 ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id );
! 	    if( mask & XIMP_PROP_PREFONT )
! 		XDeleteProperty( ic->core.im->core.display,
! 			ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id );
! 	}
! 	if( !((ic->core.input_style & XIMStatusCallbacks)  ||
! 	    (ic->core.input_style & XIMStatusNone)) ) { 
! 	    if( mask & XIMP_PROP_STATUS )
! 		XDeleteProperty( ic->core.im->core.display,
! 			ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id );
! 	    if( mask & XIMP_PROP_STSFONT )
! 		XDeleteProperty( ic->core.im->core.display,
! 			ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id );
! 	}
! 	return( False );
!     }
  }
  
  void
***************
*** 622,628 ****
  	ev->keycode = 0;
  }
  
! void
  _Ximp_ProcKeypress (d, w, ev, kev)
  	Display			*d;
  	Window			w;
--- 544,550 ----
  	ev->keycode = 0;
  }
  
! Bool
  _Ximp_ProcKeypress (d, w, ev, kev)
  	Display			*d;
  	Window			w;
***************
*** 633,638 ****
--- 555,562 ----
  	Ximp_XIC 		ic;
  
  	icid = ev->data.l[1];
+ 	if( (ic = _Ximp_LookupXIC(icid)) == NULL )
+ 	    return( False );
  	kev->type = KeyPress;
  	kev->serial = ev->serial;
  	kev->send_event = False;
***************
*** 648,657 ****
  	kev->keycode = ev->data.l[2];
  	kev->state = ev->data.l[3];
  	kev->same_screen = True;
- 	ic = _Ximp_LookupXIC(icid);
  	if(ic->ximp_icpart->input_mode) { /* ON : input_mode */
  		ic->ximp_icpart->putback_key_event = True;
  	}
  }
  
  static void
--- 572,581 ----
  	kev->keycode = ev->data.l[2];
  	kev->state = ev->data.l[3];
  	kev->same_screen = True;
  	if(ic->ximp_icpart->input_mode) { /* ON : input_mode */
  		ic->ximp_icpart->putback_key_event = True;
  	}
+ 	return( True );
  }
  
  static void
***************
*** 677,683 ****
  	unsigned long		dummy_mask;
  
  	icid = ev->data.l[1];
! 	ic   = _Ximp_LookupXIC(icid);
  
  	if(ic->ximp_icpart->input_mode) /* ON : input_mode */
  		return;
--- 601,608 ----
  	unsigned long		dummy_mask;
  
  	icid = ev->data.l[1];
! 	if( (ic = _Ximp_LookupXIC(icid)) == NULL )
! 	    return;
  
  	if(ic->ximp_icpart->input_mode) /* ON : input_mode */
  		return;
***************
*** 709,715 ****
  	Ximp_XIC		ic;
  
  	icid = ev->data.l[1];
! 	ic   = _Ximp_LookupXIC(icid);
  	XSelectInput(d, ic->core.focus_window, ic->ximp_icpart->back_mask );
  	XFlush(d);
  	ic->ximp_icpart->input_mode = 0;
--- 634,641 ----
  	Ximp_XIC		ic;
  
  	icid = ev->data.l[1];
! 	if( (ic = _Ximp_LookupXIC(icid)) == NULL )
! 	    return;
  	XSelectInput(d, ic->core.focus_window, ic->ximp_icpart->back_mask );
  	XFlush(d);
  	ic->ximp_icpart->input_mode = 0;
***************
*** 735,741 ****
  	}
  	icid      = ev->data.l[1];
  	read_prop = ev->data.l[2];
! 	ic   = _Ximp_LookupXIC(icid);
  	rval = XGetWindowProperty( d,
  				((Ximp_XIM)ic->core.im)->ximp_impart->fe_window,
  				read_prop, 0, 1024, True,
--- 661,668 ----
  	}
  	icid      = ev->data.l[1];
  	read_prop = ev->data.l[2];
! 	if( (ic = _Ximp_LookupXIC(icid)) == NULL )
! 	    return;
  	rval = XGetWindowProperty( d,
  				((Ximp_XIM)ic->core.im)->ximp_impart->fe_window,
  				read_prop, 0, 1024, True,
***************
*** 751,757 ****
  }
  
  void
! _Ximp_ProcError (d, w, ev)
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
--- 678,685 ----
  }
  
  void
! _Ximp_ProcError (ic0, d, w, ev)
! 	Ximp_XIC		ic0;
  	Display			*d;
  	Window			w;
  	XClientMessageEvent	*ev;
***************
*** 766,773 ****
  	 *	you should modify this routine.
  	 */
  
! 	icid = ev->data.l[1];
! 	ic   = _Ximp_LookupXIC(icid);
  	if (ic->ximp_icpart->error.callback) {
  		data[0] = ev->data.l[2];
  		data[2] = ev->data.l[4];
--- 694,706 ----
  	 *	you should modify this routine.
  	 */
  
! 	if( (icid = ev->data.l[1]) != 0 ) {
! 		if( (ic = _Ximp_LookupXIC(icid)) == NULL )
! 			return;
! 	}
! 	else if( (ic = ic0) == NULL )
! 		return;
! 
  	if (ic->ximp_icpart->error.callback) {
  		data[0] = ev->data.l[2];
  		data[2] = ev->data.l[4];
***************
*** 812,818 ****
  	Ximp_XIC	ic;
  
  	icid = ev->data.l[1];
! 	ic   = _Ximp_LookupXIC(icid);
  	switch (ev->data.l[0]) {
  		case XIMP_GEOMETRY:
  			_Ximp_CallGeometryCallback (ic, ev);
--- 745,752 ----
  	Ximp_XIC	ic;
  
  	icid = ev->data.l[1];
! 	if( (ic = _Ximp_LookupXIC(icid)) == NULL )
! 	    return;
  	switch (ev->data.l[0]) {
  		case XIMP_GEOMETRY:
  			_Ximp_CallGeometryCallback (ic, ev);
***************
*** 866,873 ****
  	if (ev->format == 32) {
  		switch (ev->data.l[0]) {
  		case XIMP_KEYPRESS:
! 			_Ximp_ProcKeypress (d, w, ev, &kev);
! 			XPutBackEvent(d, (XEvent *)&kev);
  			break ;
  		case XIMP_CREATE_RETURN:
  			_Ximp_ProcCreateReturn (d, w, ev);
--- 800,809 ----
  	if (ev->format == 32) {
  		switch (ev->data.l[0]) {
  		case XIMP_KEYPRESS:
! 			if( _Ximp_ProcKeypress (d, w, ev, &kev) )
! 			    XPutBackEvent(d, (XEvent *)&kev);
! 			else
! 			    return( False );
  			break ;
  		case XIMP_CREATE_RETURN:
  			_Ximp_ProcCreateReturn (d, w, ev);
***************
*** 885,891 ****
  			XPutBackEvent(d, (XEvent *)ev);
  			break ;
  		case XIMP_ERROR:
! 			_Ximp_ProcError (d, w, ev);
  			break;
  		case XIMP_GEOMETRY:
  		case XIMP_PREEDITSTART:
--- 821,827 ----
  			XPutBackEvent(d, (XEvent *)ev);
  			break ;
  		case XIMP_ERROR:
! 			_Ximp_ProcError (NULL, d, w, ev);
  			break;
  		case XIMP_GEOMETRY:
  		case XIMP_PREEDITSTART:
***************
*** 947,952 ****
--- 883,889 ----
  		ximp_impart->fe_window = (Window)NULL;
  		for(ic = Ximp_Xim_List[i]->core.ic_chain; ic; ic = ic->core.next) {
  			((Ximp_XIC)ic)->ximp_icpart->icid = NULL;
+ 			_Ximp_CallDestroyCallbackExtension( ic );
  			_XUnregisterFilter(d,
  					   ic->core.focus_window,
  					   _Ximp_XimFilter_Client,
*** /tmp/d14114	Sat Aug  1 11:11:05 1992
--- mit/lib/X/Ximp/Ximplc.h	Sat Aug  1 11:10:57 1992
***************
*** 1,4 ****
! /* $XConsortium: Ximplc.h,v 1.5 92/04/14 13:30:42 rws Exp $ */
  /*
   * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
   * Copyright 1990, 1991, 1992 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: Ximplc.h,v 1.6 92/07/29 10:16:27 rws Exp $ */
  /*
   * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
   * Copyright 1990, 1991, 1992 by SORD Computer Corp.
***************
*** 72,77 ****
--- 72,80 ----
  #include "XIMProto.h"
  
  #define USE_SJIS	True
+ #ifdef SVR4
+ #define FIX_EUC32	True
+ #endif
  
  #define GL		0x00
  #define GR		0x80
***************
*** 354,359 ****
--- 357,364 ----
   	/* Extended Callback attribute */
  	Bool			 use_lookup_choices;
  	ICExtLookupAttributes	 lookup_attr;
+ 	XIMCallback		 restart;
+ 	XIMCallback		 destroy;
  
  	void			*ictype;
  	} XICXimpRec;
***************
*** 366,368 ****
--- 371,391 ----
  	XICCoreRec	 core;
  	XICXimpRec	*ximp_icpart;
  	} Ximp_XICRec;
+ 
+ /*
+  * predicate argument
+  */
+ typedef struct {
+ 	Atom	type;
+ 	Window	owner;
+ 	int	protocol;
+ 	ICID	icid;
+ } XimpCMPredicateArgRec, *XimpCMPredicateArg;
+ 
+ typedef struct {
+ 	Atom	type;
+ 	Window	owner;
+ 	ICID	icid;
+ 	Window	window;
+ 	Atom	atom;
+ } XimpPNPredicateArgRec, *XimpPNPredicateArg;
*** /tmp/d14313	Sat Aug  1 11:13:12 1992
--- mit/lib/X/Ximp/XimpExten.c	Sat Aug  1 11:13:05 1992
***************
*** 1,33 ****
! /* $XConsortium: XimpExten.c,v 1.5 92/04/14 13:29:00 rws Exp $ */
  /******************************************************************
  
      Copyright 1991, 1992 by FUJITSU LIMITED.
      Copyright 1991, 1992 by Sun Microsystems, Inc.
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
  provided that the above copyright notice appear in all copies and that
  both that copyright notice and this permission notice appear in
! supporting documentation, and that the name of FUJITSU LIMITED or Sun
! Microsystems, Inc.  not be used in advertising or publicity pertaining
! to distribution of the software without specific, written prior
! permission.  FUJITSU LIMITED and Sun Microsystems, Inc. make no
! representations about the suitability of this software for any
! purpose.  It is provided "as is" without express or implied warranty.
  
! FUJITSU LIMITED AND SUN MICROSYSTEMS, INC. DISCLAIMS ALL WARRANTIES
! WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU LIMITED AND SUN
! MICROSYSTEMS, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
! CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
! USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
! OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
! PERFORMANCE OF THIS SOFTWARE.
  
  Author: Takashi Fujiwara     FUJITSU LIMITED
- 		       fujiwara@a80.tech.yk.fujitsu.co.jp
          Hideki Hiura         Sun Microsystems, Inc.
! 	               hhiura@Sun.COM
  ******************************************************************/
  
  #define NEED_EVENTS
--- 1,34 ----
! /* $XConsortium: XimpExten.c,v 1.6 92/07/29 10:15:43 rws Exp $ */
  /******************************************************************
  
      Copyright 1991, 1992 by FUJITSU LIMITED.
      Copyright 1991, 1992 by Sun Microsystems, Inc.
+     Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
  provided that the above copyright notice appear in all copies and that
  both that copyright notice and this permission notice appear in
! supporting documentation, and that the name of FUJITSU LIMITED, Sun
! Microsystems, Inc. and Sony Corporation not be used in advertising
! or publicity pertaining to distribution of the software without
! specific, written prior permission. FUJITSU LIMITED, Sun Microsystems,
! Inc. and Sony Corporation make no representations about the suitability
! of this software for any purpose.  It is provided "as is" without
! express or implied warranty.
  
! FUJITSU LIMITED, SUN MICROSYSTEMS, INC. AND SONY CORPORATION DISCLAIMS
! ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
! WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU
! LIMITED, SUN MICROSYSTEMS, INC. AND SONY CORPORATION BE LIABLE FOR
! ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
! OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  
  Author: Takashi Fujiwara     FUJITSU LIMITED
          Hideki Hiura         Sun Microsystems, Inc.
!         Makoto Wakamatsu     Sony Corporation
  ******************************************************************/
  
  #define NEED_EVENTS
***************
*** 37,54 ****
  #include "Xlcint.h"
  #include "Ximplc.h"
  
- #ifdef XIMP_SIGNAL
- #include <sys/signal.h>
- #endif /* XIMP_SIGNAL */
- static int	_time_flag = 0;
- #ifdef XIMP_SIGNAL
- static int
- _time_out()
- 	{
- 	_time_flag = 1;
- 	}
- #endif /* XIMP_SIGNAL */
- 
  #define		XIM_UNKNOWN_KEYSYM	0x77777777
  #define		XIM_UNDETERMINED	0x77777776
  
--- 38,43 ----
***************
*** 144,149 ****
--- 133,140 ----
  #define XNExtXimp_AuxProcessCallback    "XNExtXimp_AuxProcessCallback"
  #define XNExtXimp_AuxDoneCallback       "XNExtXimp_AuxDoneCallback"
  #define XNExtXimp_LookupBegin	        "XNExtXimp_LookupBegin"
+ #define XNExtXimp_RestartCallback	"XNExtXimp_RestartCallback"
+ #define XNExtXimp_DestroyCallback	"XNExtXimp_DestroyCallback"
  
  /*
   * Ximp properties for extented XIC attribute
***************
*** 202,207 ****
--- 193,200 ----
  Private int     ximp_ext_aux_draw_callback();
  Private int     ximp_ext_aux_process_callback();
  Private int     ximp_ext_aux_done_callback();
+ Private int     ximp_ext_restart_callback();
+ Private int     ximp_ext_destroy_callback();
  Private int	nested_list();
  
  /* If you need to extend IC attributes, please add function here */
***************
*** 228,233 ****
--- 221,228 ----
  	XNExtXimp_AuxProcessCallback, ximp_ext_aux_process_callback,
  	XNExtXimp_AuxDoneCallback, ximp_ext_aux_done_callback,
  	XNExtXimp_LookupBegin, ximp_ext_lookup_begin,
+ 	XNExtXimp_RestartCallback, ximp_ext_restart_callback,
+ 	XNExtXimp_DestroyCallback, ximp_ext_destroy_callback,
      /*
       * If you need to extend IC attributes, please add attribute/function
       * here
***************
*** 302,310 ****
  
  
  typedef struct {
! 	Atom message_type;
! 	Atom ext_type;
! 	Window owner;
  } XimpConversionPredArgRec, *XimpConversionPredArg;
  
  Private Bool
--- 297,306 ----
  
  
  typedef struct {
! 	Atom	message_type;
! 	Atom	ext_type;
! 	Window	owner;
! 	ICID	icid;
  } XimpConversionPredArgRec, *XimpConversionPredArg;
  
  Private Bool
***************
*** 323,344 ****
  {
      XimpConversionPredArg arg = (XimpConversionPredArg) arg0;
  
! 	if (ev->type == ClientMessage) {
! 		if (ev->xclient.message_type == arg->message_type) {
! 			if (ev->xclient.format == 32) {
! 				if(ev->xclient.data.l[0] == XIMP_ERROR)
! 					return(True);
! 				else if(ev->xclient.data.l[0] == XIMP_EXTENSION
! 				     && ev->xclient.data.l[3] == arg->ext_type)
! 					return(True);
! 			}
! 		}
! 	} else if (ev->type == DestroyNotify) {
! 		if (ev->xdestroywindow.window == arg->owner) {
! 			return(True);
! 		}
  	}
! 	return(False);
  }
  
  Private int
--- 319,340 ----
  {
      XimpConversionPredArg arg = (XimpConversionPredArg) arg0;
  
!     if( ev->type == ClientMessage ) {
! 	if( ev->xclient.message_type == arg->message_type  &&
! 	    ev->xclient.format == 32  &&
! 	    ev->xclient.data.l[1] == arg->icid ) {
! 	    if( ev->xclient.data.l[0] == XIMP_ERROR )
! 		return( True );
! 	    else if( ev->xclient.data.l[0] == XIMP_EXTENSION  &&
! 		     ev->xclient.data.l[2] == arg->ext_type )
! 		return( True );
  	}
!     } else if( ev->type == DestroyNotify ) {
! 	if( ev->xdestroywindow.window == arg->owner ) {
! 	    return( True );
! 	}
!     }
!     return( False );
  }
  
  Private int
***************
*** 376,428 ****
  	return True;
  	break;
      case XICOpGet:
! 	if(ic->ximp_icpart->icid == NULL) {
! 		if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver)
! 			return (False);
! 		*((long *) value) = (long)(ext_im->extension_conversion);
! 		return (True);
! 		}
! 	_Ximp_IM_SendMessage(ic, XIMP_EXTENSION,
  		     ext_im->extension_conversion_id,
  		     False,	/* GetICVelues */
! 		     value);
! #ifdef XIMP_SIGNAL
! 	signal(SIGALRM, _time_out);
! 	alarm(XIMP_TIME_OUT);
! #endif /* XIMP_SIGNAL */
  	Arg.message_type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 	Arg.ext_type     = ext_im->extension_conversion_id;
  	Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 	while(_time_flag != 1) {
! 		if( (XCheckIfEvent(ic->core.im->core.display, &event, ximp_ext_conversionPredicate, (XPointer)&Arg)) == False) {
! #ifdef XIMP_SIGNAL
! 			sleep(1);
! #endif /* XIMP_SIGNAL */
! 			continue;
! 			}
! 		if(event.type == ClientMessage &&
! 		   event.xclient.data.l[0] == XIMP_EXTENSION) {
! #ifdef XIMP_SIGNAL
! 			alarm(0);
! #endif /* XIMP_SIGNAL */
! 			ext_im->extension_conversion = (Bool)event.xclient.data.l[4];
! 			*((long *) value) = (long)(ext_im->extension_conversion);
! 			_time_flag = 0;
! 			return(True);
! 			}
! 		else {
! #ifdef XIMP_SIGNAL
! 			alarm(0);
! #endif /* XIMP_SIGNAL */
! 			_Ximp_ProcError (ic->core.im->core.display, NULL, &event);
! 			_time_flag = 0;
! 			/* return(False); */
! 			continue;
! 			}
! 		}
! 	_time_flag = 0;
! 	return(False);
! 	break;
      }
      return (False);
  }
--- 372,396 ----
  	return True;
  	break;
      case XICOpGet:
! 	if( ic->ximp_icpart->icid == NULL ) {
! 	    if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver)
! 		return( False );
! 	    *((long *) value) = (long)(ext_im->extension_conversion);
! 	    return (True);
! 	}
! 	_Ximp_IM_SendMessage( ic, XIMP_EXTENSION,
  		     ext_im->extension_conversion_id,
  		     False,	/* GetICVelues */
! 		     value );
  	Arg.message_type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 	Arg.ext_type = ext_im->extension_conversion_id;
  	Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 	Arg.icid = ic->ximp_icpart->icid;
! 	if( !_XimpIfEvent( ic, &event, ximp_ext_conversionPredicate, (XPointer)&Arg ) )
! 	    return( False );
! 	ext_im->extension_conversion = (Bool)event.xclient.data.l[4];
! 	*((long *) value) = (long)(ext_im->extension_conversion);
! 	return( True );
      }
      return (False);
  }
***************
*** 714,719 ****
--- 682,733 ----
      return (False);
  }
  
+ Private int
+ ximp_ext_restart_callback( ic, op, value )
+ Ximp_XIC        ic;
+ XICOp_t         op;
+ long            value;
+ {
+     switch( op ) {
+       case XICOpCreate:
+       case XICOpSet:
+ 	ic->ximp_icpart->restart.client_data = ((XIMCallback *)value)->client_data;
+ 	ic->ximp_icpart->restart.callback = ((XIMCallback *)value)->callback;
+ 	return( True );
+ 	break;
+ 
+       case XICOpGet:
+ 	/*
+ 	 * NOT surely implemented Yet. Need attention.
+ 	 */
+ 	break;
+     }
+     return( False );
+ }
+ 
+ Private int
+ ximp_ext_destroy_callback( ic, op, value )
+ Ximp_XIC        ic;
+ XICOp_t         op;
+ long            value;
+ {
+     switch( op ) {
+       case XICOpCreate:
+       case XICOpSet:
+ 	ic->ximp_icpart->destroy.client_data = ((XIMCallback *)value)->client_data;
+ 	ic->ximp_icpart->destroy.callback = ((XIMCallback *)value)->callback;
+ 	return( True );
+ 	break;
+ 
+       case XICOpGet:
+ 	/*
+ 	 * NOT surely implemented Yet. Need attention.
+ 	 */
+ 	break;
+     }
+     return( False );
+ }
+ 
  static void _Ximp_Extlookupstart();
  static void _Ximp_Extlookupdraw();
  static void _Ximp_Extlookupprocess();
***************
*** 1277,1283 ****
  
      icid = ev->data.l[1];
      ext_id = ev->data.l[2];
!     ic = _Ximp_LookupXIC(icid);
  
      im_impart = ((Ximp_XIM)ic->core.im)->ximp_impart;
      ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
--- 1291,1298 ----
  
      icid = ev->data.l[1];
      ext_id = ev->data.l[2];
!     if( (ic = _Ximp_LookupXIC(icid)) == NULL )
! 	return;
  
      im_impart = ((Ximp_XIM)ic->core.im)->ximp_impart;
      ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
***************
*** 1290,1293 ****
--- 1305,1333 ----
      } else;
      /* Add extension here */
      return;
+ }
+ 
+ 
+ void
+ _Ximp_CallRestartCallbackExtension( xic )
+ Ximp_XIC		xic;
+ {
+     register	XIMCallback	*cb;
+ 
+     cb = &xic->ximp_icpart->restart;
+     if( cb->callback ) {
+ 	(*cb->callback)( xic, cb->client_data, NULL );
+     }
+ }
+ 
+ void
+ _Ximp_CallDestroyCallbackExtension( xic )
+ Ximp_XIC		xic;
+ {
+     register	XIMCallback	*cb;
+ 
+     cb = &xic->ximp_icpart->destroy;
+     if( cb->callback ) {
+ 	(*cb->callback)( xic, cb->client_data, NULL );
+     }
  }
*** /tmp/d14350	Sat Aug  1 11:13:38 1992
--- mit/lib/X/Ximp/XimpICG.c	Sat Aug  1 11:13:33 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpICG.c,v 1.8 92/04/22 15:46:03 rws Exp $ */
  /******************************************************************
  
      Copyright 1991, 1992 by FUJITSU LIMITED.
--- 1,4 ----
! /* $XConsortium: XimpICG.c,v 1.9 92/07/29 10:15:56 rws Exp $ */
  /******************************************************************
  
      Copyright 1991, 1992 by FUJITSU LIMITED.
***************
*** 28,34 ****
  
  Author: Takashi Fujiwara     FUJITSU LIMITED
          Hideki Hiura         Sun Microsystems, Inc.
!         Makoto Wakamatsu     Sony Corporaion
  
  ******************************************************************/
  
--- 28,34 ----
  
  Author: Takashi Fujiwara     FUJITSU LIMITED
          Hideki Hiura         Sun Microsystems, Inc.
!         Makoto Wakamatsu     Sony Corporation
  
  ******************************************************************/
  
***************
*** 40,51 ****
  
  #include "Ximplc.h"
  
- #ifdef XIMP_SIGNAL
- #include <sys/signal.h>
- #endif /* XIMP_SIGNAL */
- 
  extern char 		*_Ximp_GetICValues();
  extern Bool		 _Ximp_GetICExtension();
  
  static Bool 		 _Ximp_PreGetAttributes();
  static Bool 		 _Ximp_StatusGetAttributes();
--- 40,48 ----
  
  #include "Ximplc.h"
  
  extern char 		*_Ximp_GetICValues();
  extern Bool		 _Ximp_GetICExtension();
+ extern Bool		_Ximp_CMPredicate();
  
  static Bool 		 _Ximp_PreGetAttributes();
  static Bool 		 _Ximp_StatusGetAttributes();
***************
*** 629,658 ****
  	return(True);
  }
  
- static int	 _time_flag = 0;
- 
- #ifdef XIMP_SIGNAL
- static int
- _time_out()
- {
- 	_time_flag = 1;
- }
- #endif /* XIMP_SIGNAL */
- 
- static Bool Check_Message(display, event, arg)
-     Display *display;
-     XEvent  *event;
-     XPointer arg;
- {
-     if ( event->type == ClientMessage && 
- 	 event->xclient.message_type == 
- 	 ((Ximp_XIM)arg)->ximp_impart->improtocol_id )
- 	return True;
-     else
- 	return False;
- }
- 
- 
  static XPointer
  _Ximp_GetRequestIM(ic, mask, get_atom_id, atom_id)
  	Ximp_XIC	 ic;
--- 626,631 ----
***************
*** 659,708 ****
  	unsigned long	 mask;
  	Atom		 get_atom_id, atom_id;
  {
! 	XEvent		 event;
! 	Atom            actual_type_ret;
! 	int		actual_format_ret;
! 	unsigned long   nitems_ret;
! 	unsigned long   bytes_after_ret;
! 	unsigned char   *data;
  
! 	if(ic->ximp_icpart->icid == (ICID)NULL)
! 		return(NULL);
! 	if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN))
! 		return(NULL);
  
! 	_Ximp_IM_SendMessage(ic, XIMP_GETVALUE, mask, NULL, NULL);
! #ifdef XIMP_SIGNAL
! 	signal(SIGALRM, _time_out);
! 	alarm(XIMP_TIME_OUT);
! #endif /* XIMP_SIGNAL */
  
! 	while(_time_flag != 1) {
! 		if (XCheckIfEvent(ic->core.im->core.display, &event, 
! 			Check_Message, (XPointer)ic->core.im) ) {
! #ifdef XIMP_SIGNAL
! 			alarm(0);
! #endif /* XIMP_SIGNAL */
! 			break;
! 		} else {
! #ifdef XIMP_SIGNAL
! 			sleep(1);
! #endif /* XIMP_SIGNAL */
! 			continue;
! 		}
! 	}
! 	_time_flag = 0;
  
! 	if(event.xclient.data.l[0] != XIMP_GETVALUE_RETURN)
! 		return(NULL);
! 
! 	XGetWindowProperty(ic->core.im->core.display,
! 			   ic->core.client_window,
! 			   get_atom_id, 0L, 1000000L, True, atom_id,
! 			   &actual_type_ret, &actual_format_ret, &nitems_ret,
! 			   &bytes_after_ret, &data);
! 
!         if(actual_format_ret == 0 || nitems_ret == 0)
! 		return(NULL);
! 	return((XPointer)data);
  }
--- 632,665 ----
  	unsigned long	 mask;
  	Atom		 get_atom_id, atom_id;
  {
!     XEvent		event;
!     Atom        	actual_type_ret;
!     int			actual_format_ret;
!     unsigned long	nitems_ret;
!     unsigned long	bytes_after_ret;
!     unsigned char	*data;
!     XimpCMPredicateArgRec	Arg;
  
!     if(ic->ximp_icpart->icid == (ICID)NULL)
! 	return(NULL);
!     if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN))
! 	return(NULL);
  
!     _Ximp_IM_SendMessage(ic, XIMP_GETVALUE, mask, NULL, NULL);
!     Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
!     Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
!     Arg.protocol = XIMP_GETVALUE_RETURN;
!     Arg.icid = ic->ximp_icpart->icid;
!     if( !_XimpIfEvent( ic, &event, _Ximp_CMPredicate, (XPointer)&Arg ) )
! 	return( NULL );
  
!     XGetWindowProperty(ic->core.im->core.display,
! 		       ic->core.client_window,
! 		       get_atom_id, 0L, 1000000L, True, atom_id,
! 		       &actual_type_ret, &actual_format_ret, &nitems_ret,
! 		       &bytes_after_ret, &data);
  
!     if(actual_format_ret == 0 || nitems_ret == 0)
! 	return(NULL);
!     return((XPointer)data);
  }
*** /tmp/d14390	Sat Aug  1 11:14:08 1992
--- mit/lib/X/Ximp/XimpICS.c	Sat Aug  1 11:13:58 1992
***************
*** 1,8 ****
! /* $XConsortium: XimpICS.c,v 1.3 92/04/14 13:29:14 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporaion
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,8 ----
! /* $XConsortium: XimpICS.c,v 1.4 92/07/29 10:16:04 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 26,35 ****
  OR PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
!           Makoto Wakamatsu     Sony Corporaion
  
  ******************************************************************/
  
  #include "Xlibint.h"
  #include "Xlcint.h"
  
--- 26,36 ----
  OR PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
!           Makoto Wakamatsu     Sony Corporation
  
  ******************************************************************/
  
+ #define	NEED_EVENTS
  #include "Xlibint.h"
  #include "Xlcint.h"
  
***************
*** 51,56 ****
--- 52,128 ----
  static Bool		_Ximp_PreSetAttributes();
  static Bool		_Ximp_StatusSetAttributes();
  
+ 
+ static Bool
+ _Ximp_PNPredicate( d, ev, arg0 )
+ Display		*d;
+ XEvent		*ev;
+ XPointer	arg0;
+ {
+     XimpPNPredicateArg arg = (XimpPNPredicateArg)arg0;
+ 
+     if( ev->type == PropertyNotify ) {
+ 	if( ev->xproperty.window == arg->window  &&
+ 	    ev->xproperty.atom == arg->atom  &&
+ 	    ev->xproperty.state == PropertyDelete ) {
+ 	    return(True);
+ 	}
+     }
+     else if( ev->type == ClientMessage ) {
+ 	if( ev->xclient.message_type == arg->type  &&
+ 	    ev->xclient.format == 32  &&
+ 	    ev->xclient.data.l[1] == arg->icid  &&
+ 	    ev->xclient.data.l[0] == XIMP_ERROR )
+ 	    return( True );
+     }
+     else if( ev->type == DestroyNotify ) {
+ 	if( ev->xdestroywindow.window == arg->owner ) {
+ 	    return( True );
+ 	}
+     }
+     return( False );
+ }
+ 
+ Bool
+ _XimpPNIfEvent( ic, atom )
+ Ximp_XIC	ic;
+ Atom		atom;
+ {
+     XEvent			event;
+     XimpPNPredicateArgRec	Arg;	
+ 
+     Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
+     Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
+     Arg.icid = ic->ximp_icpart->icid;
+     Arg.window = ic->core.client_window;
+     Arg.atom = atom;
+     XIfEvent( ic->core.im->core.display, &event, _Ximp_PNPredicate, (XPointer)&Arg );
+     if( event.type != PropertyNotify ) {
+ 	XPutBackEvent( ic->core.im->core.display, &event );
+ 	XDeleteProperty( ic->core.im->core.display,
+ 			 ic->core.client_window,
+ 			 ((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id );
+ 	XDeleteProperty( ic->core.im->core.display,
+ 			 ic->core.client_window,
+ 			 ((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id );
+ 	XDeleteProperty( ic->core.im->core.display,
+ 			 ic->core.client_window,
+ 			 ((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id );
+ 	XDeleteProperty( ic->core.im->core.display,
+ 			 ic->core.client_window,
+ 			 ((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id );
+ 	XDeleteProperty( ic->core.im->core.display,
+ 			 ic->core.client_window,
+ 			 ((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id );
+ 	if( event.type == DestroyNotify )
+ 	    XPutBackEvent( ic->core.im->core.display, &event );
+ 	else
+ 	    _Ximp_ProcError( ic, ic->core.im->core.display, NULL, &event );
+ 	return( False );
+     }
+     return( True );
+ }
+ 
  char *
  _Ximp_SetICValues(ic, values)
  	Ximp_XIC	 ic;
***************
*** 117,126 ****
  	else {
  		change_mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
  		}
! 	if(change_mask)
!  		_Ximp_IM_SendMessage(ic, XIMP_SETVALUE, change_mask, NULL, NULL);
! 	return(ret);
  	}
  
  char *
  _Ximp_SetICValueData(ic, values, mode, change_mask)
--- 189,222 ----
  	else {
  		change_mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
  		}
! 	if(change_mask) {
! 	    XWindowAttributes		war;
! 	    long			mask;
! 
! 	    XGetWindowAttributes( ic->core.im->core.display,
! 				  ic->core.client_window, &war );
! 	    XSelectInput( ic->core.im->core.display, ic->core.client_window,
! 			  war.your_event_mask | PropertyChangeMask );
! 	    _Ximp_IM_SendMessage(ic, XIMP_SETVALUE, change_mask, NULL, NULL);
! 	    if( change_mask & XIMP_PROP_FOCUS )
! 		if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id ) )
! 		    change_mask = 0;
! 	    if( change_mask & XIMP_PROP_PREEDIT )
! 		if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id ) )
! 		    change_mask = 0;
! 	    if( change_mask & XIMP_PROP_PREFONT )
! 		if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id ) )
! 		    change_mask = 0;
! 	    if( change_mask & XIMP_PROP_STATUS )
! 		if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id ) )
! 		    change_mask = 0;
! 	    if( change_mask & XIMP_PROP_STSFONT )
! 		!_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id );
! 	    XSelectInput( ic->core.im->core.display, ic->core.client_window,
! 			  war.your_event_mask );
  	}
+ 	return(ret);
+ }
  
  char *
  _Ximp_SetICValueData(ic, values, mode, change_mask)
***************
*** 144,158 ****
  		else if(strcmp(p->name, XNClientWindow)==0) {
  			if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
  				if(mode == XIMP_SET_IC && (ic->ximp_icpart->icid)) {
! 					_Ximp_IM_SendMessage(ic, XIMP_DESTROY, NULL, NULL, NULL);
! 					XDestroyWindow(ic->core.im->core.display,
! 						       ic->core.client_window);
! 					ic->core.client_window = (Window)p->value;
  					ic->ximp_icpart->value_mask |= XIMP_CLIENT_WIN;
  					if(_Ximp_SetOpenXIMP(ic, mode) == False) {
  						return_name = p->name;
  						break;
  						}
  					*change_mask = NULL;
  					}
  				else { /* XIMP_CREATE_IC | (XIMP_SET_IC && XIMP_START_IC) */
--- 240,264 ----
  		else if(strcmp(p->name, XNClientWindow)==0) {
  			if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
  				if(mode == XIMP_SET_IC && (ic->ximp_icpart->icid)) {
! 					long	icid_old, icid_new;
! 					Window	client_window;
! 
! 					icid_old = ic->ximp_icpart->icid;
! 					client_window = ic->core.client_window;
  					ic->ximp_icpart->value_mask |= XIMP_CLIENT_WIN;
+ 					ic->core.client_window = (Window)p->value;
  					if(_Ximp_SetOpenXIMP(ic, mode) == False) {
  						return_name = p->name;
+ 						ic->ximp_icpart->value_mask &= ~XIMP_CLIENT_WIN;
+ 						ic->core.client_window = client_window;
  						break;
  						}
+ 					icid_new = ic->ximp_icpart->icid;
+ 					ic->ximp_icpart->icid = icid_old;
+ 					_Ximp_IM_SendMessage(ic, XIMP_DESTROY, NULL, NULL, NULL);
+ 					ic->ximp_icpart->icid = icid_new;
+ 					XDestroyWindow(ic->core.im->core.display,
+ 						       client_window);
  					*change_mask = NULL;
  					}
  				else { /* XIMP_CREATE_IC | (XIMP_SET_IC && XIMP_START_IC) */
***************
*** 333,339 ****
  				for(i = 0, len = 0; i < list_ret; i++) {
  					len += strlen(name_list[i]);
  					}
! 				tmp = Xmalloc(len + i + 1);
  				tmp[0] = NULL;
  				for(i = 0; i < list_ret; i++) {
  					strcat(tmp, name_list[i]);
--- 439,448 ----
  				for(i = 0, len = 0; i < list_ret; i++) {
  					len += strlen(name_list[i]);
  					}
! 				if( (tmp = Xmalloc(len + i + 1)) == NULL ) {
! 				    return_name = p->name;
! 				    return( False );
! 				}
  				tmp[0] = NULL;
  				for(i = 0; i < list_ret; i++) {
  					strcat(tmp, name_list[i]);
***************
*** 480,486 ****
  				for(i = 0, len = 0; i < list_ret; i++) {
  					len += strlen(name_list[i]);
  					}
! 				tmp = Xmalloc(len + i + 1);
  				tmp[0] = NULL;
  				for(i = 0; i < list_ret; i++) {
  					strcat(tmp, name_list[i]);
--- 589,598 ----
  				for(i = 0, len = 0; i < list_ret; i++) {
  					len += strlen(name_list[i]);
  					}
! 				if( (tmp = Xmalloc(len + i + 1)) == NULL ) {
! 				    return_name = p->name;
! 				    return( False );
! 				}
  				tmp[0] = NULL;
  				for(i = 0; i < list_ret; i++) {
  					strcat(tmp, name_list[i]);
*** /tmp/d14669	Sat Aug  1 11:17:05 1992
--- mit/lib/X/Ximp/XimpRm.c	Sat Aug  1 11:16:54 1992
***************
*** 1,8 ****
! /* $XConsortium: XimpRm.c,v 1.4 92/04/14 13:29:56 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporaion
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
--- 1,8 ----
! /* $XConsortium: XimpRm.c,v 1.5 92/07/29 10:16:22 rws Exp $ */
  /******************************************************************
  
                Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporation
  
  Permission to use, copy, modify, distribute, and sell this software
  and its documentation for any purpose is hereby granted without fee,
***************
*** 26,32 ****
  OR PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
!           Makoto Wakamatsu     Sony Corporaion
  
  ******************************************************************/
  
--- 26,32 ----
  OR PERFORMANCE OF THIS SOFTWARE.
  
    Author: Takashi Fujiwara     FUJITSU LIMITED 
!           Makoto Wakamatsu     Sony Corporation
  
  ******************************************************************/
  
***************
*** 175,181 ****
  	{
  	char		 res_name[256];
  	char		 res_class[256];
! 	char		*str_type[50];
  	XrmValue	 value;
  	Bool		 ret = False;
  	KeySym		 keysym = NoSymbol;
--- 175,181 ----
  	{
  	char		 res_name[256];
  	char		 res_class[256];
! 	char		*str_type;
  	XrmValue	 value;
  	Bool		 ret = False;
  	KeySym		 keysym = NoSymbol;
***************
*** 189,195 ****
  	strcat(res_name, "inputserver");
  	strcat(res_class, "Inputserver");
  	if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				str_type, &value) == True) { 
  		if(strcmp(value.addr, "off") == 0) {
  			/* Keysym */
  			_Ximp_Get_resource_name(im, res_name, res_class);
--- 189,195 ----
  	strcat(res_name, "inputserver");
  	strcat(res_class, "Inputserver");
  	if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				&str_type, &value) == True) { 
  		if(strcmp(value.addr, "off") == 0) {
  			/* Keysym */
  			_Ximp_Get_resource_name(im, res_name, res_class);
***************
*** 196,202 ****
  			strcat(res_name, "startkeysym");
  			strcat(res_class, "Startkeysym");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				str_type, &value) == True) { 
  				keysym = XStringToKeysym(value.addr);
  				}
  			ret = False;
--- 196,202 ----
  			strcat(res_name, "startkeysym");
  			strcat(res_class, "Startkeysym");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				&str_type, &value) == True) { 
  				keysym = XStringToKeysym(value.addr);
  				}
  			ret = False;
***************
*** 220,226 ****
  			strcat(res_name, "processStartKeys");
  			strcat(res_class, "ProcessStartKeys");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 						str_type, &value)  == True) {
  				char	*string, *ss, c;
  				char	*line;
  
--- 220,226 ----
  			strcat(res_name, "processStartKeys");
  			strcat(res_class, "ProcessStartKeys");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 						&str_type, &value)  == True) {
  				char	*string, *ss, c;
  				char	*line;
  
***************
*** 249,255 ****
  	strcat(res_name, "callbackEncoding");
  	strcat(res_class, "CallbackEncoding");
  	if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				str_type, &value) == True) { 
  		if(strcmp(value.addr, "wchar") == 0) {
  			im->ximp_impart->use_wchar = True;
  			}
--- 249,255 ----
  	strcat(res_name, "callbackEncoding");
  	strcat(res_class, "CallbackEncoding");
  	if(XrmGetResource(im->core.rdb, res_name, res_class,
! 				&str_type, &value) == True) { 
  		if(strcmp(value.addr, "wchar") == 0) {
  			im->ximp_impart->use_wchar = True;
  			}
***************
*** 267,273 ****
  	Ximp_XIM	 im;
  	char		 res_name[256];
  	char		 res_class[256];
! 	char		*str_type[50];
  	XrmValue	 value;
  	Colormap	 default_colormap;
  	XColor		 screen_def, exact_def;
--- 267,273 ----
  	Ximp_XIM	 im;
  	char		 res_name[256];
  	char		 res_class[256];
! 	char		*str_type;
  	XrmValue	 value;
  	Colormap	 default_colormap;
  	XColor		 screen_def, exact_def;
***************
*** 284,290 ****
  			strcat(res_name, "preedit.background");
  			strcat(res_class, "Preedit.Background");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					str_type, &value) == True) { 
  				default_colormap = DefaultColormap(
  						im->core.display,
  						DefaultScreen(im->core.display) );
--- 284,290 ----
  			strcat(res_name, "preedit.background");
  			strcat(res_class, "Preedit.Background");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					&str_type, &value) == True) { 
  				default_colormap = DefaultColormap(
  						im->core.display,
  						DefaultScreen(im->core.display) );
***************
*** 304,310 ****
  			strcat(res_name, "preedit.foreground");
  			strcat(res_class, "Preedit.Foreground");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					str_type, &value) == True) { 
  				default_colormap = DefaultColormap(
  						im->core.display,
  						DefaultScreen(im->core.display) );
--- 304,310 ----
  			strcat(res_name, "preedit.foreground");
  			strcat(res_class, "Preedit.Foreground");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					&str_type, &value) == True) { 
  				default_colormap = DefaultColormap(
  						im->core.display,
  						DefaultScreen(im->core.display) );
***************
*** 324,330 ****
  			strcat(res_name, "preedit.linespacing");
  			strcat(res_class, "Preedit.Linespacing");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					str_type, &value) == True) { 
  				num = atoi(value.addr);
  				ic->core.preedit_attr.line_space = num;
  				ic->ximp_icpart->preedit_attr.LineSpacing = 
--- 324,330 ----
  			strcat(res_name, "preedit.linespacing");
  			strcat(res_class, "Preedit.Linespacing");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					&str_type, &value) == True) { 
  				num = atoi(value.addr);
  				ic->core.preedit_attr.line_space = num;
  				ic->ximp_icpart->preedit_attr.LineSpacing = 
***************
*** 341,347 ****
  			strcat(res_name, "status.background");
  			strcat(res_class, "Status.Background");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					str_type, &value) == True) { 
  				default_colormap = DefaultColormap(
  						im->core.display,
  						DefaultScreen(im->core.display) );
--- 341,347 ----
  			strcat(res_name, "status.background");
  			strcat(res_class, "Status.Background");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					&str_type, &value) == True) { 
  				default_colormap = DefaultColormap(
  						im->core.display,
  						DefaultScreen(im->core.display) );
***************
*** 362,368 ****
  			strcat(res_name, "status.foreground");
  			strcat(res_class, "Status.Foreground");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					str_type, &value) == True) { 
  				default_colormap = DefaultColormap(
  						im->core.display,
  						DefaultScreen(im->core.display) );
--- 362,368 ----
  			strcat(res_name, "status.foreground");
  			strcat(res_class, "Status.Foreground");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					&str_type, &value) == True) { 
  				default_colormap = DefaultColormap(
  						im->core.display,
  						DefaultScreen(im->core.display) );
***************
*** 382,388 ****
  			strcat(res_name, "status.linespacing");
  			strcat(res_class, "Status.Linespacing");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					str_type, &value) == True) { 
  				num = atoi(value.addr);
  				ic->core.status_attr.line_space = num;
  				ic->ximp_icpart->status_attr.LineSpacing = 
--- 382,388 ----
  			strcat(res_name, "status.linespacing");
  			strcat(res_class, "Status.Linespacing");
  			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 					&str_type, &value) == True) { 
  				num = atoi(value.addr);
  				ic->core.status_attr.line_space = num;
  				ic->ximp_icpart->status_attr.LineSpacing = 

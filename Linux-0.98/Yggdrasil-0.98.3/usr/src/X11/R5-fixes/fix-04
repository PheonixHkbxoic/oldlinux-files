		      Release 5 Public Patch #4
			   MIT X Consortium

To apply this patch:

cd to the top of the source tree (to the directory containing the "mit"
and "contrib" subdirectories) and do:
	patch -p -s < ThisFile
Patch will work silently unless an error occurs.  You will likely get
the following warning messages, which can be ignored:
	mkdir: mit: File exists
	mkdir: mit/fonts: File exists
	mkdir: mit/fonts/lib: File exists
	mkdir: mit/fonts/lib/font: File exists
	mkdir: mit/fonts/lib/font/util: File exists
If you want to watch patch do its thing, leave out the "-s" argument to patch.

Finally, to rebuild after applying this patch, cd to the "mit" subdirectory
and do:
	make Everything >& every.log
Note: this will *not* "clean" your tree.

Brief notes on what this patch fixes:

Xt: XtOrderProc needs to be externally visible
Xt: XtConfigureWidget on RectObj called XClearArea with uninited values
Xaw: List widget must unset all elements when the list changes
Xlib: (Xsi) Xmb/XwcTextExtents always returns 1
Xlib: (Xsi) Xmb/wcText*Extents can dereference NULL pointers
Xlib: (Xsi) Xmb/wcTextPerCharExtents per-char metrics all start from 0
Xlib: (Xsi) Xmb/wcTextPropertyToTextList fail to increment element index
editres: core dumps when saving tree to a file
editres: can't set output file to non-existent file
editres: does not save new resource values to a file
fontlib: missing helper functions for Type1 renderer (in contrib)

Prereq: public-patch-3

*** /tmp/,RCSt1002080	Mon Oct 28 16:42:31 1991
--- mit/bug-report	Mon Oct 28 16:42:33 1991
***************
*** 2,8 ****
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-3
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:
--- 2,8 ----
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-4
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:

*** /tmp/,RCSt1a20953	Fri Oct 25 18:24:23 1991
--- mit/lib/Xt/Composite.h	Thu Oct 24 13:20:17 1991
***************
*** 1,4 ****
! /* $XConsortium: Composite.h,v 1.11 91/06/11 18:19:08 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Composite.h,v 1.12 91/10/24 13:19:40 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 28,33 ****
--- 28,39 ----
  #define _XtComposite_h
  
  typedef struct _CompositeClassRec *CompositeWidgetClass;
+ 
+ typedef Cardinal (*XtOrderProc)(
+ #if NeedFunctionPrototypes
+     Widget 	/* child */
+ #endif
+ );
  
  _XFUNCPROTOBEGIN
  
*** /tmp/,RCSt1a20961	Fri Oct 25 18:24:27 1991
--- mit/lib/Xt/CompositeP.h	Thu Oct 24 13:20:20 1991
***************
*** 1,5 ****
! /* $XConsortium: CompositeP.h,v 1.14 90/03/13 10:18:12 swick Exp $ */
! /* $oHeader: CompositeP.h,v 1.2 88/08/18 15:54:11 asente Exp $ */
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
  and the Massachusetts Institute of Technology, Cambridge, Massachusetts.
--- 1,5 ----
! /* $XConsortium: CompositeP.h,v 1.15 91/10/24 13:20:18 converse Exp $ */
! 
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
  and the Massachusetts Institute of Technology, Cambridge, Massachusetts.
***************
*** 34,45 ****
   * Additional instance fields for widgets of (sub)class 'Composite' 
   *
   ************************************************************************/
- 
- typedef Cardinal (*XtOrderProc)(
- #if NeedFunctionPrototypes
-     Widget 	/* child */
- #endif
- );
  
  typedef struct _CompositePart {
      WidgetList  children;	     /* array of ALL widget children	     */
--- 34,39 ----

*** /tmp/,RCSt1a02429	Mon Sep 23 11:40:42 1991
--- mit/lib/Xt/Geometry.c	Mon Sep 23 11:11:44 1991
***************
*** 1,4 ****
! /* $XConsortium: Geometry.c,v 1.53 91/05/02 16:12:29 swick Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Geometry.c,v 1.54 91/09/23 11:09:45 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 392,423 ****
      XWindowChanges changes, old;
      Cardinal mask = 0;
  
!     if (w->core.x != x) {
! 	old.x = w->core.x;
  	changes.x = w->core.x = x;
  	mask |= CWX;
      }
  
!     if (w->core.y != y) {
! 	old.y = w->core.y;
  	changes.y = w->core.y = y;
  	mask |= CWY;
      }
  
!     if (w->core.width != width) {
! 	old.width = w->core.width;
  	changes.width = w->core.width = width;
  	mask |= CWWidth;
      }
  
!     if (w->core.height != height) {
! 	old.height = w->core.height;
  	changes.height = w->core.height = height;
  	mask |= CWHeight;
      }
  
!     if (w->core.border_width != borderWidth) {
! 	old.border_width = w->core.border_width;
  	changes.border_width = w->core.border_width = borderWidth;
  	mask |= CWBorderWidth;
      }
--- 392,418 ----
      XWindowChanges changes, old;
      Cardinal mask = 0;
  
!     if ((old.x = w->core.x) != x) {
  	changes.x = w->core.x = x;
  	mask |= CWX;
      }
  
!     if ((old.y = w->core.y) != y) {
  	changes.y = w->core.y = y;
  	mask |= CWY;
      }
  
!     if ((old.width = w->core.width) != width) {
  	changes.width = w->core.width = width;
  	mask |= CWWidth;
      }
  
!     if ((old.height = w->core.height) != height) {
  	changes.height = w->core.height = height;
  	mask |= CWHeight;
      }
  
!     if ((old.border_width = w->core.border_width) != borderWidth) {
  	changes.border_width = w->core.border_width = borderWidth;
  	mask |= CWBorderWidth;
      }

*** /tmp/,RCSt1a05837	Fri Sep 27 19:08:35 1991
--- mit/lib/Xaw/List.c	Fri Sep 27 18:38:48 1991
***************
*** 1,4 ****
! /* $XConsortium: List.c,v 1.33 91/05/22 16:31:34 converse Exp $ */
  
  /*
   * Copyright 1989 Massachusetts Institute of Technology
--- 1,4 ----
! /* $XConsortium: List.c,v 1.34 91/09/27 18:35:07 converse Exp $ */
  
  /*
   * Copyright 1989 Massachusetts Institute of Technology
***************
*** 862,868 ****
      }
  
      if (cl->list.list != rl->list.list)
!       nl->list.highlight = NO_HIGHLIGHT;
  
      if ((cl->core.sensitive != rl->core.sensitive) ||
  	(cl->core.ancestor_sensitive != rl->core.ancestor_sensitive)) {
--- 862,868 ----
      }
  
      if (cl->list.list != rl->list.list)
! 	nl->list.is_highlighted = nl->list.highlight = NO_HIGHLIGHT;
  
      if ((cl->core.sensitive != rl->core.sensitive) ||
  	(cl->core.ancestor_sensitive != rl->core.ancestor_sensitive)) {

*** /tmp/,RCSt1a02042	Tue Oct  8 14:20:58 1991
--- mit/lib/X/Xsi/TextExtBd.c	Tue Oct  8 14:18:23 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: TextExtBd.c,v 1.11 91/05/02 16:34:18 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: TextExtBd.c,v 1.14 91/10/08 14:18:01 rws Exp $
   */
  
  /*
***************
*** 49,54 ****
--- 49,55 ----
      int             scanned, ret;
      int             dir, ascent, descent, max_ascent, max_descent;
      XCharStruct     overall, all;
+     Bool            first;
  
  #define MAX(a, b)           ((a > b)? a : b)
  #define MIN(a, b)           ((a < b)? a : b)
***************
*** 63,68 ****
--- 64,70 ----
      overall.width = 0;
      overall.lbearing = 0;
      overall.rbearing = 0;
+     first = True;
      _Xmbinit(xlocale);
      _Xctinit(xlocale);
      while (text_len > 0) {
***************
*** 90,111 ****
                  XTextExtents16(fnt, (XChar2b *)gstr, (int)(glen/2),
                      &dir, &ascent, &descent, &all);
              }
!             max_ascent = MAX(max_ascent, ascent);
!             max_descent = MAX(max_descent, descent);
!             overall.ascent = MAX(overall.ascent, all.ascent);
!             overall.descent = MAX(overall.descent, all.descent);
!             overall.width = overall.width + all.width;
!             overall.lbearing = (overall.lbearing == 0)? all.lbearing :
!                             MIN(overall.lbearing, all.lbearing);
!             /*
!              * BUG:
!              * The (overall.rbearing + all.rbearing) should minus 
!              * the max rbearing of all "gstr", but it will take lots of
!              * time to get it, so with fnt->min_bounds.rbearing
!              * in stead of it.
!              */
!             overall.rbearing = overall.rbearing + all.rbearing - 
!                               fnt->min_bounds.rbearing;
          }
          if (ret == BadTerminate)
              /* The passed string "text" is terminated unexpectly, stop!*/
--- 92,113 ----
                  XTextExtents16(fnt, (XChar2b *)gstr, (int)(glen/2),
                      &dir, &ascent, &descent, &all);
              }
!             if (first) {
!                 max_ascent = ascent;
!                 max_descent = descent;
!                 overall = all;
!                 first = False;
!             } else {
!                 max_ascent = MAX(max_ascent, ascent);
!                 max_descent = MAX(max_descent, descent);
!                 overall.ascent = MAX(overall.ascent, all.ascent);
!                 overall.descent = MAX(overall.descent, all.descent);
!                 all.lbearing += overall.width;
!                 overall.lbearing = MIN(overall.lbearing, all.lbearing);
!                 all.rbearing += overall.width;
!                 overall.rbearing = MAX(overall.rbearing, all.rbearing);
!                 overall.width += all.width;
!             }
          }
          if (ret == BadTerminate)
              /* The passed string "text" is terminated unexpectly, stop!*/
***************
*** 113,129 ****
          text += scanned;
          text_len -= scanned;
      }
!     overall_ink_extents->x = overall.lbearing;
!     overall_ink_extents->y = - overall.ascent;
!     overall_ink_extents->width = overall.rbearing - overall.lbearing;
!     overall_ink_extents->height = overall.ascent + overall.descent;
  
!     overall_logical_extents->x = 0;
!     overall_logical_extents->y = - max_ascent;
!     overall_logical_extents->width = overall.width;
!     overall_logical_extents->height = max_ascent + max_descent;
  
!     return 1;    /* make compiler happy */
  
  #endif
  /*--------------------------- END ---------------------------------------*/
--- 115,135 ----
          text += scanned;
          text_len -= scanned;
      }
!     if (overall_ink_extents) {
! 	overall_ink_extents->x = overall.lbearing;
! 	overall_ink_extents->y = - overall.ascent;
! 	overall_ink_extents->width = overall.rbearing - overall.lbearing;
! 	overall_ink_extents->height = overall.ascent + overall.descent;
!     }
  
!     if (overall_logical_extents) {
! 	overall_logical_extents->x = 0;
! 	overall_logical_extents->y = - max_ascent;
! 	overall_logical_extents->width = overall.width;
! 	overall_logical_extents->height = max_ascent + max_descent;
!     }
  
!     return overall.width;
  
  #endif
  /*--------------------------- END ---------------------------------------*/

*** /tmp/,RCSt1a02052	Tue Oct  8 14:21:02 1991
--- mit/lib/X/Xsi/TextPerBd.c	Tue Oct  8 14:19:39 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: TextPerBd.c,v 1.13 91/05/02 16:34:21 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: TextPerBd.c,v 1.15 91/10/08 14:19:10 rws Exp $
   */
  
  /*
***************
*** 42,53 ****
  
      XLocale	    xlocale = ((XsiFontSet)font_set)->xlc;
      XFontStruct    *fnt;
!     char            gstr[BUFSIZ];
      int		    ctid;
      int             glen;
      int             scanned, ret;
!     int             count, numglyphs, i;
!     XRectangle      max_ink, max_logical;
      XCharStruct     *onechar;
  
  #define MAX(a, b)           ((a > b)? a : b)
--- 42,54 ----
  
      XLocale	    xlocale = ((XsiFontSet)font_set)->xlc;
      XFontStruct    *fnt;
!     unsigned char  gstr[BUFSIZ];
      int		    ctid;
      int             glen;
      int             scanned, ret;
!     int             count, i;
!     XCharStruct     overall;
!     int             max_ascent, max_descent;
      XCharStruct     *onechar;
  
  #define MAX(a, b)           ((a > b)? a : b)
***************
*** 57,65 ****
      if (!xlocale)
  	xlocale = _XFallBackConvert();
  #endif
!     max_ink.x = max_ink.y = max_ink.width = max_ink.height = 0;
!     max_logical.x = max_logical.y =
!             max_logical.width = max_logical.height = 0;
      count = 0;
      _Xmbinit(xlocale);
      _Xctinit(xlocale);
--- 58,70 ----
      if (!xlocale)
  	xlocale = _XFallBackConvert();
  #endif
!     overall.ascent = 0;
!     overall.descent = 0;
!     overall.width = 0;
!     overall.lbearing = 0;
!     overall.rbearing = 0;
!     max_ascent = 0;
!     max_descent = 0;
      count = 0;
      _Xmbinit(xlocale);
      _Xctinit(xlocale);
***************
*** 68,74 ****
          glen = BUFSIZ;
          scanned = 0;
          ret = DecomposeGlyphCharset(xlocale, text, text_len,
!                 (unsigned char *)gstr, &glen, &scanned, &ctid);
          /*
           * if ret is BadEncoding, uncovered wrong codepoint, must stop!
           */
--- 73,79 ----
          glen = BUFSIZ;
          scanned = 0;
          ret = DecomposeGlyphCharset(xlocale, text, text_len,
! 				    gstr, &glen, &scanned, &ctid);
          /*
           * if ret is BadEncoding, uncovered wrong codepoint, must stop!
           */
***************
*** 81,89 ****
              /*
               * only 1 or 2 byte-encoding font supported by X.
               */
!             numglyphs = (fnt->min_byte1 == 0 && fnt->max_byte1 == 0) ?
!                         glen : (glen/2);
!             for (i = 0; i < numglyphs && count < buffer_size; i++, count++) {
                  int ind, d, byte1, byte2;
                  /*
                   * get index of glyph of font.
--- 86,101 ----
              /*
               * only 1 or 2 byte-encoding font supported by X.
               */
!             if (!count) {
!                 max_ascent = fnt->ascent;
!                 max_descent = fnt->descent;
!             } else {
!                 max_ascent = MAX(max_ascent, fnt->ascent);
!                 max_descent = MAX(max_descent, fnt->descent);
!             }
!             if (fnt->min_byte1 != 0 || fnt->max_byte1 != 0)
!                 glen &= ~1;
!             for (i = 0; i < glen && count < buffer_size; i++, count++) {
                  int ind, d, byte1, byte2;
                  /*
                   * get index of glyph of font.
***************
*** 96,103 ****
                          ind = byte2 - fnt->min_char_or_byte2;
                  } else {
                      d = fnt->max_char_or_byte2 - fnt->min_char_or_byte2 + 1;
!                     byte1 = (gstr[i] >> 8) & 0x00FF;
!                     byte2 = gstr[i] & 0x00FF;
                      if (byte1 > fnt->max_byte1 ||
                          byte2 > fnt->max_char_or_byte2)
                          ind = 0;
--- 108,115 ----
                          ind = byte2 - fnt->min_char_or_byte2;
                  } else {
                      d = fnt->max_char_or_byte2 - fnt->min_char_or_byte2 + 1;
!                     byte1 = gstr[i++];
!                     byte2 = gstr[i];
                      if (byte1 > fnt->max_byte1 ||
                          byte2 > fnt->max_char_or_byte2)
                          ind = 0;
***************
*** 111,117 ****
                  /*
                   * set ink & logical extent.
                   */
!                 ink_extents_buffer[count].x = onechar->lbearing;
                  ink_extents_buffer[count].y = - onechar->ascent;
                  ink_extents_buffer[count].width = 
                                  onechar->rbearing - onechar->lbearing;
--- 123,129 ----
                  /*
                   * set ink & logical extent.
                   */
!                 ink_extents_buffer[count].x = overall.width + onechar->lbearing;
                  ink_extents_buffer[count].y = - onechar->ascent;
                  ink_extents_buffer[count].width = 
                                  onechar->rbearing - onechar->lbearing;
***************
*** 118,148 ****
                  ink_extents_buffer[count].height = 
                                  onechar->ascent + onechar->descent;
  
!                 logical_extents_buffer[count].x = 0;
!                 logical_extents_buffer[count].y = - onechar->ascent;
                  logical_extents_buffer[count].width = onechar->width;
!                 logical_extents_buffer[count].height = 
!                                 onechar->ascent + onechar->descent;
                  /*
                   * get min and max of ink/logical extent.
                   */
!                 max_ink.x = MIN(max_ink.x,
!                                 ink_extents_buffer[count].x);
!                 max_ink.y = MAX(abs(max_ink.y),
!                                 abs(ink_extents_buffer[count].y));
!                 max_ink.width = MAX(max_ink.width,
!                                     ink_extents_buffer[count].width);
!                 max_ink.height = MAX(max_ink.height,
!                                     ink_extents_buffer[count].height);
! 
!                 max_logical.x = MIN(max_logical.x, 
!                                     logical_extents_buffer[count].x);
!                 max_logical.y = MAX(abs(max_logical.y),
!                                     abs(ink_extents_buffer[count].y));
!                 max_logical.width = MAX(max_logical.width,
!                                         logical_extents_buffer[count].width);
!                 max_logical.height = MAX(max_logical.height,
!                                         logical_extents_buffer[count].height);
              }
          }
          if (ret == BadTerminate)
--- 130,154 ----
                  ink_extents_buffer[count].height = 
                                  onechar->ascent + onechar->descent;
  
!                 logical_extents_buffer[count].x = overall.width;
!                 logical_extents_buffer[count].y = - fnt->ascent;
                  logical_extents_buffer[count].width = onechar->width;
!                 logical_extents_buffer[count].height =
!                                 fnt->ascent + fnt->descent;
                  /*
                   * get min and max of ink/logical extent.
                   */
!                 if (!count) {
!                     overall = *onechar;
!                 } else {
!                     overall.ascent = MAX(overall.ascent, onechar->ascent);
!                     overall.descent = MAX(overall.descent, onechar->descent);
!                     overall.lbearing = MIN(overall.lbearing,
!                                            overall.width + onechar->lbearing);
!                     overall.rbearing = MAX(overall.rbearing,
!                                            overall.width + onechar->rbearing);
!                     overall.width += onechar->width;
!                 }
              }
          }
          if (ret == BadTerminate)
***************
*** 151,165 ****
          text += scanned;
          text_len -= scanned;
      }
!     max_ink_extents->x = max_ink.x; 
!     max_ink_extents->y = max_ink.y;
!     max_ink_extents->width = max_ink.width;
!     max_ink_extents->height = max_ink.height;
  
!     max_logical_extents->x = max_logical.x; 
!     max_logical_extents->y = max_logical.y;
!     max_logical_extents->width = max_logical.width;
!     max_logical_extents->height = max_logical.height;
  
      *num_chars = count;
   
--- 157,175 ----
          text += scanned;
          text_len -= scanned;
      }
!     if (max_ink_extents) {
! 	max_ink_extents->x = overall.lbearing;
! 	max_ink_extents->y = - overall.ascent;
! 	max_ink_extents->width = overall.rbearing - overall.lbearing;
! 	max_ink_extents->height = overall.ascent + overall.descent;
!     }
  
!     if (max_logical_extents) {
! 	max_logical_extents->x = 0;
! 	max_logical_extents->y = - max_ascent;
! 	max_logical_extents->width = overall.width;
! 	max_logical_extents->height = max_ascent + max_descent;
!     }
  
      *num_chars = count;
   
*** /tmp/,RCSt1a02346	Tue Oct  8 14:22:26 1991
--- mit/lib/X/Xsi/XmbTextExt.c	Tue Oct  8 12:55:28 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: XmbTextExt.c,v 1.14 91/05/02 11:57:39 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XmbTextExt.c,v 1.15 91/10/08 12:55:12 rws Exp $
   */
  
  /*
***************
*** 87,101 ****
      XTextExtents(font_set->core.font_struct_list[0], text, text_len,
  		 &dir, &ascent, &descent, &overall);
  
!     overall_ink_extents->x = overall.lbearing;
!     overall_ink_extents->y = -overall.ascent;
!     overall_ink_extents->width = overall.rbearing - overall.lbearing;
!     overall_ink_extents->height = overall.ascent + overall.descent;
  
!     overall_logical_extents->x = 0;
!     overall_logical_extents->y = -ascent;
!     overall_logical_extents->width = overall.width;
!     overall_logical_extents->height = ascent + descent;
  
      return overall.width;
  }
--- 87,105 ----
      XTextExtents(font_set->core.font_struct_list[0], text, text_len,
  		 &dir, &ascent, &descent, &overall);
  
!     if (overall_ink_extents) {
! 	overall_ink_extents->x = overall.lbearing;
! 	overall_ink_extents->y = -overall.ascent;
! 	overall_ink_extents->width = overall.rbearing - overall.lbearing;
! 	overall_ink_extents->height = overall.ascent + overall.descent;
!     }
  
!     if (overall_logical_extents) {
! 	overall_logical_extents->x = 0;
! 	overall_logical_extents->y = -ascent;
! 	overall_logical_extents->width = overall.width;
! 	overall_logical_extents->height = ascent + descent;
!     }
  
      return overall.width;
  }

*** /tmp/,RCSt1a03434	Tue Oct  8 17:48:04 1991
--- mit/lib/X/Xsi/XmbPrpText.c	Tue Oct  8 16:35:17 1991
***************
*** 1,4 ****
! /* $XConsortium: XmbPrpText.c,v 1.6 91/07/02 16:01:17 rws Exp $ */
  /*
   * Copyright 1991 by OMRON Corporation
   * Copyright 1991 by the Massachusetts Institute of Technology
--- 1,4 ----
! /* $XConsortium: XmbPrpText.c,v 1.7 91/10/08 16:35:10 rws Exp $ */
  /*
   * Copyright 1991 by OMRON Corporation
   * Copyright 1991 by the Massachusetts Institute of Technology
***************
*** 90,96 ****
      if (tp->encoding == XA_STRING ||
  	tp->encoding == XA_COMPOUND_TEXT(dpy)) {
  	cp = (unsigned char *)tp->value;
! 	for (i = j = 0; i < nelements; i++) {
  	    list[j] = start;
  	    len = datalen + 1;
  	    if (i == nelements - 1)
--- 90,96 ----
      if (tp->encoding == XA_STRING ||
  	tp->encoding == XA_COMPOUND_TEXT(dpy)) {
  	cp = (unsigned char *)tp->value;
! 	for (i = j = 0; i < nelements; i++, j++) {
  	    list[j] = start;
  	    len = datalen + 1;
  	    if (i == nelements - 1)

*** /tmp/,RCSt1a03439	Tue Oct  8 17:48:11 1991
--- mit/lib/X/Xsi/XwcPrpText.c	Tue Oct  8 16:35:21 1991
***************
*** 1,4 ****
! /* $XConsortium: XwcPrpText.c,v 1.10 91/07/06 13:48:34 rws Exp $ */
  /*
   * Copyright 1991 by OMRON Corporation
   * Copyright 1991 by the Massachusetts Institute of Technology
--- 1,4 ----
! /* $XConsortium: XwcPrpText.c,v 1.11 91/10/08 16:35:19 rws Exp $ */
  /*
   * Copyright 1991 by OMRON Corporation
   * Copyright 1991 by the Massachusetts Institute of Technology
***************
*** 93,99 ****
      if (tp->encoding == XA_STRING ||
  	tp->encoding == XA_COMPOUND_TEXT(dpy)) {
  	cp = tp->value;
! 	for (i = j = 0; i < nelements; i++) {
  	    list[j] = start;
  	    if (i == nelements - 1)
  		scand = datalen;
--- 93,99 ----
      if (tp->encoding == XA_STRING ||
  	tp->encoding == XA_COMPOUND_TEXT(dpy)) {
  	cp = tp->value;
! 	for (i = j = 0; i < nelements; i++, j++) {
  	    list[j] = start;
  	    if (i == nelements - 1)
  		scand = datalen;
***************
*** 130,136 ****
  	}
      } else {
  	cp = tp->value;
! 	for (i = j = 0; i < nelements; i++) {
  	    list[j] = start;
  #ifdef X_WCHAR
  	    len = datalen + 1;
--- 130,136 ----
  	}
      } else {
  	cp = tp->value;
! 	for (i = j = 0; i < nelements; i++, j++) {
  	    list[j] = start;
  #ifdef X_WCHAR
  	    len = datalen + 1;

*** /tmp/,RCSt1a17507	Wed Oct  9 10:42:37 1991
--- mit/clients/editres/utils.c	Wed Oct  9 10:41:27 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: utils.c,v 1.16 91/07/03 09:46:13 converse Exp $
   *
   * Copyright 1989 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: utils.c,v 1.17 91/10/09 10:39:44 dave Exp $
   *
   * Copyright 1989 Massachusetts Institute of Technology
   *
***************
*** 283,289 ****
      if ( (fp = fopen(filename, "w")) == NULL ) {
  	char buf[BUFSIZ];
  
! 	sprintf(buf, "Unable to open the file `%s' for writing.");
  	SetMessage(global_screen_data.info_label, buf);
  	return;
      }
--- 283,289 ----
      if ( (fp = fopen(filename, "w")) == NULL ) {
  	char buf[BUFSIZ];
  
! 	sprintf(buf, "Unable to open the file `%s' for writing.", filename);
  	SetMessage(global_screen_data.info_label, buf);
  	return;
      }

*** /tmp/,RCSt1001520	Mon Oct 28 15:25:32 1991
--- mit/clients/editres/handler.c	Wed Oct  9 17:37:13 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: handler.c,v 1.23 91/07/09 09:39:26 rws Exp $
   *
   * Copyright 1989 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: handler.c,v 1.25 91/10/09 17:36:13 dave Exp $
   *
   * Copyright 1989 Massachusetts Institute of Technology
   *
***************
*** 587,592 ****
--- 587,593 ----
      FILE * fp;
      char buf[BUFSIZ], * resource_string, *filename = (char *) filename_ptr;
      ResourceBoxInfo * res_box = (ResourceBoxInfo *) res_box_ptr;
+     char *value_ptr;
  
      if (filename != NULL) {
  	if (global_resources.allocated_save_resources_file) 
***************
*** 608,616 ****
  
      XtSetArg(args[0], XtNlabel, &resource_string);
      XtGetValues(res_box->res_label, args, ONE);
-     fputs(resource_string, fp);
-     fputs("\n", fp);
  
      fclose(fp);
  }
  
--- 609,620 ----
  
      XtSetArg(args[0], XtNlabel, &resource_string);
      XtGetValues(res_box->res_label, args, ONE);
  
+     XtSetArg(args[0], XtNstring, &value_ptr);
+     XtGetValues(res_box->value_wid, args, ONE);
+ 
+     fprintf(fp, "%s %s\n", resource_string, value_ptr);
+ 
      fclose(fp);
  }
  
***************
*** 656,671 ****
  XtPointer junk, filename_ptr;
  {
      char buf[BUFSIZ], *filename = (char *) filename_ptr;
- 
-     /* Check to be sure that file is okay */
- 
-     if (access(filename, W_OK) != 0) {
- 	sprintf(buf, "Unable to open this file for writing, would %s",
- 		"you like To try again?");
- 	_PopupFileDialog(toplevel, buf, filename,
- 			 _SetResourcesFile, NULL);
- 	return;
-     }
  
      if (global_resources.allocated_save_resources_file) 
  	XtFree(global_resources.save_resources_file);
--- 660,665 ----

*** /tmp/,RCSt1a13775	Fri Oct 18 11:24:24 1991
--- mit/fonts/lib/font/util/Imakefile	Fri Oct 18 11:23:04 1991
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.7 91/07/22 22:21:27 rws Exp $
  #include <Server.tmpl>
  
          INCLUDES = -I$(FONTSRC)/include -I../include -I$(FONTSERVERSRC)/include
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.8 91/10/18 11:22:58 keith Exp $
  #include <Server.tmpl>
  
          INCLUDES = -I$(FONTSRC)/include -I../include -I$(FONTSERVERSRC)/include
***************
*** 7,16 ****
       FORMAT_DEFS = FontFormatDefines
  #endif
              SRCS = bitmaputil.c fontnames.c fontutil.c fontxlfd.c format.c \
! 		   fontaccel.c atom.c miscutil.c private.c patcache.c
  
              OBJS = bitmaputil.o fontnames.o fontutil.o fontxlfd.o format.o \
! 		   fontaccel.o atom.o miscutil.o private.o patcache.o
  
  SubdirLibraryRule($(OBJS))
  NormalLibraryObjectRule()
--- 7,16 ----
       FORMAT_DEFS = FontFormatDefines
  #endif
              SRCS = bitmaputil.c fontnames.c fontutil.c fontxlfd.c format.c \
! 		   fontaccel.c atom.c miscutil.c private.c patcache.c fsfuncs.c
  
              OBJS = bitmaputil.o fontnames.o fontutil.o fontxlfd.o format.o \
! 		   fontaccel.o atom.o miscutil.o private.o patcache.o fsfuncs.o
  
  SubdirLibraryRule($(OBJS))
  NormalLibraryObjectRule()

*** /dev/null	Fri Oct 18 10:25:33 1991
--- mit/fonts/lib/font/util/fsfuncs.c	Fri Oct 18 11:23:25 1991
***************
*** 0 ****
--- 1,476 ----
+ /* $XConsortium: fsfuncs.c,v 1.1 91/10/18 11:23:03 keith Exp $ */
+ /*
+  * Copyright 1990, 1991 Network Computing Devices;
+  * Portions Copyright 1987 by Digital Equipment Corporation and the
+  * Massachusetts Institute of Technology
+  *
+  * Permission to use, copy, modify, and distribute this protoype software
+  * and its documentation to Members and Affiliates of the MIT X Consortium
+  * any purpose and without fee is hereby granted, provided
+  * that the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the names of Network Computing Devices, Digital or
+  * MIT not be used in advertising or publicity pertaining to distribution of
+  * the software without specific, written prior permission.
+  *
+  * NETWORK COMPUTING DEVICES, DIGITAL AND MIT DISCLAIM ALL WARRANTIES WITH
+  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+  * AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES, DIGITAL OR MIT BE
+  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  * $NCDId: @(#)fsfuncs.c,v 1.6 1991/07/02 16:59:18 lemke Exp $
+  *
+  */
+ 
+ #include    <X11/Xos.h>
+ #include	"fontmisc.h"
+ #include	"fontstruct.h"
+ #define FSMD_H
+ #include	"FSproto.h"
+ 
+ #define GLWIDTHBYTESPADDED(bits,nbytes) \
+ 	((nbytes) == 1 ? (((bits)+7)>>3)        /* pad to 1 byte */ \
+ 	:(nbytes) == 2 ? ((((bits)+15)>>3)&~1)  /* pad to 2 bytes */ \
+ 	:(nbytes) == 4 ? ((((bits)+31)>>3)&~3)  /* pad to 4 bytes */ \
+ 	:(nbytes) == 8 ? ((((bits)+63)>>3)&~7)  /* pad to 8 bytes */ \
+ 	: 0)
+ 
+ #define GLYPH_SIZE(ch, nbytes)          \
+ 	GLWIDTHBYTESPADDED((ch)->metrics.rightSideBearing - \
+ 			(ch)->metrics.leftSideBearing, (nbytes))
+ 
+ #define n2dChars(pfi)   (((pfi)->lastRow - (pfi)->firstRow + 1) * \
+                          ((pfi)->lastCol - (pfi)->firstCol + 1))
+ 
+ static CharInfoRec  junkDefault;
+ 
+ static int
+ getCharInfos (pfont, num_ranges, range, nump, retp)
+     FontPtr	pfont;
+     int		num_ranges;
+     fsRange	*range;
+     int		*nump;
+     CharInfoPtr	**retp;
+ {
+     CharInfoPtr	*xchars, *xci;
+     int		nchars;
+     FontInfoPtr pinfo = &pfont->info;
+     int		r, c;
+     unsigned char   ch[2];
+     int         firstCol = pinfo->firstCol;
+     int         firstRow = pinfo->firstRow;
+     int         lastRow = pinfo->lastRow;
+     int         lastCol = pinfo->lastCol;
+     int		minCol, maxCol;
+     int         num_cols = lastCol - firstCol + 1;
+     fsRange	local_range, *rp;
+     int		i;
+     FontEncoding    encoding;
+     int		err;
+     unsigned long   glyphCount;
+     unsigned short  defaultCh;
+     CharInfoPtr	    defaultPtr;
+ 
+     if (num_ranges == 0) {
+ 	if (lastRow)
+ 	    nchars = n2dChars(pinfo);
+ 	else
+ 	    nchars = lastCol - firstCol + 1;
+ 	local_range.min_char.low = firstCol;
+ 	local_range.min_char.high = firstRow;
+ 	local_range.max_char.low = lastCol;
+ 	local_range.max_char.high = lastRow;
+ 	range = &local_range;
+ 	num_ranges = 1;
+     } else {
+ 	nchars = 0;
+ 	for (i = 0, rp = range; i < num_ranges; i++, rp++) {
+ 	    if (rp->min_char.high > rp->max_char.high)
+ 		return BadCharRange;
+ 	    if (rp->min_char.high == rp->max_char.high)
+ 	    {
+ 		if (rp->min_char.low > rp->max_char.low)
+ 		    return BadCharRange;
+ 		nchars += rp->max_char.low - rp->min_char.low;
+ 	    }
+ 	    else
+ 	    {
+ 		nchars += lastRow - rp->min_char.low;
+ 		nchars += (rp->max_char.high - rp->min_char.high - 1) * num_cols;
+ 		nchars += rp->max_char.low - firstRow;
+ 	    }
+ 	}
+     }
+     xchars = (CharInfoPtr *) xalloc (sizeof (CharInfoPtr) * nchars);
+     if (!xchars)
+ 	return AllocError;
+     xci = xchars;
+     encoding = Linear16Bit;
+     if (lastRow)
+ 	encoding = TwoD16Bit;
+     defaultCh = pinfo->defaultCh;
+     ch[0] = defaultCh >> 8;
+     ch[1] = defaultCh & 0xff;
+     (*pfont->get_glyphs) (pfont, 1, ch, encoding,
+ 			  &glyphCount, &defaultPtr);
+     if (glyphCount != 1)
+ 	defaultPtr = 0;
+     for (i = 0, rp = range; i < num_ranges; i++, rp++) {
+ 	for (r = rp->min_char.high; r <= rp->max_char.high; r++)
+ 	{
+ 	    minCol = firstCol;
+ 	    if (r == rp->min_char.high)
+ 		minCol = rp->min_char.low;
+ 	    maxCol = lastCol;
+ 	    if (r == rp->max_char.high)
+ 		maxCol = rp->max_char.low;
+ 	    for (c = minCol; c <= maxCol; c++) {
+ 		ch[0] = r;
+ 		ch[1] = c;
+ 		err = (*pfont->get_glyphs) (pfont, 1, ch, encoding,
+ 					    &glyphCount, xci);
+ 		if (err != Successful)
+ 		{
+ 		    xfree (xchars);
+ 		    return err;
+ 		}
+ 		if (glyphCount != 1 || 
+ 		    *xci == defaultPtr && defaultCh != ((r<<8)+c))
+ 		    *xci = &junkDefault;
+ 		xci++;
+ 	    }
+ 	}
+     }
+     *retp = xchars;
+     *nump = nchars;
+     return Successful;
+ }
+ 
+ int
+ GenericGetExtents(client, pfont, flags, num_ranges, range, num_extents, data)
+     pointer     client;
+     FontPtr     pfont;
+     Mask        flags;
+     unsigned long num_ranges;
+     fsRange    *range;
+     unsigned long *num_extents;
+     fsCharInfo **data;
+ {
+     unsigned long size;
+     fsCharInfo *ci,
+                *pci;
+     fsRange    *rp;
+     CharInfoPtr	*xchars, *xcharsFree, xci;
+     int		nchars;
+     int		err;
+ 
+     if (flags & LoadAll)
+ 	num_ranges = 0;
+     err = getCharInfos (pfont, num_ranges, range, &nchars, &xchars);
+     if (err != Successful)
+ 	return err;
+ 
+     size = sizeof(fsCharInfo) * nchars;
+     pci = ci = (fsCharInfo *) xalloc(size);
+     if (!ci) {
+ 	xfree (xchars);
+ 	return AllocError;
+     }
+ 
+     *num_extents = nchars;
+     xcharsFree = xchars;
+ 
+     while (nchars--) {
+ 	xci = *xchars++;
+ 	pci->ascent = xci->metrics.ascent;
+ 	pci->descent = xci->metrics.descent;
+ 	pci->left = xci->metrics.leftSideBearing;
+ 	pci->right = xci->metrics.rightSideBearing;
+ 	pci->width = xci->metrics.characterWidth;
+ 	pci->attributes = 0;
+ 	pci++;
+     }
+ 
+     xfree (xcharsFree);
+ 
+     *data = ci;
+ 
+     return Successful;
+ }
+ 
+ static int
+ packGlyphs (pfont, format, flags, num_ranges, range, tsize, num_glyphs,
+ 		   offsets, data, freeData)
+     FontPtr     pfont;
+     int         format;
+     Mask        flags;
+     unsigned long num_ranges;
+     fsRange    *range;
+     int        *tsize;
+     unsigned long *num_glyphs;
+     fsOffset  **offsets;
+     pointer    *data;
+     int		*freeData;
+ {
+     unsigned long start,
+                 end;
+     int         i;
+     fsOffset	*lengths, *l;
+     unsigned long size = 0;
+     pointer     gdata,
+                 gd;
+     long        ch;
+     int         bitorder,
+                 byteorder,
+                 scanlinepad,
+                 scanlineunit,
+                 mappad;
+     int         height, bpr,
+ 		charsize,
+                 skiprows = 0;
+     Bool	contiguous, reformat;
+     fsRange    *rp = range;
+     int		nchars;
+     int         src_glyph_pad = pfont->glyph;
+     int         src_bit_order = pfont->bit;
+     int         src_byte_order = pfont->byte;
+     int         err;
+     int		max_ascent, max_descent;
+     int		min_left, max_right;
+     int		srcbpr;
+     int		lshift = 0, rshift = 0;
+     unsigned char   *src;
+     unsigned char   *dst;
+     unsigned char   bits1, bits2;
+     int		    width;
+     int		    src_extra;
+     int		    dst_extra;
+     int		    r, w;
+     fsRange	allRange;
+     CharInfoPtr	*xchars, *xcharsFree, ci;
+     FontInfoPtr	pinfo = &pfont->info;
+     xCharInfo	*cim;
+ 
+     err = CheckFSFormat(format, (fsBitmapFormatMask) ~ 0,
+ 		&bitorder, &byteorder, &scanlineunit, &scanlinepad, &mappad);
+ 
+     if (err != Successful)
+ 	return err;
+ 
+     if (flags & LoadAll)
+ 	num_ranges = 0;
+ 
+     err = getCharInfos (pfont, num_ranges, range, &nchars, &xcharsFree);
+ 
+     if (err != Successful)
+ 	return err;
+     
+     /* get space for glyph offsets */
+     lengths = (fsOffset *) xalloc(sizeof(fsOffset) * nchars);
+     if (!lengths) {
+ 	xfree (xcharsFree);
+ 	return AllocError;
+     }
+ 
+     /* compute bpr for padded out fonts */
+     reformat = bitorder != src_bit_order || byteorder != src_byte_order;
+     switch (mappad)
+     {
+     case BitmapFormatImageRectMax:
+ 	max_ascent = FONT_MAX_ASCENT(pinfo);
+ 	max_descent = FONT_MAX_DESCENT(pinfo);
+ 	height = max_ascent + max_descent;
+ 	if (height != pinfo->minbounds.ascent + pinfo->minbounds.descent)
+ 	    reformat = TRUE;
+ 	/* fall through */
+     case BitmapFormatImageRectMaxWidth:
+ 	min_left = FONT_MIN_LEFT(pinfo);
+ 	max_right = FONT_MAX_RIGHT(pinfo);
+ 	if (min_left != pinfo->maxbounds.leftSideBearing)
+ 	    reformat = TRUE;
+ 	bpr = GLWIDTHBYTESPADDED(max_right - min_left, scanlinepad);
+ 	break;
+     case BitmapFormatImageRectMin:
+ 	break;
+     }
+     charsize = bpr * height;
+     size = 0;
+     gdata = 0;
+     contiguous = TRUE;
+     l = lengths;
+     for (i = 0, xchars = xcharsFree; i < nchars; i++, xchars++) {
+     	ci = *xchars;
+     	l->position = size;
+     	if (ci && ci->bits) {
+ 	    if (!gdata)
+ 		gdata = (pointer) ci->bits;
+ 	    if ((char *) gdata + size != ci->bits)
+ 		contiguous = FALSE;
+ 	    if (mappad == BitmapFormatImageRectMin)
+ 		bpr = GLYPH_SIZE(ci, scanlinepad);
+ 	    if (mappad != BitmapFormatImageRectMax)
+ 	    {
+ 		height = ci->metrics.ascent +
+ 			 ci->metrics.descent;
+ 		charsize = height * bpr;
+ 	    }
+ 	    l->length = charsize;
+ 	    size += charsize;
+ 	}
+ 	else
+ 	    l->length = 0;
+ 	l++;
+     }
+     if (contiguous && !reformat)
+     {
+ 	*num_glyphs = nchars;
+ 	*freeData = FALSE;
+ 	*data = gdata;
+ 	*tsize = size;
+ 	*offsets = lengths;
+ 	xfree (xcharsFree);
+ 	return Successful;
+     }
+     if (size)
+     {
+ 	gdata = (pointer) xalloc(size);
+ 	if (!gdata) {
+ 	    xfree (xcharsFree);
+ 	    xfree (lengths);
+ 	    return AllocError;
+ 	}
+ 	bzero ((char *) gdata, size);
+     }
+ 
+     *freeData = TRUE;
+     l = lengths;
+     gd = gdata;
+ 
+     /* finally do the work */
+     for (i = 0, xchars = xcharsFree; i < nchars; i++, xchars++, l++) {
+ 	ci = *xchars;
+ 	/* ignore missing chars */
+ 	if (!ci || !ci->bits)
+ 	    continue;
+ 	cim = &ci->metrics;
+ 
+ 	srcbpr = GLWIDTHBYTESPADDED(cim->rightSideBearing -
+ 				    cim->leftSideBearing, src_glyph_pad);
+ 	/*
+ 	 * caculate bytes-per-row for PadNone (others done in allocation
+ 	 * phase), what (if anything) to ignore or add as padding
+ 	 */
+ 	switch (mappad) {
+ 	case BitmapFormatImageRectMin:
+ 	    bpr = GLYPH_SIZE(ci, scanlinepad);
+ 	    break;
+ 	case BitmapFormatImageRectMax:
+ 	    /* leave the first padded rows blank */
+ 	    gd += bpr * (max_ascent - cim->ascent);
+ 	    skiprows = bpr * (max_descent - cim->descent);
+ 	    /* fall thru */
+ 	case BitmapFormatImageRectMaxWidth:
+ 	    rshift = cim->leftSideBearing - min_left;
+ 	    lshift = 8 - lshift;
+ 	    break;
+ 	}
+ 	src = (unsigned char *) ci->bits;
+ 	dst = gd;
+ 	width = srcbpr;
+ 	if (srcbpr > bpr)
+ 	    width = bpr;
+ 	src_extra = srcbpr - width;
+ 	dst_extra = bpr - width;
+ 
+ #if (DEFAULTBITORDER == MSBFirst)
+ #define BitLeft(b,c)	((b) << (c))
+ #define BitRight(b,c)	((b) >> (c))
+ #else
+ #define BitLeft(b,c)	((b) >> (c))
+ #define BitRight(b,c)	((b) << (c))
+ #endif
+ 	if (!rshift)
+ 	{
+ 	    if (srcbpr == bpr)
+ 	    {
+ 		r = (cim->ascent + cim->descent) * width;
+ 		bcopy (src, dst, r);
+ 		dst += r;
+ 	    }
+ 	    else
+ 	    {
+ 		for (r = cim->ascent + cim->descent; r; r--)
+ 		{
+ 		    for (w = width; w; w--)
+ 			*dst++ = *src++;
+ 		    dst += dst_extra;
+ 		    src += src_extra;
+ 		}
+ 	    }
+ 	}
+ 	else
+ 	{
+ 	    for (r = cim->ascent + cim->descent; r; r--)
+ 	    {
+ 		bits2 = 0;
+ 		for (w = width; w; w--)
+ 		{
+ 		    bits1 = *src++;
+ 		    *dst++ = BitRight(bits1, rshift) |
+ 			     BitLeft (bits2, lshift);
+ 		    bits2 = bits1;
+ 		}
+ 		dst += dst_extra;
+ 		src += src_extra;
+ 	    }
+ 	}
+ 	/* skip the amount we just filled in */
+ 	gd += l->length;
+     }
+ 
+ 
+     /* now do the bit, byte, word swapping */
+     if (bitorder != src_bit_order)
+ 	BitOrderInvert(gdata, size);
+     if (byteorder != src_byte_order) {
+ 	if (scanlineunit == 2)
+ 	    TwoByteSwap(gdata, size);
+ 	else if (scanlineunit == 4)
+ 	    FourByteSwap(gdata, size);
+     }
+     xfree (xcharsFree);
+     *num_glyphs = nchars;
+     *data = gdata;
+     *tsize = size;
+     *offsets = lengths;
+ 
+     return Successful;
+ }
+ 
+ /* ARGSUSED */
+ int
+ GenericGetBitmaps(client, pfont, format, flags, num_ranges, range,
+ 		 size, num_glyphs, offsets, data, freeData)
+     pointer     client;
+     FontPtr     pfont;
+     fsBitmapFormat format;
+     Mask        flags;
+     unsigned long num_ranges;
+     fsRange    *range;
+     int        *size;
+     unsigned long *num_glyphs;
+     fsOffset  **offsets;
+     pointer    *data;
+     int		*freeData;
+ {
+     assert(pfont);
+ 
+     *size = 0;
+     *data = (pointer) 0;
+     return packGlyphs (pfont, format, flags,
+ 			      num_ranges, range, size, num_glyphs,
+ 			      offsets, data, freeData);
+ }

